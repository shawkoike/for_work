<p><a href="https://www.dataquest.io/blog/python-vs-r/" rel="nofollow" title="" class="ext-link">R vs Python: head to head data analysis</a> （2015-10-07） by <a href="https://twitter.com/vikparuchuri" rel="nofollow" title="" class="ext-link">Vik Paruchuri</a></p><p>主観的な観点からPythonとRの比較した記事は山ほどあります。それらに私たちの意見を追加する形でこの記事を書きますが、今回はこの2つの言語をより客観的な目線で見ていきたいと思います。PythonとRを比較をしていき、同じ結果を引き出すためにはそれぞれどんなコードが必要なのかを提示していきます。こうすることで、推測ではなく、それぞれの言語の強みと弱みの両者をしっかりと理解できます。<a href="https://www.dataquest.io/" rel="nofollow" title="" class="ext-link">Dataquest</a>では、PythonとRの両方の言語のレッスンを行っていますが、データサイエンスのツールキットの中では両者ともそれぞれに適所があります。</p><p>この記事では、NBA選手の2013/2014年シーズンの活躍を分析したデータセットを解析していきます。ファイルは<a href="https://www.dropbox.com/s/b3nv38jjo5dxcl6/nba_2013.csv?dl=0" rel="nofollow" title="" class="ext-link">ここ</a>からダウンロードしてください。解析はまずPythonとRのコードを示してから、その後に2つの異なるアプローチを解説し議論していきます。つまらない説明はこれくらいにして、データ解析の比較を早速スタートさせていきましょう！</p><p>R</p><p>Python</p><p>このコードを実行すると、NBA選手の2013/2014年シーズンのデータの入ったcsvファイル<code>nba_2013.csv</code>がそれぞれの言語で変数<code>nba</code>に読み込まれます。1つだけ違うのは、Pythonではデータフレームにアクセスできるようにするため<a href="http://pandas.pydata.org/" rel="nofollow" title="" class="ext-link">pandas</a>ライブラリをインポートしなければいけないことです。<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html" rel="nofollow" title="" class="ext-link">DataFrame</a>はRとPythonの両者に使える2次元の配列（マトリックス）で、それぞれのカラムは別のデータ型にすることができます。最終段階では、csvファイルは両者の言語によってデータフレームに読み込まれます。</p><p>R</p><p>↓</p><p>Python</p><p>↓</p><p>このコードで選手の数とそれぞれのカラムの数が出力されます。上記によると<code>481</code>個の行、つまり選手の数と、選手のデータを含んだ<code>31</code>個のカラムがあるということになります。</p><p>R</p><p>↓</p><p>Python</p><p>↓</p><p>この2つはほぼ同じですね。2つとも最初の行を出力していて、構文がよく似ています。Pythonはよりオブジェクト指向で、<code>head</code>はデータフレームオブジェクトのメソッドです。Rでは単独の<code>head</code>関数になります。これは、RとPythonで解析をするときに初めに直面する典型的なテーマです。Pythonはよりオブジェクト指向で、Rはより関数的なのです。</p><p>それぞれの統計量から平均値を割り出してみましょう。ご覧のように、カラムには<code>fg</code>（フィールドゴール成功数）や<code>ast</code>（アシスト数）などの名前がついています。これらは選手たちのシーズンの統計量です。統計量のより詳細なデータは<a href="http://stats.nba.com/help/glossary" rel="nofollow" title="" class="ext-link">こちら</a>をご覧ください。</p><p>R</p><p>↓</p><p>Python</p><p>↓</p><p>今回はアプローチに大きな違いがいくつか出ました。両者ともデータフレームのカラムに関数を適用させました。Pythonでは、データフレーム上のmeanメソッドがデフォルトで各カラムの平均を割り出してくれます。</p><p>Rでは、文字列の値の平均は<code>NA</code>（値なし）という結果になっています。しかし、平均を求める時には<code>NA</code>の値は無視しなければいけません（<code>na.rm=TRUE</code>を<code>mean</code>関数に渡す必要があります）。そうしないと、<code>x3p.</code>のようなカラムの平均は結局、<code>NA</code>になってしまいます。このカラムはスリーポイントシュート率を表しています。スリーポイントを一度も決めてない選手の欄には数字が入っていません。Rで<code>mean</code>関数を試してみると、<code>NA</code>が返されます。なので、平均を取るときは<code>NA</code>値を無視する<code>na.rm=TRUE</code>を記述しましょう。Pythonでの<code>mean()</code>メソッドは、デフォルトでNA値を無視するようになっています。</p><p>データセットを調べる一般的な方法は、それぞれのカラムが他のカラムとどのような相互関係にあるかを調べることです。<br>
<code>ast</code>と<code>fg</code>、<code>trb</code>のカラムを比べてみましょう。</p><p>R</p><p>↓</p><p><img class="full-width full-img" src="https://www.dataquest.io/blog/images/python_r/r_pairs.png"></p><p>Python</p><p><img class="full-width" src="https://www.dataquest.io/blog/images/python_r/python_pairs.png"></p><p>比べるとかなり似た図になっています。これは、Rのデータサイエンスのエコシステムが多くのより小さなパッケージ（<a href="https://cran.r-project.org/web/packages/GGally/index.html" rel="nofollow" title="" class="ext-link">GGally</a>は<a href="http://ggplot2.org/" rel="nofollow" title="" class="ext-link">ggplot2</a>のヘルパーパッケージで、Rでプロットする際に最も使われるパッケージ）やより視覚的なパッケージを持っていることを一般的に示しています。Pythonでは、<a href="http://matplotlib.org/" rel="nofollow" title="" class="ext-link">matplotlib</a>が一番重要なプロットのパッケージで、<a href="http://stanford.edu/~mwaskom/software/seaborn/" rel="nofollow" title="" class="ext-link">seaborn</a>はmatplotlibよりも広く使われるレイヤです。Pythonの可視化では、何かやるときの主な方法は通常1つですが、Rでは異なる方法をサポートするたくさんのパッケージがあります（例えば、対になるプロットを作るのに少なくとも6つくらいのパッケージがあります）。</p><p>このようなデータを探すのにいい方法は、クラスタプロットを生成することです。これで、どの選手が一番類似しているかが分かります。</p><p>R</p><p>Python</p><p>正しくクラスタリングをさせるには、数字ではないカラム、もしくは値のない（<code>NA</code>、<code>Nan</code>など）カラムは排除します。Rでは、それぞれのカラムに関数を適用し、値がない、数字ではないものがあれば排除するようにします。そして、<a href="https://ja.wikipedia.org/wiki/K%E5%B9%B3%E5%9D%87%E6%B3%95" rel="nofollow" title="" class="ext-link">k-means法</a>を実行するのに<a href="https://cran.r-project.org/web/packages/cluster/index.html" rel="nofollow" title="" class="ext-link">cluster</a>パッケージを使い、データ上で<code>5</code>個のクラスタを割り出します。<br>
<code>set.seed</code>を使ってランダムなシード値を設定し、結果を求められるようにします。</p><p>Pythonでは、メインのPython機械学習パッケージの<a href="http://scikit-learn.org/stable/" rel="nofollow" title="" class="ext-link">scikit-learn</a>を使って、モデルをクラスタリングするk-means法に適合させ、クラスタのラベルを取得します。Rで使うデータを準備するためには、非常に類似したメソッドを実行します。数字ではないカラムと値のないカラムを排除するためには、<code>get_numeric_data</code>や<code>dropna</code>のメソッドを使います。</p><p>では、選手をクラスタごとにプロットしてパターンを見つけましょう。これをやるには、まず<a href="https://ja.wikipedia.org/wiki/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90" rel="nofollow" title="" class="ext-link">PCA（主成分分析）</a>をして2次元データを作成し、プロットします。そして、クラスタの関係に従ってそれぞれの印に影をつけましょう。</p><p>R</p><p>↓</p><p><img class="full-width full-img" src="https://www.dataquest.io/blog/images/python_r/r_clus.png"><br>
<em>訳：これらの2つの成分はばらつきを100%説明している</em></p><p>Python</p><p>↓</p><p><img class="full-width" src="https://www.dataquest.io/blog/images/python_r/python_clus.png"></p><p>今回のデータから散布図を作成して、クラスタに従ってデータのアイコンに影をつけるか、もしくは変更します。Rでは、クラスタのライブラリの一部である<code>clusplot</code>関数が使われています。Rのビルトインの<code>pccomp</code>関数を用いて、PCAを実行します。</p><p>Pythonではscikit-learnライブラリのPCAクラスを使っていて、matplotlibを用いて図を作成しています。</p><p>教師ありの機械学習を行いたければ、訓練データセットとテストデータセットに分割して<a href="https://ja.wikipedia.org/wiki/%E9%81%8E%E5%89%B0%E9%81%A9%E5%90%88" rel="nofollow" title="" class="ext-link">過剰適合</a>しないようにするのがいいでしょう。</p><p>R</p><p>Python</p><p>Rには、<code>floor</code>や<code>sample</code>、<code>set.seed</code>など、データ解析にフォーカスしたビルトイン関数がより多くあるのがお分かりでしょうか。一方で、Pythonではパッケージを用いています（<code>math.floor</code>や<code>random.sample</code>、<code>random.seed</code>）。Pythonでは、最新バージョンのpandasに<code>sample</code>メソッドがあります。これは、ソースのデータフレームからある割合の数の行をサンプルとして抽出して返します。これでコードはより簡単になります。Rでは、サンプリングを単純にするパッケージがありますが、ビルトインの<code>sample</code>関数を使ったほうが簡単です。どちらにしろ、ランダムなシード値を設定して、結果を再現可能にします。</p><p>次は、選手ごとのフィールドゴールからアシストの数を予測してみます。</p><p>R</p><p>Python</p><p>Scikit-learnは、予測を適合させて生成することのできる単回帰モデルを持っています。Rではビルトインの<code>lm</code>関数と<code>predict</code>関数を用います。<code>predict</code>は、渡された適合モデルの種類によって違う振る舞いをします。つまり、適合したいさまざまなモデルに使えます。</p><p>R</p><p>↓</p><p>Python</p><p>↓</p><p><a href="https://ja.wikipedia.org/wiki/%E6%B1%BA%E5%AE%9A%E4%BF%82%E6%95%B0" rel="nofollow" title="" class="ext-link">R Square（決定係数）</a>のように、適合に関して要約統計量を出したいのであれば、RよりPythonのほうがやることが少し多くなります。Rではビルトインの<code>summary</code>関数を使うことで、モデル上の情報を引き出せます。Pythonでは、Pythonで使われる多くの統計メソッドを実行可能にしてくれる<a href="http://statsmodels.sourceforge.net/" rel="nofollow" title="" class="ext-link">statsmodels</a>パッケージを使う必要があります。どちらもほぼ同じ結果が得られますが、大抵の場合Pythonで統計分析をするほうが少しだけ複雑になり、Rに存在する統計メソッドのいくつかはPythonには存在しません。</p><p>線形回帰は変数が1つの場合に効果的ですが、ここで私たちはデータに<a href="https://en.wikipedia.org/wiki/Nonlinear_system" rel="nofollow" title="" class="ext-link">非線形</a>があるか探ってみます。ということで、<a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%83%95%E3%82%A9%E3%83%AC%E3%82%B9%E3%83%88" rel="nofollow" title="" class="ext-link">ランダムフォレスト</a>モデルを適合させます。</p><p>R</p><p>Python</p><p>2つの大きな違いは、アルゴリズムを使うためにRではランダムフォレストのライブラリを使う必要があるということです。一方で、Pythonではscikit-learnにビルトインされています。scikit-learnはPythonのさまざまな種類の機械学習アルゴリズムと一緒に使える統合インタフェースを持っていて、通常はPythonの各アルゴリズムの主要な実装が1つあるだけです。Rでは、個々のアルゴリズムを含んだ小さなパッケージが多くあり、アクセスするのに一貫性を持たないこともあります。これによってアルゴリズムに多様性が出てきますが（多くはいくつかの実装があり、研究所から出たばかりです）、使い勝手は良くありません。</p><p>では、2つのモデルが適合したところで、次は誤差を計算しましょう。<a href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="nofollow" title="" class="ext-link">MSE（平均平方誤差）</a>を使います。</p><p>R</p><p>↓</p><p>Python</p><p>↓</p><p>Pythonでは、scikit-learnライブラリには、使用できるさまざま誤差のメトリックスがあります。RではMSEを計算するより、小さないくつかのライブラリを持つ傾向があります。しかし、どちらの言語にしても手動で行うほうが断然簡単です。誤差には小さな相違がありますが、これは明らかにパラメータチューニングが原因です。でもこれは大きな問題ではありません。</p><p>2013/2014シーズンのNBA選手のデータが手元にありますが、次はこのデータを補う追加のデータを取得してみましょう。時間を節約するために、<a href="http://www.basketball-reference.com/boxscores/201506140GSW.html" rel="nofollow" title="" class="ext-link">ここ</a>にあるNBA決勝戦のボックススコアを１つ使うことにしましょう。</p><p>R</p><p>Python</p><p>Pythonでは、全てのリクエストの種類に対して一貫性のあるAPIを使用することで<a href="http://docs.python-requests.org/en/latest/" rel="nofollow" title="" class="ext-link">Requests</a>パッケージがWebページをダウンロードするのを簡単にしてくれます。Rでも同じように<a href="https://cran.r-project.org/web/packages/RCurl/index.html" rel="nofollow" title="" class="ext-link">RCurl</a>がリクエストの作成を容易にしてくれます。どちらもWebページを文字列のデータ型にダウンロードします。注釈：このステップは、次のRのステップに必要がありませんが、比較のために提示しました。</p><p>Webページがダウンロードできたので、次に選手のスコアを抽出するためにこれをパースする必要があります。</p><p>R</p><p>Python</p><p>このコードは、2つのリストを含んだリストを作成します。1つ目のリストは、<code>CLE</code>のボックススコア、2つ目のリストは、<code>GSW</code>のボックススコアとなります。どちらのリストにもヘッダー、選手名、そして彼らのゲームでの統計量が含まれています。ここでは、訓練データに変換することはしませんが、簡単に<code>nba</code>データフレームに落とし込める形式に変換することができます。</p><p>RのコードはPythonのコードに比べて、より複雑になっています。これは、項目を選択する際の正規表現の使用において、便利な方法がないからです。よって、HTMLからチーム名を取得するために追加のパースが必要となります。またRでは、ベクトルに従って関数を適用するのに有利な<code>for</code>ループを使っていません。代わりに<code>lapply</code>を使っていますが、その行がヘッダーなのかどうかに応じて各行を取り扱う必要があるので、必要な項目のインデックスを渡し、<code>rows</code>リスト全体を関数に入れ込みました。</p><p>また、最新かつ広く使われているRのWebスクレイピングパッケージ、<code>rvest</code>を使っています。このコードで、必要なデータを抽出することが可能です。</p><p>Pythonでは、最も良く使われているWebスクレイピングパッケージ、<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="nofollow" title="" class="ext-link">BeautifulSoup</a>を使いました。これにより、容易にタグを通してループしたり、リストのリストを構成したりすることが可能になります。</p><p>これまでRとPythonを比較して、それぞれのデータセットをどう解析するかを見てきました。ここでは深く掘り下げなかった多くのタスクがまだあります。例えば、解析結果を主張したり、他の人と共有したり、テストや本番準備を行ったり、また、より視覚化したりするなどです。これらについては追って対応していきたいと思います。そうすることで、より確実な結論を打ち出すことができるでしょう。ひとまず、ここで話した内容いついて結論を記述しておきます。</p><p><code>lm</code>や<code>predict</code>、その他の関数を見てきましたが、Rではほとんどの処理で関数を使用しているのに対し、Pythonでは<code>LinearRegression</code>クラスやデータフレームの<code>sample</code>メソッドを使用しています。</p><p>統計データの概要を見てみると、Rでは<code>summary</code>というビルトイン関数を使用していますが、Pythonでは、<code>statsmodels</code>というパッケージをインポートしています。Rの場合、データフレームはビルトインされていますが、Pythonの場合は、<code>pandas</code>パッケージからインポートしなければなりません。</p><p>Pythonでは、線形回帰やランダムフォレスト、scikit-learnパッケージを使ったより多くの対応が可能です。一貫性のあるAPIが提供されており、よく管理されています。Rには、多様なパッケージがより多くあるのですが、Pythonに比べるとフラグメンテーションが起こりやすく、一貫性も劣っています（線形回帰はビルトイン、<code>lm</code>や<code>randomForest</code>は別のパッケージである、など）。</p><p>Rは、統計を目的とした言語であり、実際にそれを体現しています。Pythonの<code>statsmodels</code>や他のパッケージでは、統計メソッド向けの十分な適用を提供していますが、Rのエコシステムは、これらよりもはるかに大規模です。</p><p>PythonのBeautifulSoupといった十分に管理されたライブラリやリクエスト、Webスクレイピングは、Rよりもはるかに単純です。今回、この記事で述べていないようなタスクにも同じことが言えます。例えば、データベースへの保存やWebサーバーのデプロイ、また複雑なワークフローの実行などが挙げられます。</p><p>R、Pythonのどちらも相互的に刺激しあっている点があります（pandasのデータフレームはRのデータフレームの影響を受けていますし、rvestパッケージはBeatufiulSoupの影響を受けています）。そして、それぞれのエコシステムもより強力になってきています。シンタックスやアプローチ方法など、多くの類似した共通タスクが両者の言語にあるというのは、注目するに値します。</p><p><a href="https://www.dataquest.io/" rel="nofollow" title="" class="ext-link">Dataquest</a>では、元々、Pythonのレッスンだけを行っていましたが、最近はRも行っています。両者の言語は、お互いに補い合う関係だと思っています。Pythonの方が、多くの領域で強力だと感じてはいますが、Rも有効な言語です。データ調査や解析、または単独のデータ解析ツールなど、Pythonを補う言語としても使用できるかもしれません。今回の検証で証明されたように、両者の言語には、シンタックスやアプローチ方法といった共通点が多くあることが分かりました。これについては、どちらの言語においても疑う余地のない事実です。</p>
