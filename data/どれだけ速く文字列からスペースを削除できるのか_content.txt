How quickly can you remove spaces from a string? (2017-01-20) by Daniel Lemire時によってプログラマは文字列から不要な文字を取り除きたい場合があります。例えば、テキストの一部からすべての行の末尾文字を削除したいとします。その時、全スペース(‘ ‘)や改行コード(‘\n’および‘\r’)を削除する問題を考えてみましょう。効率的に実行するにはどのような方法がいいのでしょうか。上記のコードはUTF-8でエンコードされた文字列で動作します。UTF-8がASCIIのスーパーセットであることを考えるとインターネット上で見る文字列の大半はUTF-8になります。このコードは簡単で高速なはずです。このコードを様々なコンパイラが処理するところはとても面白いです。最終的に処理された1バイトあたりの命令の数が少なくなります。しかし、プロセッサは64ビットアーキテクチャを持っていますが、バイト単位で処理しています。 64ビットワード単位でデータを処理できるのでしょうか。ワードにゼロバイトが含まれている場合は必ずtrueの値を返す、ちょっと神秘的なビット遊びの表現があります。機能することだけが分かっていれば十分です。このツールを使用すれば、さらに処理の速い関数をプログラミングできます。8文字単位のブロックに空白がなければ、処理は速くなります。
この時何が起きているかというと、ある程度コストのかかるチェックに対し、スーパースカラプロセッサで高速に処理ができるため、基本的には64ビットのワードを1つ1つコピーするだけになります。結局、64ビットのワードを使用しなくても良いのです。上記はRobin Leffmannによって提案された、とても巧妙な方法です。
分岐誤予測ミスによるペナルティを回避できるため、非常に速いアプローチとなります。さらに改善はできるのでしょうか。もちろんできます。Pentium 4（2001年）以降128ビット(SIMD)命令が存在します。Intelの(醜い？) intrinsicを使って、この128バイトのSSEによる素早い命令で同じ問題を解決してみましょう。IntelプロセッサのSIMDの命令に馴染みがあるならば、このコードは極めて理解しやすいでしょう。私はこのコードを最適化する努力は何もしていません。ですから、より速く実行させられる可能性が高いのです。私のオリジナルのSIMDコードには分岐がありましたが、Nathan Kurzはコードを単純化して分岐を削除することが一番良いと気付きました。では、どれだけ速く実行するか見てみましょう。ほんの少しの空白ががあるテキスト入力に関して、新しいIntelプロセッサ（Skylake）を使ってベンチマークを設計しました。つまり、ベクトル化されたコードは標準コードの14倍近く速いことになります。これはなかなかの結果でしょう。それでも、いくつかのスペースを削除するには、memcpyでデータをコピーするよりも5倍の時間がかかります。従って、さらに速くすることが可能かもしれません。どこまで速められるでしょうか。ヒント：私たちのIntelプロセッサは256ビットのレジスタを（AVX/AVX2の命令によって）実際に処理することができます。つまり、2倍の速さを実現することが可能ということです。悲しいことに、x64プロセッサ上における256ビットのSIMDの命令は、2つの128ビットの独立型のlane上で動作し、アルゴリズムの設計をより一層大変にします。LeffmannのアプローチはSIMDの命令と同じほど速くはありませんが、より一般的で可搬性のあるものです。そしてさらに、標準コードの3倍もの速さです。私のCコードはこちらのリンクから入手できます関連した投稿：
* Variable-length strings can be expensive（可変長の文字列は高くつくことがある）
* Intel will add deep-learning instructions to its processors
（Intelはプロセッサに深層学習の命令を追加するだろう）
* How fast is tabulation-based hashing? The downsides of…
（集計ベースのハッシングはどのくらい速いのか。ｚobristの欠点）
