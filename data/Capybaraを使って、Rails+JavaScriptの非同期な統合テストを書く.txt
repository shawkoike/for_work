<p><a href="https://robots.thoughtbot.com/write-reliable-asynchronous-integration-tests-with-capybara" rel="nofollow" title="" class="ext-link">Write Reliable, Asynchronous Integration Tests With Capybara</a> （2014-09-10） by <a href="https://twitter.com/joeferris" rel="nofollow" title="" class="ext-link">Joe Ferris</a></p><p>バランスの取れたテスト方法として、私たちは統合テストを頼りにしています。統合テストは、<a href="https://robots.thoughtbot.com/testing-from-the-outsidein" rel="nofollow" title="" class="ext-link">アウトサイドイン開発</a>をサポートしており、リグレッションを見つけたり、RubyとJavaScriptそれぞれの単体テストのギャッブを埋めたりすることができます。</p><p>しかし、RubyとJavaScriptの統合テストでは、リスクが伴います。開発者は不定期に発生するテストの失敗に対して、度々、不満を漏らしています。これらのテストのデバッグでは、ログ見る限りはテストのデータベースに挿入された記録があるレコードが、ページ上に表示されないといったような問題が起こることがあるからです。そのため、開発者の中には、統合テストを全く行わないという人もいます。</p><p>なぜ、JavaScriptでの統合テストは難しいのでしょうか？</p><p>まずは、背景からお話しましょう。</p><p>Railsアプリケーションでの統合テストは、HTMLのインターフェイスを通して行うユーザエクスペリエンスのシミュレーションによって機能します。Railsアプリケーションを読み込み、例えばCapybaraといった統合テストハーネスがサイト上でユーザのクリックをシミュレートするのです。</p><p>JavaScriptを考慮しない場合では、Capybaraはrack-testをデフォルトのドライバとして使用し、以下のようになります。</p><p><code>click_link</code>といった他のアクションでも同様に機能します。rack-testは、本来のブラウザのようにするために、クッキーの保存、リダイレクトのフォロー、フォームの投稿を行います。このシミュレーションブラウザは、本来のブラウザと同様に様々なことが行えますが、大事な機能であるJavaScriptが含まれていません。</p><p>JavaScriptのドライバは、少し異なった動きをします。なぜなら、WebKitのようなブラウザツールでは、Rubyプロセスの中に読み込むことが難しく、これらのドライバは、HTMLレンダリングエンジンと相互作用することができる外部プロセスを起動するからです。そして、この外部プロセスはRailsアプリケーションのインメモリのインスタンスにアクセスすることができないため、実際のHTTPリクエストを作成しなくてはなりません。</p><p>CapybaraのJavaScriptドライバを使用した際に実行されるインタラクションは次のとおりです。</p><p>上記が機能するには、プロセスフォーキングやHTTPリクエスト、バックグラウンドスレッドなど、追加で多くの構造が必要となります。しかしながら、よくユーザがぶち当たる主な壁は、あのやっかいなバックグラウンドスレッドなのです。</p><p>バックグラウンドスレッドでリクエストが処理されているということは、<strong>アプリケーションがシミュレーションのインタラクションに応答する間もテストは実行される</strong>ということです。このれにより、無限の数の競合状態が生じ、ページ上にまだ表示されていない要素を実行中のテストが探すことになります。</p><p>ほとんどのCapybaraのソースコードは、これらの非同期の問題を解決するためだけのものです。インタラクションまでにページが読み込まれたか分かるほど、Capybaraは賢いのです。代表的なインタラクションは次のとおりです。</p><p>
</p>
<p>上からも分かるように、ページの読み込みが完了する前に、テストでリンク探しを始めたのにも関わらず、Capybaraは優雅にインタラクションを処理しています。</p><p>しかし、Capybaraがこれらの非同期の問題を処理してくれるにもかかわらず、成功したり失敗したりする一貫性のないテストにいとも簡単に陥ってしまうのはなぜなのでしょう。</p><p>競合状態の数を最小限に抑えて、Capybara APIを正しく使用するには、いくつかのコツがあります。</p><p>悪い例</p><p>まだページに<code>.active</code>要素がない場合、<code>first</code>は<code>nil</code>を返し、クリックは失敗します。</p><p>良い例</p><p>悪い例</p><p>まだ適合する要素がない場合、空の配列を返してしまうので、要素を操作することができません。</p><p>良い例</p><p>クリックを始める前に、Capybaraはまず適合するエレメントを待ちます。</p><p>注：適合する要素を1つずつ返していくより、良いテストはありますが、記事の内容から離れてしまうためここでは触れません。よく考えてから<code>all</code>を使うようにしてください。</p><p>悪い例</p><p>JavaScriptの表現は、その動作が完了しないうちに評価されることがあり、間違った要素に影響を及ぼす、あるいはどの要素にも影響を及ぼさないかもしれません。</p><p>良い例</p><p>Capybaraは適合する要素がページに現れるまで待ち、それと相互に作用するJavaScriptのコマンドを送信します。</p><p>注：<code>execute_script</code>は、ドライバの制限あるいはその他の問題により他のCapybaraメソッドが使えない場合に限り、最終手段として用いられるべきです。</p><p>悪い例</p><p>Capybaraは適合する値を待ち、その後すぐにその値を返します。もしも値がページの読み込み、あるいはAjaxのリクエストから変化すれば、手遅れになります。</p><p>良い例</p><p>Capybaraは適合する値を待ち、その後はその値が適合するまで、最大で2秒待ちます。</p><p>悪い例</p><p>Capybaraは適合する要素を待ち、その後すぐに要求された属性を返します。</p><p>良い例</p><p>Capybaraは要素が現れるのを待ち、正しい属性を手に入れます。</p><p>悪い例</p><p>Capybaraは、要素がまだページから削除されていなければすぐに<code>true</code>を返すので、テストは失敗に終わります。また、<code>false</code>を返すまでにも2秒待ちますので、結果が出るまで時間がかかるテストだということになります。</p><p>良い例</p><p>Capybaraはテストが失敗になる前に、要素が消えるまで最大2秒間待ちます。要素が予期していたようにページにはないときは、即座にパスします。</p><p>ページとのインタラクションを行う場合は、<code>find</code>のような<a href="http://www.rubydoc.info/github/jnicklas/capybara/master/Capybara/Node/Finders" rel="nofollow" title="" class="ext-link">finderメソッド</a>の代わりに、可能なときはいつでも<code>click_on</code>のような<a href="http://www.rubydoc.info/github/jnicklas/capybara/master/Capybara/Node/Actions" rel="nofollow" title="" class="ext-link">actionメソッド</a>を使いましょう。Capybaraはこれらのメソッドで何をしているか大抵は理解していますし、おかしなエッジケースをより賢く扱うことができます。</p><p>要素が予期していたとおりにページにあるということを証明する場合は、<code>text</code>のような<a href="http://www.rubydoc.info/github/jnicklas/capybara/master/Capybara/Driver/Node" rel="nofollow" title="" class="ext-link">nodeメソッド</a> の代わりに、可能な限り<code>have_css</code>のような<a href="http://rubydoc.info/github/jnicklas/capybara/master/Capybara/RSpecMatchers" rel="nofollow" title="" class="ext-link">RSpec matcher</a>を使いましょう。Capybaraはマッチャと共に、望んでいる結果を待つことができますが、ノードでメソッドを作動させる時にどのようなテキストを期待しているかは分かりません。</p>
