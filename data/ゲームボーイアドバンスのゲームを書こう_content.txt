WRITING A GAME BOY ADVANCE GAME （2015-8-21） by JOE SAVAGE子どもの頃は、ゲームボーイのゲーム（たいがい、かなりひどいもの）で遊ぶのにたっぷり時間を費やしました。これまでは「標準の」一般的な目的に使われるコンピュータ以外のためにコードを書いたことはなかったのですが、最近考えるようになりました。「ゲームボーイ（アドバンス）のゲームは簡単に書けるだろうか？」ゲーム機には詳しくない方のために説明すると、ゲームボーイアドバンス（GBA）は、任天堂が発売した人気携帯型ゲーム機でした（写真下）。240 x 160 (3:2) 15ビット カラーLCDディスプレイ、6種類のボタンと十字キーが付いています。
ゲームボーイアドバンス内部を見ると、GBAのCPUは32-bit ARM7TDMI RISCコア（16.78MHz）です。標準の32-bit ARMのインストラクションのほかに、このチップは16ビット Thumbのインストラクションも実行できます。Thumbのインストラクションセットは、非常に一般的な32-bit ARMのインストラクションのいくつかに対してたった16ビットのエンコーディングを行うため、スペースを節約できます。メモリについては、このデバイスはCPUの中に130KBの内蔵メモリ（うち96KBはVRAM、32KBは一般利用、2KBはその他に使われている）、CPUの外部に256KBのRAMを擁しています。またシステムは、BIOSを格納する16KBのシステムROMを持っています。他にも先行機のゲームボーイカラーとの上位互換に関わる機能がいろいろあるのですが、ここでは触れません。以上全ての本体メモリに加え、GBAは一般的にいくつかの種類のゲームカートリッジを搭載できました。これらはたいていROM（インストラクション、リードオンリーデータなどを格納する）といくつかの形態のミュータブルなストレージ（SRAM、フラッシュメモリまたはEEPROMが多い）で構成されています。Game Pak ROMが16ビット幅のバス経由で接続されるので、ゲームコードの多くの時間、32ビット ARMのインストラクションよりも、当然16ビットのThumbインストラクションを使います。
GBA Game Pakの例（reinerziegier.de提供）これまで見てきたメモリセクション、I/Oハードウェアレジスタ（グラフィック、音、DMAなどを制御する）は、メモリにマッピングされており、下記のようなレイアウトになっています。これらのセクションは異なるバス幅、読み出し／書き込み権限（たとえば、VRAMには個別のバイト数書き込みは不可）を持っており、いくつかのセクションはメモリに複数の点に渡るミラーデータも持っています。実際にはもう少し複雑な状況がありますが、これが基本的なGBAゲームを作るのに必要とする主な構造です。デバイスのメモリ構造が分かったところで、GBA ROMで”Hello, World!”を表示させるプランは次のとおりです。Game Pak ROMにThumbコードを書きます。これはI/Oレジスタに、特定のディスプレイモードに適したディスプレイ変数を設定するものです。そして表示させたいグラフィックデータをVRAMに書きます。デバイスの理論は置いておいて、まずは実際に何かを作ってみましょう。GBA ROM構築プランを実行するにあたり、ROMフォーマットについて知る必要があります。細かいところに入り込む前に見ておきたいのは、GBA ROMは標準ヘッダで始まるということです。プログラムの開始アドレスの枝分かれを指示する4バイトARMインストラクションで始まり、次にいくつかの「magic」バイトが任天堂ロゴを表示させます。加えて、このヘッダにはゲームに関するデータ（ゲームタイトルなど）とこのデータの’check’値が含まれます。ROMが最適に実行されるために、ヘッダは完璧に正しくなければならないことを知っておきましょう（特に、エミュレータでなくある実在のデバイスで動かすことを目的にしている場合）。ありがたいことに、ROM作成過程のほぼ全てに使える良いツールチェーンがあります。私が使っているdevkitARMツールチェーン（GCCツールチェーンをベースにしたdevkitProのツールチェーンの1つ）は、プロセスを非常に簡単にしてくれます。ツールチェーンをセットアップしたら、実質4つの手順で、CコードをGBA ROMに入れることができるのです。私のマシンOS Xで使用しているツールチェーンのバージョンでは、上述したようにCファイルをGBA ROMにコンパイルする際、次のコマンドを実行することができます（PATH環境変数を/opt/devkitpro/devkitARM/binだとして）。最初のステップ（コンパイル）で、追加で立てておきたいフラグが他にもあるかもしれません。その場合、たとえば、-fno-strict-aliasingを使う事をおすすめします。ローメモリとポインタを多数扱いますし、C言語の厳密な言い換え規則に煩わされたくないためです。あるいは、Makefileかシェルスクリプトをこれらのコマンドと共に書くのも、ROMコンパイルを容易にするのに有益かもしれません。このような詳細はこの投稿ではやや不必要と思われるかもしれませんが。C言語からROMコンパイルのプロセスが確立したら、早速実行、テストをしてみましょう。理論には興味がない読者のため、今回作成しているGBA ROM “Hello, World” のコードを提示し、話は後にしましょう。上のコードはかなりシンプルで、GBAスクリーンの中央に赤色、緑色、青色それぞれ1つずつ、3つのピクセルが水平に並ぶというものです。では、改めてコードについて説明します。最初に、いくつかのディスプレイ変数をI/Oレジスタをマッピングしたメモリに書きます。特に、このメモリの初めの16ビットは、ディスプレイ制御レジスタ（DISPCNTとも呼ばれます）です。このレジスタの冒頭の3ビットはビデオモードを示し、11番目のビットはバックグラウンド#2（BG2）が有効か否かを示します。こうして値を書くことによって、ビデオモードをモード3に設定し、BG2を有効にします。なぜこのような作業が必要なのでしょうか？　まあ、まずはビデオモードからいきましょうか。ビデオモード3はVRAMにビットマップデータを書くことができるモードであり、BG2はこのビットマップを表示します（そのために、BG2も有効にしたいのです）。さらに、なぜ私があえて他のビデオモードでなくビデオモード3を選んだのか疑問に思われるかもしれません。その理由は、ビデオモード0から2は説明するのが非常に難しいからです（とはいえ、後でそれらも使います）。先に述べたように、GBA上のLCDは15ビットカラーの表示が可能です。よって、GBAのカラーを1つの15ビットカラーフォーマットを使って表現できるということです。しかし、データ配列の理由から、GBAは16ビットのカラーフォーマットを使います。具体的には、フォーマットは下記のとおりです。?BBBBBGGGGGRRRRR。つまり、1ビットの不使用ビットの後に、5ビットの青色、5ビットの緑色、そして5ビットの赤色が並ぶということです。このフォーマットと、ビデオモード3がVRAMを240 x 160ビットマップとしてどのように扱うかの知識をもとに、私たちの”Hello, World” ROMはシンプルに一定のピクセルオフセットでいくつかのカラー値を書き出します（例：unsigned shortが16ビットサイズだと仮定すると、vram[80*240 + 120]は240ピクセルの80行をスキップし、水平ライン上中央のピクセルにアクセスします）。憶えておきたいのは、コード内でハードウェアにインターフェース接続する全てのメモリアクセスはvolatileポインタを通じて起こるということです。このことは、コンパイラが不必要に思われるメモリオペレーションを最適化するのを妨げます。基本は脇に置いて、もう少し面白い物を作ってみましょう。一連のプロジェクトのインフラストラクチャやヘルパー関数を構築するのではなく、ここでも一緒にソリューションのプログラミングに取り組んでいきます。ただし、更に進んだGBAの画像のレンダリング機能を使用する予定です。特に、ビットマップビデオモードを使わずに描画する方法を用いましょう。GBAのビットマップビデオモード（モード3、4、5）で描画するのはとても簡単です。しかし、実際にゲーム制作に利用されることは多くありません。240×160のビットマップは、一度画面を埋めるだけでVRAMの大部分を使ってしまいます。そして各フレームで非常に多くのピクセルを使うので、コンピューターへの負荷がとても増えてしまうのです（適度なフレームレートでゲームをレンダリングしようとする余裕はなくなってしまうでしょう）。ですから、ビデオモード0、1、2を使います。これらのモードはかなり複雑なので、ここでは最も重要な部分だけをざっと説明します。GBAのビデオモード0、1、2では、個々のピクセル上で動作するのではなく、タイル上で動作します。タイルとは8×8のビットマップのことです。4及び8ビット毎ピクセル（bpp）バリアント型データの中に存在します。今回は4bppタイプを使いましょう。つまり、使用するタイルのサイズは32バイトとなります（8×8×4＝256ビット）4（または8）ビットのピクセルに、どうやって15ビットの色値を適用させるのかと疑問に思われるかもしれませんが、そうはしません。タイル内のピクセル値は、色を直接参照するのではなく、あるカラーパレット内の色を参照します。先ほど言及したカラーパレットのメモリ（0x05000000）に、色値を書き込むことでカラーパレットを定義することが可能です。ここには16ビットを512セット（つまり512色）保存でき、実質的には256色を2パレット、または16色を32パレット保存できるということです。
パレットを適用したタイルを視覚化した例ここで使っている4bppで8×8のビットマップのタイルでは、16色の32パレットとしてカラーパレットメモリを扱おうと思います。この方法では、各ピクセルに4ビットを用いてカラーインデックス（16色のパレット内）を指定することができます。タイルを基準としたビデオモードを使うと、タイルはVRAM内で「タイルブロック」または「charブロック」にセクション分けされます。各タイルブロックのサイズは16KBなので、1つのタイルブロックには512の4bppタイル、VRAMには6つのタイルブロックを適用させることができます。理論上、VRAM内の6つのタイルブロックは2つのグループに分かれます。最初の4つ（0 – 3）は背景に使うことができ、残りの2つ（4と5）はスプライトに使うことができます。同様に、パレットメモリ内にある16色32パレットは、16パレットは背景用に、別の16パレットはスプライト用に分けられています。私たちが作るゲームでは背景は扱わないので、VRAM内のタイルブロック4、5（つまり0x6010000と0x6014000から始まるアドレス）とカラーパレットのブロック1（アドレス0x5000200）だけに注目していきましょう。例えば、いくつかのタイルをタイルブロック4へとロードしたとします。これをどうしたらいいのでしょうか？　このような場合に、タイルの扱い方で肝心なのは、これらのタイルを使うスプライトを作るということです。コンピュータグラフィックスにおいて、スプライトは、より大きなシーンに適用するための2次元のイメージです。GBAには「オブジェクト」（つまりスプライト）をレンダリングできるハードウェアが備わっていて、オブジェクトがピクセル修正の流れから外れることなく動き回れるように、オブジェクトはレンダリングされます。オブジェクトを使用可能なように設定されると（ディスプレイ制御のI/Oレジスタ内のビット13が設定されると）、オブジェクトの属性をGBAのObject Attribute Memory (OAM)に書き込むことで、特定のタイルセットからオブジェクトを生成できるようになります。私たちは「ポン」の類似ゲームを作ろうとしていますが、この場合、少なくともラケットとボールの2つのスプライトが必要になるでしょう。また、どんな「オブジェクト」であっても、それぞれ16ビットの属性を3セット持っています。これらの値の詳細はこちらのページで確認できます。しかし根本的に、Y座標は属性0の中で最も低い8ビット、X座標は属性1の中で最も低い9ビットとなり、カラーモードは4bppに初期化されます（つまり、0=4bpp）。オブジェクトの「シェイプ」と｢サイズ｣のビットは、その形状を定義し、この4ビットを異なる組み合わせにすることで、最終的なシェイプを変えることができます（このシステムよりも複雑なエンティティは、より小さい複数のオブジェクトで構成されています）。１タイルのサイズよりオブジェクトを大きくしなければならない場合は、設定したマッピングモードに左右されるアピアランスのために、別のタイルを使うこととなります（ディスプレイ制御I/Oレジスタの7番目のビット）。オブジェクトが１タイルよりも大きくなってしまう場合は、メモリ内の「ベースタイル」に続くタイルを使って内部を埋める、1Dマッピングモードを使うのが一番簡単な方法でしょう。先ほど説明したスプライトについてですが、構築する準備は大体できました。今回のプログラムではビデオモード0を使いたいと思います。このモード内ではBG0～BG3が「標準」モードで作動しています（アフィン変換はできません）。あとは、GBAの十字キーからプリミティブ物理コードを入力し、ゲームループの内部全体に置くだけで、ゲームができるのです！最後に必要な2つの作業は、両方ともI/Oレジスタで行います。デバイスの入力状態は、単純にKEYINPUT I/Oレジスタ（0x04000130）から読み取ることができます。また、ビットの割り当ての詳細を使い、あるキーが押されたかどうか分かるよう、この状態にマスクを作っておきます。ゲームループに関しては、残念ですが、最後にもう一つ理論が必要となります。典型的なゲームループは、描画期間と更新期間で構成されています。今回の場合は、これが発生するタイミングを選ぶことはできません。ゲームボーイがオブジェクトを途中まで描画している最中に、表示したいものを変える場合、スクリーンを分けなくてはいけません（オブジェクトの半分はあるデータセットで描画されたもので、もう半分は別のデータセットで描画されたもの）。結果として、GBAの表示リフレッシュサイクルを使って、描画と更新を同期しなければいけません。デバイスには、描画した水平ライン（もしくはスキャンライン）が終わるたびに更新する時間が少し設けられていますが、スクリーン全体を描画した後は少し長めの時間が与えられます（およそ5ミリ秒）。この場合、画面全体を描画した後は、更新のためだけに時間を使えるようになります。この期間は「V-Blank」と呼ばれています（まだスクリーンが垂直方向に描画されている「V-Draw」の逆です）。現在、デバイスがどの程度描画されたかを確認するためにVCOUNT I/Oレジスタ（0x04000006）で8ビットの値をチェックできます。この値はV-Blankの期間に、スキャンラインが描画され続けているかのように増加し続けます（そのため0から227までの幅があります）。もし160以上の値がカウントされたら、V-Blankの期間だということが分かるのです。そのため、ゲームループの｢更新｣ステージ前にV-Drawの期間が終わるのを待っているのであれば、同期プリミティブフォームがあります。この同期によって、ようやくゲームを構築するのに充分な情報を得ることができます。今回は、1人用のポンの類似ゲームを作ることにしましょう（極めてプリミティブな物理学を用います）。コメント入りのソースコードを以下に示します。これで、基本的なゲームの完成です！　これは本当のゲームボーイアドバンスでも動くでしょうか？　多分…、動きます。もし、私が間違えていなければ正しく動くはずですが、どこかでコードを間違えている可能性だって充分あるでしょう。

    Your browser does not support HTML5 video.この投稿は、予想よりもずっと長くなってしまいました。この投稿で説明した詳細よりも、GBA開発にははるかに多くの事象があり、他のプラットフォームと同じ様に、面白い機能や癖があります。もっとGBA開発や、この投稿で紹介したデバイスの仕様を知りたい場合は、以下に記載するリソースがとても役に立つはずです。Nintendo’s AGB Programming Manual、GBATEK、CowBiteSpec、Tonc
