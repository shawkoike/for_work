Go best practices, six years in by Peter Bourgon（本稿は、QCon London 2016で行った講演の内容に基づいています。スライドとビデオは近日中に掲載予定です）2014年に開催された最初のGopherConで、私は「Best Practices in Production Environments（本番環境でのベストプラクティス）」と題した講演を行いました。SoundCloudの私たちはGoのアーリーアダプターで、その時点までに既に2年近く、本番環境向けの様々なGoコードを書き、実行し、メンテナンスしていました。そして私たちはいくつかのことを学んだので、その教訓をまとめ、多くの人に伝えたいと思ったのです。それ以来、私はフルタイムでGoを使う仕事を続けています。SoundCloudではその後の活動やインフラチームで、そして現在はWeaveworksでWeave ScopeやWeave Meshの開発に使っています。また、オープンソースのマイクロサービス向けツールキットGo kitの開発にも力を入れています。その間ずっと、Goコミュニティでも活動を続け、欧州や米国の各所であった集まりや会議で多くの開発者と会い、成功した話も失敗した話も聞いてきました。2015年11月にGoが誕生6周年を迎えたことで、私は最初の講演を思い起こしてみました。当時のベストプラクティスのうち、時を経ても変わらず有効な事例、時代遅れや非生産的になった事例は？　新たなベストプラクティスは生まれたのか？　3月にはQCon Londonで講演を行い、2014年のベストプラクティスを振り返るとともに、2016年のGoはどのような進化を遂げてきたかに注目しました。本稿はその講演の内容をまとめたものです。キーポイントは、「一言アドバイス」としてリンク付きでハイライト表示しています。以下が本稿の目次です。Goには、GOPATHを中心とした開発環境の規約があります。2014年、私は単一のグローバルなGOPATHを強く提唱していましたが、その姿勢は今では少し弱まりました。他の事情が同じならば単一のグローバルなGOPATHが一番いい、という考えに変わりはありませんが、プロジェクトやチームによっては他の方法も有効かもしれないと思うようになりました。自身や組織が構築しているものが主にバイナリの場合は、プロジェクトごとのGOPATHが便利かもしれません。Dave Cheneyとコントリビュータが開発したgbは、標準のgoツーリングをこのユースケース向けに置き換える新ツールです。多くの開発者から、gbを使った成功事例が多数報告されています。中には、$HOME/go/external:$HOME/go/internalのような2エントリのGOPATHを使うGo開発者もいますが、goツールはかねてからこの処理方法を認識しています。go getが最初のパスをフェッチするので、サードパーティコードと内部のコードを厳密に分離する必要がある場合は便利かもしれません。1つ気づいたのですが、開発者に忘れられがちな点があります。GOPATH/binをPATHに追加するということです。これをやっておけば、go getで得たバイナリを簡単に実行でき、コードをビルドするという（望ましい）go installのメカニズムが扱いやすくなります。設定しない手はありません。

エディタと統合開発環境（IDE）については、多くの改良がなされてきました。vim使いにとっては、今や最高の環境が整っています。Fatih Arslanが大変優れた取り組みを続けてくれているおかげで、vim-goプラグインは本当に素晴らしい状態となり、その分野で最良のツールとなっています。私はEmacsにはそれほど詳しくありませんが、Dominik Honnefのgo-mode.elはとても重要なツールだと思います。上位層へと移行しながらも、多くの開発者は今でもSublime Text + GoSublimeの組み合わせでうまくやっています。これはあまり速い方法ではなく、近頃はElectronを使ったエディタに注目が集まっているようです。Atom + go-plusは愛用者も多く、特に言語を度々JavaScriptに切り替えなければならない開発者は好んで使っています。意外だったのはVisual Studio Code + vscode-goで、この方法はSublime Textより遅いものの、Atomよりは明らかに速く、私にとって重要な、クリックで定義に飛ぶ機能などがデフォルトでサポートされていて素晴らしいと思います。私はこの組み合わせをThomas Adamに紹介されて以来、もう半年ほど毎日使っています。とても面白いですよ。完全なIDEに関しては、専用に作られたLiteIDEが定期的にアップデートされており、一定の愛用者が存在します。また、IntelliJ Goプラグインも着実に改良されています。

長い時間をかけてプロジェクトが成熟してくると、いくつかの明らかなパターンが見えてきます。リポジトリを構造化する方法は、プロジェクトがどのようなものかによって決まります。まず、プロジェクトが私的または社内向けの場合は、好きなようにしていいでしょう。独自のGOPATHに対応させたり、カスタムビルドツールを使ったりするなど、便利になり生産性が上がるようになることは何でも取り入れるのです。一方、プロジェクトが公的な場合（例：オープンソース）、ルールは少々厳しくなります。多くのGo開発者は、あなたが作ったパッケージの取り込みにgo getを使うはずですので、go getにきちんと対応しておくべきでしょう。何が理想的な構造であるかは、構築しているもののタイプによって決まります。リポジトリがバイナリ専用またはライブラリ専用の場合は、ユーザがgo getやimportをベースのパスで実行できるようにしておきましょう。すなわち、github.com/name/repoにはmainパッケージやインポート可能な主要リソースを置き、サブディレクトリはヘルパーパッケージ用とするのです。リポジトリにバイナリとライブラリが混在する場合は、どちらをメインにするか決めて、それをリポジトリのルートに置くべきです。例えば、バイナリがメインで、ライブラリにも使うなら、構造は以下のようになるでしょう。1つ効果的なのは、サブディレクトリlib/に置くパッケージの名前を、ディレクトリではなくライブラリにちなんで付ける方法です。上記のケースでは、libパッケージではなくfooパッケージとしています。この命名法は、かなり厳密なGoのイディオムにおける例外となりますが、実際はユーザに対して非常に親切なやり方です。このように構造化されたリポジトリの好例としては、HTTP負荷テストツールtsenart/vegetaがあります。

リポジトリが主にライブラリ用で、バイナリも多少含むという場合は、構造は以下のようになるでしょう。前述の構造を逆にして、ライブラリコードをルートに置き、サブディレクトリcmd/foo/をバイナリコード格納用にするのです。中間にcmd/を介すると便利な理由は2つあります。1つは、Goのツーリングでは自動的にmainパッケージのディレクトリにちなんでバイナリの名前が付けられるので、リポジトリにある他のパッケージとかち合う可能性のない最適な名前が得られることです。もう1つは、間に/cmd/の入ったパスでユーザがgo getを実行すれば、取り込もうとしているものについてのあいまいさがなくなることです。gbはそのように設計されているビルドツールです。

リポジトリ構造で目指すべきは、ユーザのための最適化です。あなたのプロジェクトを最も一般的な形で、利用しやすいものにしましょう。このユーザ中心の考え方は、Goの理念の一部だと思います。

フォーマッティングとスタイルに関しては、大きな変化はありません。これはGoでは以前から適切に扱われていた領域で、コミュニティ内の合意があり、言語が安定していることを大変ありがたく感じています。Code Review Commentsは大変有用で、コードレビューの際に準拠する最低基準となるものです。名前に関してもめたり一貫性がなかったりする場合は、Andrew Gerrandの示した慣用的な命名規則が優れたガイドラインとなるでしょう。

ツーリングに関しては、良くなる一方です。エディタは保存時に、gofmtか、さらに良いのはgoimportsを呼び出すように設定するといいでしょう（この点には異論はないと思います）。go vetツールでは（ほぼ）誤った結果は出ないので、pre-commitフックに組み込むことを考えてもよいかもしれません。そして気になる点のチェックを行うには、gometalinterが優れていると思います。それでも誤った結果が出る可能性はあるので、何らかの形で独自のルールをコード化しておくのも悪くありません。

設定は、実行時環境とプロセスの間をカバーする領域であり、明示的な形で、きちんと文書化されていることが望ましいでしょう。私が今でも使っていて推奨しているのはflagパッケージですが、もう少し分かりやすくなってほしいと現在感じていることは否めません。getopts式のロング形式とショート形式の引数構文が標準でサポートされておらず、ヘルプの文言が簡潔でないのは残念なことです。Twelve-Factor Appは、環境変数を設定のために使うことを推奨していますが、各変数がフラグとしても定義されているならば良い方法だと思います。明示性は重要です。アプリケーションの実行時の振る舞いを変える際には、その変化が認識でき、文書化されていることが望ましいのです。これは2014年に述べたことですが、大事な点なのでもう一度繰り返します。フラグはmain関数で定義、パースしましょう。main関数だけが、ユーザの利用できるフラグを決められるべきです。ライブラリコードで振る舞いをパラメータ化する必要があるなら、そのパラメータは型コンストラクタの一部とすべきでしょう。設定をパッケージグローバルな場所に移せば便利になるというのは思い違いであり、見せかけの省力化にすぎません。コードのモジュール性が損なわれ、開発者や未来のメンテナンス担当者が依存関係を理解するのが難しくなりますし、並列実行が可能な独立したテストを書くのはもっと大変になってしまいます。

こうした様々な特性を兼ね備え、スコープが適切に設定されたflagsパッケージがコミュニティから生まれる見込みは、大いにあると思います。ひょっとしたら、既に存在しているのかもしれません。もしあるならぜひ使ってみたいので、情報をご存じの方はどうぞお知らせください。

講演では、プログラム設計のいくつかの問題を議論するための出発点として、設定の話をしました（2014年の講演では、プログラム設計は取り上げませんでした）。まずはコンストラクタを見てみましょう。全ての依存関係を適切にパラメータ化している場合、コンストラクタはかなり大きくなる傾向があります。このようなコンストラクションは、設定オブジェクトで最適に表現されることもあります。すなわちコンストラクタに対する構造体パラメータであり、コンストラクタは構築されるオブジェクトに対するオプションのパラメータを取ります。例えば、fooKeyが必要なパラメータで、その他全ては賢明なデフォルトを持つかオプションであるとしましょう。よく見かけるのは、設定オブジェクトを少しずつ構築するプロジェクトです。ですが、いわゆる構造体の初期化構文を活用して、オブジェクトを一斉に単一の文で構築した方がずっとよくなります。オブジェクトの無効な中間状態に依存する文がありません。そして全てのフィールドはきちんと区切られてインデントされ、fooConfigの定義を反映しています。設定オブジェクトは、構築したらすぐに使うということに注意してください。この例では、構造体の宣言をnewFooコンストラクタの中に直接組み込むことで、中間状態の段階を1つ省き、コードの行数も1行減らせます。よくなりましたね。

では、賢明なデフォルトについて考えてみます。Outputパラメータは、nil値を取り得るものです。議論を進めるために、io.Writerだとしましょう。特別なことをしない限り、これをfooオブジェクトで使うためには、先にnilチェックを実行する必要があります。これではイマイチです。存在チェックをせずに出力を扱える方が、ずっと安全で便利です。ここでは有用なデフォルトを提供すべきでしょう。インターフェース型では、インターフェースのno-op（何もしない）実装を提供するものを渡すのも良い方法です。実は、標準ライブラリであるioutilパッケージには、ioutil.Discardと呼ばれるno-opのio.Writerが備わっています。

それをfooConfigオブジェクトに渡すことも考えられますが、それでもまだ脆弱です。呼び出し先での処理が抜けていれば、やはりnilパラメータで終わるでしょう。そこで代わりに、コンストラクタ内で一種の安全対策を講じることができます。これは、ゼロ値を役立たせるというGoのイディオムのちょっとした応用例です。パラメータのゼロ値（nil）によって、デフォルトの振る舞い（no-op）を適切なものにすることができるのです。

再びコンストラクタを見てみます。パラメータのfooKey、bar、period、outputは、全て依存関係を持っています。fooオブジェクトは、開始と実行に関してこの各パラメータに依存しているのです。私がこの6年間毎日のように、Goのコードを自由に書き大規模なGoプロジェクトを観察してきた中で、1つだけ学んだ教訓があるとすれば、それは依存関係を明示的にするということです。

膨大な量に及ぶメンテナンスの負荷、混乱、バグ、そして技術的負債が、不明瞭または非明示的な依存関係に由来する可能性があると、私は考えています。型fooに関する以下のメソッドを考えてみましょう。fmt.Printfは自己完結しており、グローバルな状態に影響も依存もしていません。関数型言語的に言えば、参照透過性がある状態です。つまり依存関係は存在しません。f.Barは明らかに依存関係を持っています。そして面白いことにlog.Printfは、自身に対する操作を持たないPrintf関数があるため分かりにくくなっていますが、パッケージグローバルなロガーオブジェクトに対して作用します。よって、これにも依存関係があります。依存関係はどうすればよいでしょうか？　明示的にするのです。processメソッドは処理の一環としてログに出力するので、メソッドまたはfooオブジェクト自体が、ロガーオブジェクトと依存関係を持つ必要があります。例えば、log.Printfはf.Logger.Printfにすべきでしょう。ログへの書き出しといった特定部類の処理は、付随的なものと見なしがちです。そのため、見かけ上の負荷を減らそうと、私たちはパッケージグローバルなロガーなどのヘルパーを喜んで活用します。しかし、インストゥルメンテーションのようなロギングはサービスの運用に不可欠な場合が多く、依存関係をグローバルスコープ内に隠してしまうと後で大変なことになりそうですが、実際そのとおりです。これはロガーのような一見当たり障りのないものであれ、ひょっとすると他のもっと重要な、わざわざパラメータ化していなかったドメイン特有のコンポーネントであれ、当てはまることです。厳密にすることで、未来の苦労は減らせます。依存関係は必ず明示的にしましょう。

もちろん、この例のロガーも、賢明なデフォルトを取るようにするべきです。

目下の問題について述べます。ロギングを使った制作を多く経験しているのですが、それによってこの問題への関心が高まりました。ロギングは想像するよりもずっと高価で、システムのボトルネックになりやすいのです。この件については別のブログ投稿で範囲を広げて書きましたが、まとめると次のようなことです。ロギングは高価なのに対し、インストゥルメンテーションは安価です。コードベースのあらゆる重要なコンポーネントをインストゥルメンティング、計測すべきです。それがキューのようなリソースの場合は、Brendan GreggのUSEメソッドに従い、利用率、集中度、そしてエラーカウント（率）を計測しましょう。エンドポイントのようなものであれば、Tom WilkieのREDメソッドに従い、要求カウント（率）、エラーカウント（率）、そして持続時間を計測します。他に選択肢があるとすれば、おそらくPrometheusが適切なインストゥルメンテーションシステムです。そして当然、メトリクスも依存関係です。ロガーとメトリクスを使い、より直接的にグローバル状態をピボット、アドレス指定していきましょう。以下にGoに関する事実をいくつか挙げます。これらの事実は小規模では便利ですが、規模が大きくなると扱いにくくなります。すなわち、固定グローバルロガーを使うコンポーネントのログ出力は、どうやってテストすればよいのでしょうか。その出力をリダイレクトしなければなりませんが、どうすれば並行テストができるのでしょうか。無理？それでは不十分に感じます。あるいは、異なる条件でHTTP要求する2つの独立したコンポーネントがある場合は、どうやって管理するのでしょうか。既定のグローバルhttp.Clientでは、それは非常に困難です。次の例を考えてみましょう。http.Getはパッケージhttpにおいてグローバルを要求します。暗示的なグローバルの依存を持っているのです。これを取り除くのは簡単です。ただhttp.Clientをパラメータとして渡しましょう。しかしそれは具象的な型であり、この関数をテストしたければ、実際のHTTPコミュニケーションを強制する具象的http.Clientも用意しなければなりません。面倒です。HTTPリクエストを実行できるインターフェースを渡すことで、もう少しうまく解決できます。http.Clientは自動的にDoerインターフェースの要求を満たしますが、これでテストでDoer実装のモックアップを自由に渡せるようになりました。素晴らしいではありませんか。func fooのユニットテストはfooのふるまいのみをテストするものであり、http.Clientが、公言されている通りに動くことを安全に確かめられるのです。テストの話をしましょう。2014年、私は様々なテスト用フレームワークとヘルパーライブラリを使った経験を振り返り、1つとして使えるものはないという結論に達して、stdlibのアプローチであるテーブルベースの平易なパッケージテストを薦めることにしました。言ってしまえば、今もそれがベストの助言だと考えています。Goのテストで留意すべき重要な点は、これは単にプログラミングだ、ということです。他のプログラミングと何ら異なる点はなく、独自のメタ言語を是認します。そのため、やはりパッケージテストがそのタスクには都合が良いのです。TDD/BDDパッケージは新しい、まだなじみのないDSL、制御構造で、あなたと将来のメンテナンス担当者の認知的な負担を増やします。個人的には、そのコストに見合うコードベースは見たことがありません。グローバル状態と同様、これらのパッケージは不経済の極みであり、たいていは他の言語やエコシステムのふるまいの猿真似をしたに過ぎないプロダクトだと思います。Goに入ってはGophersに従え。シンプルで、意味の分かりやすいテストを書くための言語は既にあります。Goです。そしてあなたはそれをよく知っているはずです。と言いながら、私は自分独自のコンテキストと偏見があるのを認識しています。GOPATHに対する意見と同様に、譲れるところは譲り、テスト用DSLやフレームワークを便利に使っているチームや組織の意見にも従っています。パッケージを使いたいなら、使えばいいのです。但し、明確な根拠を持って進めねばなりません。もう1つの驚くほど興味深いトピックは、テストのための設計です。この件について、近頃Mitchell Hashimotoが、ここBerlinでぜひ耳を傾けるべき講演を行いました（SpeakerDeck、YouTube）。概して最善と思われるのは、Goを一般に関数型のスタイルで書くことです。可能な限り、依存関係を明示的に列挙し、小さく、綿密にスコープを絞ったインターフェースとして用意します。ソフトウェアエンジニアリングの上で良い規律になるだけでなく、そうすることで、テストのしやすいコードへと自動的に最適化されていくように感じられるでしょう。上述のhttp.Clientの例で見たように、ユニットテストはテストの必要な部分をテストするために記述すること、それ以外にないことを覚えておきましょう。処理関数をテストするのであれば、要求の入るHTTPトランスポートや、結果が書き込まれるディスク上のパスまでテストすることはありません。インターフェースパラメータの仮の実装として入力と出力を用意し、メソッドやコンポーネントのビジネスロジックだけに注力しましょう。最もホットなトピックです。2014年、まだいろいろなことが初期段階にあった頃、私ができる唯一のアドバイスはベンダリングでした。それは今日にも変わっていません。ベンダリングは今なお、バイナリの依存関係の管理には有効な方法です。特にGO15VENDOREXPERIMENTとそれに付随するvendor/ subdirectoryはGo 1.6では初期設定になっています。そのレイアウトを使っていきましょう。そして、有り難いことに、ツールはどんどん良くなっています。いくつか薦めたいものを挙げてみます。ライブラリに関する重要な注意事項です。Goにおいて、依存関係管理はバイナリオーサーの懸念点です。ベンダリングされた依存関係を持つライブラリの使用は非常に難しく、いっそ最初から使えないと言ったほうが親切かもしれません。1.5でベンダリングが公式に導入されて以来、数か月間に渡り、多くのコーナーケース、エッジケースが展開されました（特に詳しく知りたい場合は、そのうちの1つに関するフォーラムを見てください）。
あまり深入りせずとも、すぐに学びました。ライブラリは依存関係のベンダリングをするものではありません。もし、あなたのライブラリが、エクスポートされた（公開）APIレイヤに逃げないよう依存関係を密封している場合は、例外になり得るかもしれません。エクスポートされた関数、メソッドのシグネチャ、構造、その他全てにおいて一切依存型が参照されていない場合です。バイナリとライブラリの両方を持ったオープンソースのリポジトリをメンテナンスする共通のタスクがある時は、残念ながら進退ここに窮まります。バイナリ用に依存性をベンダリングしたくても、ライブラリのためにはベンダリングする必要がなく、GO15VENDOREXPERIMENTはこのレベルの粒度を認めません。悔しい失敗です。はっきり言って、この問題に対する答えは分かりません。etcdの仲間たちはシンボリックリンクを使った解決 法を編み出しましたが、私は自信を持って薦められません。シンボリックリンクはgoのツールチェーンで十分にサポートされていない上、Windows上では作ることもできません。これを機能させるには幸運に頼るしかないと言えます。私たちはこれらの懸念全てをコアチームに提起しましたので、遠くない将来に何かが起こることを期待しています。ビルドに関して言えば、Dave Cheneyから1つ大事なことを学びました。go buildよりもgo install、です。インストールの動詞は$GOPATH/pkgの依存関係からビルドアーティファクトをキャッシュし、ビルドの速度を上げます。さらにバイナリを$GOPATH/binに置くことで、検索や起動をより簡単にします。バイナリを作成する時は、思い切ってgbなどの新しいビルドツールを使ってみてください。認知的な負担が大きく減るかもしれません。反対に、Go 1.5以降はクロスコンパイラが内蔵されていることも覚えておきましょう。適切なGOOSとGOARCH環境変数、そして適切なgoコマンドを設定しましょう。これで余分なツールは必要ありません。デプロイは、私たちGopherにとっては、Ruby、PythonあるいはJVMさえ比較にならないほど簡単です。メモ：コンテナ内にデプロイするなら、Kelsey Hightowerのアドバイスに従い、スクラッチでやりましょう。Goがこの信じがたい機会を与えてくれているのですから、使わない手はありません。より一般的なアドバイスは、プラットフォームやオーケストレーションシステムを選ぶ前に、結局選択肢がないとしても、よく考えることです。マイクロサービスの流行に飛びつく際も同様です。自動的にスケールするEC2グループへにAMIとしてデプロイされた流麗なモノリスは、小さなチームにとって非常に生産的な設定です。誇大広告には抵抗すること、少なくとも注意深く考慮するようにしましょう。一言アドバイス：Goは生まれた時から保守的な言語であり、完成度が高いため、驚きは少なく、大きな変更もないまま今に至ります。結果として、そして予測どおり、コミュニティの中で何がベストプラクティスであるかというスタンスが劇的に切り替わることもありませんでした。代わりに私たちは、初期の頃に比較的よく知られていた比喩と慣用句が具象化されていく過程や、設計パターン、ライブラリとしての「上位層への」段階的な移行、そしてプログラム構造が、探究を通してGo的なコードへと変貌を遂げていくのを見てきました。Goプログラミングの楽しく実り多い次なる6年に乾杯。
