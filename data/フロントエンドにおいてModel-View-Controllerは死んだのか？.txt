<p><a href="https://medium.freecodecamp.com/is-mvc-dead-for-the-frontend-35b4d1fe39ec#.tcva8fw4w" rel="nofollow" title="" class="ext-link">Is Model-View-Controller dead on the front end?</a> （2016-10-9） by <a href="quincy@freecodecamp.com">Alex Moldovan</a></p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*ZByyohMUALGVRHbMX9739Q.png" src="https://cdn-images-1.medium.com/max/800/1*ZByyohMUALGVRHbMX9739Q.png"><br>
多くのフロントエンド開発者が<a href="http://staltz.com/unidirectional-user-interface-architectures.html" rel="nofollow" title="" class="ext-link">一方向のアーキテクチャ</a>を採用し始めている中で、Model-View-Controller（MVC）に未来はあるのでしょうか。</p><p>状況を把握するために、まずはフロントエンドのアーキテクチャの進化を振り返ってみたいと思います。</p><p>過去4年にわたり、私は多数のWebプロジェクトに取り組み、フロントエンドの構築、そしてフロントエンドとフレームワークの統合に多くの時間を費やしてきました。</p><p>2010年以前は、従来のウェブサイトにDOM操作を追加する場合は大抵JavaScript（<em>jQuery</em>が書かれたプログラミング言語）が使用されていました。当時の開発者はアーキテクチャ自体についてはそれほど気に掛けていなかったと思います。コードベースを構造化する場合、<a href="https://toddmotto.com/mastering-the-module-pattern/#revealing-module-pattern" rel="nofollow" title="" class="ext-link">Revealing module pattern</a>のようなものがあれば十分でした。</p><p>現在、多くの議論が交わされているフロントエンド対バックエンドアーキテクチャのような構図が持ち上がってきたのは、せいぜい2010年後半からです。時期的には、開発者が<em>シングルページアプリケーション</em>のコンセプトに真剣に取り組み始め、<a href="http://backbonejs.org/" rel="nofollow" title="" class="ext-link">Backbone.js</a>や<a href="http://knockoutjs.com/" rel="nofollow" title="" class="ext-link">Knockout.js</a>のようなフレームワークが普及し始めた頃になります。</p><p>当時、これらのフレームワークの基礎となる原則の多くは、まったく新しいものであり、設計者たちは構築する際に、参考として他の場所に目を向ける必要がありました。そこで、サーバサイドのアーキテクチャとしてすでに確立されていた慣行を拝借したのです。その頃、人気のあったすべてのサーバサイドのフレームワークは、従来的な<a href="https://ja.wikipedia.org/wiki/Model_View_Controller" rel="nofollow" title="" class="ext-link">MVC</a>モデル（<a href="https://www.quora.com/What-are-the-main-differences-between-MVC-MVP-and-MVVM-design-patterns-for-the-JavaScript-developer" rel="nofollow" title="" class="ext-link">その派生形は</a>MV**という名前でも知られています）の実装が何らかの形で関係していました。</p><p><a href="https://facebook.github.io/react/" rel="nofollow" title="" class="ext-link">React.js</a>が最初に<a href="http://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library#answer-148788" rel="nofollow" title="" class="ext-link">レンダリングライブラリ</a>として導入された時、多くの開発者たちは、JavaScriptでHTMLを扱う方法が直感に反していると言って、それを嘲笑しました。しかし彼らはReactがもたらす最も重要な貢献を見落としていました。それが<strong>Component Based Architecture</strong>（コンポーネントをベースにしたアーキテクチャ）です。</p><p>コンポーネントを発明したのはReactではありませんが、Reactはコンポーネントのアイデアを一歩前進させました。</p><p>アーキテクチャにおける主要なこのブレークスルーは、FacebookがReactを “V in the MVC（MVCのV）” として宣伝した時、彼らでさえ見過ごしていたものです。</p><p>ちなみは、私は今でも<a href="https://github.com/ngReact/ngReact" rel="nofollow" title="" class="ext-link">Angular 1.xとReactの両方が連携する</a>コードベースを見直した後は、散々な思いをしています。</p><p>2015年、私たちの考え方に一大革新が起こりました。それは、慣れ親しんできたMVCのパターンから、<a href="https://github.com/reactjs/redux" rel="nofollow" title="" class="ext-link">Redux</a>や<a href="https://github.com/Reactive-Extensions/RxJS" rel="nofollow" title="" class="ext-link">RxJS</a>のようなツールがサポートする、FluxとFunctional Reactive Programmingに基づいた<strong>一方向アーキテクチャとデータフロー</strong>へのシフトです。</p><p>MVCは恐らく現在でもサーバサイドを扱うベストな方法でしょう。<a href="http://rubyonrails.org/" rel="nofollow" title="" class="ext-link">Rails</a>や<a href="https://www.djangoproject.com/" rel="nofollow" title="" class="ext-link">Django</a>のようなフレームワークも使い勝手は悪くありません。</p><p>問題は、MVCがサーバに導入する原則と分離がクライアント側と同じではないことです。</p><p>以下の図は、ViewとControllerがサーバ上でどのようにやり取りしているかを示しています。ViewとControllerの間にはタッチポイントが2つしかなく、どちらもクライアントとサーバの境界を越えています。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*QBsB-PGwkeKzjSbhulXqrQ.png" src="https://cdn-images-1.medium.com/max/800/1*QBsB-PGwkeKzjSbhulXqrQ.png"></p><p>クライアントでMVCに移動すると問題が発生します。Controllerがいわゆる “CodeBehind” に類似しているのです。ControllerはViewに大きく依存しており、フレームワークの実装においては、Viewによって作成されることもよくあります（例えば、Angularのng-controllerの場合）。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*BkoTjy0_y50zXIkaS5XFmA.png" src="https://cdn-images-1.medium.com/max/800/1*BkoTjy0_y50zXIkaS5XFmA.png"></p><p>さらに、<a href="http://www.oodesign.com/single-responsibility-principle.html" rel="nofollow" title="" class="ext-link">Single Responsibility Principle（単一責任の原則）</a>を念頭に置くと、これは明らかにその原則を破っていることになります。クライアントのControllerのコードが、一定のレベルにおいて<strong>イベントハンドリング</strong>と<strong>ビジネスロジック</strong>の両方を処理しているからです。</p><p>クライアント側のModelに格納するような種類のデータについて少し考えてみてください。</p><p>一方では、<strong>アプリケーションの状態</strong>を表す<em>users</em>や<em>products</em>のようなデータがあり、もう一方では、<em>showTab</em>や<em>selectedValue</em>などのように、<strong>UIの状態</strong>を格納しなければなりません。</p><p><strong>UIの状態とアプリケーションの状態</strong>を分離する方法がないという点では、ModelもControllerと同様、Single Responsibility Principleの原則を破っています。</p><p>コンポーネントは、ビュー＋イベントハンドリング＋UI状態です。</p><p>下の図は、実際、どのように元のMVCモデルを分割し、コンポーネントを取得するのかを示しています。線の上の領域は<strong>アプリケーションの状態</strong>と<strong>ビジネスロジック</strong>の管理であり、正にFluxが解決しようとしているものです。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*ca_poTSXLLfBvnF2XnJEpA.png" src="https://cdn-images-1.medium.com/max/800/1*ca_poTSXLLfBvnF2XnJEpA.png"><br>
Reactと<strong>Component Based Architecture</strong>の普及により、アプリケーションの状態管理における<strong>一方向のアーキテクチャ</strong>が台頭してきています。</p><p>この2つの相性がいいのは、それらが典型的なMVCのアプローチを完全にカバーするからです。また、フロントエンドのアーキテクチャを構築する際には、より良い分離を提供します。しかし、これはもはやReactだけの話ではありません。<a href="https://angular.io/" rel="nofollow" title="" class="ext-link">Angular 2</a>でも、アプリケーションの管理方法には<a href="https://github.com/ngrx/store" rel="nofollow" title="" class="ext-link">ngrx/store</a>のような別の選択肢があるものの、全く同じパターンが用いられています。</p><p>上記と比較すると、MVCのクライアント側における優位性はほとんどありません。それは最初から失敗する運命で、私たちはその過程を見る必要があっただけなのです。約5年をかけて、フロントエンドのアーキテクチャは今ある形へと進化してきました。その時間を、ベストプラクティスが登場するための過程と考えるなら、5年というのはそれほど長い時間ではないと言えるでしょう。</p><p>フロントエンドのアプリケーションがより大規模により複雑化し始めた当初、私たちはそれをどのように構築すればいいか分からなかったので、MVCは必要でした。そしてその目的は、あるコンテキスト（サーバ）から適切なプラクティスを取り出し、別のコンテキスト（クライアント）に適用することについての優れた教訓を残しつつ、果たされたと思います。</p><p>フロントエンドのアプリケーション開発において、古典的なMVCアーキテクチャが近い将来、再び台頭するようなことはないと思います。</p><p>多くの開発者がコンポーネントと一方向アーキテクチャの利点を見出し始めたことにより、今後の焦点は、それに沿った良質なツールとライブラリの構築に移るでしょう。</p><p>こうしたアーキテクチャがこれからの5年にとって最高のソリューションになるのか？　もちろんそのチャンスは十分にあると思います。ただ、繰り返しになりますが、確実なものは何ひとつありません。</p><p>5年前には、アプリケーションの開発が現在の形になるとは誰も思わなかったでしょう。だからここで未来を確実視するのは、やめておこうと思います。</p><p>以上で終わりです。皆さんがこの記事を楽しんでいただければ幸いです。フィードバックがあれば、ぜひお願いします。</p>
