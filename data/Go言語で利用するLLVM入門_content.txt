An introduction to LLVM in Go （2016-03-12） by Felix AngellFelixです。イギリスのBrighton在住、17歳の学生。趣味でプログラミングをしています。私のプログラミング言語Arkなど、主にオープンソースについて書いています。LLVMは、コンパイラを作成するための基盤です。2000年にChris Lattnerによって作成され、2003年にリリースされました。それ以来、LLVMリンカlldやLLVMデバッガlldbなど幅広いツール群を持つ包括的なプロジェクトに発展してきました。LLVMの秀でた特徴は、一般にLLVM IRと呼ばれる、その中間表現です。LLVMの考え方は、まずこのIRにコンパイルし、次にそのIRを、JITコンパイルする、インタープリタで実行する、または実行しているマシンのネイティブアセンブリにコンパイルするといういうものです。このIRの主なターゲットは、コンパイラです。実際LLVMを使用するコンパイラは、世の中に数多くあります。C言語とC++用はそれぞれclangとclang++、D言語用のldc2、Rust、Swiftなどです。Emscriptenのようなプロジェクトさえあります。これは、LLVM BC (LLVM bitcode)をブラウザで実行されるJavaScriptにコンパイルします。一般的にコンパイラの設計では、レジスタ割り当て、いろいろなアーキテクチャのためのコード生成、また十分に最適化された効率の良いコード生成に気を配る必要があります。LLVMの良さは、今述べたことを全て処理してくれるところです。LLVMは、非常に多くの最適化コレクションを備えており、さまざまなアーキテクチャをターゲットにすることができます。GNUコンパイラのコレクションが長年のデファクトスタンダードでしたが、LLVMの実装が大幅にそれを上回る結果が示されており1、多くの場合、より優れたエラーメッセージを出力します。では、LLVM IRを素早く見てみましょう。標準的なCのプログラムを-emit-llvmと-Sフラグを付けてclangでコンパイルすると、.llファイルが生成されます。このファイルの拡張子は、LLVM IRだということを表しています。LLVM IRに変換するCのコードは次のとおりです。何も最適化しないように指定してclangを実行しました。clang test.c -S -emit-llvm -O0。結果は次のとおりです。単純化のために余分なコードの多くを省略しました。IRを見てみると、冗長性が増して読みやすいアセンブリ言語のように見えます。気付いたかもしれませんが、IRは型が厳密に定義されています。型の注釈が命令、値、関数など全てに付いています。それでは、このIRの中で何が行われているのか、1行ずつ理解していきましょう。まず最初に、中括弧、型、名前、及び引数用の括弧を持つC言語風の関数によく似た構文の関数があります。関数内に、値と命令が並んでいます。このIRの中には、5つの命令が含まれています。alloca、store、load、add、そしてretです。では、これがどのように動作するのかを理解するためにIRを部分ごとに詳しく見てみましょう。ここでは、アライメントとnswフラグの説明は省きます。これらの詳細については、LLVMのドキュメントをご覧ください。ここでは、基本的な意味だけを説明します。命令に取り掛かる前に、ローカル識別子とは何かを知る必要があります。ローカル識別子は変数のようなもので、記号%で表します。名前のとおり、定義されている関数内に限られていることを示しています。従って、宣言された関数の外からは参照も変更もできません。この命令は、スタックフレームにメモリを割り当てます。関数が戻る時に、このメモリは解放されます。この命令は値を返すので、例えば%aなどにそれを代入します。戻り値は割り当てられたメモリへのポインタです。例えば次のとおりです。この命令は、32ビット符号付き整数のための領域をスタックに割り当てます。ポインタはローカル識別子aに格納されます。store命令は、指定されたポインタが指し示す場所の値を与えられた値に書き換えます。簡単に説明できる例を以下に示します。この例では、LLVMにi32型の値32をi32*型（i32型へのポインタ）のローカル識別子aに格納するよう指示しています。この命令は、void型を返します。つまり、何も返さないので、ローカル識別子に代入できません。最後は、load命令です。この命令は、指定されたメモリアドレスの値を返します。上記の例では、メモリアドレスa（i32型へのポインタ）からi32型の値をロードします。この値は、ローカル識別子2に格納されます。参照先の値を取得することはできないので、値をロードする必要があります。命令が何を意味しているか分かったので、うまくいけば、上記のIRの半分以上は読んで理解することができるはずです。残りの命令については、比較的分かりやすいはずです。add命令は与えられた値の加算を行い、結果を返します。ret命令は、関数の戻り値を指定します。LLVMは、このIRを構築するためのAPIを提供しています。元のAPIは、C++で書かれていますが、Lua、OCaml、C、Goなど様々な言語バインディングがあります。この記事では、Goバインディングを使用していきます。IRのビルドを始める前に、詳細を理解しておかなければならない事が幾つかあります。モジュールは、定義と宣言の集まりです。これは、コンテナであり、必ず作成する必要があります。通常モジュールはファイルごと作成されますので、最初の例では、C言語のファイルがモジュールです。モジュールは次のように作成します。モジュール名として文字列を渡します。これがメインモジュールとなるので、”main”と名付けましょう。LLVMは、バイト、整数、浮動小数点などのプリミティブ型から、構造体、配列、関数型のような複雑な型まで多様な型を提供しています。組み込み型は、TypeWidthType()の形式になっています。例えば、Int16Typeは16ビット幅の整数です。任意のビット幅を指定することもできます。配列は次のように指定できます。これは、要素数が16の32ビット整数型配列です。LLVMの値は命令から戻されますが、それは定数、関数、グローバル変数等々である可能性もあります。以下に値666を持つi32型定数整数を作りました。末尾のブーリアンパラメータは符号拡張するかどうかを示します。浮動小数点定数も作れます。そしてこれらの値を変数に割り当てたり、関数に渡したりすることができます。ここで2つの定数値を足す加算命令を作りましょう。これはおそらく予想するものと少々異なります。アセンブリでは、関数にラベルを使ってフローを制御します。関数に明示的な構文を備えているものの、LLVMは非常にそれに似ています。しかし、どのようにプログラムのフローの制御をすればよいのでしょうか。基本ブロックを使うのです。IRは次のようになります。main関数があり、その関数内に3つの基本ブロックがあります。entryブロック、それから0と1のブロックです。必要な数だけ基本ブロックを持つことができます。用途は、例えば、ループ、if文などです
。LLVMのためのGoバインディングで、基本ブロックを次のように定義しましょう。contextにブロックを追加したい関数を指定します。これは関数型ではありません。その点については後で述べます。IRビルダはIRを作成するツールです。値、命令などを全てまとめて与える必要があります。ビルダで重要なのは、ビルドする場所を再配置するのに利用できるということと、別の場所に命令を追加できるということです。モジュールに命令を追加する際にこのビルダを使ってみましょう。ビルダをセットアップし、関数とentryブロックを作って定数を格納するための単純な命令を追加したのが下記です。これは次のようにIRを生成します。関数はLLVMにおける1つの型です。関数型を定義するには幾つかの指定が必要です。戻り値の型、パラメータの型、そして関数が可変長引数かどうか、つまり引数の個数が可変かどうかを指定します。ここまで見てきたmain関数は次のとおりです。最初のパラメータは戻り値の型で、32 ビットの整数です。ここでの関数はパラメータを取りませんので、ただ空の配列を渡します。関数が可変長引数ではないので、falseを最後の引数に渡します。簡単ですね。AddFunctionは指定されたモジュールに、指定された名前で関数を追加します。この関数については次のようにして後で参照できます（キーと値のマップで管理されています）。これはモジュール内の関数を検索します。ここまでで学んできたことをまとめてみましょう。うまく行っていますが、allocaがポインタを返すため、まとめて追加することができません。ポインタを「参照しデータを取得する」ためには、幾つかのloadを生成しなければなりません。次は計算です。a + bを行うには、単純にadd命令を作ります。関数がi32を返しますので、次の内容を返す必要があります。これで完成です。しかし、どうすれば実行できるのでしょうか。幾つか方法があります。1つ目のオプションは実行ファイルに落とし込む方法としてより簡潔なので、こちらを選びます。2つ目は読者の演習用として残しておきましょう。実行ファイルを作成し、実行後にステータスコードを確認したら、結果は48になるはずです。Bashでこれを行うには、$?環境変数を表示させてください。標準出力に表示したい場合は、printf関数やputchまたは同等のものを定義しなければなりません。このチュートリアルを読めばその作業も十分に可能でしょう。行き詰まった場合は、（手前味噌ですが）私が作っているLLVMベースにGoで記述した言語、Arkをチェックしてください。Arkコードジェネレータはこちら。そしてLLVMのバインディングに関するドキュメントはこちらです。知っておくべき事項はほぼ掲載されています。LLVM仕様書も、同様に全てを詳細に至るまで網羅しており、命令、組み込み関数、属性なども含まれています。寄り道はこのくらいにして、早速実行してみます。この章の概要は次のとおりです。まず、モジュールが正しいことを確認します。このコードはモジュールが無効の場合、エラーを表示します。モジュールが無効になる原因は様々ですが、IRの欠陥による可能性が大きいです。mod.Dump()呼び出しはモジュールIRを標準出力にダンプします。では、実行エンジンを初期化しましょう。最後に、関数を実行し、結果を標準出力に表示します。関数は引数を取らないので、空のGenericValues配列を渡します。LLVMがインストール済みであることが前提です。幸運にもこの作業は非常にシンプルです。Windowsを使っているなら、これは少々難しいもしれません。その他のLinuxでは、パッケージマネジャでllvmを検索してください。Macなら、Homebrewが使えます。それからGoバインディングもインストールします。releaseの変数は362ですが、例えばllvm 3.7.0を使っているならこれは370になります。LLVMリポジトリをGOPATHにクローンし、バインディングをビルド、インストールする方法は下記のとおりです。次に、Goファイルに”llvm.org/llvm/bindings/go/llvm”を必ずインポートしてください。完了すると、Goファイルを実行し、結果を表示させることができます。
できました。新しい発見はあったでしょうか。これがプログラミング言語の記述にどのように使えるかが分かっていただけたなら幸いです。次のステップとしてKaleidoscopeチュートリアルをチェックするか、自身のプログラムをいろいろとテスト、実装してみることをおすすめします。最後まで読んでいただきありがとうございます :)
