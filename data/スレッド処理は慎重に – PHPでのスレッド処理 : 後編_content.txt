Thread carefully （2015-11-13） by Maxime Fabreこの記事の前半はこちら: スレッド処理は慎重に – PHPでのスレッド処理 : 前編これまで挙げてきた例は基本的なことですが、更に高度な例に取り組もうとした場合、ある共通の障害にぶち当たるでしょう。それは、親のコンテキストにオートローディングされたクラスを子スレッドが継承していないということです。これはなぜかと言うと、子スレッドは親のコンテキストを必ずしも継承する必要がないからです。状況によって継承が不都合な場合、例えばいくつかのコンテキストにおいて、ある独立したタスクを行おうとした時や、メモリの上層階で行っている全てを読み込みたくない時などです。オプションをThreadインスタンスの-&gt;start()メソッドに渡すことで、親から継承される量を制限できます。ではここで、Composerを使ってあることを要求しましょう。例に対してvar_dumpの見栄えの良いラッパ、symfony/var-dumperを要求し、ジョブに対して提供されたdump()関数を使ってみます。これ行うと実行は失敗し、以下の例外が投げられます。（クラス’Symfony\Component\VarDumper\VarDumper’は見つかりません）これは、クラスがメインスレッドに読み込まれたにもかかわらず、子スレッドには読み込まれていないからです。いくつかの回避策がありますが、一番簡単なのはrequire 'vendor/autoload.php'文をジョブのrunに含めることです。しかし、これは非常に悪い方法です。より良い方法としては、ジョブを実行する前にオートローディングの設定をするためのWorkerクラスを作成することです。考え方は同じですが、この方法であれば、どのジョブクラスにも何も要求する必要がありません。これであれば、以下のように正しい結果が与えられます。これまでクラスに関する問題について取り組んできましたが、コンテキストが完全に保存されないということを認識していないと、クロージャもまた頭を悩ます問題の1つになり得ます。恐らく皆さんは、以下の例は機能するコードだと思われるでしょう。しかし、実際は機能しません。クロージャが、変数の参照と共にメインスレッドにコンパイルされており、そしてジョブに渡すようになっているからです。これだと、参照が既存の変数を指していない子スレッド内でジョブを実行するようになってしまいます。結局のところ、PHPではクロージャのシリアライズ化は困難ということになってしまいます。そうは言っても、Threaded::fromメソッド（つまりその子スレッド全てで利用可能）を使えば、適切なシリアライゼーションでクロージャからジョブを便利に作成することができます。以下の例で機能するはずです。子スレッドが何をしているかという点については、これまで深く触れてきませんでした。しかし、メインスレッドで起こっていることと、子スレッドで起こっていることの連携が必要になる場合があります。これには、waitとnotifyメソッド、そしてisWaitingといった関連するヘルパーを使います。例のとおり、親スレッドに何かしらのタスクを行うと同時に子スレッドに他のいくつかのタスクを行うこととします。親スレッド内のメインタスクを完了させるために子スレッドから結果を得たい場合、以下のようにします。全てのコールを$job-&gt;synchronized()コール内のwaitとnotifyにラップしている仕方に注意してください。これは、コールと両方の準備が整った後に、全てを同期させるためです。つまり、メインスレッドで作業を行い、ジョブと同期を行ってから通知を待ちます。その後送信を行います。これは、子スレッドがメインスレッドに改めて統合されないという点で$job-&gt;join()を単純に行うのとは異なり、それぞれが個々に存在し続けるので、synchronizedコールの後に作業を行うことができます。前出の図のように表すと、notify/waitルーティンは以下のようになります。
このルーティンはあまり役に立たないと最初は思うかもしれませんが、実際はこれで色々なことができます。例のように、子スレッド内で完了され、その後メインスレッドに報告するクロージャを待っているPromiseクラスを作成することによって、このルーティンを通じて、非常に簡素化されたPromiseと同等の物を作ることができます。これによって、いくつかの本質的なことが明らかになっています。待機と通知を異なるスレッドに入れる必要がない、それ自身または別の子スレッドを待つようにすることができる、メインスレッドを全ての子スレッドに通知することができる、などです。これまでに見てきた例は、理解度を高めるための基本的なものでしたが、スレッド処理をさせたいタスクの理想としては、上記の例よりも大規模だったり複雑な依存関係を持っていたりするものではないでしょうか。通常、PHPの現代的なプロジェクトは、コマンドバスによってサポートされます（Laravel、Tactician、その他、好みに応じて）。スレッド処理は、コマンドバスのインスタンスを受け取り、そのコマンドを実行するWorkerのカスタムクラスを通じて、このコンテキストに簡単に統合可能です。以下をご覧ください。どうですか？　これで、コマンドバスのメリットを残したまま、2つのコマンドラインはスレッド化され並列に実行されるようになるはずです。常用文の全てを除外する特別なプールを作ることもできます。ただし、気を付けたいことが1つあります。ここで行っているように、依存関係がワーカーに渡される場合は、それがThreaded（またはスカラ）の子でなければ、必ずシリアライズ可能にしてください。つまり、それらはクロージャを含むプロパティを持ってはならないということです。もし持ってしまった場合、（例のように、コンテナおよびサービスプロバイダを介して）子スレッドにインスタンスを再作成するのが簡単な方法ですが、子スレッド内でコマンドバスのインスタンスを解決する任意の方法を用いても構いません。コマンドバスの例では、気を付けるべき点に焦点を当てています。それは、リソースはメインスレッドから子スレッドに渡すことができないということです。理由はPHPの内部動作に制限があるためで、エッジケースにおいては動き続けますが、いずれにしてもスレッド間にリソースを渡すのは避けた方が無難でしょう。ここで言うリソースとは、ソケットやデータベース接続、それにストリームなどのことです。もし子スレッドにデータベースが必要であれば、それ自体のコンテキストでデータベースに接続するワーカーを作成しましょう。ソケットについても同様です。メインスレッド内ではなく、子スレッド内でソケットに接続します。なお、これを可能にする方法はありますが、そもそも頭痛の種を増やすようなことは最初からしない方がいいと思います。可能な限り子スレッドを別のコンテキストとして考えれば、いい結果になるはずです。もう1つの落とし穴（内容を簡潔にするために、この記事の例では無視していました）はデータの破損です。例えば、ジョブがアクセスする配列をワーカーが保持しているとしましょう。この時、2つのジョブが同時に配列を変更した場合、どれだけ万全を期しても配列はじきに破損してしまいます。これはpthreads自体の制限ではなく、2つのスレッドが同じ値を同時に変更すればトラブルが発生するという、スレッド処理全般の問題です。これを回避するため、pthreadsにはStackableクラスがあり、それを使えばスレッドセーフのデータ同期が行えるよう拡張することができます。以下のような形です。これを実行した場合、配列のカウントとして予想通りに100が得られるはずです。しかし、これを、例えば$results = []のような標準的な配列で実行するとどうでしょうか。得られるのは毎回0ですね。Threadedを継承していない全ての構造体はシリアル化されるので、元の変数を参照しなくなります。そのため、子スレッドでは値は正しいままですが、メインスレッドは正しくなりません。スレッド間でデータを移動する必要がある場合は、できるだけ（Stackableのように）Threadedの子に渡すよう心がけてください。そうすればシリアル化されることはありませんし、データ破損やメモリトラブルを気にすることなくスレッド間の移動に特化した形にすることができます。PHPでのpthreadsを使ったスレッド処理を掘り下げて見てきましたが、いかがだったでしょうか。今後、同時にしなければならないことがたくさんあるような時は、PHPを完全に選択肢から排除する前に、よく考えてみてもらえればと思います。スレッド処理は作業を別個のユニットとして分割できるような特定の状況下で有効なもので（したがって、コマンドバスはとてもよく適合します）、常に解決策になるというようなものではありません。それでも頼りになるツールですし、覚えていて損はないはずです。pthreadsの拡張機能は非常に出来が良く、管理も十分にされており、PHP7ともすでに互換性があります。つい最近、新バージョンが出たばかりです（この記事の例で使用したバージョンは2.0.10ですが、PHP7用の最新バージョンは3.0.8です）。さらにうれしいことに、Githubから拡張機能のリポジトリが入手可能で、豊富なサンプルやドキュメンテーションに加え、内部構造についての説明も閲覧することができます。その他、PHP全般のスレッド処理とpthreadsに関する根拠を作者（krakjoe）が説明した一連の要項は、私のお薦めです。なお、記事に掲載した例については、必要に応じてこちらのレポジトリから全てを入手することができます。さあ、これで終わりです。スレッド処理は慎重に！
