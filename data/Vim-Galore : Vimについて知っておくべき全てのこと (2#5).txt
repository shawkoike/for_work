<p><a href="https://github.com/mhinz/vim-galore" rel="nofollow" title="" class="ext-link">Everything you need to know about Vim</a> by <a href="https://github.com/mhinz" rel="nofollow" title="" class="ext-link">Marco Hinz</a></p><p>(訳注: 2016/2/26、記事タイトルを変更いたしました。)</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/02/vim-galore.png"><img src="http://postd.cc/wp/wp-content/uploads/2016/02/vim-galore.png" alt="vim-galore" width="1500" height="278" class="alignnone size-full wp-image-6066"></a></p><p>特定のトピックについての記述をご希望ですか？ <a href="https://github.com/mhinz/vim-galore/issues" rel="nofollow" title="" class="ext-link">Issue</a>を立てるか、<a href="https://twitter.com/_mhinz_" rel="nofollow" title="" class="ext-link">Twitter</a>で私までお知らせください！ありがとう！</p><p>ファイルの中の位置、つまり行番号と列番号を記憶するためにマークを使用します。</p><p>モーションを記述するには<code>'</code>/<code>g'</code>もしくは<code>`</code>/<code>g`</code> をマークの前に付けます。</p><p><code>mm</code>を使えば、現在の位置をマーク”m”で記憶できます。ファイルの中であちこち移動したあとでも、<code>'m</code>（空白ではない最初のところ）もしくは<code>`m</code>（その列）を使えばジャンプして元の位置に戻ることができます。Viminfoファイルに指定しておけば、Vimを終了したあとも小文字のマークは記憶されたままになります。<code>`:h viminfo-'</code>を見てください。</p><p><code>mM</code>を使えば、ファイルマーク”M”で現在の位置が記憶できます。<code>'M</code>もしくは<code>`M</code>を通して別のバッファに移ったり、元のものに戻ったりできます。</p><p>他のモーションは以下のとおりです。</p><p>マークは<a href="https://github.com/mhinz/vim-galore#ranges" rel="nofollow" title="" class="ext-link">範囲</a>でも使うことができます。おそらく見かけたことがあって、どんな意味だろうと疑問に思ったことのある人が多いのではないでしょうか。ビジュアルモードでテキスト選択して<code>:</code>を実行すると、<code>:'&lt;,'&gt;</code>がコマンドラインにプリペンドされます。つまり、ビジュアル選択された部分を示す範囲（レンジ）が、次のコマンドに与えられます。</p><p><code>:marks</code>を使用すれば、全てのマークがリスト化できます。全てを<code>:h mark-motions</code>で読み込んでください。</p><p>
</p>
<p>Vimは様々な種類の挿入モード補完を提供します。もし複数の一致候補があれば、ポップアップメニューが表示され、選択するよう誘導してくれます。</p><p>一般的に補完の対象となるものは、タグ、インポートしたモジュール/ライブラリの関数、ファイル名、ディレクトリ名、同じバッファに存在する単語などです。</p><p>Vimは補完のそれぞれの種類のマッピングを提供しています。全てが、<code>&lt;c-x&gt;</code>で始まっています（挿入モードでこれらを使うのを忘れないでください）。</p><p>
</p>
<p>ユーザ定義補完とオムニ補完の違いが分からない人もいるでしょうが、技術的にはこの2つは同じことをします。両方とも、現在の位置を調べて、提案のリストを返すという関数を使います。ユーザ定義補完は、ユーザの個人的な目的のためにユーザによって定義される補完のことです。（サプライズ！）これは何にでも使えますね。オムニ補完はファイルタイプ固有の目的で、構造体メンバやクラスメソッドを補完したりします。そして、しばしばファイルタイププラグインで設定されます。</p><p>また、Vimは<code>'complete'</code>オプションを設定することで、複数の種類を一度に補完することもできます。デフォルトのままではオプションの種類が多いので、自分の好みに合わせて減らすのを忘れないでください。<code>&lt;c-n&gt;</code>（次）か、<code>&lt;c-p&gt;</code>（前）のどちらかを使用することで、この補完をトリガさせることができます。そしてこれは、ポップアップメニューでエントリを選択するときに使うキーでもあります。他の例は、<code>:h i^n</code>と<code>:h 'complete'</code>を見てください。</p><p>ポップアップメニューの動作を設定するには、<code>:h 'completeopt'</code>を確認しましょう。デフォルトはまあまあマトモですが、私は”noselect”を追加するほうが好きです。</p><p>関連するヘルプ：</p><p>
</p>
<p>モーションはカーソルを動かします。<code>h</code>/<code>j</code>/<code>k</code>/<code>l</code>/のことは分かりますよね。もしくは<code>w</code>/<code>b</code>。さらに、<code>/</code>もモーションです。また、回数を使うこともできます。<code>2?the&lt;cr&gt;</code>は、最後から2番目に使われた”the”にジャンプすることを意味します。</p><p><code>:h navigation</code>と下記の記述をみて、使用できるモーションを確認してみてください。</p><p><strong>オペレータ</strong>は、ある範囲のテキストに対して動作します。例えば、<code>d</code>、<code>~</code>、<code>gU</code>、<code>&gt;</code>などです。他にもたくさんあります。これらは、ノーマルモードかビジュアルモードでしか使えません。ノーマルモードでは、オペレータはモーションのすぐあとにきます。例えば<code>&gt;j</code>などです。ビジュアルモードでは、オペレータは単純に、選択範囲上で機能します。例えば<code>Vjd</code>です。</p><p>モーションと同様、オペレータも数を使うことができます。例えば<code>2gUw</code>は、現在の単語と2番目に出てくる単語を大文字にするという意味です。モーションとオペレータは両方とも数を数えられるので、<code>2gU2w</code>も機能し、<code>gU2w</code>を2回繰り返すことができます。</p><p><code>:h operator</code>を見て、使用できるオペレーションを確認してみてください。<code>~</code>をオペレータとして機能させるには<code>:set tildeop</code>を使用してください。</p><p><strong>テキストオブジェクト</strong>は、モーションが1つの方向にしか機能しないのに対して、多方面のエリアで機能します。実際に、単語全体、文章全体、カッコ間の全てなどのオブジェクト上で機能します。</p><p>テキストオブジェクトは、ノーマルモードではカーソルを動かすのには使えません。なぜなら、どんなに優秀なカーソルでも2カ所に同時に飛ぶことはできないからです。しかし、ビジュアルモードでは使うことができます。なぜなら、オブジェクトの一方は、すでに選択され、カーソルはもう一方のほうへジャンプすればいいからです。</p><p>テキストオブジェクトは、オブジェクトを意味する文字に続いて、<code>i</code>（innerの頭文字）もしくは<code>a</code>（aroundの頭文字）のどちらかから始めます。<code>i</code>であれば、そのオブジェクトだけに機能し、<code>a</code>であればそのオブジェクトと続く空白にも機能します。例えば、<code>diw</code>であれば現在の単語だけを削除し、<code>ci(</code>であれば、カッコ内の全てを変更します。</p><p>テキストオブジェクトも数を数えることができます。例えば、<code>((( )))</code>で、カーソルが一番内側のカッコ上もしくはそのカッコの間にあるとすると、<code>d2a(</code>は内側の2組のカッコと、その間にある全てを削除します。</p><p><code>:h text-objects</code>を見て、使用できるテキストオブジェクトを確認してみてください。</p><p>
</p>
<p>多くの場合、Vimはイベントを発行します。イベントに入るにはautocmdを使用します。</p><p>もしautocmdがなかったら、Vimを使うことはないでしょう。ユーザが気付かなくても、autocmdは常時使用されています。信じられませんか？　では、<code>:au</code>とタイプしてみてください。出力を見て圧倒されないでくださいね。これは全部、現時点で有効になっているautcmdです。</p><p>利用可能な全イベントの概要を簡単に見るには、<code>:h {event}</code>とタイプし、詳細を見るには、<code>:h autocmd-events-abc</code>とタイプします。</p><p>典型例として、ファイルタイプ特定の設定を行う例を挙げます。</p><p>でも、どうしてバッファには、ここにRubyのコードが含まれていることが分かるのでしょうか？　それは、別のautocmdがそれを検出し、それに従ってファイルタイプを設定し、その設定がさらに<code>FileType</code>イベントをトリガしたからです。</p><p>誰もが最初にvimrcに追加するものの1つは、<code>filetype on</code>です。これは単に、起動時に<code>filetype.vim</code>が読み込まれ、世の中のほぼ全てのファイルタイプにautocmdを設定することを意味します。</p><p>勇気があるなら、<code>:e $VIMRUNTIME/filetype.vim</code>を見てみましょう。文字列”Ruby”が見つかれば、Vimが単にファイル拡張子<code>.rb</code>を使ってRubyファイルを探していることが分かります。</p><p>注：同じイベントのautocmdは、作成された順序で実行されます。<code>:au</code>で、正確な順序が表示されます。</p><p><code>BufNewFile</code>イベントと<code>BufRead</code>イベントは、この場合、VimのCソースにハードコードされていて、<code>:e</code>やそれに似たコマンドを通してファイルを開くたびに発行されます。その後、<code>filetype.vim</code>から何百ものファイルタイプが全てテストされます。</p><p>簡単に言えば、Vimはイベントとautcmdを多用しますが、そのイベントドリブン・システムに入ってカスタマイズするための簡潔なインターフェイスを開示する、ということです。</p><p>
</p>
<p>最近の100回の変更の位置が<strong>チェンジリスト</strong>に保持されます。同じ行内の小さな変更は1つにまとめられますが、チェンジリストに保持される位置は最後に加えた変更の位置になります（行の途中に何かを追加した場合）。</p><p>ジャンプを行うと、ジャンプする前の位置が<strong>ジャンプリスト</strong>に記憶されます。ジャンプリストには100件までのエントリがあります。各ウィンドウについて、それぞれのジャンプリストがあります。ウィンドウを分割すると、ジャンプリストがコピーされます。</p><p>ジャンプは、<code>'</code>、<code>`</code>、<code>G</code>、<code>/</code>、<code>?</code>、<code>n</code>、<code>N</code>、<code>%</code>、<code>(</code>、<code>)</code>、<code>[[</code>、<code>]]</code>、<code>{</code>、<code>}</code>、<code>:s</code>、<code>:tag</code>、<code>L</code>、<code>M</code>、<code>H</code>のいずれかのコマンドか、新しいファイルの編集を始めるコマンドです。</p><p>
</p>
<p>全てのエントリのリストを表示すると、現在の位置がマーカ<code>&gt;</code>を使って示されます。通常は、最新の位置である第1の位置の下に示されます。</p><p>Vimを再起動した後も両方のリストを残しておきたい場合は、viminfoファイルと<code>:h viminfo-'</code>を使用する必要があります。</p><p>注：最後にジャンプする前の位置も<a href="https://github.com/mhinz/vim-galore#marks" rel="nofollow" title="" class="ext-link">マーク</a>として保持され、<code>``</code>または<code>''</code>を使ってそこにジャンプすることができます。</p><p>関連するヘルプ：</p><p>
</p>
<p>テキストの状態に加えた最新の変更が記憶されます。変更を元に戻すには<em>undo</em>を使い、戻した変更をやり直すには<em>redo</em>を使います。</p><p>重要なことは、最近の変更を保持するデータ構造は<a href="https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A5%E3%83%BC_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)" rel="nofollow" title="" class="ext-link">キュー</a>ではなく、<a href="https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)" rel="nofollow" title="" class="ext-link">ツリー（木構造）</a>だということです。変更はツリー内のノードであり、（トップノード以外の）ノードにはそれぞれ親ノードがあります。各ノードは変更されたテキストと時刻に関する情報を保持します。枝は、任意のノードから始まってトップノードにまでさかのぼる一連のノードです。変更をundoしてから他のものを挿入すると、新しい枝が生成されます。</p><p>現在、3本の線があって、ツリーは次のようになります。</p><p>undoツリーには、4つの変更が保持されています。数字は、ノードが作成された<em>時刻</em>を表します。</p><p>このツリーを辿るには、2つの経路があります。それぞれ、<em>枝方向</em>、<em>時間方向</em>と呼びましょう。</p><p>Undo<code>(u)</code>とredo<code>(&lt;c-r&gt;)</code>は、枝方向に働いて、現在の枝を上り下りします。<code>u</code>は、テキスト状態をノード”bar”に戻します。もう一度<code>u</code>を行うと、テキスト状態はさらにノード”foo”に戻されます。次に<code>&lt;c-r&gt;</code>でノード”bar”の状態に逆戻りして、その次の<code>&lt;c-r&gt;</code>ではノード”quux”の状態になります（枝方向のコマンドを使って、ノード”baz”には行けません)。</p><p>これとは異なり、<code>g-</code>と<code>g+</code>は時間方向に働きます。よって、<code>g-</code><br>
では<code>u</code>のようにノード”bar”の状態には戻らず、時系列的に直前の状態であるノード”baz”に戻ります。もう一度<code>g-</code>を行うと、状態はノード”bar”に戻り、以下同様に続きます。このように、<code>g-</code>と<code>g+</code>は単純に時間の中で進んだり戻ったりします。</p><p>
</p>
<p>undoツリーはメモリ内に保持され、Vimの終了時に消去されます。永続的なundoを可能にする方法については、<a href="https://github.com/mhinz/vim-galore#handling-backup-swap-undo-and-viminfo-files" rel="nofollow" title="" class="ext-link">Handling backup, swap, undo, and viminfo files</a>を参照してください。</p><p>undoツリーが分からなくなったときには、ツリーを視覚化するために<a href="https://github.com/mbbill/undotree" rel="nofollow" title="" class="ext-link">undotree</a>が役立ちます。</p><p>関連するヘルプ：</p><p>
</p>
<p>アクションが位置のリストを返す必要がある時には、<em>quickfix</em>リストまたは<em>location</em>リストがいつも使用できます。この場合、location（位置）は、ファイル、行番号、列番号（オプション）です。</p><p>例としては、コンパイラエラーをquickfixリストにまとめたり、外部grepツールの一致結果をlocationリストにまとめたりすることなどがあります。</p><p>この内容を空白のバッファに入れるだけで、エントリを閲覧するための優れた統一インターフェースが得られるという、大きな利点があります。</p><p>quickfixリストは常に1つしかありませんが、各ウィンドウにはそれぞれ専用のlocationリストがあります。どちらのタイプのリストも同じような感じですが、ナビゲーションに使うコマンドは少し異なります。</p><p>よく使うコマンド：</p><p>
</p>
<p>この他、全てのコマンドについては、<code>:cc</code>を参照してください。</p><p><strong>例</strong></p><p>昔ながらの<code>grep</code>を使って、現在のディレクトリ内のファイルで、あるクエリを再帰的に検索し、結果をquickfixファイルに書き込みましょう。</p><p>文字列”foo”を含むファイルがあったとすれば、今、そのファイルがウィンドウに表示されているはずです。</p><p>
</p>
<p>Vimでは、タイプ入力された文字を<a href="https://github.com/mhinz/vim-galore#registers" rel="nofollow" title="" class="ext-link">レジスタ</a>に<em>記録</em>することができます。ある作業を素早く自動的に行うための素晴らしいツールです（手の込んだ作業には、<a href="https://github.com/mhinz/vim-galore#vim-scripting" rel="nofollow" title="" class="ext-link">Vim scripting</a>を使うべきです）。</p><p><strong>例1</strong></p><p>1行挿入して、それを10回繰り返すマクロ。</p><p>（マクロを使わずに同じことができます：<code>oabc&lt;esc&gt;10</code>）</p><p><strong>例2</strong></p><p>全ての行の前に行番号を追加します。まず、最初の行に手入力で”1.”を追加します。<code>&lt;c-a&gt;</code>を使用して、<code>^A</code>と表示されるカーソルの下の番号をインクリメントします。</p><p><code>1000@q</code>を使う場合は、ファイル内の行数が1000行を超えないことを願うだけですが、<em>再帰<strong>マクロ</strong></em>を使えば、マクロが適用できる行がなくなるまでマクロが実行されます。</p><p>（マクロを使わずに同じことができます：<code>:%s/^/\=line('.') . '. '</code>)</p><p>マクロを使わずに同じことをする方法をご紹介しましたが、ほとんどの場合、マクロを使わない方法は簡単な例でしか機能しません。複雑な自動化には、マクロが非常に効果的です。</p><p>併せて<a href="https://github.com/mhinz/vim-galore#quickly-edit-your-macros" rel="nofollow" title="" class="ext-link">Quickly edit your macros</a>も参照してください。</p><p>関連するヘルプ：</p><p>
</p>
<p>カラースキームは、Vimのスタイルを設定する方法です。Vimには多くの構成要素があり、それぞれを別々の前景色と背景色、太字などのその他の属性を使ってカスタマイズすることができます。カラースキームは次のように設定することができます。</p><p>こうすると、エディタの背景が赤色になります。詳細については、<code>:h :highlight</code>を参照してください。</p><p>つまり、カラースキームは、主として<code>:highlight</code>コマンドの集合です。</p><p>実際には、ほとんどのカラースキームは2つのカラースキームなのです。上の例は、<code>ctermbg</code>と<code>guibg</code>を使って色を設定します。前者の定義は、Vimがxtermなどの端末エミュレータ内で起動された場合にのみ使用されます。後者は、gVimのようなグラフィカル環境で使用されます。</p><p>あるカラースキームを端末エミュレータ内で実行中のVimで使ったらスクリーンショットと同じ色に見えないという場合は、そのカラースキームはGUI向けの色しか定義していない可能性があります。</p><p>私は、GUIには<a href="https://github.com/morhetz/gruvbox" rel="nofollow" title="" class="ext-link">gruvbox</a>、端末には<a href="https://github.com/mhinz/vim-janah" rel="nofollow" title="" class="ext-link">janah</a>を使っています。</p><p><a href="https://github.com/mhinz/vim-galore#list-of-colorschemes-1" rel="nofollow" title="" class="ext-link">その他のカラースキーム</a></p><p>
</p>
<p>どんなテキストにも（あるいはソースコードにも）何らかの構造があります。構造があるということは、テキストが論理的にいくつかの範囲に分割されているということです。折り畳みの機能を使えば、分割されたテキストの1つの範囲を「折り畳んで」1行にして、短い説明を表示させることができます。このような折り畳みと呼ばれる行範囲で使えるコマンドはたくさんあります。折り畳みは入れ子にできます。</p><p>Vimの折り畳みの方法はいくつかに区別されます。</p><p>注：折り畳みの機能はリソースを大量に使います！　もしパフォーマンスの低下（タイピング時の遅延）があれば、<a href="https://github.com/Konfekt/FastFold" rel="nofollow" title="" class="ext-link">FastFold</a>のページを参照して、Vimが折り畳みを不要時にアップデートしないようにしてください。</p><p>関連するヘルプ：</p><p>
</p>
<p><strong>ビュー</strong>（<code>:h :mkview</code>）を保存すると、ウィンドウの設定（とそれに関連したオプションやマッピング）が保存されるので、後で復元して作業を再開することことができます。（<code>:h :loadview</code>）</p><p><strong>セッション</strong>は全てのウィンドウのビューとグローバルな設定を保存します。基本的にはVimのインスタンスのスナップショットが作成され、セッションファイルに保存されます。</p><p>これで<em>プロジェクト</em>を完全に保存できますし、プロジェクト間の切り替えも簡単に行えます。</p><p>それでは試してみましょう！　ウインドウとタブをいくつか開いて、<code>:mksession! Foo.vim</code>を実行してください。ファイル名を省略した場合は、<code>Session.vim</code>に保存されます。ファイルはカレントディレクトリに保存されます。カレントディレクトリは<code>:pwd</code>で確認してください。Vimを再起動して<code>:source Foo.vim</code>を実行したら、ほらこの通り、バッファリスト、ウィンドウのレイアウト、マッピング、作業ディレクトリ他が全てセッション保存前と同じ状態です。</p><p>ただ、セッションファイルはVimコマンドの集合体に過ぎない、ということは気に留めて、いつでも<code>:vs Foo.vim</code>を見てください。</p><p><code>'sessionoptions'</code>を設定すれば、セッションのどの部分を保存するかVimに指定できます。</p><p>関連するヘルプ：</p><p>ここまでに挙げたグローバルな概念の多くには、相対するローカルな概念があります。</p><p>また、変数にはいろいろなスコープがありますが、<a href="https://github.com/mhinz/vim-galore#vim-scripting" rel="nofollow" title="" class="ext-link">Vim scripting</a>の中に説明があります。</p>
