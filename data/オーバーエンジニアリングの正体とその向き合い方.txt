<p><a href="https://hackernoon.com/how-to-accept-over-engineering-for-what-it-really-is-6fca9a919263#.y980qlool" rel="nofollow" title="" class="ext-link">How To Accept Over-Engineering For What It Really Is</a> （2016-10-26） by <a href="https://about.me/fagnerbrack" rel="nofollow" title="" class="ext-link">Fagner Brack</a></p><p>問題は細部（あるいはその欠如）にあり。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/2000/1*YfxWi5QZkShNHS0XLuKlMQ.png" src="https://cdn-images-1.medium.com/max/2000/1*YfxWi5QZkShNHS0XLuKlMQ.png" alt="多数の刃物を1つに納めたクレイジーなスイス製アーミーナイフ"></p><p>議論とは、ソフトウェア開発の基本的な構成要素であり、スケーラビリティを向上させるためには避けられない摩擦であると言えます。議論を通して私たちは出来上がるものの品質に影響を与え得るような問題を早い段階で浮かび上がらせることができるのです。その1つがオーバーエンジニアリングの問題です。</p><p>ウィキペディアによると、オーバーエンジニアリングとは下記のとおりです。</p><p>また、ウィキペディアには、オーバーエンジニアリングが好ましい場合として、さらに、このようなことも書いてあります。</p><p>開発者のコミュニティに目を向けると、更に別の考え方も見つかります。StackOverflowのユーザ<a href="http://stackoverflow.com/users/47886/jeff-sternal" rel="nofollow" title="" class="ext-link">Jeff Sternal</a>によると、<a href="http://stackoverflow.com/questions/1941770/concrete-symptoms-of-over-engineering/1941904#1941904" rel="nofollow" title="" class="ext-link">オーバーエンジニアリングに共通する兆候</a>とは、以下のことです。</p><p>別のユーザである<a href="http://stackoverflow.com/users/111647/0scar" rel="nofollow" title="" class="ext-link">Oscar</a>は、ソフトウェア開発のコンテキストにおいてオーバーエンジニアリングがどういうものかを<a href="http://stackoverflow.com/questions/1001120/what-is-over-engineering-as-applied-to-software/1001499#1001499" rel="nofollow" title="" class="ext-link">図示して</a>います。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*sgFUiRvAq7c6dqGM9yfXBw.png" src="https://cdn-images-1.medium.com/max/800/1*sgFUiRvAq7c6dqGM9yfXBw.png"><br>
<em>注釈： （タイトル部分、左から）<br>
バランスのとれたエンジニア／自己陶酔型のエンジニア／ナルシストでエゴの強い反社会的なエンジニア</em></p><p><a href="https://en.wikipedia.org/wiki/Second-system_effect" rel="nofollow" title="" class="ext-link">セカンドシステム症候群</a>のページに、”小さくて、エレガントで、よくできたシステムは、大きな期待を持たれてしまうため、<a href="https://en.wikipedia.org/wiki/Feature_creep" rel="nofollow" title="" class="ext-link">フィーチャー・クリープ</a>の被害を受けやすい”と書かれています。ソフトウェアの開発では、<a href="https://en.wikipedia.org/wiki/Project_stakeholder" rel="nofollow" title="" class="ext-link">プロジェクト・ステークホルダ</a>（エンジニアも含む）が、プロジェクトに本質的な価値が加わることを期待して必要以上の構築をしようとした時にも、セカンドシステム症候群が見られます。これらは、実際の要因ではなく、将来への思惑によって、期待が膨らむという点で異なっています。ユーザの要件からエンジニアリングへ進む過程で推察がかけ離れてしまい、問題が最大化するのです。また、その逆の過程でも同じことが起こります。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*xzS-UkYtNOgzPvpkHGwRbQ.png" src="https://cdn-images-1.medium.com/max/800/1*xzS-UkYtNOgzPvpkHGwRbQ.png" alt="木にブランコをかける計画を例にし、従来の開発ライフサイクルにおける各パートでの間違いを描いた有名なイラスト"><br>
<em>注釈：<br>
（左上→右上）<br>
顧客が説明した内容<br>
プロジェクト・リーダーが理解した内容<br>
エンジニアが設計した内容<br>
プログラマがプログラミングした内容<br>
営業が商品の特徴を説明した内容<br>
（左下→右下）<br>
プロジェクトを文書化した内容<br>
組み込まれた働き<br>
顧客に宣伝された内容<br>
ヘルプデスクがサポートする内容<br>
顧客が本当に必要とする内容</em></p><p>それでも私たちは、”思惑によって本当に必要とされるもの”とは実際に何なのか、ということを知らなければいけません。これは、客観的な基準ではなく主観的な議論によって答えが変わる、<a href="https://hackernoon.com/how-to-destroy-the-myth-of-the-proper-solution-94ca958def1f#.i33ncdjj9" rel="nofollow" title="" class="ext-link">適切なソリューション</a>や<a href="https://medium.com/@fagnerbrack/the-legibility-argument-d1ec889b9c8a#.j3wn72w80" rel="nofollow" title="" class="ext-link">レジビリティの議論</a>と同じジレンマに要約されるでしょう。</p><p>簡単な例として、クリック時に要素のclass属性を変更する例を考えてみましょう。以下が要件です。</p><p><iframe width="100%" height="300" src="//jsfiddle.net/fagnerbrack/b3gs4wsh/embedded/js,html,css,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe></p><p>上の例では、実装に大きなパターンやフレームワークは使いません。要素をクリックすると、それが大きくなって、1秒後に元のサイズに戻ります。</p><p>明らかに重複している部分がいくつかあるので、1つの関数にまとめてみましょう。</p><p><iframe width="100%" height="300" src="//jsfiddle.net/fagnerbrack/7jpg0jmo/embedded/js,html,css,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe></p><p>これは十分なソリューションでしょうか。恐らくそうだと思います。</p><p>少し戻ってみると、クリックのライフサイクルには、クラスの組み込み、1秒の遅延、クラスの削除、という3つの共通ステップがあることに気付くでしょう。ステップのどれかに何らかの操作を加える必要がある場合は、各ステップの属性ではなく、関数を変えなければならないでしょう。jQueryには隠れた機能があり、操作の遅延キューを作ることができます。これは各ステップ内の機能を分けることに利用できます。（いやまあ、<a href="https://medium.com/@fagnerbrack/library-internals-do-not-exist-1ff50a30e3b0#.jxg98byga" rel="nofollow" title="" class="ext-link">ドキュメント化されていない機能は存在しない</a>ことは知ってますし、<a href="https://github.com/jquery/jquery/issues/1886#issuecomment-121795500" rel="nofollow" title="" class="ext-link">それはjQueryのprivateメソッドでもない</a>ことも知ってますよ）</p><p><iframe width="100%" height="300" src="//jsfiddle.net/fagnerbrack/0hf8juhh/embedded/js,html,css,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe></p><p>上の例では操作を3つのステップで構築しています。各ステップの関数は、関数の内容を変えることで、別々に展開できます。各ステップの間ならどこにでも、遅延を実装できます。</p><p>ここでの問題は、各ステップで多くの<code>next()</code>を呼び出していることです。私たちが気にしているのは、ステップが変わり、非同期フローを使用しないのはいつか、ということだけなので、<code>next()</code>を関数に取り込んでしまえば明示的に呼び出す必要はなくなります。</p><p><iframe width="100%" height="300" src="//jsfiddle.net/fagnerbrack/pusL5mru/embedded/js,html,css,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe></p><p>現段階では、最初の例よりはコードの数が少なくなりました。ステップはワンライナーで表現されていますし、変更される可能性のあるものだけが繰り返し書かれています。</p><p>反論される可能性があるとすれば、jQueryだけではこの問題に対するソリューションは十分ではないので、<strong>AngularやReact、VueJS</strong>などでアプリケーションを開発する必要があるという点です。なぜなら、アプリケーションがさらに良くなる可能性が高いですし、後から変更するコストも高くなることが予想されるからです。</p><p>ちょっと待ってください。なぜ私たちは、フレームワークやキュー、ステップのことを話しているのでしょう？</p><p>元々の要件に戻りましょう。</p><p>これはオーバーエンジニアリングでしょうか？　もしそうなのであれば、どの点においてでしょう？</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*1ceZ3tCVJ-iRyS7B2THn7Q.png" src="https://cdn-images-1.medium.com/max/800/1*1ceZ3tCVJ-iRyS7B2THn7Q.png"><br>
<em>注釈：<br>
この<a href="http://xkcd.com/974/" rel="nofollow" title="" class="ext-link">マンガ</a>の内容はこうです<br>
「塩を取ってくれる？」<br>
「ちょっと…」<br>
「分かってる！　今、勝手に調味料を渡してくれるシステムを開発中なんだよ」<br>
「もう20分も経つじゃないか！」<br>
「結果的に時間の節約になるんだ！」</em></p><p>問題は、提案されたソリューションについてではなく、要件についてだと思われます。ソリューションを実装しコード化する代わりに、エンジニアは一歩引いて、<a href="https://ja.wikipedia.org/wiki/%E3%81%AA%E3%81%9C%E3%81%AA%E3%81%9C%E5%88%86%E6%9E%90" rel="nofollow" title="" class="ext-link">「なぜ？」</a>と自問することによって、問題の根源に対して気を配るべきなのです。</p><p>もちろん原則として、すでに発見されているソフトウェアの原理の利用は、オーバーエンジニアリングと考えるべきではありません。しかし、要件が2つのボタンをいったん大きくしてまた元に戻すということだけだったとしても、ある人は拡張性を持たせて分離（decoupled）しておくことは有益であると主張するでしょうし、またある人は要件が大規模なシステムの一部な場合に限ればフレームワークやjQueryを使った開発が正当化されるけれどそうでない限りは最初の例だけで十分だ、などと主張するでしょう。</p><p>問題は、オーバーエンジニアリングは主観的なものであり、エンジニアが解決すべき問題の全体像を要件から導くことに失敗すればするほど、その主観によるダメージが大きくなってしまうということです。しかしながら、問題の全体像が明らかであった場合であっても、より良い基盤を構築しておくことは長い目で見るとより多くの問題が起こり得るナイーブな方法を取るよりも有益であると主張する立場もあります。</p><p>長期的な目線で目的や思惑が理解できないのであれば、”オーバーエンジニアリング”しそうな要素を無視しないでください。そして一歩引いて考えて、問題の全体像を理解する前に必要以上のことをしようとしないことです。</p><p>結局のところ、オーバーエンジニアリングの定義は、個々の状況や背景によってまちまちです。プロジェクトにかかわった人自身がそれぞれの意見に基づいて、何がオーバーエンジニアリングで、何がそうではないのかを決めることになるでしょう。</p><p>残念ながら、常に何がオーバーエンジニアリングであるのか、そして何がそうではないのかという質問に共通の答えはありません。</p><p>私たちはそれを受け入れなければいけないのです。</p><p><img class="graf-image" data-image-id="1*ULpvg21u7psQW5k0p6ZjFQ.gif" data-width="640" data-height="70" src="https://cdn-images-1.medium.com/max/800/1*ULpvg21u7psQW5k0p6ZjFQ.gif"><br>
記事を楽しんでいただけましたか？　より多くの記事をサポートするには、この記事を他の人にもシェアしてください。「お勧め」をクリックしていただいても結構です。</p><p><strong>2016年10月27日編集：</strong><br>
<a href="https://medium.com/@moremoschops" rel="nofollow" title="" class="ext-link">MoreMoschops</a>からいただいた<a href="https://medium.com/@moremoschops/that-requirement-simply-makes-no-sense-and-the-biggest-mistake-here-isnt-over-engineering-it-s-87f6fffdf654" rel="nofollow" title="" class="ext-link">意見</a>を基に、例として使用した要件を改善しました。</p>
