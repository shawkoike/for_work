Testing SMS Interactions （2015-07-27） by Joël QuennevilleSMS送信機能を含むアプリケーションを開発するにあたっては、実際にメッセージ送信を行う必要があります。その際、私たちが好んで使うのはTwilioのような外部サービスです。SMSと連携する部分の単体テストを行う時は、実際のSMS送信機能をスタブに置き換えるだけで、テストの独立性を保つことができます。では、feature specはどうなるでしょうか。次の2人のユーザの話を例にとりましょう。そして2人とも、SMSメッセージによる情報のやりとりを要求しています。この場合、理想的なfeature specは以下のようになるでしょう。テストの段階から、送信済みのメッセージにアクセスできる仕組みがあれば、どんなに楽なことでしょう。しかしSMSクライアントのライブラリには、そういった機能はありません。理由はおそらく、開発段階で送信されるメッセージを全て保存しておくのは、ただのメモリの無駄遣いだからです。この場合、テスト用のSMSクライアントを独自で作成するのが望ましい解決策です。 SMSメッセージを送信してメモリに保存する代わりに、実際のクライアントのAPIを再現するのです。
例えば、Twilio Ruby gemの公式資料を見ると、そのAPIが以下のようになっていることが分かります。このAPIを再現し、疑似クライアントを作成してみましょう。ここでは以下のことを行っています。疑似クライアントを実際のSMSクライアントの代わりに使う場合、いくつか選択肢があります。RSpecは、spec内に定数をスタブ化できるstub_constメソッドを提供しています。spec helperでは次のようなことができます。こうすることで、FakeSMSを参照するために、かわりにTwilio::REST::Clientに別名をつけます。定数のスタブ化がしっくりこなければ、Railのクラスローディングシステムを利用する方法があります。Railsは、既に別のものをポイントしているのでなければ、必ず定数をロードしようとするでしょう。Twilloのgemがロードされる前にTwilio::REST::Clientを定義することで、定数の再定義に関するあらゆるエラーを避けられます。保持していないコードを分離するためにTwilloのコードをアダプタ内にラップした場合は、他のオプションがあります。以下のアダプタのケースを見てみましょう。異なるクライアントを受容できるよう、アダプタは簡単に変更できます。そしてspec_helper内でコンフィギュレーションを変更できます。各テストの間にFakeSMS.messagesをリセットしたい場合は、以下のコードをspec_helperに追加してください。上記の選択肢のいずれかを選んで少し微調整すれば、feature specは問題なく動くはずです。疑似SMSクライアントを使うやり方は、SMSメッセージとのインタラクションを要求するフローをfeature specによってテストする良い方法です。ここではTwilloのクライアントを再現する方法を紹介しましたが、このアプローチはどんなSMSプロバイダにも使えます。
