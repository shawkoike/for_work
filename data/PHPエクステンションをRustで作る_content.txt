Creating a PHP extension in Rust(2015-04-04)ByJARED MCFARLANDアップデート：この記事の第一稿を投稿してから数時間後、PHPのベンチマークが機能していないことに気付きました。ですから万全を期すため、PHPとRustの双方のバージョンを更新しました。変更箇所は、GitHub（最後にリンクあり）にまとめて載せてあります。昨年10月、私はEtsyのとある同僚と、どうやったらPHPやRuby、Pythonといったインタプリタ型言語で今よりずっと簡単にエクステンションが書けるかについて議論しました。うまく書けない原因の1つとして、エクステンションは概してCで書かれますが、Cに長けているのでなければ自信を持ってコードを書くのは難しい、といったことなどを話しました。あれ以来、私はずっとRustでエクステンションを書く方法を模索し、ここ数日は実際にあれこれ試してみました。そして今朝、ついにうまくいったのです。私の基本的なアイデアは、ライブラリ形式にコンパイルしたRustのコードをいくつか書き、そこにCのヘッダをつけ、Cでそれを用いることでPHPから呼び出せるエクステンションを作る、というものでした。世界一簡単な方法というわけではありませんが、面白そうだと感じました。私が最初に行ったのは、RustにCと互換性を持たせることができるRust Foreign Function Interface（FFI）をいじることでした。1つだけの引数（Cのchar型、他の言語ではstring型と呼ばれるデータ型のポインタ）を持つhello_from_rustという1つのメソッドを使って簡単なライブラリを書きました。このメソッドは、入力したものの前に“Hello form Rust,”を加えて出力します。このコードの大部分は、『Calling a Rust library from C (or anything else!)』を参考にしました。ここで起こっていることを、うまく説明しています。これをコンパイルすると、.aのファイルであるlibhello_from_rust.aが得られます。これはスタティックライブラリで、自身の依存関係は全てこの中に含まれています。そして次に行いますが、Cのプログラムをコンパイルする時、そこにリンクすることができます。これをコンパイルすると次のように出力されることに注目してください。これはRustのコンパイラで、この依存関係を使う時に他に何とリンクする必要があるかを教えてくれます。ライブラリができたので、次はこれをCから呼び出せるようにするために、2つのことを行わなくてはなりません。まずは、Cのヘッダファイルhello_from_rust.hを作り、コンパイルする時にリンクさせる必要があります。ヘッダファイルは次のようになります。これはかなり基本的なヘッダファイルであり、1つの関数についてのみシグネチャと定義を提供します。そして、次に書く必要があるのはCのプログラムコードです。そしてコンパイルを実行します。文末に-lSystem -lpthread -lc -lmと付けます。そうやってRustコンパイラでRustのライブラリをコンパイルした際に生じる”ネイティブアーティファクト”に対して、それぞれリンクするようにgccに指示を出しています。生成されるバイナリを一度実行してしまえば、hello_cは次のように実行できます。素晴らしい！CからRustのライブラリを呼び出せました。そこで次の課題は、これをどうやってPHPエクステンションに組み込むかです。この問題を解決するのにはかなり時間を費やしました。というのも、PHPエクステンションについてのマニュアルがあまり優れていないのです。ただ、PHPソースにext_skel（おそらく”エクステンションスケルトン”の意味）というスクリプトが既に入っていることには助かりました。このスクリプトを使えば、必要なボイラープレートコードをほとんど生成することができます。これを実装するために私はPHPマニュアルの『Extension structure』をかなり読み込みました。まず手始めにPHPソースをダウンロード、解凍し、そしてPHPディレクトリに移動して実行してみましょう。このようにしてPHPエクステンションを作成するために必要になる基本的なスケルトンが生成されます。そしてこのフォルダを、エクステンションを格納したいローカルディレクトリに移し、以下のを同じディレクトリに移動させます。そうすることで、最終的にディレクトリの中身はこのようになります。これらのほとんどのファイルについてはPHPマニュアルの『Files which make up an extension』で分かりやすく解説してあります。それでは、config.m4の編集から始めていきます。コメントは全て省略していますが、こちらが私の組んだコードになります。分かったことは、これらは基本的にマクロだということです。これらのマクロについてのマニュアルはかなりひどかったです（例えば、Googleで”PHP_ADD_LIBRARY_WITH_PATH”と検索してもPHPチームが書いた文章が最初の検索結果ページに出てきません）。私はPHPエクステンションにスタティックライブラリをリンクさせる方法について話している古いスレッドを見つけ、PHP_ADD_LIBRARY_PATHのマクロに辿り着きました。それ以外のマクロについてはext_skelを実行した際に生成されるコメントが勧めていたものを使用しています。ビルド設定をセットアップできたので、次はPHPスクリプトを使ってライブラリに呼び出す必要があります。そうするために、自動的に生成されるhello_from_rust.cというファイルを修正していきます。まず、hello_from_rust.hというヘッダファイルをインクルードするようにし、confirm_hello_from_rust_compiledというPHPメソッドの定義を修正します。hello_from_rust("Jared (fromPHP!!)!");をここに挿入しました。これで、PHPエクステンションの構築に取り掛かれます。たったのこれだけです！この3行のコードで、まずメタコンフィグを生成し、Makeという設定コマンドを実行し、そしてエクステンションをインストールします。私の場合はここでsudoをインストールに使う必要がありました。なぜなら私のユーザは、直接PHPエクステンションをインストールできる権限を持っている訳ではないからです。さあ、実行してみましょう！　成功です！PHPは確かにCで作ったエクステンションにアクセスし、利用可能なメソッドや呼び出しのリストを確認しています。そしてこのCエクステンションがRustのライブラリにアクセスし、私たちが最初に作った文字列をPHPに出力しました。すばらしいです！しかし最後にセグメンテーション違反が表示されていますが、これはどういうことでしょう？　私に分かる限りでは、この問題はRustのprintln!というマクロを使ったことに関係しているようですが、現時点ではまだ掘り下げて確認していません。でもこのマクロを削除し、代わりにRustライブラリからchar*を返すように変更すれば、セグメンテーション違反は無くなります。こちらがそのRustのコードです。そして、Cヘッダを次のように変更します。これに伴い、Cエクステンションも次のように変わります。さて、なぜこんな方法を使う必要があるのでしょうか？正直に言いますと私はまだ、実世界でこの方法が必要になるケースに遭遇したことはありません。でも、PHPエクステンションがまさに適切な事例は思い当たります。フィボナッチ数列に関するアルゴリズムです。これは大体の場合、かなり簡潔で分かりやすいアルゴリズムです（以下、Rubyによる例です）。性能に関しては、本当にひどいものになりますが、再帰を使わなければパフォーマンスは向上します。では1つはPHPだけで、もう1つはRustも使って2つの例文を書き、どちらが速いか比べてみましょう。こちらがPHPだけのバージョンです。こちらが実行時間の結果です。Rustを使ったバージョンでも試しましょう。こちらがライブラリのソースです。コードを軽く確認してみましょう。私はrustc -O rust_lib.rsを使って、このライブラリを最適化できるようにコンパイルしました。（パフォーマンスをベンチマーキングするためにです）。こちらがCエクステンションのソースです。（関連する部分のみ抜粋しました）。実行に必要なPHPのスクリプトは以下の通りです。そしてこちらが結果です。3倍以上も速くなっていることが分かりますね！Rustバージョンにとっての素敵なマイクロベンチマークでした！この記事から導くことができる結論といったものはほとんどありません。Rustを使ってPHPエクステンションを書くことが適切な場面が本当にあるのか、正直わかりません。でもまあ、RustとPHPとCに数時間熱中できる楽しい試みでした。もし全てのコードを確認してご自身で試してみたければ、GitHubにまとめましたので、アクセスしてみてください。
