Rust for functional programmers（2014-07）by Raphael ‘kena’ Possこの投稿はEdward Z. Yangが2010年に書いたOCaml for Haskellers、私自身が今年頭に書いたHaskell for OCaml programmersの流れに沿っています。C言語プログラマのためのRustと、関数型プログラマのためのRustは異なります。他のプログラミング言語を使用した経験のあるC言語系統のプログラマなら、Rustはとても多くの新しい特徴と変わった構造を持っていると感じるでしょう。どちらかというと難解と感じるかもしれません。C++、JavaやC#プログラマでさえ、Rustは別物のように感じます。Rustはオブジェクトを持ちますがクラスを持ちません。“structed enums”を持ち、C言語系統では同等のものがない変わったマッチステートメントを使います。同じ変数を2度割り当てること避け、C系統言語では聞いたことのない変則的なルールを適用しています。それはなぜでしょう？現在のRustマニュアルではあえて明言していないものの、Rustは関数型言語であり、ここ数年主流となっているプログラミング言語デザインの影響を受けています。Rust支持者が直面している問題があります。それは言語としても規律としても、関数型プログラミングが30年にわたり汚名を着せられてきたことです。例えば、関数型プログラムは判別が難しい、C言語に比べ処理が遅い、実行時には高くつく機構が必要になる（少なくともガベージコレクタ、しばしばシステムI/Oの関数型ラッパなど）、また学ぶのが難しく、変則的なシンタックスを使用するなどです。C言語プログラマへ関数型言語としてのRustを説明する場合、受け入れてもらうにはとても骨が折れるでしょう。というのも公式のRustマニュアルとチュートリアルは明確に、下位タスクの実行に、どのようにRustを使用するか説明していますし、多くのCプログラミングパターンに相当するRustを現行のプログラミング言語に言及することなく、少しずつ説明していくとしています。これがすべてであると言えるのですが、もしあなたがすでに関数型プログラミングについて知っていたらどうでしょうか？Haskell、OCamlなどを使用したことのある経験者にとって、関数型プログラミングの基礎を事細かく説明したマニュアルを読むことはとても退屈なことでしょう。対象者のレベルに合わせ、以下では関数的側面から急ぎ足でRustの紹介をしていきます。良くも悪くも、この先も大抵のハードウェアプロセッサはプログラムカウンタ、レジスタ、そしてアドレス指定のできるメモリに基づいていくだろうとされています。これは私たちが1970年代にいた場所とまったく変わっていません。当時はC言語が設計された時代であり、C言語が現在も普及している理由になっています。特にC言語の抽象機械モデルはほとんどのハードウェアのプラットフォーム上で適しているとされ、割り込みハンドラやガベージコレクタ、仮想メモリマネージャのような低レベルのシステムを構築するのにちょうどいいレベルの抽象化になっています。しかしながらC言語の“ユーザインターフェース”、特にプリプロセッサと型システムは、とても時代遅れになっています。新しいものを学んだプログラマにとっては、率直に言ってダメな言語です。こうしたことを背景にRustはつくられてきました。RustはC言語の抽象機械モデルを保ちますが、言語のインターフェースが刷新されています。Rustは書き方のバリエーションが豊富で、型システムはシステムコードをより安全にします。その強力なメタプログラミングファシリティはコードの自動作成の新しい方法を可能にします。しかし、この記事を書いている時点ではRustは、いまだ安定していないことに注意してください。ほとんど予告なく、まだ変更されることがあり、公式の資料は実装と完全には同期されていません。Haskellと同じように、Rustの数値リテラルでサフィックスがないものについでは、あらかじめ定義された型はありません。実際の型はコンテキストから推論されます。Rustの文字リテラルはどんなUnicodeのスカラ値も表すことができ、Latin-1エンコードのみのOCamlの文字とは対照的です。Rustの他のリテラルフォームは同記事内で後述するリテラルのセクションで示します。プリミティブ型Rustではstr型は特別です。プリミティブなので、コンパイラは特定の文字列演算を最適化することができます。しかし、第一級ではないために、str型の型変数を定めたり、関数に直接str型の値を渡すことができません。プログラムでRustの文字列を使用するには、後で述べるように文字列参照を使用しなければいけません。演算子の等価性：Rustはブーリアン演算と、整数型上での単一ビットごとのNOT演算子の両方に!を使います。単一の~はRustでは、以下で説明するように、C言語とは違った意味を持ちます。複合式：ブロック式の値は、ブロック内の最後の式の値になることに注意してください。ブロックがセミコロンで終わる場合は、その値は()になります。関数の型と定義：パターンマッチとガード副作用を伴う再帰明らかに、OCamlと同様に、Rustは正格（先行）評価を行い、関数が副作用のある式を含むことが可能です。Rustが用いるLLVMコードジェネレータは上記の関数に対して末尾呼び出しの除去ができますが、Rustは末尾呼び出しの除去を（現在のところ）保証していないことに注意してください。不確かな場合は、下記が同等です。レコード型の式とフィールドアクセス自由な型パラメータ（ジェネリックなデータと関数型）代数的データ型ラムダ式と高階関数Rustの“トレイト”はHaskellの型クラスに似ています。Haskellと主に違う点は、トレイトはドット表記法の式に対してのみ介在するということです。すなわちa.foo(b)のような形です。しかしながら、C++、Java、C#、OCamlのプログラマは、トレイトを伝統的なオブジェクトクラスと混同してはいけません。トレイトはまさに型クラスです。つまり、トレイトを、プリミティブ型を含む任意のデータ型に追加することができます。例トレイトのメソッド宣言において、識別子“self”は、そのメソッドが適用される実際のオブジェクトを示します。Haskellと同様に、Rustのトレイトは演算子のオーバーロードに使うことができます。例えば、Peano整数に対して新たな直和型を定義する場合は、そして、PartialEqクラスを例示することで、比較演算子==をPeano整数の間にオーバーロードできます。また、Haskellと同様に、トレイトはメソッドに対するデフォルト実装を提供できます。インスタンスが特殊化を省略する時に使用されます。トレイト宣言内のメソッド宣言において、識別子“self”はそのトレイトが適用される実際の型を指します。Rustにおいてオーバーロード可能な各演算子には、標準ライブラリの中に対応するトレイトがあります。forループは次のように、特殊なトレイトstd::iter::Iteratorを使用します。メソッドnextはIteratorが実装します。nextの戻り値の型はOptionです。これは、“繰り返すものが残っていない”ことを意味する値None、あるいは次の繰り返し値がxであることを意味する値Some(x)を持つことができます。トレイトが提供する仕組みに加えて、どのstructやenumも、“impl”を使って1つ以上のメソッドインターフェースを使ってデコレートすることができます。デコレートは定義から分離され，異なるモジュール内ででデコレートすることができます。C言語と同様に、Rustの関数パラメータはデフォルトで、値によって渡されます。大きなデータ型では、データのコピーはコストが高くなるかもしれないため、代わりに参照を使うことも考えられます。型Tのどんなオブジェクトvでも、式“&amp;v”を使ってそのオブジェクトを指す参照を作ることができます。その参照自体はその時、型&amp;Tを持つことになります。この例で示しているように、Rustはstruct参照のためのシンタックスシュガーを提供しています。つまりp1の型が&amp;PtでありPtがxという名前のフィールドを持つ場合は、p1.xと書くことも可能です。このシンタックスシュガーはメソッド呼び出し（x.foo()）にも利用できます。しかし、他の多くのケースでは、参照される値が*単行演算子で“取得される”か、パターンが&amp;でマッチしなければなりません。単純な参照では下部のオブジェクトの変更を許していません。このため、参照によって変更できることが望ましい場合は、次のように“&amp;mut”を使用します。Rustの型システムは、参照を通した可変な別名を許しません。つまり、C言語とは違って、参照で別名を使って同じオブジェクトを変更することはできません。これは借用という概念を通して行われます。つまり、オブジェクトの所有権が参照によって借用されている間は、元の変数を使用できないということです。例を挙げます。“すべての値はデフォルトでは不変”であることや所有権・借用のルールと共に、参照型はRustの型システムの核となる特徴です。この特徴によって、Rustの型システムはC言語よりも根本的に安全なものとなっています。RustはC言語と同じ抽象機械モデルについて定義されています。この抽象機械にはメモリのセグメントがあり、言語のランタイム機構はプログラムの実行中にメモリのセグメントの割り当てと解除を行うことができます。抽象機械において、RustではC言語と同様に下記の2つの概念が定義されています。C言語におけるメモリ関連の問題はすべて、Cプログラムでは寿命外（すなわち割り当て前または解除後）あるいは記憶域外（すなわちメモリの下位アドレスまたは上位アドレス）のオブジェクトを指す参照を操作できることから起こっています。Rustは、オブジェクトが寿命外または記憶域外で使用できないことを確実にすることで、そうした問題を徹底的に防ぐようにしています。C言語やRustの抽象機械には、4種類の記憶域、つまりstatic（静的）、thread（スレッド）、automatic（自動）、allocated（割り当て）があります。C言語では、オブジェクトの寿命はその記憶域だけで決まります。Rustでは、staticとautomaticのオブジェクトの寿命はC言語と同じです。しかしながら、Rustは、さまざまな型付けルールに関連して、ボックスに対する多くの管理戦略をサポートしています。Rustの管理オブジェクトの扱い方は、比較的シンプルです。“puts objects into boxes”の式にあるboxキーワードによって、オブジェクトの寿命が動的に管理されます。ボックスの不可変性と所有権については、前述した参照と同様の考え方です。boxキーワードは、実際にはbox(HEAP)の省略形です。“box(A) E”は、Aによって割り当てられたメモリオブジェクトにEの値の結果を置くことを意味し、これがトレイトです。Rustのバージョン0.11において、これ以外に標準ライブラリ内にあるアロケータは、ガベージコレクションされたオブジェクトであるGCだけです。管理オブジェクトは、適切な再帰的代数的データ型を実装するための”失われた環”になっています．ボックスが提供する利便性を補完するものとして、Rustの標準ライブラリには、参照がカウントされる不変オブジェクトへのラッパーが2つ実装されています。これにより複数のオーナーからの参照が可能になります。参照カウントを使えば、最後の参照が終了したその時に、オブジェクトの割り当てが解除されたことが保証されます。ボックスの使用のトレードオフは、新しい参照が作られたり参照が終わったりするたびに、参照カウントを更新しなければならない、ということです。std::rc::Rcとstd::arc::Arcという2つの実装が提供されています。どちらも同じインターフェースを提供します。なぜ同じようなものがあるかというと、プログラマにパフォーマンス上のトレードオフを与えるためです。Rcはメモリを使いません。だから軽量で、つまり速いのです。しかしスレッド間で共有できません。Arcはメモリを使います。Rcと比べるとやや効率が悪いですが、スレッド間でデータを共有できます。マクロを定義する基本的なシンタックスは次のようになります。例えば、次に示すマクロは、forループをPascalのように定義したものです。このマクロが、ローカルネームを付けるに当たってどのようにマッチステートメントを使っているかに注目してください。これによって1度しか値を返さないようになっています。Scheme同様、マクロも再帰可能です。例えば次に示すマクロでは、stepがあってもなくてもpforを実装するために再帰を使っています。マクロは可変個引数であり、シンタックス内の任意の繰り返しは、マクロの1つの引数で記録できます。例えば、次に示すマクロでは、各引数においてprintln!を呼び出し、それは任意の型になり得ます。シンタックスは次のようになります。マクロ式の左側（pattern）では、$( PAT )DELIM*が、DELIMによって区切られているPATのゼロまたはそれ以上の出現に一致し、右側（expansion）では、$( TEXT )DELIM*が、DELIMによって区切られたTEXTの1回またはそれ以上の繰り返しを展開します。展開される繰り返しの回数は、含まれるマクロの引数がマッチする回数によって決まります。示した例の中では、それぞれの引数（カンマによって区切られる）は、セミコロンによって区切られるprintln!という呼び出しで代用されています。Rustにはさまざまな数値リテラルの語彙があります。文字、バイト、文字列によるエスケープのリテラルC言語ファミリでよく使われるエスケープ（\a、\fなど）や、8進法表記のエスケープ（例、\0123）は、Rustでは使えないことに注意してください。最後に、RustはPython同様に、raw文字列、複数の文字列のデリミタをサポートしており、これにより文字列内のデリミタのオカレンスを引用することを避けています。RedditやHacker Newsでクオリティの高いコメントを寄せてくれた多くの人たちに感謝します。この記事の初版に磨きをかけるに当たって、いただいたコメントが大変参考になりました。Copyright © 2014, Raphael ‘kena’ Poss. Permission is granted to distribute, reuse and modify this document according to the terms of the Creative Commons Attribution-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.
