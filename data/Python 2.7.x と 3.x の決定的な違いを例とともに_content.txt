The key differences between Python 2.7.x and Python 3.x with examples by Sebastian RaschkaPythonを始めたばかりのユーザーの多くが、どちらのバージョンを使えばいいのか迷っています。私の答えは、「気に入ったチュートリアルに書かれているバージョンにしましょう。そして、あとで違いを調べてください」という言葉につきます。 それでは、新しいプロジェクトを始めるときにはどちらを選べばいいのでしょうか？ 使おうとしているライブラリを全てサポートしているなら、2.7.x系と3.x系のどちらを使ってもよいでしょう。そうはいっても、この2つのメジャーバージョンについて大きな違いを見ておくのは良いでしょう。どちらかのみでコードを書いたり、プロジェクトに使おうとしている時によくある落とし穴を避けられるからです。Python 3.x で導入されていて Python 2 で使えないキーワードについては、 __furute__ モジュールをインポートすることで Python 2 で使えます。あなたのコード中で Python 3 をサポートするときは __future__ モジュールのインポートが推奨されています。例えば Python 3.x の整数除算のの挙動を Python 2 に取り入れたいときは、以下のようにインポートします。他にも以下の表にある機能がインポートできます(ソース: https://docs.python.org/2/library/future.html)些細な事かもしれませんが、print構文が変わったことは広く知られている変化ですが、取り上げる価値があります。Python 2のprint文は print() 関数で置き換えられます。printしたいオブジェクトを丸括弧で囲うことが必要になります。Python 2 では括弧が追加されても問題ありませんが、Python 3 では対称的に Python 2 のやり方で括弧のないprint関数は SyntaxError になります。Python2で “Hello, World” を上記のように印字するのは極めてふつうのことです。しかし丸括弧のなかに複数のオブジェクトがあった時は、printは文なので、タプルを作ることになります。コードを移植しようとしたり、Python3のコードをPython2で実行しているなら、除算の変化はとりわけ危険になります。整数除算の挙動の変化は、しばしば気づかれないからです。（SyntaxErrorは発生しません）なのでPython3のスクリプトではPython2を使ってる人の面倒ごと省くために、 3/2 と書かずに float(3)/2 もしくは 3/2.0 と書くようにしています(逆もまたりかりで、Python2のスクリプトでは from __future__ import division を使うように推奨しています)。Python 2 では ASCIIの str() 型を、 unicode() とは別に持っていますが、 byte 型はありません。Python 3 では、ついに Unicode (utf-8) の str 文字列と、 2バイトクラス: byte と bytearray が登場しました。xrange() は Python 2.x ではイテラブルなオブジェクトを作るのによく使われています。例えば、for-loop や list/setとディクショナリの内包表記などがあります。挙動はジェネレータ（例: 遅延評価）とよく似ています。しかしxrangeのイテラブルは枯渇することはありません。無限にイテレート可能なのです。遅延評価のおかげで、range() の xrange() に対する利点は、一回で全てイテレートする場合に若干速いということにとどまります。(for-loopなど)しかし、一度のイテレーションとは対照的に、何度もイテレーションしてしまうときには推奨されません。なぜなら、いつも一からジェネレートが起こってしまうからです。Python 3 では range() は xrange() 関数のように実装されています。おかげで専用の xrange() はもうありません。他にも、Python 3.xでは range が 新たに__contains__ メソッドを手に入れました。(Yuchen Yingさん、ご指摘ありがとうございます)__contains__ メソッドは Python 3.x の range における 整数とブール値型のルックアップを劇的に高速化します。timeit の結果をみれば、 浮動小数点数に比べて整数ルックアップの実行速度が60,000倍も速いことがわかります。しかし Python 2.x の range や xrange は __contains__ メソッドを持っていないので、整数と浮動小数点数のルックアップはそこまで変わりません。以下は Python 2.x では __contain__ メソッドが実装されてないことの証明です。Python 3 の range() と Python 2 の xrange() の速度の差について指摘する人もいます。同じように実装されているのだから同じ速さになるだろうからです。しかし、以下の違いは Python 3 は 一般に Python 2 より遅くなるという事実からきています。Python 2 が新旧どちらの構文もうけつけるようなところでは、丸括弧で例外を閉じなければ、 Python 3 は(SyntaxErrorを出して)行き詰まってしまいます。Python 3 では例外処理もすこし変わりました。Python 3 では as キーワードを使う必要があります。next() (.next()) はよく使われる関数ですが、以下は言及する価値のある構文の変化(そして実装の変化)です。Python 2.7.5 で関数とメソッドの構文を使えるところでは、Python 3 では next() 関数しか残っていません。(.next() メソッドを呼ぶと AttributeError になります)朗報: Pthon 3.x の for-loop 変数はグローバル名前空間へ漏れることがなくなりました！What’s New In Python 3.0 で取り上げた変化にさかのぼりますが、以下のようになります:他にも Python 3 でのナイスな変化といえば、列挙不可能な型同士を比較しようとしたときに、TypeError が警告として送出されるようになったことがあります。ついてることに、input() 関数は Python 3 でユーザー入力を常にstr オブジェクトとして保持するように直されました。Python 2 においては、strings 型以外の型として読みこむような危険な振る舞いを避けるため、raw_input() を使わなければなりません。xrange の節で見たように、Python 3 のある関数やメソッドでは Python 2 ではリストとして返していたものを、イテラブルなオブジェクトとして返します。私達はよく一度にイテレートするので、この変化のおかげでかなりメモリーを省力できると考えていました。しかし、ジェネレータとは対照的に、必要であれば何度でも全体をイテレートすることができます。ただしそこまで効率的ではないのですが。本当にリストオブジェクトが必要な場合、list() 関数を使って list に変換することができます。以下のよく使われている関数とメソッドは、Python3ではもうリストを返さなくなっています:フォローアップにおすすめな、Python 2 と 3 をつなぐ良質な記事のリストをあげておきます。**// Python 3 への変換 **// Python 3 のメリット・デメリット
