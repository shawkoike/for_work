<p><a href="https://ablagoev.github.io/linux/adventures/commands/2017/02/19/adventures-in-usr-bin.html" rel="nofollow" title="" class="ext-link">Adventures in /usr/bin and the likes</a> （2017-02-19） by <a href="https://ablagoev.github.io/about/" rel="nofollow" title="" class="ext-link">Alexander Blagoev</a></p><p><small>(注：2017/04/10、いただいたフィードバックを元に翻訳を修正いたしました。)</small></p><p>私はLinuxが大好きです。コンピュータとのやりとりが楽しくなるし学ぶことも多くなります。OSとハードウェアの基盤となる基本原則を学びたい人にとって、Linuxはとてもいい出発点と言えるでしょう。</p><p>ご存じのとおりLinuxとは大抵の場合プログラム（コマンド）を通してやりとりします。Linuxと他のUNIX系システムが持っている特徴は、コマンドラインと、パイプのコンセプトです。プログラムの提供する入力と出力を統合すれば、データを操作するのに非常にパワフルなプラットフォームになります。</p><p>Linuxのコマンド、プログラム、バイナリ（何と呼んでもいいのですが）の大部分は、/usr/bin、/usr/sbin/、/binそして/usr/local/binに存在しています。これらのディレクトリを見れば、プログラムがたくさん見つかるでしょう。それでふと、これらのバイナリが日々の仕事にどう関わってくるのかと考えました。それで、宝探しをしてみることに決め、発見をこのブログに投稿してみることにしました。</p><p>手始めに、私のマシンの/usr/binにある簡単なカウント機能で、データを参照してみます。</p><p>これはもちろん日々私が使っているシステムで、ここで多くのものを保管しています。Centos 6.8（X Serverなし）の標準サーバに少しだけソフトウェアを追加して稼働しています。</p><p>半分になりましたが、まだずいぶん数が多いですね。日常業務ではおそらく平均して20コマンドくらいしか使いません。以下はzsh環境でチェックする簡単な方法です。</p><p>これで最新の146のコマンドが求められます。fcを使いタイムスタンプを参照し、今日の分だけのコマンドを抽出しました。</p><p>このデータを念頭に置いて、/usr/binやその周辺の内部を掘り下げ、隠された宝石がないかどうか調べてみることにしました。私はCentos 6.8の標準インストールをしているので、違うディストリビューションであれば違いがあるでしょう。</p><p>この投稿を書きながら各プログラムについて学びました。無知さ加減が目についたらご容赦ください。</p><p>目次</p><p>いいですね。私はいつも単発のジョブを設定しようとしてcronの構文を間違ってしまいますが、こういったユースケースに対してはずっと簡単に使えそうです。例を挙げます。</p><p><code>date &gt; /tmp/test_at.log</code>は同日の9:26p.m.に実行されます。保留中のジョブも参照可能です。</p><p>atはイカした日時の書式をいくつか理解しているようです。例えばお茶の時間（<code>at teatime</code>）も知っています。クールですね。</p><p>
</p>
<p>今日の日付を反転表示して、しゃれたカレンダーを表示してくれます。個人的にはすごく便利だと思います。</p><p>
</p>
<p>これも便利です。<code>mkfifo</code>はシンプルなIPC（プロセス間通信）に使えます。この時生成される<code>named pipe</code>は、Linuxでは通常そうであるように、ファイルです。つまりこのファイルに書き込むプロセス（writer）とこのファイルから読み込むプロセス（reader）が装備されています。下記の2つのPythonのスクリプトを参考にしてみてください。</p><p>スクリプトを利用する前にFIFOを生成します。</p><p>writerを起動します。</p><p>readerも起動します。</p><p>readerがFIFOの内容を出力する出力レートに注目してください。writerと同期しています。FIFOが通常のファイルだとしたら、readerは新しいアイテムがあろうがなかろうが、常に読み込むはずです。FIFOに対する読み込みと書き込みはブロッキングオペレーションだからです。FIFOを通常のファイルに変更して違いを確認してみてください。</p><p>他に<a href="https://ja.wikipedia.org/wiki/Netcat" rel="nofollow" title="" class="ext-link">WikipediaのNetcatの項</a>にもすばらしい例があります。</p><p>これはプロキシの例で、ポート12345のリクエストをすべてポート80のwww.google.comに転送します。パイプが単方向性なので、FIFOが必要となります。</p><p>
</p>
<p>通常、ホストのIPアドレスを取得するのにはpingを使いますが、<code>resolveip</code>の方が簡単です。</p><p>私と同類の人なら、しょっちゅうIPをコピーする必要にかられ、IPだけを返す-sオプションを使っているはずです。</p><p>.bash_aliasesというファイルに保存するだけで、簡単に関数にできます。</p><p>
</p>
<p>コードを編集したくない時に便利です。例を挙げます。</p><p>プログラムは10秒間実行され、そのあとTERMシグナルが送られます。シグナルや、時間の単位（例えば分、時間、日）は変更できます。</p><p>
</p>
<p>マルチユーザのシステムでは便利です。</p><p>
</p>
<p><code>watch</code>はプログラムを定期的に実行したり出力を監視したりするのに便利なツールです。シンプルな時計は以下のようになります。</p><p>-nオプションはwatchにプログラムを毎秒実行するように命令します。-dオプションは出力の差異を強調するようwatchに指示します。</p><p>
</p>
<p>
</p>
<p>この項目についてはブログの投稿をすべて費やしてもいいほどですが、私は正直詳細まで記述できるほど準備ができていません。理解している範囲では、システムのI/Oをiostatよりも低レイヤーで監視することができ、I/O関連のメトリクスを多く測定することができるというものです。この件に関しては<a href="https://brooker.co.za/blog/2013/07/14/io-performance.html" rel="nofollow" title="" class="ext-link">これ</a>が優れた投稿だと思います。</p><p>これは新しいカーネルにのみ実装されています。古いものにはパッチを当てなくてはなりません。</p><p>
</p>
<p>システムに「niceness」を設定できることについてはご存じですよね。知らなかったのですが、CPUのスケジューリングポリシーも変更できます。現在、最新のカーネルは以下のポリシーをサポートしています。</p><p>また、プロセスにはリアルタイムと標準の2種類があります。リアルタイムプロセスの方が優先度が高く、時間的な制約のあるアプリケーションに適用されます。</p><p>プロセスのポリシーを変更することで、Linuxがプロセスをスケジュールする方法を変更できます。</p><p>ユーザプロセスは通常リアルタイムではなく、デフォルトがSCHED_OTHERポリシーになっています。カーネルプロセスを調べてみたところ、SCHED_FIFOのものもありましたが、（少なくとも私のマシンには）SCHED_RRを持っているものはありませんでした。</p><p><code>chrt</code>を使えばプロセスのスケジューリングポリシーの変更やクエリが可能です。例えば、initをチェックするには以下のようになります。</p><p>結果としてプロセスポリシーを以下のように変更することができます。</p><p>しかし、実用的なユースケースや本番環境のポリシーに干渉する意味も見つけることができません。<a href="https://barro.github.io/2016/02/being-a-good-cpu-neighbor/" rel="nofollow" title="" class="ext-link">こちらの投稿</a>ではいくつかの評価基準が掘り下げられています。ぜひ、このポリシーに関する皆様の経験や知識を共有していただけると嬉しいです。</p><p>詳細は以下をお読みください。</p><p>
</p>
<p>これはかなりイケてます。マシン（のトポロジー）のハードウェアレイアウトの表示のために使用することができます。数多くの異なる出力フォーマットだけでなくASCIIアートにも対応しているところが最高です。以下に例を挙げています。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2017/04/20170403.png"><img src="http://postd.cc/wp/wp-content/uploads/2017/04/20170403-241x300.png" alt="20170403" width="241" height="300" class="alignnone size-medium wp-image-9605"></a></p><p>Istopoコマンドは<code>hwloc</code>パッケージで提供されます。</p><p>
</p>
<p>これらのコマンドだけの投稿ができるほど話題につきません。私の知る限り、両コマンドはプロセスやスレッドのCPUアフィニティを制御するために使用されます。例えば、異なプロセスやスレッドを異なるコアやソケットに指定することが可能になります。さらに、プロセスやスレッドが使用するべきメモリノード（NUMA環境下でのバッファプール）を管理します。実際、Linuxスケジューラが最適ジョブを実行せず、スレッドや同様のプロセスをコア中に渡してしまう時に使用されています。始める前にまず、NUMAのアーキテクチャをおさらいしましょう。</p><p>上は2つのCPUソケットと計16コアを持つ48ギガビットのサーバです。メモリは2つのノードに分かれています。</p><p>numactlの簡単な例は以下のとおりです。</p><p>これで1つ目のCPUソケット(0)上の<code>program</code>を実行します。</p><p>プロセスのアフィニティを起動時に変更したい場合は、<code>taskset</code>で実行できます。tasksetはソケットではなくコアで機能しますので、単体のソケットにプロセスを指定したい場合は、全てのコアを一覧にする必要があります。</p><p>-c 0を使用することで、PIDをコア#0に指定します。<code>cat /proc/cpuinfo</code>を使用すればコアを見ることができます。</p><p>さらに、プロセスの現在のCPUコアを見たい場合は、psのpsr列を見てください。</p><p>つまり、この場合、initプロセスがコア#1になっていることが分かります。</p><p>
</p>
<p>たくさんのミス（プロセスの好むノードではないノードにメモリが割り当てられること）があるのは、システム上のどこかでアフィニティが最適ではないからと考えるのが論理的だと思います。</p><p>
</p>
<p>このコマンドは既定のプロセスのI/Oを監視するために使うことができます。先に進める前にpeekfdのLinux Manページから以下の引用をご紹介します。</p><p>本番環境で使用する際は注意が必要です。どなたか安定性についてご存じの方は教えてください。いずれにせよ、保存時にvimの動作を監視します。</p><p>ファイルに何が書き込まれるか見えるのがすごいです。もちろんstraceを使ったり出力のフィルタリングを行ったりしても同じことができます。</p><p>
</p>
<p>このコマンドは、既定のプロセスやシステム全体のあらゆる統計を監視するために使うことができます。top/htopに似ていますが、更に詳しい情報を提供してくれます。例えば以下のような情報です。</p><p>最後の「1」は統計のポーリングを毎秒実行するようpidstatに指示します。-dオプションを使ってI/O統計を見ることができます。</p><p>メモリは以下のとおりです。</p><p>タスク（コンテクスト）の切り替えは以下のとおりです。</p><p>
</p>
<p>このコマンドは、プロセスによって操作中のディレクトリを簡単に取得できる使い勝手のいいツールです。</p><p>
</p>
<p>
</p>
<p>このコマンドは使い方が少し難しいのですが、使うだけの価値はあります。低レイヤーのプログラミングをしている人は日常的に異なる場合において使っています。私はsegfaultのデバッグに便利だと思って使っています。</p><p>Segfaultは以下のような形式になっています。</p><p>上の場合segfaultは共有ライブラリ（xcache.so）に出ています。ライブラリオフセット(xcache.so[7f46db763000+23000])を命令ポインタ(ip part)から減算してaddr2lineの正しいアドレスを算出する必要があります。</p><p>アドレスが分かったら、共有のオブジェクトの位置情報と一緒にaddr2lineに与えます。</p><p>このマシンの場合の出力は以下のとおりになります。</p><p>これはsegfaultを生成するC言語ソースコードの違反行です。最高です。</p><p>前述のとおり、このコマンドも単独の記事が書けるほど奥が深いのです。例えば、機能させるには、デバッグシンボルの設定をONにしてバイナリをコンパイルする必要があります。さらに、アドレス計算の裏には面白い理論が存在します（私の読むべきものリストに含まれています）。また、他にもさらに踏み込んだデバッグ（gdb）をしてくれるツールがあります。</p><p>
</p>
<p>繰り返しになりますが、すごいです。暴走プロセスのスタックトレースを見ることができるということは、問題解明に絶対役立ちます。使い方はいたって簡単です。</p><p>このコマンドはgdbのラッパです。そのため、ディストリビューションにない場合は、gdbで同じような効果が期待できます。</p><p>
</p>
<p>
</p>
<p>このコマンドは素晴らしいのに今まで知りませんでした。列の書式入力に使うことができます。個人的に一番使い勝手がいいと思うのがCSVファイル形式です。とりわけすごいのは異なる列の区切り文字を指定することができることです。</p><p>コマンドを実行します。</p><p>次のコマンドと組み合わせて使うとさらに面白くなります。</p><p>
</p>
<p>このコマンドは入力から列を削除する場合に使えます。個人的にはawkを使い慣れていますが、単純なユースケースにおいては、colrmの方が使いやすいようです。前のコマンドで得た結果を元に、このコマンドを実行して最初の列を削除することができます。</p><p>
</p>
<p><code>comm</code>を使えば2つのファイルを比較して、片方のファイルにしか存在しない項目（行）の有無や両方のファイルに存在する行を確認することができます。例えば、以下のような2つファイルがあるとします。</p><p><code>comm</code>を両方のファイルで実行することで、以下のような結果を得ることができます。</p><p>列ごとに出力は分けられ、最初の列は最初のファイルのみに存在し、2つ目の列は2つ目のファイルのみに存在し、3つ目の列は両方のファイルに存在するといったように結果を表示します。ここでの注意点は、ファイルがアルファベット順に分類されている必要があるということです。そして、表示したい列を制御するオプションもあります。</p><p>
</p>
<p>このコマンドはsplit（ご存じない方は要チェックです）に似ていますが、csplitは大きいファイルを複数の小さいファイルに分割してくれます。splitとは異なり、<code>csplit</code>は正規表現で使うことができ、分割したファイルはそれぞれ異なる大きさにすることができます。以下の例を見てください（テキストファイル）。</p><p>以下のコマンドを実行します。</p><p>結果、アイテムブロックのみを含む3つのファイルが表示されます。<code>--suppress-matched</code>オプションはcsplitに共通の行は出力結果に表示しないよう指示します。<code>{*}</code>はcsplitにパターンマッチングを可能な限り実行するよう指示します。残念ながら、csplitは行単位で実行します。例えば、正規表現の複数行モードでは使えません。</p><p>
</p>
<p>Cutはよく使われていますが、私はこれまで使ったことがありません。見た限りでは、とてもパワフルなツールのようです。colrm同様にcutコマンドはファイルの部分的（列）抽出を可能にしてくれますcolrmとは異なり、開始・終了オフセットの設定だけでなく、区切り文字を指定することもできます。これが、CSVファイルの強力な解析の実行を可能にしてくれます。例えば、以下のデータ(テキストファイル)があります。</p><p>上でcutを実行すると以下のようになります。</p><p>-dオプションで区切り文字を指定します（ここでは、「;」になります）。-fオプションで出力したい列の指定をします。列1と列3を出力したい場合は、以下のようになります。</p><p>この他にもコマンドに柔軟性を持たせるオプションはあります。ここであえて挙げるとしたら、出力する区切り文字を制御するオプションでしょう。例えば以下のとおりです。</p><p>–output-delimter $’\t’はタブ文字を使うようcutに指示します。</p><p>
</p>
<p>これも人気のあるコマンドです。詳しくは知りませんが、何とか説明してみましょう。2つのファイルのデータを、共通フィールド単位で結合します。例えば以下の2つのファイルがあります。</p><p>joinを実行すると結果は以下のようになります。</p><p>最初の列に基づいてファイルを結合することができました。このコマンドは両方のファイルでどの列を使うか、区切り文字に何を指定する（デフォルト設定は空白）かなどを柔軟に選ばせてくれます。</p><p>
</p>
<p>Pasteは複数のファイルを連結したい場合に使用できます。最も簡単なケースとしては、ファイルの中の全ての行を連結したい場合に使えます。以下のファイル(データ)を例に見てみましょう。</p><p>コマンドを実行します。</p><p>-d オプションによって区切り文字が指定され、-sオプションによってファイルの行を連結されます。ここで-sオプションの表現方法と単一ファイルでは機能しない理由が理解できていません。</p><p>恐らく-sを実行しなければ、行単位で処理が実行されるのでしょう。</p><p>ファイル結合の別の例を見てみましょう。以下のファイル(ex1とex2)があります。</p><p>もちろん最初に挙げた例のように区切り文字を指定することもできます。</p><p>
</p>
<p>このコマンドをさえ知っていれば、簡単な検索や置換を実行するためにsedコマンドの構文を暗記する必要がなかったのにと思います。このコマンドはファイルの文字列の置き換えに使えます。以下のファイル（データ）を例として見てみましょう。</p><p><code>replace</code>を実行して「variable」を「x」に置き換えます。</p><p>速くて簡単です。複数の検索や置換を同時に実行することも複数のファイルで実行することもできます。</p><p>
</p>
<p>このコマンドは貴重です。ファイルの各行のうち、指定された文字列で始まっている行を表示します。基本的にはgrep “^PREFIX”と同じことをしてくれますが、正規構文なしで実行してくれます。以下のファイル（データ）で見てみましょう。</p><p>Manページで<code>look</code>をスペルチェックに使用する面白いユースケースが紹介されています。恐らく/usr/share/dict/wordsに英語辞典があり、<code>look</code>コマンドでスペルチェックするようデフォルト設定されているのでしょう。以下のようになります。</p><p>
</p>
<p>とても便利なちょっとしたツールです。ファイルに行番号を追加してくれます。以下のファイル（データ）があります。</p><p>上のファイルで<code>nl</code>を実行します。</p><p>
</p>
<p>Catのようなコマンドですが、ファイルを逆順に出力してくれます。</p><p>これは簡単なコマンドですが便利です。タブをスペースに変換してくれます。</p><p>上のコマンドとは反対のことをします。スペースをタブに変換してくれます。</p><p>以上で終わりです。この投稿を書きながら多くのことを学ぶことができ、さらにLinux愛が深まりました。システムの透明性や詳細を提供してくれていることに感嘆します。他にもすごいコマンドを知っている方はぜひ下のコメント欄で共有してください。ここで挙げたコマンドの多くは初めて見るものもあったので、誤りがあるかもしれません。もしあるようでしたらぜひご指摘ください。</p>
