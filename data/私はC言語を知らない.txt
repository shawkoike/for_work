<p><a href="https://kukuruku.co/post/i-do-not-know-c/" rel="nofollow" title="" class="ext-link">I Do Not Know C</a> （2015-03-03） by <a href="https://habrahabr.ru/post/136283/" rel="nofollow" title="" class="ext-link">Dmitri Gribenko</a></p><p><small>(注：2017/04/27、いただいたフィードバックを元に翻訳を修正いたしました。)</small></p><p>この記事では、皆さん（特にC言語のプログラマ）に「自分はCを分かっていなかった」と気付いてもらうことを目標にしています。</p><p>Cの落とし穴は、思っているよりもずっと身近なところにあります。ちょっとしたコードにも<em>未定義の動作</em>が潜んでいることを以下で示しましょう。</p><p>この記事はQ&amp;A形式になっており、それぞれの例題は独立したソースコードとして扱ってください。</p><p>Q: これは正しいコードでしょうか？　（変数の二重定義エラーが発生するでしょうか。上述の通り、これは独立したソースファイルであり、関数本体や複合ステートメントの一部ではありません）</p><p><strong>解答</strong></p><p>A: 正しいコードです。1行目は仮定義であり、2行目でコンパイラが処理した後に “定義” になります。</p><p>Q: <code>ｘ</code>がNULLポインタであっても<code>bar()</code>が呼び出されました（プログラムはクラッシュしません）。これはオプティマイザのエラーでしょうか。それとも何も問題はないのでしょうか？</p><p><strong>解答</strong></p><p>A: 何も問題はありません。もし<code>x</code>がNULLポインタなら、1行目の未定義の動作が発生するので、プログラマには何も保証されません。つまり、この1行目でプログラムがクラッシュするとは限りませんし、2行目でプログラムが制御を返すとも限りません。コンパイラが従う一連の処理ルールについても説明しましょう。まず、コンパイラでは1行目を解析します。そして<code>x</code>がNULLポインタになり得ないことを確認すると、2行目と3行目の実行されないコードを削除します。変数<code>y</code>は未使用なので削除されます。また、<code>*x</code>型はvolatile型修飾子とは見なされないため、メモリから読み取られた値も削除されます。</p><p>このようにして、未使用の変数によってNULLポインタのチェックが取り除かれます。</p><p>以下の関数があるとしましょう。</p><p>これを次のように最適化します。</p><p>Q: 元の関数と最適化した関数を呼び出して、<code>zp</code>で異なる結果を得ることはできるでしょうか？</p><p><strong>解答</strong></p><p>A: <code>yp == zp</code>とすると可能です。</p><p>Q: この関数で<code>inf</code>が返されることはあるでしょうか？　浮動小数点数は（ほとんどのマシンで）IEEE 754に従って実装されており、<code>assert</code>が有効（NDEBUGは未定義）であると仮定します。</p><p><strong>解答</strong></p><p>A: はい、あります。1e-309などの非正規化した値を<code>x</code>に渡せば十分です。</p><p>Q: 上記の関数は、ヌル(文字)で終わる行の長さを返す必要があります。バグはどこでしょうか？</p><p><strong>解答</strong></p><p>A: オブジェクトのサイズを格納するために<code>int</code>型を使用することは間違っています。なぜならintがオブジェクトのサイズを格納できるという保証はないからです。 <code>size_t</code>を使うべきでしょう。</p><p>Q: 上記のコードは無限ループになります。なぜでしょうか？</p><p><strong>解答</strong></p><p>A: <code>size_t</code>は符号なしのデータ型です。<code>i</code>も符号なしなので、<code>i &gt;= 0</code>が常にTRUE（真）となるため、上記は無限ループになります。</p><p>このプログラムを2つの異なるコンパイラにかけて、リトルエンディアンのマシンで実行しました。すると、次の通り実行結果が一致しませんでした。</p><p>Q: 2番目の結果が得られる理由を説明してください。</p><p><strong>解答</strong></p><p>A: 上記のプログラムは未定義の動作となります。例えば、エイリアス（別名）の厳格な規則に違反しているためです。コードの2行目で<code>int</code>の値を変更していますね。すると、<code>long</code>の値は変わらないと仮定することができます（互換性のないデータ型を持つ別のポインタのエイリアスは、逆参照できません）。従ってコンパイラは、1行目を実行して読み取った値をそのまま、3行目の<code>long</code>へ渡します。</p><p>Q: このコードは正しいですか？　未定義の動作ではないとすると、print文で何が出力されるでしょうか？</p><p><strong>解答</strong></p><p>A: はい、正しいです。ここではコンマ演算子が使われていますね。まず、コンマの左側の引数が計算されて廃棄されます。次に、右側の引数が計算されて、演算子全体の処理結果として使われます。出力結果は「<code>10 2 10</code>」となります。</p><p>ここで、関数呼び出しにもコンマ記号が使われることに注意してください（例えば<code>f(a(), b())</code>)。これはコンマ演算子ではありません。従って関数呼び出しの場合は、計算の順序は保証されません。<code>a()</code>と<code>b()</code>は任意の順序で呼び出されます。</p><p>Q: <code>add(UINT_MAX, 1)</code>の実行結果はどうなりますか？</p><p><strong>解答</strong></p><p>A: 符号なしの数値のオーバーフローが定義されていますね。これは<code>2^(CHAR_BIT * sizeof(unsigned int))</code>で計算されます。結果は0となります。</p><p>Q: では、<code>add(INT_MAX, 1)</code>の実行結果はどうなるでしょうか？</p><p><strong>解答</strong></p><p>A: 符号付きの数値がオーバーフローするので、未定義の動作となります。</p><p>Q: このコードは、未定義の動作となるでしょうか？仮にそうだとすれば、どの引数でそれが起こるでしょうか？</p><p><strong>解答</strong></p><p>A: <code>neg(INT_MIN)</code>です。ECMが追加コード（2の補数）で負の値を表す場合、<code>INT_MIN</code>の絶対値は<code>INT_MAX</code>の絶対値よりも大きく、その差は1となります。この場合、<code>-INT_MIN</code>が符号付きのオーバーフローとなるため、未定義の動作になります。</p><p>Q: このコードは、未定義の動作となりますか？仮にそうだとすれば、どの引数でそれが起こるでしょうか？</p><p><strong>解答</strong></p><p>A: ECMが追加コードで負の値を表す場合、 <code>div(INT_MIN, -1)</code>で未定義の動作となります。理由については、直前の質問の解答を参照してください。</p><p>— Dmitri Gribenko <a href="https://kukuruku.co/post/i-do-not-know-c/mailto:gribozavr@gmail.com" rel="nofollow" title="" class="ext-link">gribozavr@gmail.com</a></p><p><img src="https://s3.amazonaws.com/kukuruku-co/uploads/images/00/00/01/2015/03/03/a1b5cfa8a4.png" alt=""><br>
この作品は<a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="nofollow" title="" class="ext-link">クリエイティブ・コモンズ 表示-継承 3.0 非移植ライセンス</a>の下に提供されています。</p>
