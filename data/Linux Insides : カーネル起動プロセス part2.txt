<p><a href="https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-2.html" rel="nofollow" title="" class="ext-link">Kernel booting process Part 2</a> by <a href="https://github.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a><br>
in <a href="https://www.gitbook.com/book/0xax/linux-insides/details" rel="nofollow" title="" class="ext-link">Linux Inside</a> GitBook</p><p>前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-1.md" rel="nofollow" title="" class="ext-link">パート</a>では、Linuxカーネルの内部について探り始め、カーネルをセットアップするコードの最初の部分を見ていきました。前回の投稿は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/main.c</a>内の<code>main</code>関数（C言語で書かれた最初の関数）を呼び出すところまで確認しました。<br>
このパートでは、引き続きカーネルのセットアップコードについて調査し、併せて以下の内容も学びます。</p><p>それでは始めていきましょう。</p><p>ネイティブのIntel64の<a href="https://en.wikipedia.org/wiki/Long_mode" rel="nofollow" title="" class="ext-link">ロングモード</a>に移行する前に、カーネルはCPUをプロテクトモードに切り替える必要があります。</p><p>では、この<a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89" rel="nofollow" title="" class="ext-link">プロテクトモード</a>とは何でしょう？　プロテクトモードが最初にx86アーキテクチャに追加されたのは1982年のことです。 このモードは<a href="https://ja.wikipedia.org/wiki/Intel_80286" rel="nofollow" title="" class="ext-link">80286</a>プロセッサが出てから、Intel 64とロングモードが登場するまでの間、主要なモードでした。</p><p><a href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89" rel="nofollow" title="" class="ext-link">リアルモード</a>から移行した主な理由は、RAMへのアクセスが非常に限られていたからです。前回のパートでもお話ししましたが、リアルモードで利用可能なRAMはせいぜい2<sup>20</sup>バイトか1メガバイトで、中には640キロバイトしかないものもあります。</p><p>プロテクトモードになって、さまざまな点が変わりましたが、その中で最も大きな変更点はメモリの管理です。アドレスバスが20ビットから32ビットに変更されたことで、リアルモードでは1メガバイトのメモリにしかアクセスできなかったのが、4メガバイトのメモリにアクセスが可能になりました。さらにプロテクトモードは、<a href="https://ja.wikipedia.org/wiki/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E6%96%B9%E5%BC%8F" rel="nofollow" title="" class="ext-link">ページング方式</a>にも対応しています。こちらの内容は、次のセクションで紹介します。</p><p>プロテクトモードにおけるメモリ管理は、ほぼ独立した次の2つの方式に分かれます。</p><p>ページング方式については次のセクションで扱うので、ここではセグメント方式についてのみ紹介しましょう。</p><p>前回のパートで、リアルモードではアドレスが以下の2つの部分から構成されていることを学びました。</p><p>そして、これらの2つの情報が分かれば、次のように物理アドレスを取得できます。</p><p>プロテクトモードになって、メモリのセグメンテーションが一新され、64キロバイトの固定サイズのセグメントがなくなりました。その代わりに、各セグメントのサイズと位置は、<em>セグメントディスクリプタ</em>と呼ばれる関連データの構造体で表現されます。このセグメントディスクリプタが格納されているのが、<code>Global Descriptor Table</code>（GDT）というデータ構造体です。<br>
GDTはメモリ上にある構造体で、これはメモリ内の決まった場所にあるわけではなく、専用の<code>GDTR</code>レジスタにアドレスが格納されています。LinuxカーネルのコードでGDTを読み込む方法については、後ほど説明します。GDTは以下のような操作で、メモリに読み込まれます。</p><p>このlgdt命令で、<code>GDTR</code>レジスタにベースアドレスとグローバルディスクリプタテーブルの制限（サイズ）を読み込みます。<code>GDTR</code>は48ビットのレジスタで、以下の2つの部分から構成されています。</p><p>先ほど説明したように、GDTにはメモリセグメントを表す<code>segment descriptors</code>が含まれています。各ディスクリプタのサイズは64ビットで、ディスクリプタの一般的な配置は次のようになっています。</p><p>リアルモードの後でこれを見ると、少しゾッとするかもしれませんが、簡単なのでご心配なく。例えば、LIMIT 15:0というのは、ディスクリプタのビット0 – 15に制限の値が含まれていることを意味します。そして残りはLIMIT 19:16の中にあります。よってリミットのサイズは0 – 19なので、20ビットです。では、もう少し詳しく見てみましょう。</p><p>1. リミット[20ビット]は0 – 15と16 – 19のビットにあります。これは<code>length_of_segment – 1</code>を定義し、<code>G</code>（粒度）ビットに依存します。</p><p>2. ベース[32ビット]は（0 – 15、32 – 39、56 – 63ビット）にあり、これはセグメントの開始位置の物理アドレスを定義します。</p><p>3. タイプ/属性（40 – 47ビット）はセグメントのタイプとセグメントに対する種々のアクセスについて定義します。</p><p>このセグメントがコードとデータ、どちらのセグメントなのかを判別するには、以下の図で0と表記されたEx(ビット43)属性を確認します。これが0ならセグメントはデータセグメントで、1ならコードセグメントになります。</p><p>セグメントは以下のいずれかのタイプになります。</p><p>ご覧のように最初のビット（ビット43）は、データセグメントの場合は<code>0</code>で、コードセグメントの場合は<code>1</code>です。続く3つのビット(40, 41,42)は<code>EWA</code>（エキスパンド、書き込み可能、アクセス可能）またはCRA（コンフォーミング、読み取り可能、アクセス可能）のどちらかになります。</p><p>1. DPL2ビットはビット45 – 46にあります。これはセグメントの特権レベルを定義し、値は0-3で、0が最も権限があります。</p><p>2. Pフラグ（ビット47）は、セグメントがメモリ内にあるか否かを示します。Pが0なら、セグメントは<em>無効</em>であることを意味し、プロセッサはこのセグメントの読み取りを拒否します。</p><p>3. AVLフラグ（ビット52）は利用可能な予約ビットで、Linuxにおいては無視されます。</p><p>4. Lフラグ（ビット53）は、コードセグメントがネイティブ64ビットコードを含んでいるかを示します。1ならコードセグメントは64ビットモードで実行されます。</p><p>5. D/Bフラグ（ビット54）は、デフォルト/ビッグフラグで、例えば16/32ビットのようなオペランドのサイズを表します。フラグがセットされていれば32ビット、そうでなければ16ビットです。</p><p>セグメントレジスタには、リアルモードとのようにセグメントのベースアドレスが含まれていません。その代わりに<code>Segment Selector</code>という特殊な構造があり、各セグメントディスクリプタは関連するセグメントセレクタを含んでいます。<code>Segment Selector</code>は16ビットの構造体です。</p><p>各々のセグメントレジスタは見える部分と隠れた部分を持っています。</p><p>以下は、プロテクトモードにおいて物理アドレスを取得するのに要する手順です。</p><p>図で表すとこうなります。</p><p><img src="https://camo.githubusercontent.com/a47fe9d65396ec1a906257d7f7589ef15ea21465/687474703a2f2f6f6936322e74696e797069632e636f6d2f32796f333639762e6a7067" alt="linear address" data-canonical-src="http://oi62.tinypic.com/2yo369v.jpg" style="max-width:100%;"><br>
リアルモードからプロテクトモードへ移行するためのアルゴリズムは、</p><p>次の章でlinuxカーネルの完全なプロテクトモードへの移行をします。ただ、プロテクトモードへ移る前にもう少し準備が必要です。</p><p><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/main.c</a>を見てみましょう。キーボード初期化、ヒープ初期化などを実行するルーティンがあるのが目につきます。よく見てみましょう。</p><p>“main.c”の<code>main</code>ルーティンから始めましょう。<code>main</code>の中で最初に呼び出される関数は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c#L30" rel="nofollow" title="" class="ext-link"><code>copy_boot_params(void)</code></a>です。これは、カーネル設定ヘッダを、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/bootparam.h#L113" rel="nofollow" title="" class="ext-link">arch/x86/include/uapi/asm/bootparam.h</a>にて定義された<code>boot_params</code>構造体のフィールドにコピーします。</p><p><code>boot_params</code>構造体は、<code>struct setup_header hdr</code>フィールドを内包しています。この構造体は<a href="https://www.kernel.org/doc/Documentation/x86/boot.txt" rel="nofollow" title="" class="ext-link">linuxブートプロトコル</a>で定義されているのと同じフィールドを内包し、ブートローダによって、カーネルのコンパイル/ビルド時に書き込まれます。<code>copy_boot_params</code>は2つのことを実行します。</p><p>1. <code>hdr</code>を<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L281" rel="nofollow" title="" class="ext-link">header.S</a>から<code>setup_header</code>フィールド内の<code>boot_params</code>構造体へコピーする。</p><p>2. カーネルが古いコマンドラインプロトコルでロードされた場合に、ポインタをカーネルのコマンドラインに更新する。</p><p><code>hdr</code>を、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/copy.S" rel="nofollow" title="" class="ext-link">copy.S</a>ソースファイルで定義されている<code>memcpy</code>関数と一緒にコピーしていることに注目してください。中身を見てみましょう。</p><p>そう、Cコードに移ってきたばかりですが、またアセンブリに逆戻りです。:) まず初めに、<code>memcpy</code>とここで定義されている他のルーティンが2つのマクロで挟まれており、<code>GLOBAL</code>で始まって<code>ENDPROC</code>で終わっているのに気づきます。<code>GLOBAL</code>は、<code>globl</code>のディレクティブとそのためのラベルを定義する<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/linkage.h" rel="nofollow" title="" class="ext-link">arch/x86/include/asm/linkage.h</a>に記述されています。<code>ENDPROC</code>は、<code>name</code>シンボルを関数名としてマークアップし<code>name</code>シンボルのサイズで終わる<a href="https://github.com/torvalds/linux/blob/master/include/linux/linkage.h" rel="nofollow" title="" class="ext-link">include/linux/linkage.h</a>に記述されています。</p><p><code>memcpy</code>の実装は簡単です。まず、<code>si</code>と<code>di</code>レジスタから値をスタックにプッシュします。それらの値は<code>memcpy</code>の実行中に変化するので、スタックにプッシュすることで値を保存するのです。<code>memcpy</code>（に加え、copy.S内の他の関数）は<code>fastcall</code>呼び出し規約を使うため、入力パラメータを<code>ax</code>、<code>dx</code>そして<code>cx</code>レジスタから取得します。<code>memcpy</code>の呼び出しは次のように表示されます。</p><p>ですから、<br>
* <code>ax</code>は、<code>boot_params.hdr</code>のアドレスをバイトで内包する。<br>
* <code>dx</code>は、<code>hdr</code>のアドレスをバイトで内包する。<br>
* <code>cx</code>は、<code>hdr</code>のサイズをバイトで内包する。</p><p><code>memcpy</code>は<code>boot_params.hdr</code>のアドレスを<code>si</code>に入れ、スタック上にそのサイズを保存します。この後、2サイズ右にシフト（あるいは4で除算）し、<code>si</code>から<code>di</code>に4バイトでコピーします。この後、<code>hdr</code>のサイズを再びリストアし、4バイトで配列して残りのバイト（あれば）を<code>si</code>から<code>di</code>にバイトごとにコピーします。最後に<code>si</code>と<code>di</code>の値をスタックからリストアすると、コピーは終了です。</p><p><code>hdr</code>を<code>boot_params.hdr</code>にコピーしたら、次のステップは、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/early_serial_console.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/early_serial_console.c</a>に定義されている<code>console_init</code>関数を呼び出し、コンソールの初期化をすることです。</p><p>その関数は、<code>earlyprintk</code>オプションをコマンドラインから検索し、オプションが特定できたら、ポートアドレスとシリアルポートのボーレートを解析し、シリアルポートを初期化します。<code>earlyprintk</code>コマンドラインオプションの値は、次のうちのいずれかです。</p><p>シリアルポート初期化の後、1番目のアウトプットが得られます。</p><p><code>puts</code>は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/tty.c" rel="nofollow" title="" class="ext-link">tty.c</a>内に定義されています。見てのとおり、それは<code>putchar</code>関数を呼び出すことで、1文字1文字をループで表示します。<code>putchar</code>の実装を見てみましょう。</p><p><code>__attribute__((section(".inittext")))</code>は、このコードが<code>.inittext</code>セクションに入ることを意味しています。このセクションは、リンカファイル<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/setup.ld#L19" rel="nofollow" title="" class="ext-link">setup.ld</a>内にあります。</p><p>まず最初に、<code>putchar</code>は<code>\n</code>シンボルをチェックし、それが見つかれば<code>\r</code>を先に表示します。その後、<code>0x10</code>の割り込み呼び出しでBIOSを呼び出し、VGAスクリーンに文字を表示させます。</p><p>ここで、<code>initregs</code>は<code>biosregs</code>を引数にとり、まず<code>memset</code>関数を使って<code>biosregs</code>にゼロを入力し、それからレジスタ値を入力します。</p><p><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/copy.S#L36" rel="nofollow" title="" class="ext-link">memset</a>の実装を見てみましょう。</p><p>上から読み取れるように、<code>memcpy</code>関数のように、<code>fastcall</code>呼び出し規約を使っています。つまり、関数は<code>ax</code>、<code>dx</code>そして<code>cx</code>レジスタからパラメータを取得しているということです。</p><p>概して<code>memset</code>は、<code>memcpy</code>の実装に似ています。<code>di</code>レジスタの値をスタックに保存し、<code>ax</code>値を<code>biosregs</code>構造体のアドレスである<code>di</code>に置きます。次に<code>movzbl</code>インストラクションが、<code>dl</code>値を<code>eax</code>レジスタの低2バイトにコピーします。<code>eax</code>の高2バイトの残りにはゼロが入力されます。</p><p>次の命令は<code>eax</code>に<code>0x01010101</code>をかけます。この行程が必要なのは、<code>memset</code>が同時に4バイトをコピーするためです。例えば、<code>memset</code>を使って構造体のフィールドすべてを<code>0x7</code>で埋めたいとします。この場合、<code>eax</code>は<code>0x00000007</code>値を含みます。そこで<code>eax</code>に<code>0x01010101</code>をかけると、<code>0x07070707</code>を取得してこれら4バイトを構造体にコピーできるのです。<code>memset</code>は、<code>eax</code>を<code>es:di</code>にコピーする際、<code>rep; stosl</code>インストラクションを使います。</p><p><code>memset</code>関数がその他に行うことは、<code>memcpy</code>とほぼ同じです。</p><p><code>biosregs</code>構造体が<code>memset</code>により値を満たされると、<code>bios_putchar</code>は、文字を表示する<a href="http://www.ctyme.com/intr/rb-0106.htm" rel="nofollow" title="" class="ext-link">0x10</a>割り込みを呼び出します。次に、シリアルポートが初期化されたか否かをチェックし、そこに<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/tty.c#L30" rel="nofollow" title="" class="ext-link">serial_putchar</a>と、もし設定がされていればinb/outbインストラクションで文字を書き出します。</p><p>スタックとbssセクションが<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S" rel="nofollow" title="" class="ext-link">header.S</a>（前の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-1.md" rel="nofollow" title="" class="ext-link">パート</a>参照）に準備できたら、カーネルは<code>init_heap</code>関数を使って<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c#L116" rel="nofollow" title="" class="ext-link">ヒープ</a>を初期化する必要があります。</p><p>まず<code>init_heap</code>はカーネル設定ヘッダにある<code>loadflags</code>から<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/bootparam.h#L21" rel="nofollow" title="" class="ext-link"><code>CAN_USE_HEAP</code></a> フラグをチェックし、フラグが下記のように設定されている場合はスタックの終わりを計算します。</p><p>つまり、<code>stack_end = esp - STACK_SIZE</code>という計算を行います。</p><p>そのため<code>heap_end</code>計算は以下のようになります。</p><p>これは、<code>heap_end_ptr</code>または、<code>_end + 512(0x200h)</code>を意味します。最後に<code>heap_end</code>は<code>stack_end</code>より大きいかどうかがチェックされます。それが正の場合は、それらをイコールにするため、<code>stack_end</code>が<code>heap_end</code>に適用されます。</p><p>さて、ヒープは初期化され、<code>GET_HEAP</code>メソッドを用いてこれを使うことができるようになりました。では、実際の使われ方、使い方、実装のされ方を次に見ていきます。</p><p>次のステップは当然、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/cpu.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/cpu.c</a>に書かれた<code>validate_cpu</code>によるCPU検証です。</p><p>これは<code>check_cpu</code>関数を呼び出し、CPUレベルと必須のCPUレベルを渡してカーネルが正しいCPUレベルでローンチされていることをチェックします。</p><p><code>check_cpu</code>はCPUのフラグ、x86_64（64ビット）CPUの場合は<a href="https://en.wikipedia.org/wiki/Long_mode" rel="nofollow" title="" class="ext-link">ロングモード</a>の配置をチェックします。またプロセッサのベンダーを確認し、SSE+SSE2がない場合にそれらをAMDのためにオフにするような特定のベンダーに備えます。</p><p>次のステップは<code>detect_memory</code>関数によるメモリ検知です。<code>detect_memory</code>は基本的に使用可能なRAMのマップをCPUに提供します。メモリ検知には<code>0xe820</code>、<code>0xe801</code>そして<code>0x88</code>などのいくつかのプログラミングインターフェースを使います。ここでは<strong>0xE820</strong>の実装のみを見ていきます。</p><p><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/memory.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/memory.c</a>ソースファイルから<code>detect_memory_e820</code>の実装を見ましょう。まず先述のように<code>detect_memory_e820</code>関数は<code>biosregs</code>構造体を初期化し、レジスタに<code>0xe820</code>呼び出しのための特別な値を入力します。</p><p>次に、メモリに関するデータを収集するループです。<code>0x15</code>BIOS割り込みの呼び出しで始まり、アドレス割り当てテーブルから1行を書き出します。次の行を取得するには、この割り込みを再度呼び出す必要があります（ループ内で行います）。次の呼び出しの前に<code>ebx</code>は前に返された値を持たねばなりません。</p><p>最後に<code>ebx</code>はループ内で反復し、アドレス割り当てテーブルからデータを集め、そのデータを以下のように<code>e820entry</code>配列に書き込みます。<br>
* メモリセグメントの開始<br>
* メモリセグメントのサイズ<br>
* メモリセグメントのタイプ（予約可能か、利用可能かなど）</p><p>この結果は<code>dmesg</code>アウトプット内で見ることができます。以下はその例です。</p><p>次のステップは<code>keyboard_init()</code>関数の呼び出しで行うキーボードの初期化です。最初に<code>keyboard_init</code>は、キーボードのステータスを取得するため、<code>initregs</code>関数を使い、<a href="http://www.ctyme.com/intr/rb-1756.htm" rel="nofollow" title="" class="ext-link">0x16</a>割り込みを呼び出して、レジスタを初期化します。</p><p>この後、<a href="http://www.ctyme.com/intr/rb-1757.htm" rel="nofollow" title="" class="ext-link">0x16</a>を再度呼び出しリピート率と遅延時間を設定します。</p><p>次に続くのはいくつかのパラメータのためのクエリです。これらクエリについて詳細は述べませんが、後にまた参照します。簡単にこれらの関数を見てみましょう。</p><p><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/mca.c#L18" rel="nofollow" title="" class="ext-link"><code>query_mca</code></a>ルーティンは、<a href="http://www.ctyme.com/intr/rb-1594.htm" rel="nofollow" title="" class="ext-link">0x15</a>BIOS割り込みを呼び出し、マシンモデルナンバー、サブモデルナンバー、BIOSアップデートレベル、そしてその他のハードウェア仕様属性を取得します。</p><p>これは<code>ah</code>レジスタに<code>0xc0</code>で入力し、<code>0x15</code>BIOS割り込みを呼び出します。割り込みが実行された後、<a href="https://en.wikipedia.org/wiki/Carry_flag" rel="nofollow" title="" class="ext-link">キャリーフラグ</a>をチェックし、1に設定されている場合はBIOSは<strong><a href="https://ja.wikipedia.org/wiki/Micro_Channel_Architecture" rel="nofollow" title="" class="ext-link">MCA</a></strong>をサポートしません。キャリーフラグが0の場合は、<code>ES:BX</code>はシステム情報テーブルへのポインタを内包します。記述は次のとおりです。</p><p>次に、<code>set_fs</code>ルーティンを呼び出し、<code>es</code>レジスタの値をそこに渡します。<code>set_fs</code>の実行は非常にシンプルです。</p><p>この関数はインラインのアセンブリを内包しており、<code>seg</code>パラメータを取得してそれを<code>fs</code>レジスタに置きます。<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/boot.h" rel="nofollow" title="" class="ext-link">boot.h</a>には、その中の値を読む<code>set_gs</code>、<code>fs</code>、<code>gs</code>といった多数の関数があります。</p><p><code>query_mca</code>の最後では、<code>es:bx</code>によってポイントされていたテーブルを<code>boot_params.sys_desc_table</code>にコピーするだけです。</p><p>次のステップは、<code>query_ist</code>関数を呼び出し、<a href="https://ja.wikipedia.org/wiki/Intel_SpeedStep_%E3%83%86%E3%82%AF%E3%83%8E%E3%83%AD%E3%82%B8" rel="nofollow" title="" class="ext-link">Intel SpeedStepテクノロジ</a>の情報を取得することです。まずCPUレベルをチェックし、それが正しければ<code>0x15</code>を呼び出して情報を取得し、その結果を<code>boot_params</code>に保存します。</p><p>下記の<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/apm.c#L21" rel="nofollow" title="" class="ext-link">query_apm_bios</a>関数は<a href="https://ja.wikipedia.org/wiki/Advanced_Power_Management" rel="nofollow" title="" class="ext-link">Advanced Power Management</a>情報をBIOSから取得します。<code>query_apm_bios</code>は<code>0x15</code>のBIOS割り込みも呼び出しますが、<code>APM</code>のインストールをチェックするため<code>ah</code>=<code>0x53</code>を使います。<code>0x15</code>実行後、<code>query_apm_bios</code>関数は<code>PM</code>の署名（<code>0x504d</code>であること）、キャリーフラグ（<code>APM</code>がサポートしている場合は0）と<code>cx</code>レジスタ（0x02の場合、プロテクトモードインターフェースがサポートされていること）をチェックします。</p><p>次に再度<code>0x15</code>を呼び出しますが、<code>APM</code>インターフェースとの接続を切り、32ビットプロテクトモードインターフェースに接続するため、<code>ax=0x5304</code>を使います。最後にBIOSから得た値を<code>boot_params.apm_bios_info</code>に入力します。</p><p><code>query_apm_bios</code>は、<code>CONFIG_APM</code>か<code>CONFIG_APM_MODULE</code>が設定ファイルにセットされている場合のみ実行されることに注意してください。</p><p>最後の<code>query_edd</code>関数は、<code>Enhanced Disk Drive</code>情報をBIOSに問い合わせます。“`query_edd“の実装を見てみましょう。</p><p>まず<a href="https://github.com/torvalds/linux/blob/master/Documentation/kernel-parameters.txt#L1023" rel="nofollow" title="" class="ext-link">EDD</a>オプションをカーネルコマンドラインから読み取り、<code>off</code>に設定されている場合は<code>query_edd</code>の値をそのまま返します。EDDが有効になっている場合は、<code>query_edd</code>はBIOSサポートのハードディスクに行き、次のようなループでEDD情報を問い合わせます。</p><p><code>0x80</code>があるのは最初のハードドライブで<code>EDD_MBR_SIG_MAX</code>マクロの値は16です。これはデータを<a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/edd.h#L172" rel="nofollow" title="" class="ext-link"><code>edd_info</code></a>構造体の配列に集めます。<code>get_edd_info</code>はEDDが<code>0x41</code>として<code>ah</code>を使った<code>0x13</code>割り込みを呼び出すことで得られていることをチェックし、それが正の場合はさらに<code>get_edd_info</code>が再び<code>0x13</code>割り込みを呼び出します。しかし、<code>0x48</code>の<code>ah</code>と<code>si</code>はEDD情報がストアされるバッファのアドレスを持っています。</p><p>これでLinuxカーネルインターナルに関する記事のパート2は終わりです。次のパートではビデオモード設定とプロテクトモード移行の前に必要な残りの準備、そしてそのまま移行について見ていきましょう。</p><p>質問や助言があればコメント送信または、<a href="https://twitter.com/0xAX" rel="nofollow" title="" class="ext-link">Twitter</a>でのメッセージをお願いします。</p><p><strong>ご注意：英語は私の第一言語ではないことをご承知おきください。誤りを見つけた方は<a href="https://github.com/0xAX/linux-insides" rel="nofollow" title="" class="ext-link">linux-internals</a>に、プルリクエストを送ってください。</strong></p>
