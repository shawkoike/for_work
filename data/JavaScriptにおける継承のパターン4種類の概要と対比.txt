<p><a href="https://medium.com/@PitaJ/javascript-inheritance-patterns-179d8f6c143c" rel="nofollow" title="" class="ext-link">JavaScript inheritance patterns</a> （2015-07-29） by <a href="https://twitter.com/P1taJ" rel="nofollow" title="" class="ext-link">Peter Jaszkowiak</a><br>
プログラミングやその他いろんなことを楽しむイチ学生。</p><p><img class="graf-image" data-image-id="1*pWfJGrCbLcK6cy5TDT4DiA.jpeg" data-width="2432" data-height="1448" data-action="zoom" data-action-value="1*pWfJGrCbLcK6cy5TDT4DiA.jpeg" src="https://cdn-images-2.medium.com/max/1512/1*pWfJGrCbLcK6cy5TDT4DiA.jpeg"><br>
JavaScriptはとても強力な言語です。強力がゆえ、実はプロトタイプをデザインしたり、オブジェクトのインスタンスを生成したりするのに何種類もやり方があります。それぞれの方法には長所も短所もあります。そこでJavaScript初心者の皆さんのために私がそのあたりを整理して説明したいと思います。今回の投稿は、以前私が書いた<a href="https://medium.com/@PitaJ/stop-classifying-javascript-4cc823dfbedf" rel="nofollow" title="" class="ext-link">「JavaScriptを分類するな」</a>の続編です。前回の投稿でたくさんのコメントをいただき、コードの例を出してほしいをいう反応をいただいたので、今回はそれらにお応えします。</p><p>つまり、JavaScriptでは、オブジェクトは別のオブジェクトを継承することができます。<code>{ }</code>波括弧を使って生成されるJavaScriptの基本的なオブジェクトは、唯一のプロトタイプとして<code>Object.prototype</code>をプロトタイプに持ちます。<code>Object.prototype</code>はそれ自身もオブジェクトであり、<code>Object.prototype</code>のメンバ全てが、全てのオブジェクトからアクセスが可能です。</p><p><code> [ ] </code>角括弧を使って生成された、基本的な配列は、<code>Object.prototype</code>や<code>Array.prototype</code>などの数種類のプロトタイプを持ちます。つまり、<code>Object.prototype</code>と<code>Array.prototype</code>の全てのメンバは、配列のメンバ同様にアクセス可能なのです。<code>.valueOf</code>や<code>toString</code>のように、重複するメンバは一番近いプロトタイプによってオーバーライドされます。今回の場合は<code>Array.prototype</code>です。</p><p>JavaScriptは、コンストラクタ関数という特殊な関数を持っています。これは他の言語のコンストラクタと似た働きをします。コンストラクタは強制的に<code>new</code>キーワードをつけて呼び出され、コンストラクタ関数によって生成されたオブジェクトにthis キーワードをbindします。典型的なコンストラクタは以下です。</p><p>このコンストラクタは、別の言語のインスタンス化のやり方に似ています。</p><p><code>bark</code>と<code>print</code>は全てのDogに適用されるプロトタイプのメソッドです。<code>name</code>と<code>breed</code>のプロパティはコンストラクタによって設定された自身のプロパティです。通常は、全てのメソッドがプロトタイプ内に設定され、全てのプロパティはコンストラクタによって設定されます。</p><p><code>class</code>は、初期のころからずっと、将来的に使用されるJavaScriptの予約済みキーワードという位置づけでしたが、今では実際に使われるようになりました。JavaScriptにおけるclassの定義は、他の言語での定義と大変よく似ています。</p><p>このシンタックスは多くの人が好んで使います。理由は、このシンタックスがコンストラクタ、スタティック、プロトタイプメソッド宣言を、1つの優れたブロックの中に兼ね備えているからです。使い方はコンストラクタメソッドと全く同じです。</p><p>このメソッドでは、<code>class</code>シンタックスの後に、プロトタイプ継承を実際に表示することができます。また、<code>new</code>キーワードを省くことが可能です。</p><p>このシンタックスは大変優れていて、プロトタイプがとても明示的に定義されます。どちらがプロトタイプのメンバで、どちらがオブジェクトのメンバかがはっきりと分かります。また、<code>Object.create</code>の優れている点は、ある特定のプロトタイプからオブジェクトを生成できるところです。どちらの場合も、<code>.isPrototypeOf</code>によるチェックは可能です。使い方は異なりますが、大きな違いではありません。</p><p>これはメソッド3をわずかに変えたメソッドです。このメソッドでは、ファクトリはクラス、対クラスはファクトリメソッドを含むオブジェクトとなっています。コンストラクタの例（メソッド1）に似ていますが、代わりにファクトリと<code>Object.create</code>を使います。</p><p>このメソッドの優れている点は、使い方はメソッド1と似ているのに、<code>new</code>キーワードを要求せず、<code>instanceof.</code>を使うところです。<code>new</code>を用いないで、メソッド1と同じやり方をすれば使えます。</p><p>メソッド4ではなくメソッド1を使う理由はほとんどありません。メソッド1では,<br>
コード内で<code>new</code>を使うか、コンストラクタで以下のようにチェックしなければいけません。</p><p>この場合も、ファクトリ内で<code>Object.create</code>を使うだけでいいかもしれません。また、<code>this</code>がめちゃくちゃになってしまうので、コンストラクタ関数上で<code>Function#call</code>や<code>Function#apply</code>を使うこともできません。上記のチェックをすれば、この問題が是正されますが、可変長の引数を用いたい場合は、ファクトリを使わなければいけません。</p><p>コンストラクタと<code>new</code>に関し、上記で適用したのと同じ理由がこの比較にも適用されます。<code>instanceof</code>チェックは、<code>class</code>シンタックスを<code>new</code>なしで、あるいは<code>Function#apply</code>と<code>Function#call</code>を用いて使う場合に不可欠です。</p><p>プログラマは明瞭なコードを追求すべきです。メソッド3の明示的なシンタックスは、非常にはっきりと何が行われているのかを表しています。またそれは容易な複数継承と連結継承を可能にします。<code>new</code>キーワードの使用は、<code>apply</code>や<code>call</code>と適合せず、開放/閉鎖原則を破ることになるので、避けましょう。<code>class</code>キーワードは、プロトタイプを使うJavaScriptの継承の性質を、古典的なシステムに見せかけて隠しています。</p><p><code>Object.create</code>は、bindされた<code>this</code>変数と<code>new</code>よりもさらに直感的で明確です。また、プロトタイプはファクトリそのもののスコープ外にあるオブジェクトの中に格納され得るので、修正と改善がより簡単です。ちょうどES6クラスのように<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="nofollow" title="" class="ext-link">メソッドと定義</a>シンタックスを使うこともできます。</p><p>不必要な、場合によっては破壊的な何かを追加し、言語の本来の性質に逆らうのは間違った動きです。<br>
あなたが<code>class</code>の利用を選ぶなら、私は自分がそのコードのメンテナンスに携わらなくて済むように願います。私の考えでは、開発者はコンストラクタ、<code>class</code>、<code>new</code>の利用を避け、より密接に言語の構造に沿った継承メソッドを使うべきです。</p><p><code>Object.assign(a, b)</code>は、オブジェクト<code>b</code>の全てのenumerableなプロパティをオブジェクト<code>a</code>上にコピーし、オブジェクト<code>a</code>を返します。<br>
<code>Object.create(proto) </code>は、<code>proto</code>をプロトタイプに持つ新規オブジェクトを生成します。<br>
<code>Object.setPrototypeOf(obj, proto) </code>は<code>obj</code>の内部<code>[[Prototype]]</code>プロパティを、<code>proto</code>に設定します。</p>
