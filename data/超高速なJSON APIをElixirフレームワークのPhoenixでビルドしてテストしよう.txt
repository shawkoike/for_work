<p><a href="https://robots.thoughtbot.com/testing-a-phoenix-elixir-json-api" rel="nofollow" title="" class="ext-link">Build and test a blazing fast JSON API with Phoenix, an Elixir framework</a> （2015-03-20） by <a href="https://twitter.com/paulcsmith" rel="nofollow" title="" class="ext-link">Paul Smith</a></p><p>連絡先リストの役割を果たすJSON APIをビルドしてみましょう。ElixirとPhoenixを使って書きます。<a href="http://www.phoenixframework.org/" rel="nofollow" title="" class="ext-link">Phoenix</a>はElixirベースのフレームワークで、記述の高速化と、低遅延のWebアプリケーションをできる限り楽しく作成する目的で作られています。ElixirやPhoenixのインストール手順についてはここでは触れません。まず初めに<a href="http://www.phoenixframework.org/v0.10.0/docs/getting-started" rel="nofollow" title="" class="ext-link">Phoenixのガイド</a>を読んでください。</p><p>Erlanｇは、ポンコツの板金にくるまれたフェラーリのようなものです。ものすごいパワーを持っていますが、見た目が悪いと感じる人が多いのです。WhatsAppはこれを使って膨大な数の接続を処理していますが、見慣れないシンタックスとツールの不足のせいで多くの人が苦労しています。<a href="http://elixir-lang.org/" rel="nofollow" title="" class="ext-link">Elixir</a>はそこを改善したものです。Erlang上に構築されていますが、美しくかつ楽しめるシンタックスを備え、<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" rel="nofollow" title="" class="ext-link">mix</a>などのツールが、効率よくビルド、テスト、アプリケーションとの連携を促進してくれます。</p><p>Phoenixでは、Elixir上で楽しみながら非常に低遅延のWebアプリケーションを作成し構築することができます。超高速のアプリケーションと楽しめる開発環境は、もはや相互矛盾するものではありません。ElixirとPhoenixはその両方を与えてくれます。Phoenixのレスポンスタイムはミリ秒ではなくマイクロ秒で計測されることも少なくありません。</p><p>さて、このフレームワークを使ってビルドしてみたい理由をお話ししました。今度は実際にビルドしてみましょう。</p><p>PhoenixのWebサイト上の<a href="http://www.phoenixframework.org/v0.10.0/docs" rel="nofollow" title="" class="ext-link">はじめに</a>を参照して、<code>HelloPhoenix</code>という名前の新しいアプリを作成してみましょう。この演習にはPhoenix 0.10.0を使います。</p><p>Phoenixのアプリケーションが設定できたら、まずはテストを書いてみましょう。次のファイルを作成します。<br>
<code>test/controllers/contact_controller_test.exs</code></p><p>まず、<code>setup</code>の関数を書きます。テストを始める時に常にデータベースが空であるということを保証するための処理の中で、Ecto callsをラップします。</p><p>テスト自体は、特別なものではありません。<code>use Plug.Test</code>によって、接続を生成する<code>conn/2</code>関数にアクセスできます。このテストでは、新規の連絡先を1件挿入し、1つのリストにラップしてエンコードします。次に、新たな接続を生成し、リクエストを送ります。レスポンスの成功と、ボディがJSONにエンコードされた連絡先リストを含むことをアサートしましょう。</p><p><code>mix test</code>を実行すると、<code>HelloPhoenix.Contact.<strong>struct</strong>/0 is undefined, cannot expand struct HelloPhoenix.Contact</code>というエラーが表示されます。これは、まだモデルが生成されていないためです。<a href="https://github.com/elixir-lang/ecto" rel="nofollow" title="" class="ext-link">Ecto</a> を用いて、Postgresデータベースに接続しましょう。</p><p>Ectoは、データベースのデータ保存と取り出しにリポジトリを使います。Phoenixにはあらかじめリポジトリがインストールされ、初期設定がなされています。<code>config/dev.exs</code>と<code>config/test.exs</code>の実行で、Postgresのユーザとパスワードが正しいことを確認してください。</p><p><code>mix -h | grep ecto</code>の実行によって、Ectoから新規に取得した<code>mix</code>のタスクを見てみましょう。</p><p>複数のタスクが使えることが分かったら、開発環境とテスト用データベースを構築しましょう。その後、最初のモデルを追加します。</p><p><code>web/models/contact.ex</code>内の<code>Contact</code>にスキーマを追加しましょう。</p><p>次に、<code>mix ecto.gen.migration create_contacts</code>でマイグレーションを作ります。新規生成したマイグレーションに、次のように記述します。</p><p>Ectoマイグレーションに初期設定されているコラムは、:stringです。その他のオプションは、<a href="http://hexdocs.pm/ecto/Ecto.Migration.html" rel="nofollow" title="" class="ext-link">Ecto.Migration docs</a>を参照してください。</p><p>では、<code>mix ecto.migrate</code>を実行して新規テーブルを生成し、もう一度<code>MIX_ENV=test mix ecto.migrate</code>でテストします。</p><p><code>/api/contacts</code>といったルートを用いて、APIのエンドポイントにつなぎましょう。</p><p>Railsを知っている人なら、<code>/api/contacts.json</code>が404 not foundを返すことに気づくでしょう。ここでは、適切なリクエストヘッダを設定する必要があります。ひとまず、<code>/api/contacts?format=json</code>で実行できますが、おすすめしません。パフォーマンスの観点からパラメータの文末指定は避けたいこと、またHTTPヘッダが既にその機能を備えていることがその理由です。</p><p>ただ、<code>mix test</code>を実行した後も、<code>ContactController</code>が必要です。</p><p><code>web/controllers/contact_controller.ex</code>でコントローラを作成しましょう。</p><p>まず、<code>Repo.all(Contact)</code>の全てのコンタクトを用意してください。次に<code>Phoenix.Controller.render/2</code>でJSONをレンダリングします。Use <code>HelloPhoenix.Web, :controller</code>を呼び出せば、関数は自動的に取り込まれます。<code>Web/web.ex</code>をチェックして、他に何が呼び出されているかを確認してみましょう。</p><p>ここで<code>Mix test</code>を実行しても、まだパスしません。</p><p>JSONをレンダリングするには、viewが必要なのです。</p><p>viewはJSONの出力方法を処理します。今現在これは非常にシンプルな操作ですが、将来的には例えば、ユーザのパーミッションに基づいて、送信するものを変更することもできます。</p><p>では<code>Web/views/contact_view.ex</code>にファイルを作成しましょう。</p><p>これはパターンマッチングを使用して設定し、<code>contacts</code>を返します。PhoenixはJSONへのコンタクトの配列を自動的にエンコードします。このviewの関数を使ってJSONの表示方法をカスタマイズすることができますが、これについては、また別の記事で説明します。</p><p>ここで<code>mix test</code>を実行すれば、全てのテストをパスするでしょう。</p><p><code>web/web.ex</code>内の<code>HelloPhoenix.Web</code>をチェックして、もう少しアプリケーションをクリーンアップしてみましょう。このファイルを開くと、既にコントローラの関数には<code>HelloPhoenix.Repo</code>のエイリアスがあることが分かります。</p><p>つまり、コントローラで<code>HelloPhoenix.Repo</code>のエイリアスを取り除けるということです。</p><p><a href="http://elixir-lang.org/docs/stable/ex_unit/ExUnit.CaseTemplate.html" rel="nofollow" title="" class="ext-link">ExUnit.CaseTemplate</a>を使って、テストを少しクリーンアップします。<code>test/test_helper.exs</code>では次のようになります。</p><p><code>using</code>にコードを追加すると、これらの関数とエイリアスは全てのテストで利用可能になります。なので、<code>send_request/1</code>とテストの他のエイリアスを取り除き、<code>use HelloPhoenix.Case</code>で置き換えることができます。</p><p>PhoenixでJSON APIを作成して、テストする方法を見てきました。また、ファイルをクリーンアップして、将来的に<code>HelloPhoenix.Web</code>と<code>EXUnit.CaseTemplate</code>を使うことで、他のコントローラとテストでモジュールの利用を簡単にする方法を説明しました。これで、このアプリケーションを<a href="https://github.com/HashNuke/heroku-buildpack-elixir" rel="nofollow" title="" class="ext-link">Elixir buildpac</a>でHerokuに展開することができます。</p>
