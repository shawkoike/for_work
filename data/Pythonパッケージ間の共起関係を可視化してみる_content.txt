Visualizing relationships between python packages （2016-07-10） by Robert Kozikowski私は、BigQueryのGitHubデータを使って、GitHubリポジトリにある上位3,500個のPythonパッケージの共起を抽出し、速度ベルレ積分を使ってd3のForceレイアウトを可視化してみました。また、python-igraphにあるアルゴリズムを使ってグラフをクラスタ化し、http://graphistry.com/にアップデートしました。以下のスクリーンショットは、d3の可視化にあるNumPyのクラスタです（画像をクリックするとライブ版をご覧いただけます）。以下は、graphistrynによって抽出されたNumPyのクラスタです（画像をクリックするとライブ版をご覧いただけます）。グラフの特徴：私のアプリケーションは、http://clustering.kozikow.com/?center=numpyでご覧いただくことができます。以下のことが可能です。graphistryのビューで興味深いものについては、次のセクションである特定のクラスタの分析でご紹介します。グラフの可視化は、見た目が恰好いいということを除いては、時に実用的な洞察を得られないこともあります。使用できる実用的な洞察は以下のとおりです。この投稿の編集履歴はgithubで閲覧可能であり、これはorg modeになっています。d3の可視化結果に加え、更にpython-igraphにあるcommunity_infomap().membershipを使ってデータをクラスタ化し、それをgraphistryにアップロードしました。クラスタによる除外機能やフィルタ機能は、とても便利です。当然のことですが、それはNumPyが中心です。面白いことに、統計学とマシンラーニングでは相違が見られます。Webフレームワークは興味深い機能群です。クラスタ化のアルゴリズムの結果を見てみると、”中間サイズ”のクラスタだけに興味を引き付けられます。真っ先に目を引くことが明らかなものを挙げると、osやsysのようなパッケージが多数を占めるクラスタです。クラスタが非常に小さいと、これに興味を引き付けられることはありません。こちらの図は、サイズが5～30のクラスを表示させたものです。以下にその他のクラスタを記載しておきました。今回のコードの大部分は、Phytonに特化したものではありません。最初のステップであるパッケージでテーブルを作成するだけがPhytonに特化したコードです。グラフの見栄えが良くなるように、シミュレーションパラメータでパラメータを調整するのに相当な時間を費やしました。各言語のグラフは、異なる特徴を持っているので、恐らく、他の各言語に対しても同様の適合を行う必要があるのでしょう。この次にはJavaとScalaの分析を行おうと思います。例えば、Pythonの可視化データパッケージを全て一緒にクラスタ化したら面白いのではないでしょうか。直観的に、このようなパッケージは似たようなコンテキストで使用されますが、一緒に使用されることはあまりありません。「グラフはNpmiの同時発生行列Mで表現される」と仮定すると、パッケージxとyにおいては、ベクトルxとyの相関性は高くなりますが、M[x][y]は低くなるでしょう。あるいは、M^2 /. Mにも可能性があるかもしれません。/.は要素ごとの商で、M^2は、グラフ上で”2つのホップ”を大まかに表現しています。隣同士の重みだけでも相関性は高いのですが、直接的なエッジは低くなります。これは、多くの状況で機能しますが、うまく機能しない場合もあります。以下がその例です。従って、django ORMとsqlalchemyは近隣の重み付けが相関されることはありません。私はあまりWeb開発を行わないので、ORMの詳細が間違っている可能性はあります。また、node2vedの実験や、隣接行列の2乗を行う予定です。現在、私は同じファイル内でのインポートだけを見ています。”同じリポジトリ内”の関連性を使って構築した同じグラフを見たり、”同じリポジトリ内”と”同じファイル内”の関連性を体系的に比較してみたりするのも面白いと思います。PyPIダウンロードとGitHub上の使用量を比較しても面白いでしょう。PyPIはBigQueryからもアクセスが可能です。以下のコードを、wide-silo-135723:github_clustering.packages_in_file_pyに保存します。このSQLにより生成されるテーブルは、2つのフィールドを持ちます。つまり、ファイルを示すidと、1つのファイル内にあるパッケージによる繰り返しのフィールドです。繰り返しのフィールドは、配列に似ています。このページに、繰り返しのフィールドのベストな表現を見付けました。このステップのみpython特有のものです。いくつかファイルを無作為に選び、インポートがここまで正しくパースされているか確認してください。少なくとも200回出現するパッケージが3,501個あり、そこで頭打ちとなるようです。フィルタリングされたテーブル、wide-silo-135723:github_clustering.packages_in_file_top_pyを作成します。結果は、「wide-silo-135723:github_clustering.packages_in_file_top_py」に格納されます。では、エッジを生成してテーブル「wide-silo-135723:github_clustering.packages_in_file_edges_py」に保存します。上位10個のエッジは以下のSQLで求められます。エッジの重みの分位は以下のように求めます。最初の実行時には、全てのカウントに基づいてエッジをフィルタリングしました。これは良いアプローチではありませんでした。極端に小さいパッケージ間にある強い関連性よりも、大きなパッケージ2つの間にある弱い関連性の方が、残ってしまう傾向があるためです。wide-silo-135723:github_clustering.packages_in_file_nodes_pyを作成します。テーブルpackages_in_file_edges_top_pyを作成します。googleドキュメントに全ての結果を保存しておきました。Pandasによって、合計16個のエッジが求められました。dfとedges_dfは、同じ長さになるはずです。つまり、11122と11122です。全体のシミュレーションは、安定するまで1分かかります。単純に画像をダウンロードすることは出来ますが、その場合はノードを押すとPyPIを開くといったような、追加の機能はありません。次のコードで、javascriptコンソールからシミュレーション後のすべての座標をダウンロードします。座標xとyをエッジのデータフレームに結合すると、d3に渡すことができます。物理的シミュレーションSimulationは、d3のバージョン4.0で新しく速度ベルレ積分のforce graphを利用しています。Simulationは安定するまで大体1分ほどかかります。このためグラフを表示させる目的の場合は、私は自分のマシン上でシミュレーションを実行した後で、ノードの座標をハードコードしています。シミュレーションのコアコンポーネントは、以下の通りです。シミュレーションを再実行する場合は、以下の手順が必要です。しばらくシミュレーションパラメータを微調整してみました。かなり密度の高いグラフの”中心”では、グラフのエッジ上でクラスタ間が衝突しています。最新のグラフからも分かるように、中心のノードはたまに重複しています。これは、グラフのエッジにおけるノード間の距離が大きいためです。出来る限り衝突パラメータを求めさらに増加させてみましたが、それは得策ではありませんでした。潜在的には、中心に向かって重みは増します。しかしそのため、いくつかの価値ある”クラスタ”が、グラフのエッジから中心の大きな”核”に向かって集中していったのです。複数の大きなクラスタを分離してプロットすることは、この課題を解決するのに役立ちます。興味がありましたら、GitHubのデータを分析した他の記事も読んでみてください。
