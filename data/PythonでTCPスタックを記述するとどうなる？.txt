<p><a href="http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/" rel="nofollow" title="" class="ext-link">What happens if you write a TCP stack in Python?</a>（2014-8-12）by<a href="http://jvns.ca/about/" rel="nofollow" title="" class="ext-link">Julia Evans</a></p><p>Hacker School在籍中、ネットワーキングの理解をより深めたいと思い、小規模なTCPスタックを書いてみようと思い立ちました。個人的には、C言語よりもPythonの方になじみがありましたし、その頃ちょうど、パケット送信を<a href="http://jvns.ca/blog/2013/10/31/day-20-scapy-and-traceroute/" rel="nofollow" title="" class="ext-link">非常に簡単に</a>する<a href="http://www.secdev.org/projects/scapy/" rel="nofollow" title="" class="ext-link">scapy</a>ネットワーキングライブラリも見つけたところでした。</p><p>そんなわけで、<a href="https://github.com/jvns/teeceepee" rel="nofollow" title="" class="ext-link">teeceepee</a>を書き始めました。</p><p>基本的な構想は次のとおりです。</p><p>適切なエラー処理などについてはさほどの注意も払わず、ただただウェブページを取得し、勝利を宣言しようと思っていました(^_^)</p><p>手始めは、GoogleとのTCPハンドシェイクです（以下は必ずしも正しく動作しませんが、原理は示します）。各行にはコメント文を付けました。</p><p>TCPハンドシェイクの実行手順：</p><p>とてもシンプルですよね。実際にコードにしてみると次のようになります。</p><p><b>シーケンス番号？</b></p><p>このシーケンス番号は何なのでしょうか。TCPにおいて重要な点は、一部のパケットが消えた場合にパケットを再送信できるようにすることです。シーケンス番号により、パケットが消えたかどうかを確認することができるようになります。たとえば、Googleが4パケットを送ってきたとしましょう。サイズはそれぞれ110、120、200、そして500バイトです。最初のシーケンス番号を0とすると、パケットの各番号は0、110、230、そして430となります。</p><p>ここで、仮にシーケンス番号が2000で100バイトのパケットが突然送られてきたら、それはパケットが消えたということ意味します。なぜなら、次の番号は930であるべきですからね。</p><p>こちら側でパケットが消えたということをGoogle側はどう把握するのでしょうか？Googleからパケットを受信する度に、こちらはACKを送る必要があります（シーケンス番号230のパケットを受け取ったよ。ありがとう！）。もしGoogleが、このACKを受け取らなかった場合、Googleはパケットを再送信するのです。</p><p>TCPプロトコルは、極度に複雑で、その中にはありとあらゆるレート制限の論理が含まれています。しかし、この投稿では、それらについて詳しく触れるようなことはしませんので、TCPが複雑だということだけを覚えておいていただければ結構です。</p><p>SYNパケットがシーケンス番号にどのように作用するか、などを含め、より詳しい情報を知りたい場合、個人的には<a href="http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/" rel="nofollow" title="" class="ext-link">Understanding TCP sequence numbers</a>が分かりやすくてお勧めです。</p><p>上記のコードを実行すると、問題が発生しました。うまく動作しないのです。</p><p>しかも予想外の挙動です。全く応答を得ることができません。私はWireshark（パケットを監視できるすばらしいツール）を使って、内容を解析してみました。</p><p>おかしいですね。RSTパケットなんて送った覚えはありません。RSTとは「接続停止。終了」の意味です。私のコードにそんな命令はありません。</p><p>その時に脳裏をかすめたのが、自分のコンピュータにはTCPスタックが既に存在している、という事実でした。つまり、どういうことが実際に起こっていたかというと：</p><p>カーネルを回避するには、どうしたらいいでしょうか？このことを<a href="https://github.com/jtakkala" rel="nofollow" title="" class="ext-link">Jari Takkala</a>に相談すると、彼は<a href="http://jvns.ca/blog/2013/10/29/day-18-in-ur-connection/" rel="nofollow" title="" class="ext-link">ARPスプーフィング</a>を提案してくれました。ARPスプーフィングを使えば、異なるIPアドレス（たとえば192.168.0.129のように）があると見せかけることができます。</p><p>これを経て、新たな交信は以下のようになりました。</p><p>今度は無事に動作しました。すばらしい。パケットが送信できるようになり、カーネルの干渉なしに応答を得られるようになったのです。やりましたね。</p><p>このステップはある意味、中断のステップです。ここで、苛立たしい数多くのバグを修正し、Googleがhttp://google.comのHTMLを送ってこないようにします。最終的に、私は全てのバグを修正し、この戦いに勝つことに成功しました！</p><p>やらなければならないことは：</p><p>全てが動作するようになった段階で、またWiresharkを使い、パケット交信の内容を調べてみました。詳しくは以下をご覧ください。</p><p>Googleからのパケット（P）とこちらからのACK（A）のシーケンスは、「P P P A P P P P P A P P A P P P P A」のような感じです。Googleからのパケットは、私のプログラムがそれに応答しACKを送信するよりも、はるかに速く送られてきていますね。面白いことに、Googleのサーバは、こちらがACKを送らないことをネットワークの問題か何かと勘違いしてしまったようです。</p><p>そして最終的には、恐らく通信に問題があると判断され、リセットされてしまいました。</p><p>でも、問題だったのは通信ではありません。私のプログラムの応答速度だったのです。Pythonのプログラムは、ミリ秒単位でパケットに応答するにはあまりに遅すぎました。</p><p>（後記：この認識は、どうやら誤りのようです(^_^)　この時の実際の原因として考えられるものが、こちらで<a href="https://news.ycombinator.com/item?id=8167546" rel="nofollow" title="" class="ext-link">議論</a>されています。）</p><p>実際に業務用のTCPスタックを書く場合、Pythonはお勧めしません（驚きですが）。また、TCPの仕様は本当に複雑ではありますが、仮に実装が完全ではなかったとしても、サーバからの応答は得ることができます。</p><p>私も自分の作ったものが動作したことには満足しています。ARPスプーフィングは非常に厄介でしたが、私はそれを使ってcurlのバージョンを作りました（ただし、25％の確立でしか動作しません）。もし、そのコードを知りたい場合は<a href="https://github.com/jvns/teeceepee/" rel="nofollow" title="" class="ext-link">https://github.com/jvns/teeceepee/</a>でご覧ください。</p><p>今回の試みは、たとえばC言語のような全うな言語でTCPスタックを記述するよりも、はるかに楽しく示唆に富んだものだったと思います(^_^)</p>
