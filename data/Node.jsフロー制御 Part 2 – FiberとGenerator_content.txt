Node.js Flow (part 2) – Fibers and Generators （2015-02-16） by Eirik VullumEirik Vullum
美しいものが好きです。コード。ビジュアル。自然。音楽。このブログには技術と生活についての発見や、とりとめのない事を書いています。この記事は、以前投稿したJavaScript/node.jsでの非同期フローに関する記事の続編です。今回は以下について取り上げます。ここでも私の書いた、Expressフレームワークを使った以下のルート処理（お粗末ですが）を例に見てみましょう。fiberを使用することで、フローは同期的なコードのようになります。非同期関数が値を返すようになるからです。これは、fiberがもたらす”マジック”のような効果の一部です。関数あるいはオブジェクトのメソッドは全て、これを可能にする.syncバージョンを持つことになります。generatorはES6で新しく導入された仕組みで、function *()というキーワードを使ってgenerator関数を作り出すことができます。generator関数は（var iter = genFun();）という記述で呼び出され、iteratorを返します。iteratorには、新しく導入されたyieldというキーワードが出現するまでコードの処理を進めることができる特別な機能があります。また、yield式は実行中のアプリケーションを終了させず、戻り値を待つ間だけ一時的に停止させます。詳細についてはこちらをご覧ください。iteratorの実行関数runの部分thunkifyは基本的にカリー化の2つのステップと同等の処理を行う関数なので、最初の呼び出しで入力データを渡し、2回目でコールバックを渡します。generator関数にyieldを入れてPromiseを使うには、それをサポートするために、iteratorの実行関数runを修正する必要があります。独自のiteratorの実行関数を構築する代わりに、T.J Holowaychuckが作成したcoモジュールを使うことができます。このモジュールは、promiseで実行全体をラップしている間、promise、thunk、配列、オブジェクトなどといったいくつかのオプションをyieldするサポート機能があります。このコードをさらに簡潔にするには、mzと呼ばれるヘルパーライブラリを使うことができます。mzは、Promiseを戻すように全てのネイティブな非同期APIを修正します。このシリーズのPart 1はこちら
