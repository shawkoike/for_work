<p><a href="http://adriansampson.net/blog/opengl.html" rel="nofollow" title="" class="ext-link">Weep for Graphics Programming</a> （2016-05-02） by <a href="http://adriansampson.net/" rel="nofollow" title="" class="ext-link">Adrian Sampson</a></p><p>リアルタイムのグラフィックAPIのメインストリームであるOpenGLとDirect3Dは、プログラマが異なるハードウェアと相互にやりとりする方法としては恐らく最も広く利用されているものでしょう。しかし、これらの行うCPU-GPUインテグレーションの品質は到底受け入れがたいものです。良いパフォーマンスを実現するためには、CPU側のコードとGPU側のシェーダプログラムを緊密に調整する必要がありますが、今のAPIではCPUとGPUは独立して実行するものとして扱われています。そのため、文字列型のインターフェイスや大量のボイラープレート、貧しいGPU固有のプログラミング言語が存在することになってしまうのです。</p><p>この投稿では、必ずしも愉快とは思えないOpenGLアプリの些細な現実をいくつかお見せします。<a href="http://sampsyo.github.io/tinygl/" rel="nofollow" title="" class="ext-link">プログラムリスト</a>や<a href="https://github.com/sampsyo/tinygl/blob/master/tinygl.c" rel="nofollow" title="" class="ext-link">全ソースコード</a>を参照しながらお読みください。</p><p>3Dでオブジェクトの外見を定義する場合、リアルタイムコンピュータグラフィックスでは <em><a href="https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC" rel="nofollow" title="" class="ext-link">シェーダ</a></em>と呼ばれるアプリケーションが使用されます。これは、レンダリングパイプラインの一部としてGPU上で実行させる小さいプログラムです。シェーダにはいくつか<a href="https://en.wikipedia.org/wiki/Shader#Types" rel="nofollow" title="" class="ext-link">種類</a>がありますが、最もよく使用されるのは、オブジェクトのメッシュの頂点の位置を特定する<a href="https://www.opengl.org/wiki/Vertex_Shader" rel="nofollow" title="" class="ext-link">頂点シェーダ</a>とオブジェクトの表面色のピクセルを作成する<a href="https://www.opengl.org/wiki/Fragment_Shader" rel="nofollow" title="" class="ext-link">フラグメントシェーダ</a>です。シェーダを書く時に特別なC言語に似たプログラミング言語が使用されます。OpenGLでは<a href="https://www.opengl.org/documentation/glsl/" rel="nofollow" title="" class="ext-link">GLSL</a>というシェーダ専用言語が使用されます。</p><p>これがうまくいかない原因となるのです。シェーダを設定するために、ホストプログラムが、<em>シェーダのソースコードを含む文字列</em>をグラフィックスカードドライバへと送信します。ドライバは実行時にソースコードをGPUの内部アーキテクチャにコンパイルし、ハードウェアにロードします。</p><p>簡略化したGLSL <a href="http://sampsyo.github.io/tinygl/#section-7" rel="nofollow" title="" class="ext-link">頂点シェーダとフラグメントシェーダのC言語文字列リテラル</a>のペアは次のようになります。</p><p>（起動時にテキストファイルからシェーダコードをロードする方法も一般的です）<a href="https://www.opengl.org/wiki/Type_Qualifier_(GLSL)" rel="nofollow" title="" class="ext-link"><code>in</code>、 <code>out</code>、<code>uniform</code>修飾子</a>は、CPUとGPUの間やGPUの異なる段階にあるレンダリングパイプラインの間の通信チャネルを示します。<code>myPos</code>変数は、頂点シェーダからフラグメントシェーダへとデータを渡すのに役立ちます。頂点シェーダの<code>main</code>関数は<code>gl_Position</code>という魔法の組み込み変数を出力のために割り当て、フラグメントシェーダは、<code>gl_FragColor</code>変数を割り当てます。</p><p><a href="http://sampsyo.github.io/tinygl/#section-18" rel="nofollow" title="" class="ext-link">シェーダプログラムをコンパイルしてロードする</a>方法は次のようになります。</p><p>このボイラープレートを使って<code>shader_program</code>を呼び出してオブジェクトを描画する準備ができました。</p><p>文字列シェーダのインターフェイスはグラフィックスプログラミングの原罪なのです。つまり、完全なプログラムのセマンティックスの一部はランタイムまで知ることはできないことを意味します。これには、異なるハードウェアを標的にしていること以外に特に理由はありません。これは<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" rel="nofollow" title="" class="ext-link">JavaScriptの<code>eval</code>関数</a>のようですが、これ以上に面倒なのは、全てのOpen GLプログラムではコードを文字列に詰め込むことが<em>必要</em>になるのです。</p><p>Direct3Dや次世代のグラフィックスAPIである<a href="http://www.amd.com/en-us/innovations/software-technologies/technologies-gaming/mantle" rel="nofollow" title="" class="ext-link">Mantle</a>や<a href="https://developer.apple.com/metal/" rel="nofollow" title="" class="ext-link">Metal</a>、<a href="https://www.khronos.org/vulkan/" rel="nofollow" title="" class="ext-link">Vulkan</a>は、生のソースコードの代わりにバイトコードを使用してシェーダを実行することで、きれいなプログラムにできます。しかし、IRへのプリコンパイルシェーダープログラムは根本的な問題を解決してはいません。その問題とは、「CPUコードとGPUコードとの間の<em>インターフェイス</em>が無駄に動的であるため、異種のプログラム全体を静的に論証できない」というものです。</p><p>文字列でラップされたシェーダコードがOpenGLの自己資金投資の痛みなら、CPUとGPUの通信インターフェイスを介して、痛みの配当金を集めます。</p><p>頂点シェーダの<code>position</code>変数とフラグメントシェーダの<code>phase</code>変数をそれぞれ確認してみてください。<code>in</code>修飾子と<code>uniform</code>修飾子はCPUからのパラメータです。このパラメータを使用するには、ホストプログラムはまず各変数の<a href="http://sampsyo.github.io/tinygl/#section-28" rel="nofollow" title="" class="ext-link">位置情報を探します</a>。</p><p>変数の名前を文字列として渡して探します。<code>phase</code>パラメータは単にスカラー型の<code>float</code>ですが、<code>position</code>は位置ベクトルの動的配列のため、<a href="http://sampsyo.github.io/tinygl/#section-34" rel="nofollow" title="" class="ext-link">バックバッファを設定する</a>には、さらにボイラープレートが必要になります。</p><p>次にこれらハンドルを使用して<a href="http://sampsyo.github.io/tinygl/#section-42" rel="nofollow" title="" class="ext-link">シェーダにデータを渡し</a>、それぞれのフレームを描画します。</p><p><a href="http://sampsyo.github.io/tinygl/#section-42" rel="nofollow" title="" class="ext-link">Verbose モード（詳細な起動ログを出力するモード）</a>によって気をそらされますが、<a href="https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml" rel="nofollow" title="" class="ext-link"><code>glUniform1f</code></a>や<a href="https://www.opengl.org/sdk/docs/man2/xhtml/glBufferSubData.xml" rel="nofollow" title="" class="ext-link"><code>glBufferSubData</code></a>での呼び出しは<code>let variable = value</code>の代わりに<code>set("variable", value)</code>と書くのと同じことになのです。C言語やGLSLのコンパイラはCPUとGPUコードを別々にチェックし最適化してくれます。文字列型のCPUとGPUのインターフェイスはそれぞれのコンパイラがプログラム全体に影響を与えないようにしてくれます。</p><p>ハードウェア異質性の時代においては、OpenGLやこれに相当するものは哀れな主唱者となってしまいます。異質性は急速にユビキタスになってきています。そのため、異なる機能を持つハードウェアに対応できるソフトウェアを書くためのより良い方法が必要とされています。OpenGLのプログラミングモデルは、「異質のソフトウェアは、疎結合な複数の個別プログラムで構成されるべき」という単純な観点を重視しています。</p><p>説得力のある異質性が成功するには、20世紀的見解を捨てる必要があります。必要となるプログラミングモデルは、複数の実行内容を可能にする<em>1つ</em>のプログラムを書くことができることなのです。しかし、異質性の複雑さの本質をなくすことはできません。しかし、CPUコード以外のものをもう少し重んじることができるのではないでしょうか。</p>
