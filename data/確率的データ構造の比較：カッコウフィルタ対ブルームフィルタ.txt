<p><a href="http://blog.fastforwardlabs.com/post/153566952648/probabilistic-data-structure-showdown-cuckoo" rel="nofollow" title="" class="ext-link">Probabilistic Data Structure Showdown: Cuckoo Filters vs. Bloom Filters</a> (2016-11-23) By <a href="https://twitter.com/julius_adebayo" rel="nofollow" title="" class="ext-link">Julius Adebayo</a></p><p><img src="http://68.media.tumblr.com/02f8acc9218bd0faa09ab3c373629884/tumblr_inline_oh29g1UjZy1qcg73w_500.png" data-orig-width="600" data-orig-height="241" width="500" height="200"></p><p>確率的データ構造は少ないメモリでデータをコンパクトに保存し、保存されたデータに関するクエリに対し、おおよその答えを提供してくれます。クエリに対し空間効率の良い方法で答えるように設計されており、それはつまり、正確さを犠牲にするということにもなります。しかし、これらは一般的に、問われているデータ構造の仕様にもよりますが、誤差率の保証と境界を提供してくれます。メモリ使用量が少ないため、確率的データ構造はストリーミングや低出力の設定に特に有用なのです。ですから、動画の視聴回数を数えたり、過去に投稿された一意となるツイートのリストを維持したりするなど、ビッグデータの環境下では非常に有用です。例えば、<a href="https://research.neustar.biz/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/" rel="nofollow" title="" class="ext-link">HyperLogLog++</a><a href="https://en.wikipedia.org/wiki/HyperLogLog" rel="nofollow" title="" class="ext-link">構造</a>は、2.56KBのメモリで最大790億の一意のアイテムを数えることができるのですが、誤差率はわずか1.65パーセントです。</p><p>Fast Forward Labsのチームは、『リアルタイムストリームのための確率論手法』のレポートとプロトタイプを活用して確率的データ構造を詳しく調査しました（この話題に興味があれば、連絡をください）。この記事では、標準的なブルームフィルタを改良した<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.cs.cmu.edu%2F%7Edga%2Fpapers%2Fcuckoo-conext2014.pdf&amp;t=YWM1YjUwMGY1ODQ0NGQxZmNmYzkzZGNkMjZhYzAyNDIwMmEwMjcwYSxCZG5yZ01sZw%3D%3D&amp;b=t%3AAOV1EfYxABx8FqjbeSpWDQ&amp;m=1" rel="nofollow" title="" class="ext-link">新しい</a>確率的データ構造であるカッコウフィルタを調査することによってアップデートされた内容を紹介します。カッコウフィルタには、いくつかの利点があります。1) 要素の動的な削除と追加を可能にする。2) 同じような機能を持つブルームフィルタのバリアントと比べて、実装が容易である。3) 特に容量が小さい場合には、似たような空間の制限の下では、カッコウフィルタは偽陽性を出す可能性が低い。ここではカッコウフィルタをPythonで実装し、それをカウンティング･ブルームフィルタ（ブルームフィルタの変形）と比較します。</p><p>難解に思えますが、確率的データ構造は非常に役立つものです。例えば、大きなスケールのインターネットアプリケーションであるTwitterは、新規ユーザを確保し続けるために奮闘しています。この問題に取り組むため、Twitterの普及・エンゲージメントチームは、新規ユーザとあまり熱心に利用していないユーザの両方に、もっと頻繁にTwitterを利用してもらうようマーケティングキャンペーンを展開しています。このキャンペーンを補助するために、全ての新規ユーザをカッコウフィルタに追加することができます。ユーザがアクティブになるとそのユーザは除外され、エンゲージメントチームは現在カッコウフィルタに含まれているユーザに的を絞って促進キャンペーンを行うことができるのです。カッコウフィルタは、ユーザのアクティビティレベルに応じて、ユーザを追加したり削除したりできます。カッコウフィルタは実装が簡単なので、このユースケースでは適した方法と言えます。何億人ものユーザがいても、メモリ使用量が少なく、低い偽陽性率で処理できるのです。</p><p>ブルームフィルタと同様に、カッコウフィルタもある要素が集合のメンバであるかをテストするための確率的データ構造です。”カッコウ”という名前は、フィルタの基盤ストレージ構造としてカッコウハッシュテーブルを使うことからきています。カッコウハッシュテーブルという名前は、鳥の<a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%83%E3%82%B3%E3%82%A6%E7%A7%91" rel="nofollow" title="" class="ext-link">カッコウ</a>が行う<a href="https://ja.wikipedia.org/wiki/%E6%89%98%E5%8D%B5" rel="nofollow" title="" class="ext-link">托卵</a>に似たふるまいをするように設計されていることから名づけられました。カッコウは他の鳥の巣の中に卵を産むことで知られています。そして卵が孵化すると、カッコウのヒナは巣の持ち主の卵を排除してしまうのです。カッコウハッシュテーブルはこれと似た方法で、使用されている”バケット”の中に要素を挿入するのです。この方法については後ほど、カッコウフィルタの項目で説明します。カッコウフィルタについて知る前に、ブルームフィルタについてざっと確認しておきましょう。</p><p><a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AB%E3%83%BC%E3%83%A0%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF" rel="nofollow" title="" class="ext-link">ブルームフィルタ</a>は、集合のメンバシップの空間効率の良いテストを可能にする一般的な確率的データ構造です。例えば、ツイートのリアルタイムストリームを監視する際、ブルームフィルタによってツイートが最新のものであるのか、それとも繰り返しのものであるかをテストすることができます。ブルームフィルタでは、ハッシュ関数を使い、整数として要素をコンパクトにエンコードします。エンコードされた要素は、その時に設定されたビット配列のインデックスとして扱われます。要素が繰り返し使われているのか、そうでないのかをテストするには、ブルームフィルタで要素をハッシュし、そのインデックス一式を生成します。そして生成された各インデックスが、以前に設定されたものなかどうかの確認を行います。同じインデックスに対して、複数の要素をハッシュすることが可能なので、メンバシップテストは、偽もしくはおそらく新しい要素であるのどちらかを返してきます。つまり、ブルームフィルタでは偽陰性が生じることはないのですが、制御可能な偽陽性率が生じるということになります。要素が繰り返し使われているものではないとブルームフィルタが示した場合、その結果は正しいと考えることができますが、逆に繰り返し使われていると示した場合、間違っている（偽陽性）可能性があります。</p><p><img src="http://68.media.tumblr.com/d81cde7cca090981ae8fe3fb45e6db91/tumblr_inline_oh29hewgi21qcg73w_500.png" data-orig-width="600" data-orig-height="289" width="500" height="240"><br>
<em>注釈：新しい要素、繰り返し使われている要素</em></p><p>従来のブルームフィルタでハッシングを行う際、情報の損失を伴ったり、元の状態に戻せなかったりという点から、要素を削除することができません。つまり、削除には全フィルタを構築しなおすという作業が必要になってきてしまいます。しかし、上記で挙げたTwitterに投稿された特定のツイートの例のように、繰り返し使われている要素を削除したい場合どうしたらいいのでしょう？　この問題を解決するために、カウンティング・ブルームフィルタが導入されました。カウンティング・ブルームフィルタでは、従来のブルームフィルタ内にあるバケットを1ビットからnビットのカウンタに拡張して削除を行えるようになっています。つまり、ブルームフィルタのインデックスを設定するよりも、インクリメントを挿入した方が良いということです。</p><p>要素の削除が要求される場合、ブルームフィルタの代わりにカッコウフィルタを使うこともできます。このフィルタは<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" rel="nofollow" title="" class="ext-link">2014年</a>にFan氏らによって発表されました。カウンティング・ブルームフィルタ同様、カッコウフィルタでは、挿入、削除、検索を行うことができるのですが、ブルームフィルタとは異なった基本データ構造や挿入方法を使用しています。</p><p>カッコウフィルタは、挿入された要素の”フィンガープリント”を格納する<a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/13/Small13.pdf" rel="nofollow" title="" class="ext-link">カッコウハッシュテーブル</a>で成り立っており、要素のフィンガープリントは、その要素のハッシュから派生したビット文字列です。カッコウハッシュテーブルは、バケットの配列で構成されており、バケットに挿入された要素は、2つのハッシュ関数に基づいて収容可能な2つのバケットへとマッピングされます。各バケットは、フィンガープリントの変数を格納するように設定することができ、通常、カッコウフィルタは、そのフィンガープリントとバケットのサイズで識別されます。例えば、(2,4)というカッコウフィルタでは、2ビットの長さのフィンガープリントを格納し、カッコウハッシュテーブル内の各バケットには、最大4つのフィンガープリントを格納することができます。上述の2014年に発表された<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pd" rel="nofollow" title="" class="ext-link">論文</a>を受けて、私たちはカッコウフィルタを<a href="https://github.com/fastforwardlabs/cuckoofilter" rel="nofollow" title="" class="ext-link">Python</a>で実装しました。以下のコードは、カッコウフィルタを初期化し、簡単な挿入と削除のテストを行うものです。パフォーマンスを比較するために、カウンティング・ブルームフィルタも実装しました。</p><p><img src="http://68.media.tumblr.com/0ea03a886e0ae985263a915d45b2d370/tumblr_inline_oh29vg1Nx41qcg73w_500.png" data-orig-width="1224" data-orig-height="439" width="500" height="179"><br>
<em>注釈：(a) 要素xを挿入する前、(b) 要素xを挿入した後、(c) カッコウフィルタ：各要素に2つのハッシュと関数、各バケットに4つのエントリ</em></p><p>カッコウフィルタは、挿入、削除、検索の3つの操作をサポートしています。Fan氏らの論文で記述されている上記の図は、カッコウフィルタへの挿入がどのように機能するかを示しています。カッコウフィルタのあらゆる操作では、挿入操作が最も使用されています。カッコウフィルタに要素を挿入するためには、ハッシュとそのフィンガープリントに基づいた要素から、2つのインデックスを取得します。その後、これらのインデックスを取得するとすぐに、得られたインデックスに対応する収容可能な2つのバケットのうちの1つへと要素のフィンガープリントを挿入します。私たちの実装では、最初のインデックスを初期値としました。</p><p>カッコウハッシュテーブルが満たされ始めると、要素が挿入されるべき収容可能な2つのインデックスに空きがないという状況に直面します。この場合、この時点でカッコウハッシュテーブルにある要素は、新しい要素を挿入するために必要な空間を解放すべく、他のインデックスと交換させられます。この方法で挿入を実装することによって、収容可能な2つのインデックスのうちの1つにあるフィンガープリントを調べ、そのフィンガープリントが存在するのであれば、簡単にテーブルから要素を削除することができます。この挿入方法をより具体的にするために、私たちは、挿入方法を実装する以下のコードを提供しています。</p><p>カッコウフィルタとカウンティング・ブルームフィルタを比較してみましょう。ブルームフィルタやカッコウフィルタといった確率的データ構造において重要なメトリックが偽陽性率です。挿入の項目で示したように、カッコウフィルタとブルームフィルタの各内部での働きが異なることを考えると、これらを比較することは容易ではありません。偽陽性率の問題に対処すべく、両フィルタの空間割り当てを修正し、偽陽性率の変化を観測するために、容量に変化を与えました。以下の図は、両データ構造の容量に対する偽陽性率をグラフ化したものです。</p><p><img src="http://68.media.tumblr.com/953cf79fb096626b9d7b931f1fe605b1/tumblr_inline_oh2b4bgQtZ1qcg73w_500.png" data-orig-width="714" data-orig-height="494" width="500" height="345"><br>
<em>注釈：偽陽性率、容量（挿入された要素の最大値）</em></p><p>グラフを見て分かるように、カッコウフィルタにおける主な優位性は、空間を修正した場合に少ない容量でより低い偽陽性率になることです。原論文に記されている通り、3パーセント以下の偽陽性率（青い点線）が要求されるアプリケーションでは、カッコウフィルタがとりわけ理想的であると言えます。注目すべきは、この場合のカッコウフィルタは、単純に空間の最適化を行わずに実装を行っているということです。つまりこれは、最適化されたブルームフィルタと比較すると、調整を行っていないカッコウフィルタの方がより良いパフォーマンスを発揮することになります。カウンティング・ブルームフィルタとカッコウフィルタを比較したその他のパフォーマンスの評価テストは、こちらの<a href="https://github.com/fastforwardlabs/cuckoofilter/blob/master/bench_marking_notebook.ipynb" rel="nofollow" title="" class="ext-link">ノートブック</a>をご覧ください。</p><p>その他に考慮すべき重要なメトリックは、挿入時のスループットです。挿入時のスループットとは、既存のフィルタに要素を挿入する際にかかる時間を指します。カウンティング・ブルームフィルタの設計上、要素をフィルタに挿入する時間は、フィルタが満たされても変化がありません。しかし、カッコウフィルタでは、フィルタが容量を満たしていくにつれ、フィルタに要素を挿入する時間が増していきました。もし、要素がカッコウテーブルに挿入され、可能性のあるインデックスの両方に空きがない場合、今ある要素は、挿入されようとしている要素の空きを解放するために他のインデックスと交換されるのです。カッコウテーブルが満たされると、通常、より多くの交換が発生することになり、より多くの要素が他に移動されることになります。</p><p>以下の図では、同じ容量、同じ占有率の下で、カウンティング・ブルームフィルタとカッコウフィルタの挿入時間を示したものです（詳しくは<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Ffastforwardlabs%2Fcuckoofilter%2Fblob%2Fmaster%2Fbench_marking_notebook.ipynb&amp;t=ZDNlOGRkMDliNTAwZWY0OTUwYmIxOWNiZWVmZDZjM2U2NWM4NTdiZixCZG5yZ01sZw%3D%3D&amp;b=t%3AAOV1EfYxABx8FqjbeSpWDQ&amp;m=1" rel="nofollow" title="" class="ext-link">ノートブック</a>をご覧ください）。カッコウフィルタでは、80パーセントの占有率であった場合、最大85パーセントまで挿入のスループットが増加したのに対し、カウンティング・ブルームフィルタでは、一貫して安定したスループットを保っていました。また、カッコウフィルタの挿入のスループットが顕著に増加しているにもかかわらず、カッコウフィルタは全範囲にわたって、カウンティング・ブルームフィルタよりも3倍速いことが、この図から見て取れます。このように違いがはっきりと示されたとは言え、カウンティング・ブルームフィルタは、最適化することによってカッコウフィルタと同等の挿入速度を提供することができます。ここでは、カッコウフィルタの容量が満たされている場合に起こる、挿入時のスループットの明らかな変化を強調しようとしたにすぎません。</p><p><img src="http://68.media.tumblr.com/01724fa5dfa126e5b020fb646d4b68d4/tumblr_inline_oh2b5ykZg71qcg73w_500.png" data-orig-width="715" data-orig-height="497" width="500" height="347"><br>
<em>注釈：時間（秒）、フィルタの占有率</em></p><p>ブルームフィルタやブルームフィルタの変形から、ストリーミングによるアプリケーションやメンバシップテストが重要とされる場合においては、このフィルタが役に立つことが証明されました。この記事では、単純に実装が可能なカッコウフィルタが、特定の状況下において、追加設定や調整をせずにカウンティング・ブルームフィルタよりも、より良い実質的なパフォーマンスを発揮することを紹介しました。結論として、通常カウンティング・ブルームフィルタが使用される場合でも、他の選択肢としてカッコウフィルタを使用することができます。</p>
