Adventures in the land of substrings and RegExps. （2016-11-23） by Vyacheslav Egorov数週間前、Dart SDKに関して、String.substringのパフォーマンスが非常に悪いというバグが報告されました。以下は、その問題と一緒に提出されたマイクロベンチマークの中心部分です。結果は、Dartバージョンでかなり悪くなっています。見る方の経歴によっては、Dartでの実行時間が非線形増加を示していることにも驚くかもしれません。つまり、入力文字列のサイズを2倍（25000から50000）に増やすと、実行時間が4倍（244ミリ秒から949ミリ秒）に増えているのです。dart --observeでベンチマークを実行してCPUプロファイルをObservatoryで見てみると、意外ではない結果となりました。実行時間の大部分が、部分文字列の操作に費やされています。では、なぜDart VMの部分文字列はV8のよりも時間がかかるのでしょうか？実装が全く異なっているのに違いありません。そして、実際そうなっています。Dart VMは、String.substring(start, end)を非常に直接的な方法で実装しています。長さend - start + 1の新しいStringオブジェクトを割り当て、この新しい文字列に文字列コンテンツをコピーします。形式的にいえば、これはO(n)の実装であり、線形時間としても知られています。部分文字列の長さに比例した演算量が必要になるということです。ベンチマークの中心部分を見てみると、実行時間が2次成長を示した理由が明らかになるはずです。文字列sの初めの長さをNと仮定すると、ループの最初の反復で長さN−1の部分文字列が生成されます。次の反復で長さN−2の部分文字列が生成され、以後同様に続きます。最後の反復で長さ1の部分文字列が生成されます。ループに必要な演算は以下の数式で表されます。これは、N2に比例します。[上記の数列を今まで見たことのなかった方は、ちょっと時間を取って、和の公式の導き方について考えてみることをお勧めします。解法がいかに単純で簡潔かが分かると、Webpackの設定との格闘をやめられるようになるかもしれません。数学のフリードリヒ・ガウスは、これを8歳の時に見事に理解していました。もちろん、ガウスがモダンなJavaScriptのエコシステムを前にした時に何をするかは、想像もつきませんが]上記ループの計算量O(N2)こそ、文字列の反復時に処理済みの部分をスライシングする方法が適さない理由を示しています。ただし、ランタイムが内部で”ちょっとした”マジックを使って、この特定のパターンを最適化できるのであれば、もちろん話は別です。V8はその最適化を行います。V8のソースを調べてみると、何だか恐ろしくごちゃごちゃとした、様々な文字列表現があることが分かりました。それぞれ、特定のユースケース（索引付け、連結、スライシング）のための最適化です。JavaScriptコードで文字列値を見る時、実はこれらの表現が背後にあるわけですが、その時はいつでも、ランタイムはこれらの表現を切り替えて操作することができ、操作のパフォーマンスが向上するのであれば、ある表現から別の表現へ動的に移行することさえ可能です。［他のJavaScriptランタイムも、ベンチマーク競争から生じた同じく複雑な表現階層を持ち、一般的な使用パターンのための最適化を志向しています。SpiderMonkeyのString.hや、JSCのJSString.h、Chakraのソースにある*String.hファイルをご参照ください］様々なJavaScriptランタイムで使われている様々な文字列表現の違いを理解することは、通常、自分の書いた文字列操作コードが一定のパフォーマンスを示す理由を理解するための鍵となります。例えば、少し脱線して以下の例で考えてみましょう。このコードは、SpiderMonkeyではV8の場合より60倍速く動きます。ただ残念ながら、その詳細について扱うのは本記事の範囲外です。String.prototype.substringのマイクロベンチマークの話に戻りましょう。C++のレイヤとアセンブリをかき分けていくと、最終的に、部分文字列操作を実装しているコードに到達するはずです。［V8では、1つの場所だけに実装されたものはないので、部分文字列の実装探しに迷える人は、さらにCodeStubAssembler::SubStringを詳しく調べることになるかもしれません。これは、マシンコードにコンパイルされてSubStringスタブとして役立つTurboFanグラフを作成します。SubStringスタブは基本的に、上記C++ロジックへのファストパスを実装するものです］このC++ロジックをDartに変換すると、以下のようになります。これがJavaScriptバージョンのおおよその動作であり、マイクロベンチマークで2次の計算量が観察されない理由が示されています。大まかにいえば、部分文字列操作は（入力文字列が単調だと仮定し、メモリ管理のオーバーヘッドを無視すると）一定時間を要します。したがって、上記ではなく、下記になります。
パフォーマンスが劇的に向上するのであれば、なぜDart VMで同様の最適化を実装しないのでしょうか。それは、この部分文字列最適化には危険な落とし穴があるからです。驚くべきメモリリークを引き起こすのです。上記のobjは、わずか20文字のトークンではなく、10GBの入力文字列全体を保持します。なぜなら、このトークンの内部表現は、ソース文字列を指すSlicedStringであるからです。わざとらしい例に見えるかもしれませんが、このようなメモリリークは本当に実際の場で起こりがちです。例えば、three.jsはこの問題を回避しなければなりません。ランタイムが見えないところで巧妙な最適化を行ってコードを速めることには、厄介な側面もあります。Issue 2869では、この問題のV8側での修正について経過をたどっていますが、2013年以来、実際的には何も起こっていません。その理由は恐らく、唯一のシンプルかつ確かな解決法は、スライシングされた文字列を完全に除去することだからでしょう。興味深いことに、これはまさにJavaが行っていたことです。Javaはかつて、親のStringのchar[]ストレージを部分文字列オブジェクトのために再利用することで、O(1)時間でのString.substringを実装していました。しかし、これはメモリリークを引き起こし、結局2012年に廃止されました。V8の文字列スライスに関する経緯は、さらに不思議です。V8には元々、文字列スライスがあり、2009年に廃止されましたが、その後2011年に復活したのです。以上のことは、本記事の道のりの出発点となったDart SDKのバグにとっては、少々厄介な問題です。実のところDart VMは、スライシングされた文字列による部分文字列最適化を実装しそうにありません。そこで私は、一体なぜ部分文字列のパフォーマンスが測定されているのかを探ることにしました。冒頭のバグは、less_dartが遅いことについての調査で見つかったものだと分かりました。less_dartとは、less.jsのJavaScriptからDartへのポートです。less_dartのベンチマークをObservatoryで見てみると、以下の結果になりました。
Lessパーサが、私なら勧めないことをまさに行っています。つまり、部分文字列操作で入力文字列の処理を繰り返しているのです。ソースを調べたところ、以下のコードが浮上し、部分文字列を使っている理由も明らかになりました。［コードはJavaScriptから逐語的にポーティングされていますので、まさに同じコードがJavaScriptバージョンに存在します。そちらでは、準最適化が有用なJavaScriptランタイムの存在によって隠れています］Lessの作者は、カスタムレクサを書くのではなく正規表現を使って入力をパースすることに決めました。しかし、ES6以前の世界ではRegExpで解析することは複雑でした。なぜなら、正規表現を使って指定位置でマッチするかを簡単に調べることができなかったためですが、それこそ、文字列をたどってトークンに分割する際にレクサが行う必要のあることです。matchは、ES6で導入されたRegExpのstickyフラグをサポートするモダンなJavaScriptインタプリタなら、どれにでも容易に実装できます。［フラグyは、LexのAPIの一部であるyylexにちなんで名付けられたようです（その技術はES7に含まれるも技術よりも高度なものでつくられた宇宙船Lexxと混同しないように）。恐らくstickyという名前も、*yで終わるという理由で選ばれたのでしょう］では、ES6以前のJavaScriptエンジンでmatchを実装する方法とは？　非常に単純なアプローチを取るとしたら、以下のようになるでしょう。ですが、この方法は極めて非効率です。というのも、match(/\d+/g)を呼び出すと基本的に、最初の数字列を探すためにthis.idx以降を検索して、this.idxで出現したマッチでなければ破棄することになるからです。RegExpの機能にもう少し詳しい人であれば、以下のような最適化を考えるかもしれません。しかし、matchを実装するもっと一般的かつ直接的な方法は、substringとアンカーを付けた正規表現を使うものでしょう。これはまさしく、less.jsとless_dartにあるコードです。less.jsにとっては幸いなことに、V8ランタイムはString.prototype.substringをO(1)の演算として実装し、less_dartにとっては不運なことに、Dart VMはO(1)の演算として実装していません。Dart VMが実装しているのは、RegExp.matchAsPrefixのメソッドです。これは基本的に、指定された正規表現についてstickyなマッチを指定位置で実行するものです。バンザイ！☺しかし、less_dartコードに必要な変更を施したところ、実際には何倍も遅くなってしまいました。うーん。☹結局、VMのRegExp実装の内部に、ちょっとしたTODOがあったことが分かりました。明らかに、この解決法は、V8がstickyフラグを実装しているのと同じやり方でRegExp.matchAsPrefixを実装することでVMを修正する、というものでした。これは、Dart VMが基本的に、V8と同じくIrregexpと呼ばれる正規表現エンジンを使っているので、ややシンプルになっています。［Dart VMポートをIrIrRegexpと呼ぶべきだったかもしれません。なぜなら、Dart VMは、RegExp特有の中間表現（IR）をマシンコードに変換する代わりに、マシンに依存しないIRにまで変換し、その処理をジェネリックなコンパイラパイプラインに任せるからです。これによって、マシン特有の正規表現関連バックエンドコードをポーティングしなくても、IrregexpをDart VMに組み込むことができたのです］そこで私は、オリジナルのIrregexpでstickyフラグの実装を推進していた1人であるErik Corryに直接相談してみました。そして、stickyフラグをDart VMにポーティングしてみました。その際に、V8のstickyの実装における非常に小さなバグを発見し、修正しました。RegExp.matchAsPrefixが効率的な形で実装されたので、私がless_dartの修正を行った結果、期待されたパフォーマンス改善が実現して、less_dartとless.jsが互角の状態になりました。できればこのポジティブな雰囲気で本記事を終えたかったのですが、ソースコードをトークン化するために正規表現を使うという一般的な話に戻りたいと思います。その実現に際して非常に重要な点は、確かに正規表現は解析に便利な方法であるとはいえ、決して効率的な方法ではないということです。関係している抽象化レイヤがとにかく多すぎるのです。前に試したように、正規表現でのトークン化とそのベンチマークテストを("aaaaa aaaa ".repeat(50) + "10 ").repeat(10000)のような単純な文字列で実行してみると、以下のようなパフォーマンス数値が得られます。速度を上げられるでしょうか？　抽象化レイヤを取り払い、完全に手動でやってみましょう。別用途の際に私が使ったものと全く同じベンチマークで、このトークナイザのベンチマークテストを実行します。すると、以下の結果が出ました。このことから分かる重要なポイントは、作業量が減ればプログラムははるかに速くなるということです。例えば、この手動トークナイザは、部分文字列オブジェクトのトークンへの割り当ては行わず、単純に文字列をたどるものです。しかし、var val = l.val;をベンチマークのループ内に追加してこの無意味な割り当てを強制するようにすると、やはり、RegExpベースのパーサよりはるかにパフォーマンスが良いことが分かります。以下にDartにおける同種のレクサベンチマークを挙げておきます。Dart VMは、このコードでなかなかのパフォーマンスを見せました。まとめると、パフォーマンスに関する総合的なアドバイスは以下のようになります。
