<p><a href="http://alex.dzyoba.com/programming/dynamic-arrays.html" rel="nofollow" title="" class="ext-link">On dynamic arrays</a> (2016-06-26) By <a href="http://alex.dzyoba.com/about.html" rel="nofollow" title="" class="ext-link">Alex Dzyoba</a></p><p>私はSkienaの『Algorithm Design Manual』<em>(訳注：『アルゴリズム設計マニュアル』 <a href="https://www.amazon.co.jp/dp/4621085107" rel="nofollow" title="" class="ext-link">上巻</a>・<a href="https://www.amazon.co.jp/dp/4621085115" rel="nofollow" title="" class="ext-link">下巻</a>)</em> を読んでいました。ところでこの本は素晴らしい本で、連結リストと配列についてこんな比較をしていました(chapter 3.1.3)。</p><p>Skiena氏は包括的な比較をしてくれているのですが、残念ながら最後のポイントについての重きの置き方が十分ではありません。私はシステムプログラマとして、「メモリアクセスパターンや効率的なキャッシュ、効率的なCPUパイプラインの利用が大きな影響力を持ち得る・<em>持つ</em>」ということを知っており、ここではそれを示したいと思っています。</p><p>簡単なテストをしてみて、連結リストと動的配列のデータ構造での基本的な操作(挿入や検索など)のパフォーマンスを比較してみましょう。</p><p>コンピュータ・サイエンスの場における完璧なツールとして、私はJavaを使うことにします。Javaには<code>LinkedList</code>と<code>ArrayList</code>の両方があります。これらはそれぞれ連結リストと動的配列を実装しており、両方が同じ<code>List</code>インターフェイスを実装しています。</p><p>テストには以下のものを含みます。</p><p>ソースは私のCS playgoundリポジトリの<a href="https://github.com/dzeban/cs/tree/master/ds/list-perf" rel="nofollow" title="" class="ext-link"><code>ds/list-perf</code> ディレクトリ</a></p><p>Sources are at my CS playground in <a href="https://github.com/dzeban/cs/tree/master/ds/list-perf" rel="nofollow" title="" class="ext-link"><code>ds/list-perf</code> ディレクトリ</a>にあります。これはMavenプロジェクトなので、<code>mvn package</code>するだけでjarを入手可能です。テストは極めてシンプルで、例えば以下がランダム挿入のテストです。</p><p>これは<code>List</code>インターフェイスを利用して動作しており(そうです、ポリモーフィズムです！)、何も変更せずとも<code>LinkedList</code>と<code>ArrayList</code>の両方を渡すことができます。テストは先ほど書いた通りの順番(割り当て→挿入→検索→削除)で複数回実行され、全ての結果の最小値/中央値/最大値を計算します。</p><p>さあ、説明はこれで十分でしょうから、実行してみましょう！</p><p>ぱっと見て分かる通り、<code>LinkedList</code>が劣っています。しかし、素晴らしい箱ひげ図をご覧になって下さい。</p><p><img src="http://alex.dzyoba.com/assets/img/dynamic-array/allocation_delete.png" alt="Allocation and delete in LinkedList and ArrayList"><br>
LinkedListとArrayListでの割り当てと削除</p><p><img src="http://alex.dzyoba.com/assets/img/dynamic-array/insert.png" alt="Insert in LinkedList and ArrayList"><br>
LinkedListとArrayListでの挿入</p><p><img src="http://alex.dzyoba.com/assets/img/dynamic-array/search.png" alt="Search in LinkedList and ArrayList"><br>
LinkedListとArrayListでの検索</p><p>そして、<a href="https://plot.ly/~dzeban/2/linked-list-vs-array-list/" rel="nofollow" title="" class="ext-link">全てのテストをまとめた</a>リンクもあります。</p><p>全ての操作において、<code>LinkedList</code>が恐ろしく劣っています。唯一の例外が先頭への挿入ですが、それでも動的配列の最悪のケースと勝負しているだけです。このケースにおいて、動的配列は配列全体を毎回コピーしなければならないからです。</p><p>これを説明するために、実装について少し深く見ていきます。Java 8のOpenJDKのソースを使います。</p><p><code>ArrayList</code>と<code>LinkedList</code>のソースは<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/util/" rel="nofollow" title="" class="ext-link">src/share/classes/java/util</a>にあります。</p><p>Javaの<code>LinkedList</code>は、<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/util/LinkedList.java#969" rel="nofollow" title="" class="ext-link"><code>Node</code>内部クラス</a>を通じた双方向リストとして実装されています。</p><p>では、シンプルな割り当てテストの状況下で何が起こっているのかを見てみましょう。</p><p>これは、<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/util/LinkedList.java#329" rel="nofollow" title="" class="ext-link"><code>add</code></a>メソッドを<br>
呼び出し、さらに<code>add</code>メソッドはJDKの<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/util/LinkedList.java#137" rel="nofollow" title="" class="ext-link"><code>linkLast</code></a>メソッドを呼び出します。</p><p>基本的に、<code>LinkedList</code>での割り当ては<strong>定数時間の操作</strong>となります。<code>LinkedList</code>クラスは末尾のポインタを保持しているため、挿入のために必要なのは「新しいオブジェクトの割り当て」「2つのポインタの更新」のみとなります。これが<strong>そんなに遅くなるはずがないのです</strong>！ では、なぜ実際は遅くなっているのでしょう？<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/util/ArrayList.java#207" rel="nofollow" title="" class="ext-link"><code>ArrayList</code></a>と比較してみましょう。</p><p>Javaの<code>ArrayList</code>は実のところ、「初期設定として10個までの容量を持ち、容量を増やす際には毎回1.5倍に増やす」という動作をする動的配列なのです。<code>//overflow-conscious code</code>という記述も実におかしです。なぜこのようになっているのかという理由は、<a href="http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b" rel="nofollow" title="" class="ext-link">こちら</a>で読むことができます。</p><p>自身のリサイズは<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/util/Arrays.java#3260" rel="nofollow" title="" class="ext-link"><code>Arrays.copyOf</code></a>を通じて行われており、これはJavaの<em>ネイティブ</em>メソッドである<a href="http://code.metager.de/source/xref/openjdk/jdk8/jdk/src/share/classes/java/lang/System.java#480" rel="nofollow" title="" class="ext-link"><code>System.arraycopy</code></a>を呼び出します。ネイティブメソッドの実装はJDKの一部ではないため、これはJVM固有の機能となります。HotSpotのソースを探し出し、見てみましょう。</p><p>簡潔にまとめると以下の通りです―この機能は<a href="http://code.metager.de/source/xref/openjdk/jdk8/hotspot/src/share/vm/oops/typeArrayKlass.cpp#128" rel="nofollow" title="" class="ext-link"><code>TypeArrayKlass:copy_array</code></a>メソッド内にあり、これは<a href="http://code.metager.de/source/xref/openjdk/jdk8/hotspot/src/share/vm/utilities/copy.cpp#29" rel="nofollow" title="" class="ext-link"><code>Copy:conjoint_memory_atomic</code></a>を呼び出します。このメソッドはアラインメントを探しますが、見ての通りメソッド内にはコピーメソッドのlong、int、short、bytes(アラインメントがない場合)向けのバリエーションがあります。int向けのメソッドである<a href="http://code.metager.de/source/xref/openjdk/jdk8/hotspot/src/share/vm/utilities/copy.hpp#137" rel="nofollow" title="" class="ext-link"><code>conjoint_jints_atomic</code></a>を見てみますが、これは<a href="http://code.metager.de/source/xref/openjdk/jdk6/hotspot/src/os_cpu/linux_x86/vm/copy_linux_x86.inline.hpp#229" rel="nofollow" title="" class="ext-link"><code>pd_conjoint_jints_atomic</code></a>のラッパであり、OSとCPUに固有のものとなります。Linux用のバリエーションを探してみると、<a href="http://code.metager.de/source/xref/openjdk/jdk8/hotspot/src/os_cpu/linux_x86/vm/linux_x86_32.s#420" rel="nofollow" title="" class="ext-link"><code>_Copy_conjoint_jints_atomic</code></a>への呼び出しが見つかります。最後に待ち受けているのはアセンブリの獣です！</p><p>ポイントは、VM言語が遅いことにあるの<strong>ではなく</strong>、ランダムメモリアクセスがパフォーマンスを低下させていることにありました。<code>conjoint_jints_atomic</code>の肝は<code>rep; smovl</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup>です。そして、CPUが本当に好むのものがあるとすれば、それは<code>rep</code>命令です。これに対して、CPUはパイプラインやプリフェッチ、キャッシュなど、この命令のために構築された全ての物―ストリーミング計算と予測的メモリアクセスを利用することができます。<a href="http://www.lighterra.com/papers/modernmicroprocessors/" rel="nofollow" title="" class="ext-link">«Modern Microprocessors. A 90 Minute Guide!»</a>をお読みください。</p><p>これの意味するところは、アプリケーションに対して<code>rep smovl</code>は実際には線形時間の操作ではなく、やや定数時間寄りの操作である、ということです。最後のポイントを見ていきましょう。100万個の要素のリストについて、先頭に100、1000、10000個の要素を挿入してみましょう。私のマシンでは、以下のサンプルが得られました。</p><p>10倍にするごとに、計算も10倍になっていますね。これは10 * O(1)だからです。</p><p>熟練の開発者はエンジニアであり、そういった人々は<a href="http://www.stevemcconnell.com/psd/04-senotcs.htm" rel="nofollow" title="" class="ext-link">コンピュータサイエンスはソフトウェアエンジニアリングではない</a>というのを御存じでしょう。理論上は良いものが、全てのファクターを考慮しないことにより実践では悪くなるということもあります。実世界で成功するためには、下部を支えるシステムとその動作に関する理解がとても重要になり、影響力を持ちます。</p><p>そしてこれは私だけの意見ではなく、数年前<sup id="fnref:2"><a href="#fn:2" class="footnote-ref">2</a></sup>からRedditにこんなリンクがありました―「<a href="https://www.reddit.com/r/programming/comments/25xpre/bjarne_stroustrup_why_you_should_avoid_linked/" rel="nofollow" title="" class="ext-link">Bjarne Stroustrup: Why you should avoid LinkedLists</a>」というものです。私は彼の論旨に同意しています。しかし、勿論、気を確かに持って、誰かや何かを盲目的に信じることのないようにしましょう。計測、計測、計測です。</p><p>私の今までで一番のお気に入りである<a href="http://scholar.harvard.edu/files/mickens/files/thenightwatch.pdf" rel="nofollow" title="" class="ext-link">James Mickensの『The Night Watch』</a>を添えてお別れしたいと思います。</p>
