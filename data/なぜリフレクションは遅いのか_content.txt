Why is reflection slow? (2016-12-14) by Matt Warren.NETのリフレクションが遅いのは周知の事実ですが、なぜなのでしょうか。この投稿では、リフレクションの実装を見ながらなぜ遅いのかを解明します。リフレクションが速くない理由の1つとして、そもそも高いパフォーマンスが設計上の目標にされてはいないことを挙げることができます。型システム概要 – 設計の目標および非目標では次のように記載されています。また、型ローダ設計-主なデータ構造では次のように記載されています。リフレクションの高速処理を実現することが設計目標ではないことは分かりましたが、では、何に時間がかかっているのでしょうか。実は複数のことが実行されているのですが、理解しやすいようにリフレクションの呼び出しで実行されるマネージドコードとアンマネージドコードのコールスタックを見てみましょう。上記のリンクにアクセスして個別のC#/cppメソッドを確認しなくても、多くのコードが実行されていることは想像がつくと思います。例えば、最終メソッドであり、処理の大部分が実行される System.RuntimeMethodHandle.InvokeMethodの行数は400以上にも及びます。概要は分かったと思いますが、では具体的に何をしているのでしょうか。リフレクションを介してフィールドやプロパティ、メソッドを呼び出す前に専用のFieldInfo/PropertyInfo/MethodInfoハンドルを取得する必要があります。下記のコードを使用します。前セクションで記載したように、関連するメタデータを取得したり、パースしたりなどしなければならないため、これにはコストがかかります。興味深いことに、ランタイムは、全てのフィールドやプロパティ、メソッドの内部キャッシュを保持することで助けてくれます。このキャッシュはRuntimeTypeCacheクラスによって実装され、使用例はRuntimeMethodInfoクラスで見ることができます。このgistを実行してキャッシュの動きを見てみると、リフレクションを適切に使用してランタイム内部を検証しているのが分かります。リフレクションでFieldInfoを取得する前に、gistのコードは下記を出力します。フィールドを1つでも取得すると下記が出力されます。ReflectionOverhead.Programは下記のとおりです。つまり、すでに作成され、存在するリストをランタイムでフィルタするだけなので、継続的にGetFieldあるいはGetFieldsを呼び出す方がコストがかからないことを意味します。これは、GetMethodやGetPropertyにも当てはまり、GetMethodやGetPropertyを最初に呼び出した時にMethodInfoキャッシュあるいはPropertyInfoキャッシュが作成されます。MethodInfo取得後、Invokeを呼び出す前にまだやるべきことがたくさんあります。下記のようなコードを書いたと想像してください。実行すると、下記の例外が発生します。上記はStringクラスのLengthプロパティのPropertyInfoを取得した結果なのですが、Uriオブジェクトで呼び出したため、明らかに異なる型になっています。これに加え、呼び出すメソッドに渡す引数のバリデーションも必要です。引数を渡すために、リフレクションAPIは、引数ごとに1つのobjectの配列であるパラメータを取ります。従って、リフレクションを使用してAdd(int x、int y)メソッドを呼び出す場合は、methodInfo.Invoke(..、new [] {5、6})を使用します。渡された値と型は実行時にチェックする必要があります。この場合、値が2つで、両方ともintであることを保証する必要があります。欠点は、多くの場合、追加コストのかかるボックス化を伴うことですが、将来的に軽減されることを期待します。実行されている主なタスクの1つが複数のセキュリティチェックです。例えば、リフレクションを使用して好みのメソッドを呼び出すことはできません。信頼性の高い.NET Frameworkコードでのみ呼び出しのできる制約あるいは「危険なメソッド」が存在します。ブラックリストに加えて、呼び出し中にチェックする必要がある最新のコードアクセスセキュリティの許可の有無に応じた動的なセキュリティチェックが実行されます。リフレクションが舞台裏で何をしているのか分かったところで、かかるコストを見てみましょう。これらのベンチマークは、直接リフレクションを介してプロパティへの読み書きを比較していることにご注意ください。.NETにおいて、プロパティは実はコンパイラが生成するGet / Setメソッドのペアですが、単なるバッキングフィールドがあるプロパティの場合、パフォーマンス上の理由から.NET JITはメソッドの呼び出しをインライン化します。つまり、プロパティにアクセスするためのリフレクションの使用は最悪の方法と言えるのですが、ORMやJSONのシリアル化/逆シリアル化ライブラリ、およびオブジェクトマッピングツールなどでも見られるとおり、最も一般的に使用されている方法なのです。下記はBenchmarkDotNetで表示している生の結果です。さらに同じ結果を2つの表形式でも表示しています(ベンチマークの全コードはこちらです) 。注釈：method – メソッド
Mean – 平均
StdErr – Standard Error – 標準エラー
Scaled – 縮尺
Bytes Allocated/Op – 割り当てられたバイト数注釈：method – メソッド
Mean – 平均
StdErr – Standard Error – 標準エラー
Scaled – 縮尺
Bytes Allocated/Op – 割り当てられたバイト数上記から通常のリフレクションコード(GetViaReflectionとSetViaReflection)の方がプロパティに直接アクセスする(GetViaPropertyとSetViaProperty)よりもかなり遅いことは明確です。他の結果については、さらに詳しく見てみましょう。まず、下記のようなTestClassから始めます。さらに、全オプションの活用を可能にする共通のコードは下記のとおりです。まず、開始地点や「最悪のケース」の役目を果たす通常のベンチマークコードを使用します。次は、毎回取得するのではなく、PropertyInfoを参照先として保持することで、速度を少し上げます。しかし、プロパティに直接アクセスするよりもまだ遅いです、これは、リフレクションの「呼び出し」にはかなりコストがかかることを実証しています。ここでは、使い方の簡単なMarc GravellのFast Memberライブラリを利用します。ここでの注意点は、他のオプションとは若干異なることをしていることです。1つだけではなく、型の全プロパティへのアクセスを可能にするTypeAccessorを作成します。しかし、欠点は結果的に実行に余計時間がかかることです。これは、プロパティの値を取得する前にリクエストしたプロパティ(この場合は「データ」)のdelegateをまず内部で取得する必要があるからです。でも、このオーバヘッドはかなり小さく、FastMemberを使用する方がリフレクションよりもかなり早い上、簡単なので、まずは見てみることをお勧めします。このオプションを初め、これ以降のオプションは全てリフレクションコードをdelegateに変換することで、毎回のリフレクションのオーバヘッドなしで直接呼び出し、高速化しています。delegateの作成にもコストはかかることを述べておきます(詳しい情報は関連記事をお読みください)。簡単に言うと、コストのかかることを1回(セキュリティチェックなど)で終わらせ、強い型付けのdelegateを格納することで、小さいオーバヘッドで繰り返し使用することができるのです。結果、速度を上げることができるのです。リフレクションの使用が1度だけならこのような手法は使用しませんし、1度だけならパフォーマンスの弊害にもなりませんので、遅いことが気になることはないでしょう。delegateを介したプロパティの読み込みの方が直接のプロパティを読み込むより遅い理由は、.NET JITがプロパティへのアクセスのようにdelegateメソッドの呼び出しをインライン化しないからです。つまり、delegateを使用する際は、メソッドの呼び出しには直接アクセスする場合にはかからないコストが発生するということです。このオプションではCreateDelegate関数を使用して、PropertyInfoを通常のdelegate変換します。欠点はコンパイル時に確定した型を知っている必要があることです。例えば、上記のコードのFunc&lt;TestClass, string&gt;の部分です(Func&lt;object, string&gt;は使用できません。使用した場合は例外処理が実行されます)。リフレクションを使用している状況においてコンパイル時に確定した型が分かっている場合はほとんどありません。だからこそ、リフレクションを使用することになるのです。これは解決策としては不十分です。これを回避できる非常に興味深く/思いがけない方法については、Jon Skeetの素晴らしいブログ記事『リフレクションを機能させ、デリゲートを探る』のMagicMethodHelperコード、あるいはこの後に続くオプション4またはオプション5をお読みください。ここでもdelegateを生成しますが、何が違うかというと、objectを渡すことで「オプション 3」の制約を回避できることです。ここで使用するのは、動的コードの生成を可能にする.NETのExpressiontreeAPIです。Expressionベースのアプローチの全コードはブログ投稿『式木を使用してリフレクションを速くする』を参照くしてださい。やっと最下位レベルのアプローチ、生ILを記述する方法にたどり着きました。しかし、「大いなる力には大いなる責任が伴う」ものなのです。Expressiontreeの使用(オプション4)は、直接ILコードを記述する時のような柔軟性はありませんが、無効なコードを記述するのを防いでくれます。間違えたプログラミングをしても、もっと良いエラーメッセージで注意してくれる素晴らしいSigilライブラリの使用をお勧めします。要点は、リフレクションを使用してパフォーマンス問題に直面した場合のみ、いくつかの異なる方法で速度を上げることができるということです。delegateの取得でこれらは可能になり、毎回のリフレクションのオーバヘッドなしでプロパティやフィールド、メソッドに直接アクセスすることができます。この投稿の意見を/r/programmingと/r/csharpにお寄せください。参考としてランタイムがデリゲート作成の際に通過するコールスタックやコードフローを一覧にしました。
