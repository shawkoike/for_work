<p><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e#.8x3io5nuj" rel="nofollow" title="" class="ext-link">React Higher Order Components in depth</a> (2016-06-13) by <a href="https://twitter.com/franleplant" rel="nofollow" title="" class="ext-link">Fran Guijarro</a>(<a href="https://twitter.com/franleplant" rel="nofollow" title="" class="ext-link">@franleplant</a>)</p><p><small>(編注：2016/7/27、いただいたフィードバックをもとに記事を修正いたしました。)</small></p><p>この投稿は、HOCパターンを利用してみたいという<strong>上級ユーザ</strong>向けの記事です。もしReactが初めての方は、まず<a href="https://facebook.github.io/react/docs/getting-started-ja-JP.html" rel="nofollow" title="" class="ext-link">Reactのドキュメント</a>を読むところから始めるとよいでしょう。</p><p>Higher Order Componentsは、さまざまなReactライブラリにとって価値があることがわかっている素晴らしいパターンです。この投稿で、HOCとは何か、できることは何か、制約は何か、どのように実装するのか……という点について詳細に見ていきます。</p><p>付録として、関連トピックについても見ていきます。それらは、HOCを学ぶ上での中核にはならないものの、カバーしておくべきだと私が思っているものです。</p><p>この投稿を網羅的なものにしたいと考えているため、もし何か私が見落としている点を見つけた場合は是非教えてください。必要な変更を加えようと思います。</p><p>この投稿はES6に関する知識があるものとして進めていきます。</p><p>それでは始めましょう！</p><p>このパターンは通常は関数として、基本的には<em>class</em> factoryとして実装されて(そうです、class factoryです！)、Haskell風の擬似コードで書くと、以下のようなシグネチャを持ちます。</p><p><em>W</em> (<em>WrappedComponent</em>)はラップされる<em>React.Component</em>で、<em>E</em> (Enhanced Component)は新しいHOC、つまり返される<em>React.Component</em>となります。</p><p>この「ラップする」という単語の定義は、意図的にあいまいにしておきます。なぜなら、これには2つの可能性があるからです。</p><p>この2つのパターンについて、より詳細に見ていきましょう。</p><p>高レベルでのHOCにより、以下のことが可能になります。</p><p>これらの項目についてはすぐに詳細に見ていきますが、まずはHOCをどのように実装するのかを見ていきます。なぜなら、この実装がHOCで実際にできることを制限したり可能にしたりするからです。</p><p>この節では、ReactでHOCを実装する2つの主な方法、Props Proxy (PP)とInheritance Inversion (II)について学んでいきます。どちらも違った方法で<em>WrappedComponent</em>の操作を可能にしてくれます。</p><p>Props Proxy (PP)は以下のようにして簡単に実装できます。</p><p><script src="https://gist.github.com/franleplant/6b7aa3f11747228c45d4.js"></script></p><p>ここで重要なのは、HOCのrenderメソッドが<em>WrappedComponent</em>型のReact Elementを<strong>返す</strong>ことです。HOCが受け取ったpropsをそのまま渡していますが、これを今後<strong>Propx Proxy</strong>と呼びます。</p><p>注記：</p><p>これらは両方とも、調停(Reconciliation)プロセスにおいてReactが何をレンダリングすべきかを説明するReact Elementを生成します。React ElementとComponentの比較についてもっと知りたい場合は、この<a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html" rel="nofollow" title="" class="ext-link">Dan Abramovによる投稿</a>を見て、<a href="https://facebook.github.io/react/docs/reconciliation.html" rel="nofollow" title="" class="ext-link">調停プロセス</a>に関するドキュメントをお読みください。</p><p><strong>Props Proxyでできることは何か？</strong></p><p><strong>propsの操作</strong></p><p><em>WrappedComponent</em>へ渡されるpropsに対して、読んだり追加したり変更したり消去したりといった操作ができます。</p><p>重要なpropsを消去したり変更したりする場合は注意してください。HOCのpropsが<em>WrappedComponent</em>を壊さないよう適切に命名しなければなりません。</p><p>例：新しいpropsを追加する。アプリケーションで現在ログインしているユーザが、<em>WrappedComponent</em>内では<em>this.props.user</em>で利用可能になります。</p><p><script src="https://gist.github.com/franleplant/e9fa28d67ac8fc381c1f.js"></script></p><p><strong>参照を経由したインスタンスへのアクセス</strong></p><p><em>参照</em>を用いて、<em>this</em> (<em>WrappedComponent</em>インスタンス)にアクセスすることができます。しかし、参照が計算されるためには、<em>WrappedComponent</em>の完全な通常のrenderプロセスが最初から必要となります。つまり、HOCのrenderメソッドで<em>WrappedComponent</em>を返し、Reactに調停プロセスを行わせることが必要になり、そうすることで<em>WrappedComponent</em>インスタンスへの参照が得られるようになる、ということです。</p><p>例：以下の例では、<em>WrappedComponent</em>のインスタンスメソッドとインスタンス自身に<a href="https://facebook.github.io/react/docs/more-about-refs-ja-JP.html" rel="nofollow" title="" class="ext-link"><em>参照</em></a>を経由してアクセスする方法を試しています。</p><p><script src="https://gist.github.com/franleplant/29af569dce10273e8fa1.js"></script></p><p>WrappedComponentがレンダリングされると、refコールバックが実行され、<em>WrappedComponent</em>インスタンスへの参照が得られるようになります。これは、インスタンスのpropsの読込/追加や、インスタンスメソッドの呼び出しに用いられます。</p><p><strong>Stateの抽象化</strong></p><p><em>WrappedComponent</em>にpropsとコールバックを渡すことで、Stateを抽象化することができます。これは、Smart componentがDumb componentを扱う方法に似ています。<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.o2qmm6j3h" rel="nofollow" title="" class="ext-link">Dumb/Smart componentについては</a>より詳細を見てみてください。</p><p>例：以下のState抽象化の例では名前のinputフィールドの<em>value</em>と<em>onChange</em>ハンドラを素朴に抽象化しています。”素朴に”というのは、このやり方は普遍的でないものの、要点を理解してもらうにはよいと考えたからです。</p><p><script src="https://gist.github.com/franleplant/6683e538ab673aa1c748.js"></script></p><p>以下のように使うことができます。</p><p><script src="https://gist.github.com/franleplant/4cf3e1d35d1845063568.js"></script></p><p>このinputはなんと自動的に<a href="https://facebook.github.io/react/docs/forms-ja-JP.html" rel="nofollow" title="" class="ext-link">制御されたinput</a>になります。</p><p><strong>WrappedComponentを他の要素でラップする</strong></p><p>スタイルやレイアウト、その他の目的のために、<em>WrappedComponent</em>を他のcomponentや要素でラップすることができます。基本的な使い方のうちいくつかは通常の親componentで達成できます(付録Bをご覧ください)が、前述したとおりHOCではよりフレキシブルにできます。</p><p>例：スタイリング目的でのラップ</p><p><script src="https://gist.github.com/franleplant/cb88b640d7e0cae373f8.js"></script></p><p>Inheritance Inversion (II)は以下のようにして簡単に実装できます。</p><p><script src="https://gist.github.com/franleplant/bf1fc65295bb772c65c9.js"></script></p><p>ご覧のとおり、返されたHOC class(Enhancer)は<em>WrappedComponent</em>を<strong>継承</strong>します。WrappedComponentがEnhancer classを継承するのではなく、逆に受動的にEnhancerによって継承されることから、これをInheritance Inversionと呼びます。このやり方では、これらの関係は<strong>逆転</strong>しているように見えます。</p><p>Inheritance Inversionにより、HOCは<em>WrappedComponent</em>インスタンスに<em>this</em>でアクセスできるようになります。つまり、<strong>State、props、コンポーネントのライフサイクルのフック、そしてrenderメソッドにアクセスできる</strong>のです。</p><p>ライフサイクルのフックで何ができるか、ということについて深入りはしません。というのも、これはReactに特有の話であり、HOCに特有の話ではないからです。しかし、IIパターンによってWrappedComponentに新たなライフサイクル・フックを作成できる、ということを付記しておきます。<em>WrappedComponent</em>を壊さないよう、常に<em>super.[lifecycleHook]</em>を呼び出すことを忘れないようにしてください。</p><p><strong>調停プロセス</strong></p><p>詳細に見ていく前に、いくつかの理論をまとめておきましょう。</p><p>React Elementは、「Reactが<a href="https://facebook.github.io/react/docs/reconciliation.html" rel="nofollow" title="" class="ext-link">調停(reconciliation)</a>プロセスを実行するときに何がレンダリングされるか」を説明します。</p><p>React Elementには文字列型のものと関数型のものがあります。文字列タイプのReact Element(String Type React Elements = STRE)はDOMノードを表し、関数タイプのReact Element(Function Type React Elements = FTRE)はReact.Componentを継承することで作られるComponentを表します。ElementとComponentについてより詳細を知るには、<a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html" rel="nofollow" title="" class="ext-link">この投稿</a>を読んでください。</p><p>FTREは、Reactの<a href="https://facebook.github.io/react/docs/reconciliation.html" rel="nofollow" title="" class="ext-link">調停</a>プロセスで完全なSTREツリーとして解決されます(最終結果は常にDOM要素です)。</p><p>これはとても重要です。<strong>Inheritance Inversion</strong>による<strong>High Order Componentは解決された完全な子ツリーを持つとは限らない</strong>ということを意味するのです。</p><p>Render Hijackingを学ぶ際に、このことが重要であるとわかります。</p><p><strong>Inheritance Inversionでできることは何か</strong></p><p><strong>Render Hijacking</strong></p><p>HOCが<em>WrappedComponent</em>のレンダリング結果のコントロール等をすべてできることから、これはRender Hijackingと呼ばれます。</p><p>Render Hijackingにより、以下のことが可能です。</p><p><em>*render</em>は<em>WrappedComponent</em>.<em>render</em>メソッドを指します。</p><p>ここまで学んできたように、II HOCは解決された完全な子ツリーを持つとは限らないのですが、それによってRender Hijackingテクニックにいくらかの制約が生じます。経験則として、Render Hijackingで操作できるのはWrappedComponentのrenderメソッドの出力となっている要素のツリーであり、それ以上でもそれ以下でもありません。もしその要素のツリーが関数タイプのReact Componentを含む場合、そのcomponentの子を計算することはできません(スクリーンに実際にレンダリングされるまでReactの調停プロセスによって遅らせられます)。</p><p>例1：条件に応じたレンダリング。このHOCは、<em>this.props.loggedIn</em>がtrueでない限りは<em>WrappedComponent</em>のレンダリングするものをそのままレンダリングします。(HOCがloggedIn propを受け取るとします)</p><p><script src="https://gist.github.com/franleplant/5220ee01c908a431675c.js"></script></p><p>例2：<em>render</em>で出力されたReact Elementツリーの変更</p><p><script src="https://gist.github.com/franleplant/710a992bb6b1b46312da.js"></script></p><p>この例では、<em>WrappedComponent</em>のレンダリング結果がトップレベルの要素としてinputを持つ場合、そのvalueを<em>“may the force be with you”</em>に変更します。</p><p>こういったあらゆる操作をここで行うことができます。要素ツリー全体をトラバースしたり、ツリー内のどんな要素についてもpropsを変更したりできます。<a href="http://stack.formidable.com/radium/" rel="nofollow" title="" class="ext-link">Radium</a>がやっていることというのはまさにこれです(ケーススタディとしてRadiumについてはより詳細に述べます)。</p><p><strong>Stateの操作</strong></p><p>HOCは、<em>WrappedComponent</em>インスタンスのStateを読込/変更/消去することができ、必要に応じてさらにStateを追加することもできます。<em>WrappedComponent</em>のStateに干渉すると、何かが壊れる結果に至る可能性があることを忘れないでください。ほとんどの場合、HOCはStateを読む/追加するのみに制限されるべきであり、後者については<em>WrappedComponent</em>のStateに干渉しないように名前空間を保つべきです。</p><p>例：<em>WrappedComponent</em>のpropsとStateにアクセスすることでのデバッグ</p><p><script src="https://gist.github.com/franleplant/d7ad9e5083b51a21b381.js"></script></p><p>このHOCは、<em>WrappedComponent</em>を他の要素でラップしており、また、<em>WrappedComponent</em>のインスタンスのpropsとStateを表示します。<em>JSON.stringify</em>によるトリックは<a href="https://twitter.com/ryanflorence" rel="nofollow" title="" class="ext-link">Ryan Florence</a>と<a href="https://twitter.com/mjackson" rel="nofollow" title="" class="ext-link">Michael Jackson</a>が教えてくれました。このデバッガの完全に動作する実装は<a href="https://github.com/franleplant/react-hoc-examples/blob/master/ii_debug.js" rel="nofollow" title="" class="ext-link">こちら</a>でご覧いただけます。</p><p>HOCでComponentをラップする時は、元の<em>WrappedComponent</em>の名前を失うことになり、開発とデバッグに影響が出るかもしれません。</p><p>これについてふつう用いられるのが、<em>WrappedComponent</em>の名前を取ってきて、その頭に何かを付け加えることでHOCの名前をカスタマイズする方法です。以下の例はReact-Reduxからのものです。</p><p><em>getDisplayName</em>は以下のように定義されています。</p><p>実のところ、<a href="https://github.com/acdlite/recompose" rel="nofollow" title="" class="ext-link">recompose</a>ライブラリがすでにこの機能を提供しているため、これを自分自身で書き直す必要はありません。</p><p><a href="https://github.com/rackt/react-redux" rel="nofollow" title="" class="ext-link"><strong>React-Redux</strong></a></p><p>React-Reduxは、Reactのための<a href="http://redux.js.org/" rel="nofollow" title="" class="ext-link">Redux</a>公式バインディングです。機能の一つとして、storeをリスニングしたのちにクリーニングするのに必要なすべてのブートストラップを扱う<em>connect</em>を提供しています。これはProps Proxyでの実装により実現されています。</p><p>純粋な<a href="https://facebook.github.io/flux/docs/overview.html" rel="nofollow" title="" class="ext-link">Flux</a>を使ったことがあればご存知かと思いますが、1つあるいは複数のstoreに紐付けられているReact Componentには、storeリスナーの追加/削除や必要なStateの部分の選択のため、多くのブートストラッピングが必要になります。React-Reduxの実装が大変素晴らしいのは、これらのブートストラップをすべて抽象化してくれるからです。基本的に、自分自身でそれを書く必要がなくなるのです！</p><p><a href="http://stack.formidable.com/radium/" rel="nofollow" title="" class="ext-link"><strong>Radium</strong></a></p><p>Radiumは、インラインスタイルでの<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes" rel="nofollow" title="" class="ext-link">CSS擬似セレクタ</a>の利用を可能にすることで、インラインスタイルの効力を高めるライブラリです。「なぜインラインスタイルが良いのか？」というのは別の議題になってしまいますが、多くの人はそれをし始めていますし、Radiumのようなライブラリはそのゲームを実にステップアップしてくれます。インラインスタイルについてより詳しく知りたい場合は、<a href="https://medium.com/u/46fa99d9bca4" rel="nofollow" title="" class="ext-link">Vjeux</a>による<a href="https://speakerdeck.com/vjeux/react-css-in-js" rel="nofollow" title="" class="ext-link">このプレゼンテーション</a>から始めてみてください。</p><p>それでは、RadiumはどのようにしてhoverのようなCSS擬似セレクタをインラインで使用可能にしているのでしょうか？ここでは、hoverなどのCSS擬似セレクタをシミュレートするために適切なイベントリスナ(新たなprops)を注入するため、Render Hijackingを用いており、そのためにInheritance Inversionをパターンを実装しています。イベントリスナはReact Elementのpropsのハンドラとして注入されます。このために、Radiumは<em>WrappedComponent</em>のrenderメソッドで出力される要素ツリーの全てを読む必要とがあり、style propを持つ要素を見つけ次第イベントリスナのpropsを付与します。単純に言うと、Radiumは要素ツリーのpropsを変更するのです(Radiumが実際に行っていることはもう少し複雑ですが、理解はして頂けたかと思います)。</p><p>RadiumはとてもシンプルなAPIを提供しています。ユーザに気付かれさえせずに全ての仕事をしてくれることを考えると、非常に印象的です。HOCの力を垣間見ることができます。</p><p>HOCにパラメータを利用することは時に有用です。これまで示した例では暗黙のうちに使っていましたし、中級のJavaScript開発者にとっては極めて自然なものでしょうが、この投稿の網羅性のため、簡単にカバーしていきましょう。</p><p>例: 簡単なProps ProxyでのHOCパラメータ。重要なのはHOCFactoryFactoryです。</p><p><script src="https://gist.github.com/franleplant/c8e1e4d2f7244ed1c243.js"></script></p><p>これを以下のように使うことができます。</p><p>親Componentは、単に子を持つReact Componentのことです。ReactにはComponentの子を操作したりアクセスしたりするためのAPIがあります。</p><p>例:親Componentが子にアクセスする</p><p><script src="https://gist.github.com/franleplant/c78566c6b3fe7ad55ee6.js"></script></p><p>それでは、親Componentができること/できないことについて、HOCとの比較や重要な詳細を見つつ検討していきましょう。</p><p>一般的に、もしやりたいことが親Componentでできるのであれば、HOCほどハック的でないのでそちらを用いるべきです。しかし、上記のリストに示した状況であれば、HOCに比べて自由度に欠けます。</p><p>この記事を読んだあと、あなたのReact HOCに関する知識が増えていれば幸いです。React HOCは高い表現力があり、別のライブラリでもとても良いということが分かっています。</p><p>Reactは多くのイノベーションをもたらしましたし、RadiumやReact-Redux、React-Router、その他のプロジェクトを動かしている人たちがそのよい証拠です。</p><p>もし私とコンタクトを取りたければ、ぜひ私をtwitterでフォローしてください。 @franleplant</p><p>この記事で説明したいくつかのパターンを実験するために私の遊んだコードで遊べますので、<a href="https://github.com/franleplant/react-hoc-examples" rel="nofollow" title="" class="ext-link">こちらのリポジトリ</a>も見てみてください。</p><p>React-Redux, Radium, <a href="https://twitter.com/sebmarkbage" rel="nofollow" title="" class="ext-link">Sebastian Markbåge</a>によるこちらの<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" rel="nofollow" title="" class="ext-link">gist</a>、それと私自身の実験に帰するものです。</p>
