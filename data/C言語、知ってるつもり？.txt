<p><a href="https://hackernoon.com/so-you-think-you-know-c-8d4e2cd6f6a6" rel="nofollow" title="" class="ext-link">So you think you know C?</a> by <a href="https://hackernoon.com/@okaleniuk?source=post_header_lockup" rel="nofollow" title="" class="ext-link">Oleksandr Kaleniuk</a></p><p>「Cならわかるよ」というプログラマーは大勢います。確かにCの文法はよく知られているし、44年の歴史を誇るわけだし、あいまいな機能に悩まされることもありません。簡単ですよね！</p><p>あ、「Cならわかるよ」と<strong>言うだけなら</strong>簡単ですよねっていう意味ですよ。学校で習った人もいるだろうしお仕事で使ったことがある人もいるでしょう。覚えることもそんなに多くないし、完璧だという人もいるかもしれません。いいでしょう。でも、Cって実は、そんなにシンプルではないのです。</p><p>嘘だと思うなら、今から挙げる問題を解いてみましょう。たった5問です。基本的にはどれも同じで「戻り値は何ですか？」という問題ばかりです。四択方式で、どの問題も正解はひとつだけです。さあどうぞ。</p><p><code><br>
A. 4<br>
B. 5<br>
C. 8<br>
D. わかりません。</code></p><p><code><br>
A. 0<br>
B. 1<br>
C. 2<br>
D. わかりません。</code></p><p><code><br>
A. 416<br>
B. 160<br>
C. -96<br>
D. わかりません。</code></p><p><code><br>
A. 0<br>
B. 1<br>
C. 16<br>
D. わかりません。</code></p><p><code><br>
A. 1<br>
B. 2<br>
C. 3<br>
D. わかりません。</code><br>
はい、ここまで。鉛筆を置いてください。正解はこの曲のあとで。</p><p>それでは正解です。</p><p>正解は、ぜんぶ「わかりません」でした。</p><p>それでは、ひとつずつ解説していきましょう。</p><p><strong>第1問</strong>は、構造体のパディングを扱ったものです。Cコンパイラは、データをRAMに格納するときに、隙間なくびっしり詰めると効率が悪くなることを知っています。そこでコンパイラは、隙間を入れてデータの配置が揃うようにしています。構造体のデータが5バイトだったとしても、実際にはおそらく8バイトぶん確保していることでしょう。16バイトかもしれませんし、6バイトかもしれません。それ以外になることだってあるでしょう。GCCの<code>aligned</code>属性や<code>packed</code>属性のような拡張を使えば、このあたりをある程度は思いどおりに制御できます。ただ、それは標準規格からは外れています。標準Cにはパディングを扱う属性が定義されていないので、正解は「わかりません」となります。</p><p><strong>第2問</strong>は汎整数拡張に関する問題です。結果が<code>short int</code>の最大値になる式の型が<code>short int</code>になるのは妥当でしょう。でも、妥当だからといって、必ずしもそれがCとして正しいとは限りません。すべての整数の式は、<code>int</code>として扱うというルールがあります。実際のところはもう少し入り組んだ話なのですが、そのあたりは規格書を読んで楽しんでください。</p><p>それはそれとして、ここで比較しているのは型ではなく、そのサイズです。<code>short int</code>と<code>int</code>のサイズについて標準規格が定めていることといえば、前者が後者より大きくなってはいけないということだけです。両者が同じサイズになることだって十分あり得ます。なので、正解は「わかりません」です。</p><p><strong>第3問</strong>は、標準規格がカバーしていない部分に関する問題です。整数のオーバーフローについても、<code>char</code>型の符号の有無についても、標準規格では定められていません。オーバーフロー時の振る舞いは不定だし、後者については実装依存です。そもそも、<code>char</code>型のサイズが何ビットであるかさえも定められていないのです。このサイズが6ビットなプラットフォームもありましたし（<a href="https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C" rel="nofollow" title="" class="ext-link">トライグラフ</a>、覚えてますか？）、5種類の整数型のサイズをすべて32ビットでそろえているプラットフォームもあります。これらがすべて決まらない限り、いくら結果を予測してもそれは無意味です。したがって、正解は「わかりません」です。</p><p><strong>第4問</strong>は少しトリッキーですが、ここまでくればそんなに難問でもないでしょう。みなさんは既に、<code>int</code>型のサイズが標準規格で定められていないことを知っているからです。サイズが16ビットの場合だってあるでしょう。そんな場合は、演算の最初のほうでビットがあふれてしまい、振る舞いは不定になります。これはCのせいではありません。プラットフォームによっては、そもそもアセンブリのレベルでこの挙動が不定な場合もあります。Cコンパイラが演算結果の妥当性を保証するには、大量の処理が必要になってしまうのです。</p><p>というわけで、正解はまた「わかりません」となります。</p><p><strong>第5問</strong>は、まあ古典的なやつですね。<code>+</code>の両オペランドの評価順序についても、前置インクリメント演算子と後置インクリメント演算子との間の優先順位についても、標準規格では定められていません。つまり、<code>i++</code>と<code>++i</code>を含む演算には落とし穴があります。これらはオペランドを変更してしまうからです。あるプラットフォームでは期待どおりに動いたとしても、別のプラットフォームでは違う結果になることだってあり得ます。これが、定義されていない挙動に関する問題です。こんな場面に遭遇したら、答えはいつだって「わかりません」です。</p><p>ここでひとこと謝っておかないといけませんね。どの問題も挑発的なものばかりでした。気を悪くなさったならごめんなさい。</p><p>私がCを覚えたのは1998年ごろで、それから15年くらいはずっと「自分はCができる」と思いこんでいました。大学時代に学んだ言語だったし、最初に入った職場でもいくつかのプロジェクトを成功に導きました。C++を主に使うようになってからも、C++は要するに肥大化したCだと考えていました。</p><p>そんな考えを改めることになったのが2013年のこと。安全性が最重要視されるPLCプログラミングにかかわるようになったときでした。それは原発のオートメーションに関する研究プロジェクトで、仕様化されていない挙動は絶対に受け入れられませんでした。Cのプログラミングについてはよく知っているつもりでしたが、改めて学びなおす必要がありました。そして、知ってるつもりだったことの大半が、間違いだったのです。学びなおすのは、それはもうつらいことでした。</p><p>言い伝えに頼るのではなく標準規格を参照すること、推測を信じるのではなく計測すること、そして「とりあえず動く」は疑ってかかること。エンジニアとしての姿勢を学びなおすことになりました。ここがポイント。人ごとだと思わないでくださいね。</p><p>今回のちょっとしたテストが、過去の私のような人たちの考えを（15年もかけずに15分で）改めさせる助けになることを願います。</p>
