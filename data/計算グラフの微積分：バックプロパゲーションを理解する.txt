<p><a href="http://colah.github.io/posts/2015-08-Backprop/" rel="nofollow" title="" class="ext-link">Calculus on Computational Graphs: Backpropagation</a> （2015-08-31） by <a href="https://twitter.com/ch402" rel="nofollow" title="" class="ext-link">Christopher Olah</a></p><p>バックプロパゲーションとは、ディープモデルの学習を計算可能にしてくれる重要なアルゴリズムです。現代のニューラルネットワークでは、最急降下法という計算法を使えば単純な実装と比べて1000万倍の速さで学習ができます。例えば、最急降下法では学習に1週間しかかからないのに対して、単純な実装では同じことをやると20万年かかる計算になります。</p><p>ディープラーニングでの使用以外にも、バックプロパゲーションはさまざまな分野で使えるとても便利な計算ツールです。それぞれで呼ばれる名称は違うのですが、天気予報から、数値的安定性を分析する時にまで多岐にわたり使用できます。実際に、このアルゴリズムは、いろいろな分野で少なくとも20回は再開発されています（参照：<a href="http://www.math.uiuc.edu/documenta/vol-ismp/52_griewank-andreas-b.pdf" rel="nofollow" title="" class="ext-link">Griewank（2010）</a>）。一般的な用途自体の名前は”リバースモード微分”といいます。</p><p>基本的に、この技術は微分の計算をスピードアップさせるものです。ディープラーニングだけではなく、さまざまな計算法の場面で、気軽に使える必要不可欠な方法です。</p><p>計算グラフは数式を考える上でとてもいい手段です。例えば、<script type="math/tex">e=(a+b)*(b+1)</script>という数式があるとしましょう。これには3つの演算があります。加算が2つと、乗算が1つです。話を進めるために、追加で<script type="math/tex">c</script>と<script type="math/tex">d</script>という2つの変数を加えましょう。こうすれば、全ての関数の出力を変数と考えることになります。以下のように表せます。</p><p><script type="math/tex">c=a+b</script><br>
<script type="math/tex">d=b+1</script><br>
<script type="math/tex">e=c*d</script></p><p>そして、入力変数に沿ってこれらの演算を節点にして計算グラフを作ります。ある節点の値が別の節点の入力となっていたら、矢印をそちらに向けてつなぎます。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/tree-def.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-53"><br>
このようなグラフはコンピュータ・サイエンスの世界で関数プログラムの話になると常に登場してきます。依存性グラフやコールグラフの考え方ととても似ています。また、これは<a href="http://deeplearning.net/software/theano/" rel="nofollow" title="" class="ext-link">Theano.</a>という人気のあるディープラーニングのフレームワークと関わりのあるコアの抽象化概念でもあります。</p><p>この式の値を求めるには、入力変数に特定の値を代入し、節点をグラフの下から上に計算していきます。例えば、<script type="math/tex">a=2</script>、<script type="math/tex">b=1</script>だとしましょう。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/tree-eval.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-54"><br>
式の値は6となりました。</p><p>計算グラフの微分を理解するには、辺の微分を理解するのがポイントです。もしaが直接的にcに作用するならば、どのようにcに作用があるのか探りたくなりますよね。もしaが少しでも変化すれば、cはどうやって変化していくのでしょうか。これを、aに対するcの偏微分と呼びます。</p><p>このグラフの偏微分の値を求めるには、<a href="https://en.wikipedia.org/wiki/Sum_rule_in_differentiation" rel="nofollow" title="" class="ext-link">和の微分法則</a>と<a href="https://ja.wikipedia.org/wiki/%E7%A9%8D%E3%81%AE%E5%BE%AE%E5%88%86%E6%B3%95%E5%89%87" rel="nofollow" title="" class="ext-link">積の微分法則</a>が必要になります。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd.jpg" alt="d_postd" width="366" height="193" class="size-full wp-image-5831"></a><br>
以下のグラフは、微分係数がそれぞれの辺に書いてあります。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/tree-eval-derivs.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-55"></p><p>直接つながっていない節点同士の関係は、どのように理解すればよいでしょうか。理解するためには、aはどのようにeに作用しているのか考えてみましょう。もし1の速さでaが変化したら、cも同じように1の速さで変化します。次に、1の速さで変化するcは、2の速さでeに作用します。つまり、aに対するeは1*2の割合で変化することになります。</p><p>このグラフの原則では、ある節点から別の節点にいく道筋の全てのパターンを合計します。道筋のそれぞれの辺の微分係数を全て掛けるのです。例えば、bに対するeの微分係数を求めるには以下のような式になります。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd2.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd2.jpg" alt="d_postd2" width="271" height="120" class="size-full wp-image-5829"></a></p><p>これは、bがcを通してどのようにeに作用し、また、dを通してどのように作用したかによります。この”道筋の合計”の原則は単に、<a href="https://en.wikipedia.org/wiki/Chain_rule#Higher_dimensions" rel="nofollow" title="" class="ext-link">多変数の連鎖律</a>の別の考え方と思ってください。</p><p>単に”道筋の合計”を行うことの問題は、道筋の数によって容易に組合せが爆発的に増加するということです。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/chain-def-greek.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-56"></p><p>上の図では、XからYへの道筋は3つあり、さらにYからZに3つの道筋があります。全ての道筋を合計することで微分を求めようとすると、3∗3=9の道筋の和が必要です。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd3.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd3.jpg" alt="d_postd3" width="644" height="86" class="size-full wp-image-5830"></a><br>
道筋は、上の図では9通りだけでしたが、グラフが複雑になれば、その数が飛躍的に増加するのは想像に難くありません。<br>
そうした場合、単純に道筋を加算するよりも、それを因数分解した方がはるかに得策でしょう。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd4.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/01/d_postd4.jpg" alt="d_postd4" width="389" height="92" class="size-full wp-image-5828"></a><br>
ここで使われるのが”フォワードモード微分”と”リバースモード微分”です。この2つは、道筋を因数分解することで効率的に合計を算出できるアルゴリズムで、明示的に全ての道筋を合計する代わりに各節点で道筋を1つに結合し、同じ和をより効率的に導き出します。実際のところ、両方のアルゴリズムでは厳密に1回、各辺を通ります。</p><p>フォワードモード微分はグラフへの入力で始まり、各節点で与えられた全ての道筋を合計しながら、終わりに向かって移動します。それぞれの道筋は、入力から節点への作用のしかたを表すものです。道筋を加算していくことで、入力が節点に与える全ての作用のしかたを得ることができます。それが微分係数です。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/chain-forward-greek.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-57"><br>
<em>注釈：フォワードモード微分</em></p><p>グラフという点から見ると想像しにくいかもしれませんが、フォワードモード微分は、微積分を学ぶ際に自然に身に付くことに、とても近いのです。</p><p>リバースモード微分はそれとは逆で、グラフの出力から始まり、節点で発生した全ての道筋をマージしながら、先頭に向かって移動します。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/chain-backward-greek.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-58"><br>
<em>注釈：リバースモード微分</em></p><p>ある入力がどのように各節点に作用するのかを追跡するのがフォワードモード微分だとすれば、各節点がある出力にどう作用するのかを追跡するのがリバースモード微分だと言えるでしょう。つまり、フォワードモード微分は<script type="math/tex">\frac{\partial}{\partial X}</script>演算子を全ての節点に適用し、リバースモード微分は<script type="math/tex">\frac{\partial Z}{\partial}</script>演算子を全ての節点に適用しているというわけです。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup></p><p>この時点で皆さんは、誰がリバースモード微分に関心を持つのか、と不思議に思われるかもしれません。確かに、フォワードモード微分と結果が同じ割には、ずいぶんおかしな方法に見えます。どんな利点があるのでしょうか。<br>
ここで、再び最初の例を考えてみることにしましょう。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/tree-eval-derivs.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-59"><br>
bから上がってフォワードモード微分すると、bに対する全ての節点の微分係数を得ることができます。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/tree-forwradmode.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-60"><br>
入力の1つに対する出力の微分係数である<script type="math/tex">\frac{\partial e}{\partial b}</script>を計算しました。</p><p>これを、eから下りてリバースモード微分するとどうなるでしょうか。以下のように、全ての節点に対するeの微分係数を得ることができます。</p><p><img src="http://colah.github.io/posts/2015-08-Backprop/img/tree-backprop.png" alt="" data-disqus-identifier="/posts/2015-08-Backprop/disqussion-61"><br>
リバースモード微分で、全ての節点に対するeの微分係数を得られるということに言外の意味はなく、実際に<em>全ての節点</em>を意味しています。得ることができるのは、両方の入力に対するeの微分係数の両方、つまり<script type="math/tex">\frac{\partial e}{\partial a}</script>と<script type="math/tex">\frac{\partial e}{\partial b}</script>です。フォワードモード微分では「1つの入力に対する出力の微分係数」が得られるだけですが、リバースモード微分ではそれらの全てが得られるのです。</p><p>このグラフでは、計算速度は2倍にアップしただけですが、例えば100万の入力と1つの出力を持つ関数があると考えてみてください。フォワードモード微分だと、微分係数を得るのにグラフを100万回行き来しなければなりませんが、リバースモード微分だと1回の降下で全てが得られます。100万倍のスピードアップともなれば、その魅力も100万倍です。</p><p>ニューラルネットワークの学習においては、パラメータ（ネットワークの挙動を記述する数字）の関数としてコスト（ニューラルネットワークの不適切な実行を記述する値）を考えています。<a href="https://ja.wikipedia.org/wiki/%E6%9C%80%E6%80%A5%E9%99%8D%E4%B8%8B%E6%B3%95" rel="nofollow" title="" class="ext-link">最急降下法</a>を用いるには、全てのパラメータに対するコストの微分係数を計算する必要があります。また、ニューラルネットワークではパラメータが100万あるいは1,000万あることも珍しくありません。そんな時、リバースモード微分（ニューラルネットワークではバックプロパゲーションと呼ばれています）がスピードアップの大きな力となってくれるのです。</p><p>（逆にフォワードモード微分が理に適っているような状況はあるのでしょうか。もちろん、あります。リバースモードでは、全ての入力に対して1つの出力の微分係数が得られますが、フォワードモードでは、1つの入力に対して全ての出力の微分係数が得られます。つまり、出力の数が多い関数の場合、フォワードモードの方がはるかに高速に計算できるというわけです。）</p><p>私が初めてバックプロパゲーションとは何か理解した時は、「ああ、これはまさに連鎖律だ！　考案されるまでなぜこんなに時間がかかったんだ？」と思いました。そう思ったのは私だけではありません。事実、「フィードフォワードニューラルネットワークの微分係数を計算するための良い方法はないだろうか？」と思案した場合、この考えに行きつくことはそう難しいことではありません。</p><p>しかしこれは見かけよりはずっと難しかったと私は思います。ご存知のように、バックプロパゲーションが考案された当時、フィードフォワードニューラルネットワークはそれほど注目されていませんでした。また、微分を学習に使うのが正しいのかも定かではなかったのです。微分を速く計算するには循環依存の関係を使えばよかったのですが、みんなが気づいたのはあとになってのことでした。</p><p>さらに悪いことに、「循環依存は使用できない」と見切りをつけるのはとても容易でした。ニューラルネットワークの学習に微分を使う？　間違いなく極小値で行き詰まるだけです。それに全ての微分係数をコンピュータで計算すると高くつくのは明らかでしょう。そのアプローチでうまく行きそうにない理由のリストアップをすぐ始めたりしないのは、うまく行くことを今なら知っているからに過ぎません。</p><p>これは後知恵というものです。質問をする時には、一番大変な仕事は終わっているのです。</p><p>微分はあなたが思うより気軽に使えます。それがこの記事における主な教訓です。微分が手軽なのは論理的な事実なのですが、私たち愚かな人類はその事実を何度も再発見しなければなりませんでした。ディープラーニングを理解するのは大事なことです。そして、他の分野を知ることは、特にそれが周知の事実ではない場合、大変役に立ちます。</p><p>他にも教訓があるかって？　あると思いますよ。</p><p>バックプロパゲーションは、あるモデルで微分の流れを理解しようとする時にも大変便利です。流れがわかることは一部のモデルの最適化が困難な理由を説明するのにとても役立ちます。典型的な例としては、リカレントニューラルネットワークにおける勾配ベクトルの減少が挙げられます。</p><p>最後に私は、これらの技術からアルゴリズムに関する一般的な教訓を得られると断言します。バックプロパゲーションとフォワードモード微分は一組の強力な手段（線形化と動的計画法）を使って、人が想像する以上に効果的に微分を計算します。これらの技術をきちんと理解すれば、微分を含むいろいろな興味深い式を効率よく計算できます。私たちはこのことを今後のブログ記事で掘り下げていく予定です。</p><p>この記事ではバックプロパゲーションのごく概要的な処理にのみ触れました。Michael Nielsenが書いた記事の<a href="http://neuralnetworksanddeeplearning.com/chap2.html" rel="nofollow" title="" class="ext-link">この章</a>を読むことを強くお勧めします。考察に優れ、ニューラルネットワークに関してより具体的に焦点が当てられています。</p><p>この記事の校正をしてくれた<a href="http://research.google.com/pubs/GregCorrado.html" rel="nofollow" title="" class="ext-link">Greg Corrado</a>、<a href="https://shlens.wordpress.com/" rel="nofollow" title="" class="ext-link">Jon Shlens</a>、<a href="http://bengio.abracadoudou.com/" rel="nofollow" title="" class="ext-link">Samy Bengio</a>、<a href="http://www.vision.caltech.edu/anelia/" rel="nofollow" title="" class="ext-link">Anelia Angelova</a>に感謝します。</p><p>それから、バックプロパゲーションをどう説明するか議論してくれた<a href="http://colah.github.io/posts/2015-08-Backprop/" rel="nofollow" title="" class="ext-link">Dario Amodei</a>、<a href="http://michaelnielsen.org/" rel="nofollow" title="" class="ext-link">Michael Nielsen</a>、<a href="http://www.iro.umontreal.ca/~bengioy/yoshua_en/index.html" rel="nofollow" title="" class="ext-link">Yoshua Bengio</a>にも感謝します。そして、討議やセミナーの席で、私がバックプロパゲーションの説明を練習することを許してくれた皆さん、ありがとうございました！　</p><p>注釈</p>
