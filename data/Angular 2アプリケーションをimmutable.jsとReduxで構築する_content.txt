building angular 2 applications with immutable.js and redux （2016-7-4） by Houssein Djirdeh過去にJavaScript開発をやったことがある人であれば、Reduxのことは聞いたことがあるでしょう。Reactとともに一般に普及し、開発者の中には「当時のJavaScript関係で一番興奮した出来事だった」、「アプリケーションの構築に大変革をもたらした」、はては「Reduxのおかげで地球温暖化が完全に止まった」と言う人もいるくらいです。失礼、ちょっと我を忘れてしまいました。しかし、真面目な話、Reduxはアプリケーションの構築方法に、変化をもたらしたのは本当です。この投稿では、Reduxを別のライブラリのImmutable.jsと一緒に、Angular 2と統合するやり方をご説明します。この投稿では、FluxアーキテクチャとReduxの基本的な概念を考えていきます。それから、簡単な連絡先リストのアプリケーションを段階的に作っていきます。初めは基本的なセットアップを構築し、その後、不変性を追加し、最後にはReduxの状態のコンテナを作成します。デモを見る
ソースコード
進めていく上で、なぜそれをしなければいけないかを1つずつ丁寧に説明していくよう努めます。最後までいってもアプリケーションは完成しませんが、おおまかなやり方をつかんでいただけると思います。Fluxはユーザインターフェースを構築するための、簡単なアーキテクチャパターンです。フレームワークやライブラリではありません。クライアントサイドのアプリケーションを構築するためのデザインパターンなのです。
ソース：Flux Documentation『Structure and Data Flow』ReduxはDan Abramov氏が開発したFluxの実装です。Fluxはそれ自身がライブラリではないので、FacebookはFlux中心のアプリケーションが利用できるDispatcherライブラリを作成しました。Reduxも同じアーキテクチャですが、これは特定の抽象化を簡単にするために作られたものになります。基本的な性質を見てみましょう。1) アプリケーション内の変更はすべて、1つのJavaScriptオブジェクト、つまりストアに格納される。
2) オブジェクトストアはアプリケーションの状態のコンテナとして機能します。
3) 状態は読み取り専用で、変更できない（つまり、不変である）。
4) 状態に変更を加える（ユーザイベントやAPIインタラクションなど）には、変更を説明するJavaScriptオブジェクトを送る必要がある。つまり、アクションをディスパッチする。
6) データはストアからビューに転送され、その逆方向への転送はない。よって、ビューは状態を変更することができない。前述したように、状態変更は現在の状態を変更することはできません。Reduxでは、変更が発生するたびに、新しいJSONオブジェクトが返されなければいけません。これを実現するために、状態の変更は純粋関数を使ってトリガーさせる必要があります。純粋関数は同じ入力に対しては常に同じ値が帰ってくるという関数です。つまり、外のものは何も変更ができないということです。外部変数を変更したり、データベースを呼び出すこともできません。Reduxでは、これらはReducerとして知られ、アプリケーションの状態がアクションに対応してどのような変更するかの決定を下します。ここまでできて、まだはっきりと理解できていなくても大丈夫です。先に読み進め、Reducerやアクション、ストアが具体例の中でどう使われているのか見ていけば、理解はどんどん深まるはずです。では、連絡先リストを実際に構築していきましょう。まだの人がいれば、Angular 2 QuickStartを使ってアプリケーションをセットアップすることもできます。今回は、埋め込みコードでのクラスの定義やスタイルの要素などの必要のないものは省略し、必要なものだけを説明しますが、それぞれのステップの最後には、完全なソースコードのリンクを貼っておきますので、参考にしてください。まずは、純粋にAngularの要素で簡単なものを構築してみましょう。最初にContact Storeでアプリケーションのロジックを処理します。このやり方はAngular 1.xでサービスをセットアップする方法にとても似ています。これで、ストアが連絡先を追加、削除、お気に入りに登録できるアプリケーションの状態を制御するようになりました。では、コンポーネントをセットアップします。ここでは、プライベートなstoreプロパティを定義し、それをContactStoreインジェクションとして特定するコンストラクタがあります。addContact、removeContact、starContactなどの入力のメソッドはすべて、ContactStoreのそれぞれのメソッドにリンクしています。今のところ、使用可能なシンプルなものを構築することに成功しました。いい滑り出しです。ソースコードはこちらからどうぞ。Angular 2はコンポーネントベースなので、連絡先ごとにコンポーネントがあることは理にかなっています。実際のリスト上で親コンポーネントを設定しましょう。そして、子コンポーネントはこの連絡先のコンポーネントとなります。ご覧のとおり、ストアインスタンスは親コンポーネントにも子コンポーネントにも挿入されました。少し理解が深まったのではないでしょうか。ソースコードはこちらからどうぞ。Angular 2では、すべてのコンポーネントがそれぞれでChange Detectorを持っており、それぞれのテンプレートでバインドするようになっています。例えば、私たちはContactコンポーネントにバインドする{{ contact.name }}を持っています。つまり、Contactコンポーネントの裏にあるChange Detectionは、contact.nameとその変更のデータを提示するのです。では、イベントが引き起こされると何が起きるのでしょう。Angular 1.xでは、digestサイクルが起動すると、すべてのバインディングがアプリケーション全体で引き起こされます。Angular 2でも似ていて、すべてのコンポーネントがチェックされます。Angularは、イベントが起きるたびではなく、入力プロパティの中の1つが変更されたときだけ、コンポーネント上でChange Detectionを始めるんです。いいでしょう？　私たちのコンポーネントレベルではAngularのChangeDetectionStrategyを使ってこれができます。こんなに簡単なんです！　このコンポーネントのChange Detectionは、コンポーネントのバインディングに変更が起きたときのみ、起動するようになりました。ちなみに、今回のようなシンプルなアプリケーションでこれは本当に重要なことでしょうか？　そもそもアプリケーションに多くのバインディングがなければ意味はありません。しかし、巨大なアプリケーションでは、イベントが引き起こされるたびにバインディングの数をかなり減らすができ、とても有効です。Change Detection Strategyを有効活用するには、状態を完全に不変にしておく必要があります。しかし、JavaScriptオブジェクトの性質として、初期設定で可変になっています。そこで、Facebookのチームが開発したライブラリであるImmutable.jsを使用します。簡単に言えば、不変オブジェクトは本質的に変更されないオブジェクトなのです。それらを変更するには、変更したい内容の参照オブジェクトを新たに作成し、元のオブジェクトは残しておく必要があります。Immutable.jsは、アプリケーションに含めることのできる不変データストラクチャを数多く提供してくれます。不変性は、npm install immutableでインストールできます。インストールができたら、SystemJSの設定をアップデートしなければなりません。もし、Angular 2 QuickStartに従ってアプリケーションをセットアップしたなら、systemjs.config.jsファイルの中にあります。あとは、割り当てられたらフィールドをもう1つ追加し、システムローダが、immutableが参照されたときに正しいファイルを探せるようにするだけです。これだけです。では、ContactStoreを更新しましょう。ご覧の通り、contactsのインスタンス化を変更し、配列の代わりにListを使っています。ListはJavaScriptの配列と類似していますが、不変であり、完全に持続性があります。リストへの変更を持続させるために、pushとdeleteとupdateのメソッドを使っています。配列と同じように、indexOfもリストの中の選択された連絡先を探すのに使われます。重要なのは、これらのすべてのメソッドでは、現在のコレクションは変更されませんが、新しく不変コレクションが生成されるということです。ソースコードのリンクはこちらです。注釈：もしかしたら、なぜstarContactメソッドで、&lt;any&gt;を使うのか疑問に思っている人もいるかもしれません。これはただのTypeScriptの型のアサーションで、アップデートされた連絡先のオブジェクトを返す時のコンパイラエラーを防いでいます。これは、リストに対してメソッドを実行したときの型定義にともなう問題があるため、単なる回避策なのです（こちらで詳しく解説しています）。Reduxは、npm install --save reduxでインストールできます。また、ここでシステム設定のアップデートを再度してください。ここで、アクションファイル追加します。ご覧のとおり、すべてのアクションは、シンプルなJavaScriptオブジェクトなのです。例えば以下のようになります。Reduxでは、アクションは実行されるアクションの型を説明するtypeプロパティを必ず必要とします。また、文字列定数として定義することをおすすめします。これ以外にも、アクションのストラクチャをあなたの好きなようにセットアップできます。私はそれぞれのアクションで必要なもののみを含むようにセットアップし、idとnameで連絡先を追加し、idで削除とお気に入りに登録することができるようにしました。それぞれのアクションが、それを作った関数の中に含まれているのが分かるはずです。これらはaction creatorとして知られ、それぞれが、生成したIContactActionインターフェースに定義されます。では、次にreducerのセットアップの仕方を見ていきましょう。純粋関数に関して先ほど言ったことを覚えているでしょうか？　reducerは状態を変更しませんし、副作用もありません。それぞれのアクションに対して、新しく生成された状態をただ返すだけなのです。では、必要なストアのアップデートを実行しましょう。シンプルでいいですね。createStoreメソッドは、アプリケーションの完全な状態を持っているReduxストアを生成します。第二引数では、アプリケーションのプリロードされた状態に不変の連絡先リストを挿入します。現在の状態はgetStateでアクセスされ、アクションはdispatchメソッドでディスパッチされます。そして、Contactクラスにidフィールドを追加します。では、コンポーネントコンタクトメソッドをアップデートしましょう。インクリメントしたIDの値は追加されたそれぞれの連絡先にセットされます。actionsから適切なアクションをインポートし、dispatchでアクションを実行します。では、子コンポーネントを見てみましょう。これで終わりです。アプリケーションでのReduxの基本的な使い方はすべて説明しました。最後のソースコードはこちらからどうぞ。お気付きだとは思いますが、Reduxの状態コンテナと一緒に不変コレクションを実装することは、アプリケーションに複雑性が増すことにつながります。今回の方法はAngularアプリケーションを構築する唯一の選択肢ではないですし、最善のやり方でもありません。複数ある中の1つのやり方であり、特定の状況下では力を発揮するものになっているはずです。初期設定で、Angularのchange detectionはアプリケーションで変更が生じたすべてのコンポーネントをチェックすることになっています。不変性を強制することで、いくつかのコンポーネント上で、ChangeDetectionStrategy.OnPushを使えるようになり、必要なときだけ、チェックするようになりました（つまり、入力プロパティが変更されたときです）。このシンプルで使いやすい方法を実行するにはImmutable.jsのようなライブラリを使いましょう。これよりもいい質問はこうでしょう。「アプリケーションでFlux型アーキテクチャはいつ実行すべきか？」。これに対する答えは、この回答がすべてを語ってくれています。Angular 2でChange Detectionがどのように機能するのかを詳しく説明している資料です。Change Detection in Angular 2―Victor Savkin
Angular 2 Change Detection Explained―ThoughtramDan Abramov氏がegghead.ioにすばらしいレッスンを載せています。―Getting Started with ReduxColin Eberhardt氏が状態の永続性とタイムトラベルをRuduxと統合する方法を分かりやすく説明しています。―Angular 2 Time Travel with Redux
