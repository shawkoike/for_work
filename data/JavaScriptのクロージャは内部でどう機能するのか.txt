<p><a href="http://dmitryfrank.com/articles/js_closures" rel="nofollow" title="" class="ext-link">How do JavaScript closures work under the hood</a> by <a href="http://dmitryfrank.com/about" rel="nofollow" title="" class="ext-link">Dmitry Frank</a></p><p>もうだいぶ前からすでに私はクロージャを使っています。使い方を学びましたが、実際にクロージャがどう機能するのか、また、使うと隠れたところで実際に何が起きるのかを明確に理解しているとは言えませんでした。そもそも、クロージャとは一体何なのでしょうか。<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3" rel="nofollow" title="" class="ext-link">ウィキペディア</a>はあまり役に立ちません。クロージャはいつ生成され、いつ削除されるのでしょうか。どのように実装されるべきなのでしょうか。</p><p>やっと理解できた時は、非常に興奮しました。そして、解説しようと思ったのです。もう絶対に忘れることはありませんから。下記の格言のようにね。</p><p>クロージャについての説明をいろいろと読みあさり、どのオブジェクトが他の何を参照するのか、どのオブジェクトを継承するのかなど、オブジェクト同士の関係について想像してみました。結局、役に立つイラストを見つけることができませんでしたので、自分で図に描くことにしました。</p><p>読者のみなさんはすでにJavaScriptに詳しく、Global Objectが何か、グローバルオブジェクトがJavaScriptの関数で第一級オブジェクトであることなどを知っていると思います。</p><p>JavaScriptのプログラムを実行している時、ローカル変数を格納する場所が必要になります。それを、スコープオブジェクト(<code>LexicalEnvironment</code>とする人もいます)と呼びましょう。例えば、ある関数を呼び出し、関数がローカル変数を定義した時、これらの変数をスコープオブジェクトに保存します。オブジェクト自体を直接参照できないという重要な点以外では、普通のJavaScriptオブジェクトと同じだと思って良いでしょう。これらのオブジェクトはプロパティのみ変更でき、スコープオブジェクト自体を参照することはできません。</p><p>このスコープオブジェクトの概念は、ローカル変数をスタックに保存するC言語やC++とは異なります。JavaScriptで、ローカル変数はヒープ領域に割り当てられます（あるいは、そうかのように振る舞います）。そのため、関数が返された後も、割り当てられたままかもしれません。これについては、後でさらに触れます。</p><p>期待どおり、スコープオブジェクトには親がいます。コードで変数にアクセスしようとすると、現在のスコープオブジェクトのプロパティをインタープリタが検索します。プロパティが存在しない場合、インタープリタは親のスコープオブジェクトのプロパティを検索します。これは、値が見つかるまで、あるいは、親が存在しないと分かるまで続きます。このスコープオブジェクトのシーケンスをスコープチェーンと呼びましょう。</p><p>スコープチェーンで変数を解決する振る舞いは、プロトタイプ継承でのそれに似ていますが、一つ重要な違いがあります。プロトタイプチェーンの場合、普通のオブジェクトの存在しないプロパティへアクセスを試みて、そのプロパティがプロトタイプチェーンにも存在しない場合、エラーではなくただ<code>undefined</code>を返すのに対し、スコープチェーンの存在しないプロパティ（例えば、存在しない変数）にアクセスを試みると、<code>ReferenceError</code>が発生することです。</p><p>スコープチェーンの最後の要素は常にグローバルオブジェクトです。トップレベルのJavaScriptコードの場合、スコープチェーンの要素はグローバルオブジェクトのみとなります。そのため、トップレベルのコードで変数を定義する場合は、グローバルオブジェクトに定義されます。ある関数が呼び出されるとスコープチェーンは複数のオブジェクトを含みます。トップレベルのコードで関数を呼び出すと、ちょうど2つオブジェクトをスコープチェーンに含むことが保証されると思うかもしれませんが、必ずしもそうではありません。関数によって異なりますが、2つ以上のスコープオブジェクトが存在することがあります。これについては、後でさらに触れます。</p><p>理論はここまでにして、実際にコードを見てみましょう。下記はとても簡単な例です。</p><p><a href="http://dmitryfrank.com/_export/code/articles/js_closures?codeblock=1" rel="nofollow" title="" class="ext-link">my_script.js</a></p><p>変数を2つだけトップレベルコードで生成します。上記でも述べたように、トップレベルコードではスコープオブジェクトはグローバルオブジェクトです。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_1.png" class="media" alt=""></p><p>上記の図では、実行コンテクスト（ただの<code>my_script.js</code>のコード）があり、スコープオブジェクトを参照しています。実際には、標準でホストに限定されたものが<code>Global Object</code>に多く含まれていますが、図ではそれを省いています。</p><p>では、今度は下記のスクリプトを検討しましょう。</p><p><a href="http://dmitryfrank.com/_export/code/articles/js_closures?codeblock=2" rel="nofollow" title="" class="ext-link">my_script.js</a></p><p><code>myFunc</code>関数が定義されると、<code>myFunc</code>識別子が現在のスコープオブジェクトに追加されます（この場合はグローバルオブジェクト）。この識別子が<strong>関数オブジェクト</strong>を参照します。関数オブジェクトは、関数のコードや他のプロパティを持っています。ここで興味があるのは、internalプロパティの<code>[[scope]]</code>です。これは、<strong>現在のスコープオブジェクト</strong>を参照します。つまり、関数が定義された時（この場合も、グローバルオブジェクト）に、アクティブ状態のスコープオブジェクトを参照します。</p><p>そのため、<code>console.log("outside");</code>が実行される時には、次のような構成になります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_2.png" class="media" alt=""></p><p>ここでもまた、ちょっと考えてみましょう。<code>myFunc</code>変数が参照する関数オブジェクトは、関数コードを保持するだけでなく、関数が定義された時に有効なスコープオブジェクトを参照します。<strong>これはとても重要です。</strong></p><p>関数が<em>呼び出される</em>と、<code>myFunc</code>（とその引数の値）のローカル変数を持つ新しいスコープオブジェクトが生成されます。そして、この新しいスコープオブジェクトは、関数を呼び出した時に参照したスコープオブジェクトを継承します。</p><p>そのため、実際には<code>myFunc</code>が呼び出され、次のような構成になります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_3.png" class="media" alt=""></p><p>ここにあるのが<em>スコープチェーン</em>です。<code>myFunc</code>内の変数にアクセスしようとすると、まずJavaSciptは、最初のスコープオブジェクト<code>myFunc() scope</code>で検索します。検索が失敗すると、チェーンの次のスコープオブジェクト（この場合は<code>Global object</code>）を検索します。リクエストされたプロパティがチェーンの全てのスコープオブジェクトにない場合、<code>ReferenceError</code>が発生します。</p><p>例えば、<code>myFunc</code>から<code>a</code>にアクセスした場合、<code>myFunc()　scope</code>から<code>1</code>の値が返されます。<code>foo</code>にアクセスした場合は、同じ<code>myFunc()　scope</code>から<code>3</code>の値を返し、<code>foo</code>プロパティを効果的に<code>Global object</code>から隠します。<code>bar</code>にアクセスした場合は、<code>Global object</code>から<code>2</code>の値が返されます。プロトタイプ継承のような動作をします。</p><p>ここで覚えておかなければならない重要な点は、これらのスコープオブジェクトは参照されている限り存続するということです。しかし、ある特定のスコープオブジェクトへの参照がなくなると、ガベージコレクションが起動し、そのスコープオブジェクトは解放されます。</p><p><code>myFunc()</code>が完了し、<code>myFunc() scope</code>が参照されていないと、ガベージコレクションが起動し、解放されてしまうため、次のような構成になります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_2.png" class="media" alt=""><br>
これ以降は、図が大きくなりすぎてしまうため、明確な関数オブジェクトを省きます。もうすでにご存じだと思いますが、JavaScriptで関数を参照するということは、関数オブジェクトを参照することで、同じくスコープオブジェクトを参照します。</p><p>このことを忘れないでください。</p><p>前にも述べたように、関数が完了すると、スコープオブジェクトの参照が外れるため、ガベージコレクションにより処理されます。しかし、関数をネストして定義して返した（あるいは、外部に保存した）場合はどうでしょうか。ご存じのとおり、関数オブジェクトは常にその関数オブジェクトを生成したスコープオブジェクトを参照します。そのため、ネストされた関数を定義する場合、外側の関数の現在のスコープオブジェクトを参照します。また、ネストされた関数を外部のどこかに格納すると、ネストの外側の関数が返されても参照は維持されるため、スコープオブジェクトがガベージコレクションにより処理されることはありません。次を考えてみてください。</p><p><a href="http://dmitryfrank.com/_export/code/articles/js_closures?codeblock=3" rel="nofollow" title="" class="ext-link">my_script.js</a></p><p><code>createCounter(100);</code>を呼び出すと、次のような構成になります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_4.png" class="media" alt=""></p><p>お気づきだとは思いますが、ネストされた関数<code>increment</code>と<code>get</code>が、<code>createCounter(100) scope</code>を参照しています。しかし、<code>createCounter()</code>が、これらの関数を参照するオブジェクトを返すため、次のようになります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_5.png" class="media" alt=""></p><p>ちょっと考えてみましょう。<code>createCounter(100)</code>がすでに返されていますが、返されたオブジェクトのスコープは存在し、内部の関数によってのみアクセスすることができます。<code>createCounter(100)</code>スコープオブジェクトに直接アクセスするのは全く不可能であり、<code>myCounter.increment()</code>あるいは<code>myCounter.get()</code>の呼び出しだけが可能です。これら関数は、<code>createCounter</code>スコープに特別に直接アクセスできるようになっています。</p><p>では、例として<code>myCounter.get()</code>を呼び出してみましょう。どの関数を呼び出しても新しいスコープオブジェクトが生成され、参照するスコープチェーンはこの新しいスコープオブジェクトによって増やされていくことを思い出してください。そのため、<code>myCounter.get()</code>を呼び出すと、次のようになります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_6.png" class="media" alt=""></p><p>チェーン内での、関数<code>get()</code>の最初のスコープオブジェクトは空のオブジェクト<code>get() scope</code>なので、<code>get()</code>が変数<code>counter</code>にアクセスする時、JavaScriptはスコープチェーン内の最初のオブジェクト上では見つけられず、次のスコープオブジェクトに移動します。そして変数<code>counter</code>を<code>createCounter(100) Scope</code>で使い、関数<code>get()</code>はただそれを返します。</p><p>お気づきかもしれませんが<code>myCounter</code>オブジェクトは、<code>this</code>（図の中で赤い矢印で示されている箇所）として追加で<code>myCounter.get()</code>に渡されています。なぜかというと、<code>this</code>は決してスコープチェーンの一部にはならず、そのことを認識しておく必要があるからです。このことについては<a href="http://dmitryfrank.com/articles/js_closures#scope_chain_and_this" rel="nofollow" title="" class="ext-link">後ほど</a>もう少しご説明します。</p><p><code>increment(5)</code>の呼び出しはもう少し面白いものです。引数を持つ関数だからです。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_6_inc.png" class="media" alt=""></p><p>ご覧のとおり、<code>value</code>という引数は、<code>increment(5)</code>を一度呼び出すためだけに生成されたスコープオブジェクトに保存されます。この関数が変数<code>value</code>にアクセスすると、Javascriptはすぐさま、スコープチェーンの中の最初のオブジェクト内を探します。しかしその関数が<code>counter</code>にアクセスする時、JavaScriptはスコープチェーンの最初のオブジェクトでは見つけられず、次のスコープオブジェクトに移動し、そこでまた探します。<code>increment()</code>は<code>createCounter(100) scope</code>の中の変数<code>counter</code>を変更します。そして、仮想的には他にこの変数を変更できるものはありません。だからこそクロージャはこんなにもパワフルなのです。オブジェクト<code>myCounter</code>に不正アクセスすることは不可能です。クロージャは機密性の高い情報を保存するのに非常に適切な場所なのです。</p><p>　<code>createCounter()</code>の引数<code>initial</code>は、使用されていないもののスコープオブジェクト内にも保存されているということにお気づきでしょうか。つまり、明確に<code>var counter = initial;</code>を取り除けば少しメモリを節約できます。<code>initial</code>を<code>counter</code>に名前を変更し、直接使うのです。しかし、分かりやすいよう、ここでは明示的な引数<code>initial</code>と<code>var counter</code>を使っています。</p><p>スコープの境界が”動的”であるということを強調することが重要です。関数が呼び出された時、現在のスコープチェーンはこの関数のためにはコピーされていません。スコープチェーンは新しいスコープオブジェクトによって増えていきます。そして、チェーン内のスコープオブジェクトが何らかの関数によって変更された場合、この変更は、スコープチェーンにこのスコープオブジェクトを持つすべての関数から、すぐに可観測な状態になります。<code>increment()</code>が<code>counter</code>の値を変更したら、次に呼び出された<code>get()</code>は更新された値を返します。</p><p>このよく知られた例は機能しないのはそういった理由からです。</p><p>このループの中で複数の関数が作られ、それらの関数はすべてスコープチェーンの中の同じスコープオブジェクトを参照します。だから、それらの関数は自分用のコピーではなく、まったく同じ変数<code>i</code>を使うのです。この例に関してさらに詳しく知りたければ、<a href="http://jslinterrors.com/dont-make-functions-within-a-loop" rel="nofollow" title="" class="ext-link">ループ内に関数を作らない</a>を参照してみてください。</p><p>さて、このcounterの例題を少し拡張して、もう少し楽しいことをしましょう。複数のcounterオブジェクトを作成したらどうなるでしょうか。簡単ですよ。</p><p><a href="http://dmitryfrank.com/_export/code/articles/js_closures?codeblock=5" rel="nofollow" title="" class="ext-link">my script.js</a></p><p><code>myCounter1</code>と<code>myCounter2</code>が作成されると、下記のようになります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_7.png" class="media" alt=""><br>
それぞれの関数オブジェクトはスコープオブジェクトを参照しているということをちゃんと覚えておいてください。上の例では<code>myCounter1.increment</code>と<code>myCoutner2.increment</code>が参照する関数オブジェクトは、まったく同じコードと同じプロパティの値（<code>name</code>、<code>length</code>と<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Function_prototype_object" rel="nofollow" title="" class="ext-link">その他</a>）を備えていますが、それらの<code>[[scope]]</code>は<strong>違うスコープオブジェクト</strong>を参照しているのです。</p><p>分かりやすくするために他の関数オブジェクトは図に含めていませんが、ちゃんと存在しています。</p><p>例を挙げます。</p><p>このようになります。クロージャのコンセプトは非常にパワフルですよね。</p><p>好き嫌いに関わらず, <code>this</code>はスコープチェーンの一部としてはまったく保存されません。その代わり、<code>this</code>の値は<em>関数呼び出しパターン</em>に依存します。つまり、同じ関数を、<code>this</code>として渡された違う値により呼び出すこともあるかもしれません。</p><p>見出しの名前が内容を表していますから詳しくは述べませんが、簡潔な概要として、4つの呼び出しパターンを紹介しています。以下をご覧ください。</p><p>呼び出しの表現がrefinement（ドット、または<code>[subscript]</code>）を含んでいる場合、その関数はメソッドとして呼び出されます。ですから、上の例では<code>myFunc()</code>に渡された<code>this</code>は<code>myObj</code>により参照されます。</p><p>Refinementがない場合は、コードがstrictモードで実行されているかどうかによって異なります。</p><p>上記のコードは<code>“use strict”;</code>によりstrictモードで実行されるので、<code>myFunc()</code>は<code>undefined</code>を返します。</p><p>関数が<code>new</code>というプレフィックスで呼ばれる場合、JavaScriptは関数のプロパティ<code>prototype</code>から継承された新しいオブジェクトを割り当てます。そして、新たに割り当てられたオブジェクトは<code>this</code>として、関数に渡されます。</p><p>このように、<code>this</code>として任意の値を渡すことができます。上記の例ではそのために<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="nofollow" title="" class="ext-link"><code>Function.prototype.apply()</code></a>を使いました。さらに詳しい説明は、以下を参照してください。</p><p>次に挙げる例では、主にメソッド呼び出しパターンを使います。</p><p>下記について考えてみてください。</p><p>出力：<code>hidden: 'value-in-closure', myProp: 'inner-value'</code></p><p><code>myObj.createInnerObj()</code>が呼ばれる時までは、下記のようになっています。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_8_this_1.png" class="media" alt=""></p><p>そして<code>myInnerObj.innerFunc()</code>を呼ぶと、下記のようになります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_8_this_2.png" class="media" alt=""></p><p>上の図を見ると、<code>myObj.createInnerObj()</code>に渡された<code>this</code>は<code>myObj</code>を指していることが明らかですが、<code>myInnerObj.innerFunc()</code>に渡された<code>this</code>は<code>myInnerObj</code>を指しています。上記で説明したように、どちらの関数もメソッド呼び出しパターンで呼ばれています。それで<code>innerFunc()</code>内の<code>this.myProp</code>は<code>"outer-value"</code>ではなく<code>"inner-value"</code>を評価するのです。</p><p>ですから、以下のように、<code>innerFunc()</code>をだまして<code>myProp</code>を使わせることが簡単にできます。</p><p>出力: <code>hidden: 'value-in-closure', myProp: 'fake-inner-value'</code></p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_8_this_2a.png" class="media" alt=""></p><p>または、<code>apply()</code>や<code>call()</code>を使うと以下のようになります。</p><p>出力: <code>hidden: 'value-in-closure', myProp: 'fake-inner-value-2'</code></p><p>しかし、しばしばinner関数は、呼び出された方法に関わらず、outer関数に渡された<code>this</code>へのアクセスを必要とします。これには共通の表現方法があります。私たちは必要な値を明確にクロージャ内に保存する必要があります（つまり、現在のスコープオブジェクト内に）。例えば<code>var self = this;</code>のように。そして<code>this</code>の代わりにinner関数の中の<code>self</code>を使います。</p><p>次を考えてみてください。</p><p>出力: <code>hidden: 'value-in-closure', myProp: 'outer-value'</code></p><p>このようすると、次の図のようになります。</p><p><img src="http://dmitryfrank.com/_media/articles/js_closure_8_this_3.png" class="media" alt=""></p><p>ご覧のとおり、<code>self</code>はクロージャの中に保存されていますが、今回<code>innerFunc()</code>は、<code>this</code>としてouter関数に渡された値にアクセスがあります。</p><p>記事の冒頭での疑問に答えてみましょう。</p><p>以下は参考文献です。<br>
* <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" rel="nofollow" title="" class="ext-link">『JavaScript: The Good Parts』</a> Douglas Crockford著。（訳注: 日本語版があります。<a href="http://www.amazon.co.jp/gp/product/4873113911/" rel="nofollow" title="" class="ext-link">『JavaScript: The Good Parts ―「良いパーツ」によるベストプラクティス』</a>）クロージャの働きについて理解するのはいいことですが、正しい使い方を学ぶ方がもっと重要です。この本は非常に簡潔で、多くの優れていて便利なパターンが掲載されています。<br>
* <a href="http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1441159889&amp;sr=1-1&amp;keywords=9780596805524" rel="nofollow" title="" class="ext-link">『JavaScript: The Definitive Guide』</a> David Flanagan著。（訳注: 日本語版があります<a href="http://www.amazon.co.jp/JavaScript-%E7%AC%AC6%E7%89%88-David-Flanagan/dp/4873115736/ref=sr_1_2?ie=UTF8&amp;qid=1443172180&amp;sr=8-2&amp;keywords=javascript" rel="nofollow" title="" class="ext-link">JavaScript 第6版</a>）タイトルから推測されるように、この本では詳細にわたってJavaScript言語について解説しています。</p>
