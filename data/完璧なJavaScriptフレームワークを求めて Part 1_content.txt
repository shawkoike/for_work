In search of the perfect JavaScript framework （2014-10-28） by Krasimir Tsonev最近のフロントエンド開発では、多くのフレームワークやライブラリが利用できます。ただし玉石混淆で、良い物もあれば悪いものもあります。そんなわけで多くの場合、私たちは特定のコンセプトやモジュールまたは構文に傾倒しがちです。でも、それが万能かと言うとそうでもありません。この投稿では、将来的なフレームワーク、つまりまだ存在していないフレームワークについて話をしていきたいと思っています。現状で利用可能なJavaScriptフレームワークの利点や欠点をまとめて、完璧なソリューションを思い描いてみましょう。私たちはシンプルなツールが好きですよね。複雑さはある意味、命取りです。作業が難しくなり、一定時間内で多くのことを覚えなければならなくなる（急勾配の学習曲線が求められる）ようなことが多々あります。プログラマは仕組みを理解するまで気も休まらないのではないでしょうか。複雑なシステムで作業をする場合、使用者がシステムを「使う」ことと、そのシステムの仕組みを「知っている」ことの間には、大きなギャップがあると言えるでしょう。例えば、以下のコードには複雑さが隠れています。これを実際のフレームワークとして考えてみましょう。裏ではcreatePageが、home.htmlのテンプレートを読み込む新しいViewクラスを生成します。visibleのパラメータにより、新規作成されたDOM要素をツリーに加えるか加えないかが選択可能です。ここで、開発者の立場になって考えてみてください。私たちはこのドキュメンテーションから、これがあるテンプレートを伴う新規ページを作成するということは読み取れますよね。しかしこれは抽象化されているため、特定の詳細については何ら知ることは出来ないのです。近年の一部のフレームワークでは、1つだけではなく多くのレベルで抽象化がなされています。しかし、そのフレームワークを適切に使うために、時には詳細な情報を知る必要だって出てくることもあるはずです。抽象化というのは機能をまとめるパワフルな方法で設計上の決定事項をカプセル化するものですが、プロセスの追跡が出来ないため、抽象化をする際には賢明な判断が求められます。上の例を次のように変えてみるとどうでしょうか。どうですか？　何がどう動いているかが分かりますよね。テンプレートと追加が、個別のAPIメソッドとして表記されているからです。これだと、開発者はプロセスに制御を加えたり、その中間で何かをしたり出来るようになります。次はEmber.jsを取り上げてみましょう。とても優秀なフレームワークで、これを使えば数行のコードでシングルページアプリケーションを作成できるようになります。しかし、それにはある犠牲が伴うことも事実です。裏では、いくつかのクラスが定義されます。例えばこんな感じです。フレームワークは3つの経路を作成し、それぞれにコントローラが付いていますよね。これは、フレームワークがアプリケーションを動作させるために必要とするものなので、あなたが使おうと使うまいと、いや応なしに存在するクラスです。プロジェクトを進めていると、往々にしてカスタム機能が必要な場合が出てくるでしょう。全ての要求に応えることの出来るフレームワークなんてありませんからね。そこで、簡単には解決できない問題に直面します。正しいやり方を探すために全ての仕組みを理解しなくてはならなくなってくるのです。もちろんカスタムの方向性はそれぞれに異なるため、フレームワークを使うというよりも、バラバラに切り刻んでいくような感覚に陥るかもしれません。ここで例に挙げるBackbone.jsでは、いくつかの定義済みオブジェクトを導入しています。その中にはコア機能が含まれていますが、実装するかどうかはプログラマ次第です。下にあるDocumentViewクラスは、Backbone.Viewを拡張していますね。それだけです。コードとフレームワークのコア機能との間に複数の階層はありません。個人的には、複数のレベルで抽象化されているようなフレームワークよりも、透明性の高いフレームワークの方が好みですね。一部のフレームワークはこちらが指定したクラスを受け入れてくれますが、コンストラクタは生成してくれません。インスタンスをいつどこで生成するかを決めるのはフレームワークです。これを私たちが出来るようなフレームワークがもっとあればいいと思いますね。例として、Knockoutを挙げましょう。このフレームワークではモデルを定義し、初期化することが可能です。AngularJSでは、これとは少し異なります。ここでは再度クラスを定義しますが、実行するわけではありません。これはただのコントローラなので、プロセスを決めるのはフレームワークです。私たちがアプリケーションのフローを可視化する際に使用するキーポイントがなくなるので、これについては混乱してしまうかもしれません。私たちが何をするにせよ、DOMとの関わりを避けては通れません。重要なのは、それをどのようにするかです。なぜなら一般的にページ上の全てのノード操作では、コストがかかるリフローとリペイントが発生するからです。例として、次のJavaScriptのクラスの使用について考えてみましょう。この小さなフレームワークは、与えられたデータから番号なしの順不同リストを作成します。リストをホストするDOM要素を送ると、画面にデータを表示するupdate関数を呼び出します。このコードを実行すると、以下のようになります。

なぜこれが悪い設計なのかを説明するために、ページにリンクを追加してclickというイベントリスナを取り付けてみましょう。この関数は再度updataメソッドを呼び出しますが、アイテムは異なります。配列の最初の要素を変えただけで、送るデータはほとんど同じです。しかしinnerHTMLを使用しているので、再描画は各クリックの後に発火されます。ブラウザは最初の行の変更だけが必要なことを知らないので、リスト全体が再描画されます。ではOperaの開発者ツールを使って、プロファイルを実行しましょう。次のGIFアニメーションのデモで結果を見てください。
各クリックの後にコンテンツ全体が再描画されましたね。特にページ上で同じテクニックを多用する時などは、これが問題になります。もっといいやり方は、

