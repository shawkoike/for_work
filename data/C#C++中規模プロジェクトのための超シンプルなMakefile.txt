<p><a href="https://spin.atomicobject.com/2016/08/26/makefile-c-projects/" rel="nofollow" title="" class="ext-link">A Super-Simple Makefile for Medium-Sized C/C++ Projects</a> （2016-08-26） by <a href="http://twitter.com/JobVranish" rel="nofollow" title="" class="ext-link">Job Vranish</a></p><p>私は多くの小規模プロジェクトで<a href="https://www.gnu.org/software/make" rel="nofollow" title="" class="ext-link">Make</a>を使ってきましたが、より大きな規模のプロジェクトになると、それは非常にうんざりするようなものでした。最近までは、自分のビルドシステムに行いたいことが4つあったのですが、Makeでの方法が分かりませんでした。</p><p>以下にこれらの全てを行える、C、C++、およびアセンブリで動作するシンプルなMakefileを紹介します。</p><p>MAKEFILE</p><p>悪くないですね。</p><p>なお、out-of-sourceビルドにこだわらないという場合は、もっとシンプルなMakefileが使えます。これなら、built-inの持つ暗黙ルールが使えるという強みもあります。</p><p>MAKEFILE</p><p>これらのいずれかを使うには、<code>Makefile</code>（タブ文字がコピーされることを確認しましょう！　それに関してMakeはとてもうるさいです）、<code>./src</code>（このディレクトリは、SRC_DIRSを変更することにより変えることができます）のディレクトリあるいはサブディレクトリにあるソースやヘッダなどの全てを呼び出すファイルに、Makeコードを配します。そうしたら、あなたのプロジェクト用に必要となる値をCCとCFLAGSに設定するか、またはMakeのデフォルトを使うか、確認してください。</p><p><code>make</code>と入力します。</p><p>問題が発生した場合には、<code>make -d</code>を実行すると役に立つでしょう。</p><p>では、その動き方の概要を見てみます。</p><p>私は、最終的には全てのビルドアーティファクトを、ソースとは切り離されたいくつかのディレクトリ（通常、 “./build” と名前を付けています）に生成したいと思っています。このようにMakeをすると、Makeを介して生成された他のビルドアーティファクトがそのディレクトリにそれぞれ並んだとしても、clean（単に、<code>rm -rf ./build</code>）がしやすいのです。また、ソースでgrepを行う場合など、他にも多くのことがずっとやりやすくなります。</p><p>Makeでこのようにするには通常、あなたの出力先のディレクトリを自分のパターンルールの先頭に追加する必要があります。例えば、.cファイルから同じディレクトリ内に.oファイルを作成することになる、<code>%.o: %.c</code>といったパターンの代わりとしては、<code>$(BUILD_DIR)%.o: %.c</code>を使うことになります。</p><p>ヘッダの依存関係の処理は、おそらく、古典的なMakeテクニックを使うものの中でも、<em>最も</em>退屈なものだと言えると思います。特に、その後で、あなたが何かしくじれば、明示的なエラーが全く出ず、再コンパイルもされるべき時にされないということになります。これは、タイプやプロトタイプがどういったものなのかについて、様々な考え方を持つ.oファイルが生成されることになってしまいます。</p><p>そこで、<a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites" rel="nofollow" title="" class="ext-link">ここに</a>ドキュメントがあります。ただし、このドキュメントでは、依存関係のあるファイルはコンパイルステップとは別のステップで生成されていることが前提とされているようです。</p><p>コンパイルステップの一部として依存関係のあるファイルを生成するなら、もっとずっとシンプルになります。依存関係のあるファイルを<em>生成する</em>ためにしなければならないことは、コンパイルコマンド（<a href="http://clang.llvm.org/get_started.html" rel="nofollow" title="" class="ext-link">Clang</a>と<a href="https://gcc.gnu.org/" rel="nofollow" title="" class="ext-link">GCC</a>の両方でサポートされています）にいくつかフラグを追加するだけです。</p><p>まず、定められたソースディレクトリで全てのソースファイルを検索します。私が見つけた、この検索を最もシンプルに素早く行う方法は、単にシェル関数で<code>find</code>を使うことです。</p><p>インクルードディレクトリフラグを生成するためにも、似たようなテクニックを使っていました。定められたソースディレクトリの下にあるディレクトリ全てを検索します。</p><p>以上のテクニックがお役に立てば幸いです。</p>
