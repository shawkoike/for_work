<p><a href="http://raganwald.com/2016/04/15/laziness-is-a-virtue.html" rel="nofollow" title="" class="ext-link">“We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris”</a> （2016-04-11） by <a href="https://gist.github.com/raganwald" rel="nofollow" title="" class="ext-link">Reginald Braithwaite</a></p><p><small>(編注：2016/5/31、頂いたフィードバックを元に記事を修正いたしました。)</small></p><p><img src="http://raganwald.com/assets/images/Larry_Wall_and_Camelia.jpg" alt="Larry Wall and Camelia, the Perl 6 Mascot"></p><p>コンピューティングにおいて、”laziness(怠惰)”は幅広い意味の単語です。大抵は、もし必要が無ければ何もしないということを意味します。その正反対を指すのは”eager(勤勉)”です。後で必要になる場合に備えて、できるだけ働くということを意味します。</p><p>以下のJavaScriptを見てみましょう。</p><p>ここで、問題です。「JavaScriptは<code>2+3</code>を評価する？」答えはお分かりですね。「評価する」です。呼び出し関数に、引数を引き渡すこととなると、JavaScriptは<em>eager(勤勉＝先行評価)</em>で、式の全てを評価します。式の値が使われようが使われまいが、評価するのです。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup></p><p>もしJavaScriptが<em>lazy(怠慢＝遅延評価)</em>だったら、式<code>ifThen(1 === 0, 2 + 3)</code>の<code>2+3</code>は評価されないでしょう。ではJavaScriptは”勤勉な”言語なのでしょうか？　おおむねそうでしょう。しかし、いつもとは限りません。もし、<code>1 === 0 ? 2 + 3 : undefined</code>と書けば、JavaScriptは<code>2+3</code>を評価<em>しません</em>。<code>?:</code>や<code>&amp;&amp;</code>、<code>||</code>のような演算子は、<code>if</code>のようなプログラムの制御構造と一緒に使われると怠慢になります。何が勤勉で、何が怠慢なのか、頭の中ですぐに理解しなければなりません。</p><p>そして、もともと遅延評価ではないものを遅延させたいと思うならば、JavaScriptの先行評価を避けなければなりません。以下に例を示します。</p><p>JavaScriptは関数である<code>() =&gt; 2 + 3</code>を先行評価します。しかし、関数が呼び出されるまで、JavaScriptは関数本体の中にある式を評価しません。つまり、関数は呼び出されていないので、<code>2+3</code>は評価されません。</p><p>評価を先延ばしにするために、関数の式をラッピングすることは昔からあるプログラミングテクニックです。口語では「<a href="https://en.wikipedia.org/wiki/Thunk" rel="nofollow" title="" class="ext-link">サンク</a>」と呼ばれ、このサンクに関する面白いアプリケーションがたくさんあります。</p><p>関数の本体は、いわば遅延的なものです。というのも、関数は呼び出されるまで、評価されないからです。これは<code>if</code>文、そしてその他全ての制御フロー構造と密接な関わりがあります。つまり「JavaScriptは、コードが実際に命令文に行き当たらない限り、命令文を評価しない」ということです。</p><p>以下のコードを考えてみましょう。</p><p>おそらく、その無邪気さに含み笑いをしているでしょう。例えば、このリストを1から10億までの数字のリスト、<code>[1, 2, 3, ..., 999999998, 999999999, 1000000000]</code>と仮定してください。そして、呼び出します。</p><p>正しい結果が得られますが、最初に10億個の数字の各々について命令を反復します。ひどい話です。小さな子供や熱のある人でなければ、JavaScriptの関数のどこでからでも<code>returun</code>できると知っているでしょう。そこで、次のように書くことができます。</p><p>このバージョンの関数は、最初の関数よりも怠慢です。特定のリストに特定の値を含むかどうか決定するのに必要な最低限のことだけを実行します。</p><p><code>containing</code>から、類似の関数<code>findWith</code>を作ることができます。</p><p><code>findWith</code>は、判定関数を適用して、trueを返す最初の値を遅延的に見つけます。残念ながら、<code>findWith</code>は遅延的であるのに反して、上で述べたように、その引数は勤勉に評価されます。そこでリストの中で、<code>99</code>より大きく回文状になっている、最初の数字を見つけたいとしましょう。</p><p>もちろん、以前と同じ原則です。10億個の数字の端から端まで反復し、<code>99</code>よりも大きく回文状の数字、<code>101</code>に行き当たったところで止まります。</p><p>しかしJavaScriptは<code>findWith</code>に対する引数を先行評価します。つまり、<code>isPalindromic, gt(99))</code>を評価して、<code>predicate</code>とバインドします。その後<code>billion</code>を先行評価し、<code>list</code>とバインドします。</p><p>1つの値をもう1つの値にバインディングするのは簡単です。しかし、もし10億個の数字を<em>生成</em>しなければいけないとしたらどうでしょう。</p><p><code>NumbersUpTo(1000000000)</code>は先行的です。そのため、必要なのは最初に出てくる<code>101</code>だけだというのに、10億個の数字全てのリストを作ります。これは遅延性を求める私たちにとって問題です。私たちは計算全般において、面倒なことは避けなければいけません。</p><p>ちょうどいいことに、先ほどジェネレータ<sup id="fnref:2"><a href="#fn:2" class="footnote-ref">2</a></sup>を扱ったばかりなので、遅延式の数字リストの作り方は、ちゃんと分かっています。</p><p>ジェネレータは値を遅延的に生成しし、<code>findwith</code>は遅延的に検索しようとします。そのため、膨大な数字の配列を1つも生成することなく<code>101</code>を見つけることができます。それでもJavaScriptは<code>Numbers()</code>を先行評価し、<code>list</code>にバインディングしようとしますが、この時点では配列ではなくイテレータにバインディングされます。<code>for (const element of list) { ... }</code>命令は、<code>billion</code>配列から値を得るのと同じように、遅延的にイテレータから値を取り出します。</p><p>以下は<a href="https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9" rel="nofollow" title="" class="ext-link">エラトステネスの篩</a>を先行評価スタイルでプログラミングしたものです。</p><p>エラトステネスの篩を遅延評価スタイルで書いてみましょう。まずは、このブログに既に登場しているいくつかの便利な方法や「<a href="https://leanpub.com/javascriptallongesix" rel="nofollow" title="" class="ext-link">JavaScript Allongé</a>」に書かれている方法を使います。</p><p>すぐ使える方法として、1つのイテラブルなオブジェクトを値のシーケンスにマッピングするジェネレータ作ることができます。この値のシーケンスには<code>null</code>に変換された全ての<code>nth</code>要素が含まれます。<sup id="fnref:3"><a href="#fn:3" class="footnote-ref">3</a></sup></p><p>これが「篩」の振る舞いの核となります。数字リストの最前部の要素を<code>n</code>と呼び、その後ろの<code>nth</code>要素を全て篩にかけます。</p><p>この時点では、<code>nullEveryNth</code>を再帰的に適用することができます。リストの最前部から篩にかけられていない最初の数字を取り出し、その倍数を篩い落として、その結果残った数字の結果を生成します。</p><p><code>sieve</code>があれば、<code>range</code>を使って、<code>2</code>から始まる数字のリストを手に入れ、再帰的に篩にかけることができます。そして、その結果に対して<code>compact</code>を使い、全ての<code>nulls</code>を篩にかけて消し、最終的に素数のみを残すことができます。</p><p>パフォーマンスの問題だけでなく、バグがあふれていることに気がつきましたか？　実行してみると、動かないことが分かります。問題なのは、最後の<code>compact</code>の部分です。<code>compact</code>は先行的な関数で、遅延的な関数ではありません。そのため、最終的にnullを篩い落とす前に膨大な素数のリストを構築しようとしてしまうのです。</p><p><code>compact</code>の遅延評価バージョンが必要です。</p><p>これで動きます。</p><p>遅延スタイルでコーディングする時は、全ての通常演算を遅延バージョンにしなければいけません。例として、<code>unique</code>を先行評価の方法で実装したコードを下に示します。</p><p>当然ですが、遅延的なイテレータから固有の値を見つけたい場合は、遅延的な実装が必要です。</p><p>そして、リストで使う既存の演算は全て同様です。イテラブルで使える遅延バージョンが必要で、全体を通して遅延演算を行わなければいけません。混在させて使うことはできないのです。</p><p>このセクションでは思いがけない発見があるでしょう。</p><p>ジェネレータと遅延性はすばらしいものになり得ます。例えば、ジェネレータを使い、同期されたコードを非同期の演算でエミュレーションすると、すごいことが起こります。しかし、ここまで説明してきたように、遅延的なコードを書きたい場合は、一貫して遅延的であるように注意しなければいけません。もし、うっかり遅延評価のコードと先行評価のコードを混ぜてしまったら、問題が発生します。</p><p>これは<a href="http://raganwald.com/2015/03/12/symmetry.html" rel="nofollow" title="" class="ext-link">対象性</a>の問題です。更に踏み込むと、「ダック・タイピング」という概念の問題が明らかになります。これは一般的な考え方で、オブジェクトが正しいインターフェースを扱い、適切なメソッドに応答している限り、そのオブジェクト同士には互換性があるというものです。</p><p>しかし、常にそうとは言えません。先行バージョンでも遅延バージョンでも<code>compact</code>は、<code>compact</code>としてリスト上で演算を行います。しかし、片方は遅延的で、片方はそうではないのです。「ダック・タイピング」では、怠慢な関数とそうでない関数の違いを捉えようとしませんし、捉える能力もありません。</p><p>他にも同じような事例が数多くあります。エスケープ処理された文字列と、それを元に戻された（アンエスケープされた）文字列や、難読化されたIDとネイティブなIDなどがその例として挙げられます。同じインターフェースなのに意味的な違いなどがある場合、それらを区別するために<em>型</em>が必要なのです。</p><p>それぞれの型で、正しい演算によってプログラムを動かすようにしなければいけません。例え、正しくない演算であっても「ダック・タイピングの互換性」によって、一見動いているように見えてしまうからです。</p><p>補足記事：<a href="http://raganwald.com/2016/04/25/hubris-impatient-sieves-of-eratosthenes.html" rel="nofollow" title="" class="ext-link">The Hubris of Impatient Sieves of Eratosthenes</a>（短期なエラトステネスの篩の傲慢さ）</p><p><script src="https://gist.github.com/raganwald/cdfbd4c7b8aaf75469e2b404892718df.js"></script></p>
