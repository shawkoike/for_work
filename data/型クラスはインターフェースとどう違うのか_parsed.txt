How do type class differ from interfaces? （2017-01-07） by Matt Persons
(注：2017/02/27、いただいたフィードバックを元に翻訳を修正いたしました。)
Haskellの型クラスは、Haskellを学び始めたばかりの多くの人にとっては難しい概念です。たいていの言語はこれを表すことが全くできませんし、それに近い概念も持っていません。多くのオブジェクト指向型の言語にとっては、利用可能なものの中ではInterfaceが最も近い言語要素でしょう。Rubyのmodulesは似たような役割を持っています。しかし、この概念は両方とも、名前の多重定義と一種のポリモーフィズムをアドレスするので、型クラスが提供するパワーの一部を欠いています。この記事は、型クラスに興味を持っている人向けです。Haskellや関数型プログラミングの予備知識は必要ありません。JavaやC言語のような静的な型付き言語に慣れていれば、役に立つでしょう。型クラスとは何かを知っているなら、この項目は飛ばしてください。要約すると、Haskellの型クラスとは、以下のように定義されます。上記のコードスニペットは以下のように解釈できます。まず、toyデータ型のToyOrdを作ります。このデータ型には、2つの構成要素があります。フィールドを持たないSmolと、1つのIntフィールドを持つLargeです。これをOrdのインスタンスにするには、Eqのインスタンスにしなくてはいけません。ToyOrdデータ型のためのEqインスタンスを定義したので、Ordを定義できます。型クラスを得たら、インプットとしてその型クラスのインスタンスだと期待される関数を書くことができます。順序付け演算子を定義してみましょう。この関数はaを提供する全ての型で機能するように記述します。そのような型は、Ord型クラスのインスタンスです。Javaのインターフェースを使えば、オブジェクトがサポートするメソッドのセットを記述することができますし、Java 8では、これらのメソッド用のデフォルトでの実装も記述することができます。ですから、Ordと本質的には全く同じインターフェースを書くことができるのです。これは、JavaのEqインターフェースです。デフォルトの実装を利用しています。どちらか一つをオーバーライドしなければ、メソッドを呼び出そうとする際に無限にループを続けることになります。これらのインターフェースに関して、ジェネリックなメソッドを書くこともできます。表面上は、これらはそっくりに見えます。しかし、いくつか重要な違いがあるのです。Haskellのcompare関数の型シグネチャは、その引数の型に非常に特異的なものです。この型シグネチャが意味するのは、次のようなことです。忘れないでほしいのは、compareに対するパラメータがいずれも同じ型を持つように型シグネチャが要求するということです！　compare Smol 10と記述してしまうと実行できません。Javaの場合は2つのオブジェクトが何であろうと、Ordインターフェースが実装されていれば引き渡されます。Javaによる同等のコードはこんな風になります。このメソッドのシグネチャはジェネリックの型変数Aを導き、AによってOrdインターフェースが拡張か実装されなければならないと述べています。このメソッドでは、次に2つのパラメータを取り上げますが、どちらも同じジェネリックA型です。Javaのクラスは1か所で定義されます。クラスが実装するインターフェースはいずれも同じクラス上に定義されなければなりません。Javaは直和型を処理することが得手ではありませんので、上位のToyOrdクラスからLargeを処理するだけになります。compareとequalToを定義しました。注意すべきは、これらのメソッドが適切に実装されるようにinstanceofを実行し、型の変換を行なわなければならないということです。では、任意の型のオブジェクト2つを取り上げ比較することにどんな意味があるでしょうか？あるupstream packageからLargeを取り込み、独自のインターフェースを定義したとします。SomeOtherPackageインターフェースにLargeを実装させることは全くできません！　そんなことはせずに、コントロール可能な新しいクラスで元々のクラスをラップしなければなりません。そうすることでインターフェースが実装されるのであり、もしそうしない場合にはLargeへデリゲートします。型クラスはデータ型の定義とクラスのインスタンスに分けられます。ゆえに別のパッケージからToyOrdを取り込むとしたら、以下のようなことが容易にできます。これが、幅広くて驚嘆の誰でも使える型クラスです。return型ポリモーフィズムと言います。ちょっといやらしい存在です。実行してもうまくいかないHaskellの型クラスを定義してみましょう。Maybe型用のインスタンスは簡単に作ることができます。では、CanFailインスタンスを書いてみましょう。CanFailの項で幾つかの関数を書くことができます。安全なゼロ除算関数が書けます。この関数シグネチャはとても面白いことを行なっています。普通の文章に翻訳してみましょう。えっ、callerが型を選択？　つまり下記のようなコードが書けます。上の関数でsafeDivisionのcallerのように、Maybe型を選択することもできます。他のインスタンスは何があるでしょうか。MaybeErrorも同じく選択できます！　必要ならIOのインスタンスも作れます。あたかもprintか同様のもののように、IOでsafeDivision関数を使えるようになります。return型ポリモーフィズムは非常にスマートで、間違いなく型クラスの中で最高のものの1つです。同時に、他の言語でのインターフェースやモジュールとはかけ離れたところにあるものの1つです。
