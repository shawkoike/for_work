Easy audio capture with the MediaRecorder API（2014-06-10） by Chris Mills and Robert Nyman[Editor]MediaRecorder APIはNavigator.getUserMedia()内で使用されるシンプルな構造のAPIです。これを使えばユーザの入力デバイスからメディアストリームを手軽に録音し、即座にWebアプリケーションで利用することができます。今回の記事ではMediaRecorderの使用方法について、基本的な使い方を書いてみようと思います。MediaRecorderはFirefox Desktop、Mobile 25、FirefoxOS 2.0上でサポートされています。Firefox OS上でメディアをキャプチャするのは案外手間がかかるものです。getUserMedia()を単独で使う場合raw PCMデータを生成するので、ストリームするのには問題ありません。しかし、音声やビデオをキャプチャして、PCMデータ上で手作業でエンコーディングしようと思うと、とたんに複雑になってきます。Firefox OSのCamera APIを利用する手もあります。しかし、Certified APIだったのが最近Privilegedに格下げされました。またWeb activitiesではCameraなどのアプリケーションを使ってメディアキャプチャできるものが提供されています。上記2つの方法でやっかいなのは、音声トラックとビデオを同時にキャプチャするしかない点です。音声トラックだけが欲しい時は切り離さなくてはなりません。MediaRecorderを使えば、音声だけを簡単にキャプチャすることができます（とりあえず音声のみで、ビデオは後で追加できます）。MediaRecorder APIの基本的な使用方法をデモするためにWebベースの音声レコーダを作ってみました。音声のサンプルデータなどを録音し、再生することができます。更に、Web Audio APIを使って装置のサウンド入力の視覚化もしてくれます。ここでは録音と再生の機能についてのみ触れます。実際のデモアプリはここで、Githubのソースコードはこちらから取得できます (直接zip形式のファイルをダウンロードするにはここからどうぞ)。このアプリのHTMLはとても分かりやすいので、ここでは詳細は触れません。CSSについては説明しがいがありそうなので、この後の項で少し解説します。CSSに興味がなく、すぐJavaScriptについて知りたい方はここを飛ばして「アプリケーションの基本的なセットアップ」の項に進んでくださいね。calc関数は、CSSの便利なユーティリティの1つです。最初はそれほど感じなくても、そのうちに「どうして今まで無かったんだろう？　CSS2のレイアウトは何て使い勝手が悪かったんだろう」と思うでしょう。この関数を使うことで、プロセス内の異なる単位を組み合わせて、CSSユニットの値を決める計算が可能となります。例えば、Web音声レコーダには、縦方向に並んだ、メインとなる3つのユーザ・インターフェースのエリアがあります。まず、最初の2つ（ヘッダとコントローラ）の高さを指定します。次に3番目のエリア（再生可能な3つの録音サンプルが格納されています）について、左側の余白やデバイスの高さに左右されずに、設定を行いたいと思います。Flexboxを使う方法がありますが、この程度の簡単なレイアウトに使うのは大げさです。その代わりに、3番目のエリアの高さを親要素の100％とし、他の2つのエリアの高さと余白をマイナスすることで解決できます。注：calc()はモダンブラウザのほとんどがサポートしています。Internet Explorer 9でさえもサポートしています。これに関してはすでに、かなり詳しい解説がありますが、ここではチェックボックスの仕掛けについて説明したいと思います。これは、チェックボックスのラベルをクリックすることで、チェックボックスのチェック有無を操作できる機能を利用したものです。Web音声レコーダでは、ヘッダの右端にある？マークをクリックすると表示／非表示を切り替えられる、インフォメーション画面に活用できます。最初に、要素の仕様をどのようにするか決めます。その際、対象ラベルが常に他の要素より上位の階層にあって、ポインタを合わせたりクリックしたりできるように、z-indexの値が十分かどうか確かめることが必要です。次に、インフォメーション画面（&lt;aside&gt;要素に含まれています）の仕様を決めます。位置を固定することで、レイアウトあちこちに現れて、メインのユーザ・インターフェースの邪魔にならないようにします。表示したい位置に現れるように初期設定でtransformを指定し、さらにスムーズに表示／非表示ができるようにtransitionを指定します。最後に、チェックボックスがチェックされたとき（クリック、もしくはポインタを合わせたとき）の仕様を記述します。&lt;aside&gt;要素に続く部分は、水平方向へ移動して、スムーズに遷移することを表しています。録音したいメディアストリームをキャプチャするために、getUserMedia()を使います（gUMと省略します）。そして、MediaRecorder APIでストリームを録音し、その結果を生成された&lt;audio&gt;要素に与えることで、再生が可能となります。まず、ベンダープレフィックスを問わずにgUMを動作させるために、分岐を組み込みます。そうすることで、将来的に他のブラウザがMediaRecorderのサポートを開始すれば、そのブラウザ上でもアプリケーションを簡単に動作させることができるようになります。次に、録音開始と終了ボタンと、生成されたオーディオプレーヤーを含む&lt;article&gt;要素の、変数を宣言します。セクションの最後に、gUMの基本的なセットアップを行います。アプリケーションを実行する前に、gUMがサポートされているかどうかをチェックし、実行のコードはネスト内に記述します。次に、getUserMedia()を呼び出し、その内部で定義を行います。注：以下のコードはすべてコールバック成功時のgUM内に設定されています。一度、gUMがメディアストリームを取得できたら、MediaRecorder()によってMedia Recorderのインスタンスが生成され、直接ストリームを渡せます。これでthe MediaRecorder APIを使用するエントリポイントまで来ました。ストリームはBlobにそのままキャプチャされる準備ができ、ブラウザの初期値のエンコーディング・フォーマットになります。MediaRecorderのインターフェースでは、利用可能な一連のメソッドを提供しており、メディアストリームの録音を操作できます。Web 音声レコーダでは、2つのメソッドを活用します。1つ目がMediaRecorder.start()です。レコードボタンを押すと、ストリームがBlobに録音され始めます。MediaRecorderで録音しているとき、MediaRecorder.stateプロパティは”recording ” の値を返してくるでしょう。2つ目は、MediaRecorder.stop()メソッドです。ストップボタンを押して録音を停止し、アプリケーション上で使えるBlobへの格納を完了します。録音が終了すると、プロパティは”inactive “の値を返してきます。Blobへの格納が完了し、利用可能となるケースとしては、他に以下のものが挙げられます。上記で述べたようにblobへの格納が完了し、利用可能になると、dataavailable イベントが発生し、mediaRecorder.ondataavailableハンドラによって扱えるようになります。上記のコードを試して、どうなるか見ていきましょう。まず、クリップ名をつけるようユーザに対してプロンプトを表示します。次に、下記のようなHTML ストラクチャを生成し、クリップコンテナへ書き込んだものが、&lt;section&gt;要素になります。この後に、window.URL.createObjectURL(e.data)を使用し、イベントデータの属性を示すオブジェクトのURLを生成します。この属性は録音されたオーディオのBlobを含んでいます。それからオブジェクトのURLを表す、&lt;audio&gt;要素のsrc特性の値をセットすると、オーディオプレーヤーの再生ボタンが押された時に、Blobを再生します。最後にすべてのHTMLストラクチャを消去する機能を持たせたデリートボタンにonclickハンドラをセットします。このように、MediaRecorderを使えばアプリケーションにおけるメディアの録音を快適にできます。実際に試してみて、ぜひ感想を教えてください。楽しみにしてますよ！
