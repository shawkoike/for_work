<p><a href="https://github.com/mhinz/vim-galore" rel="nofollow" title="" class="ext-link">Everything you need to know about Vim</a> by <a href="https://github.com/mhinz" rel="nofollow" title="" class="ext-link">Marco Hinz</a></p><p>(訳注: 2016/2/26、記事タイトルを変更いたしました。)</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/02/vim-galore.png"><img src="http://postd.cc/wp/wp-content/uploads/2016/02/vim-galore.png" alt="vim-galore" width="1500" height="278" class="alignnone size-full wp-image-6066"></a></p><p>特定のトピックについての記述をご希望ですか？ <a href="https://github.com/mhinz/vim-galore/issues" rel="nofollow" title="" class="ext-link">Issue</a>を立てるか、<a href="https://twitter.com/_mhinz_" rel="nofollow" title="" class="ext-link">Twitter</a>で私までお知らせください！ありがとう！</p><p>Vimには、特殊なレイアウトのテキストファイル群から成る素晴らしいヘルプ文書が付属しています。Vimはタグをベースとするシステムを使って、これらのヘルプファイルの特定の部分にアクセスします。</p><p>まず始めに<code>:help :help</code>を実行し、読んでください。新しいウィンドウで<code>$VIMRUNTIME/doc/helphelp.txt</code>というファイルが開いて、ファイル内の<code>:help</code>タグに移動します。</p><p>簡単なルールがいくつかあります。</p><p><code>&lt;c-d&gt;</code>（ctrlキー + dキー）を使えば、入力したクエリに一致する全てのタグのリストが出力されます。例えば、<code>:h tab&lt;c-d&gt;</code>と入力すると、<code>tab</code>の項の<code>'softtabstop'</code>から<code>setting-guitablabel</code>まで全てのタグがリスト出力されます。</p><p>VimLの関数全部のリストが欲しければ簡単です。<code>:h ()&lt;c-d&gt;</code>。ウィンドウは別なほうがよければ、<code>:h win*()&lt;c-d&gt;</code>です。</p><p>ヘルプはすぐにうまく使えるようになりますが、特に最初のうちは、どんなタグを探せばいいのか見当がつかない時もあるでしょう。そんな時は関係のありそうなキーワードをいくつか思い浮かべてください。<code>:helpgrep</code>が役に立ちます！</p><p>このコマンドで、全てのドキュメントファイルから “backwards”という単語を探し、最初にヒットした箇所に移動します。検索結果はQuickfixリストの形に集約されます。<code>:cn</code>/<code>:cp</code>を使えば、次の/前の結果に移動します。または<code>:copen</code>でQuickfixリストをウィンドウ表示にして、<code>&lt;cr&gt;</code>を入力すればヒットした行に移動します。全容は<code>:h quickfix</code>を参照してください。</p><p>
</p>
<p>次のリストは、Vim開発者の中でも活動的な@chrisbraによってまとめられ、<a href="https://groups.google.com/forum/#!forum/vim_dev" rel="nofollow" title="" class="ext-link">vim_dev</a>に掲載されています。</p><p>若干の変更を加えてここに掲載しています。</p><p>探しているものが分かっていれば、ヘルプの検索を使った方が大抵の場合は簡単に見つかります。項目はスタイルガイドに沿って分類されています。</p><p>持っているVimのバージョンのヘルプで検索できるので、持っているバージョンより古いヘルプ項目や新しいヘルプ項目が検索結果に出ることはありません。</p><p>そのため、ヘルプの使い方やヘルプで使用されている言語を覚える必要があります。いくつか例を挙げます（内容的に不完全あるいは書き忘れたことがあるかもしれません）。</p><p>さらに、存在する場合は、ユーザドキュメント(多くの場合、コマンドの説明はユーザ視点からのものが多く、詳しく書かれているものは少ない)へのリンクはヘルプページの一番上に記載されています。<code>:h pattern.txt</code>でユーザマニュアルの項目である<code>:h 03.9</code>と<code>:h usr_27</code>を見ることができます。</p><p>
</p>
<p>どうしても解決のできない問題があったり、一般的な情報が必要だったりする場合は、<a href="https://groups.google.com/forum/#!forum/vim_use" rel="nofollow" title="" class="ext-link">vim_use</a>のメールリストを参照してください。別の素晴らしい資料としては、<a href="https://de.wikipedia.org/wiki/Internet_Relay_Chat" rel="nofollow" title="" class="ext-link">IRC</a>があります。<a href="https://freenode.net/" rel="nofollow" title="" class="ext-link">Freenode</a>の<code>#vim</code>チャンネルを使用している人が多く、役立つ情報を多く得ることができます。</p><p>Vimのバグの報告は<a href="https://groups.google.com/forum/#!forum/vim_dev" rel="nofollow" title="" class="ext-link">vim_dev</a>メールリストを使ってください。、</p><p>
</p>
<p>GUIサポートのないVimをUNIXシステムで使用する際に、<code>'clipboard'</code>オプションを使用する場合は、<code>+clipboard</code>、そして随意で<code>+xterm_clipboard</code> <a href="http://postd.cc/vim-galore-1/#what-kind-of-vim-am-i-running">機能</a> が必要となります。</p><p>関連するヘルプ：</p><p>記事後半の括弧付きペースト（なぜいつも”paste”を設定しなくてはならないのか）も参照してください。</p><p>
</p>
<p>Windowsには<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms649012(v=vs.85).aspx" rel="nofollow" title="" class="ext-link">clipboard</a>機能があります。OSXには<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PasteboardGuide106/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008100-SW1" rel="nofollow" title="" class="ext-link">pasteboard</a>機能があります。</p><p>両方ともユーザが期待するような機能です。コピーしたいテキストを<code>ctrl+c/cmd+c</code>で選択し、<code>ctrl+v/cmd+v</code>で別のアプリケーションにペースト（貼り付け）できます。</p><p>コピーされたテキストはクリップボートに移されるため、コピー元のアプリケーションを他のアプリケーションにペーストする前に閉じても問題はないことを覚えておいてください。</p><p>この作業の時、クリップボードレジスタの<code>*</code>には選択範囲の文字列が入ります。Vimからは、<code>"*y</code>や<code>"*p</code>を使ってクリップボートにあるテキストをヤンク・ペーストしてください。</p><p>常に<code>*</code>レジスタを指定したくない場合は、次をvimrcに入れてください。</p><p>通常、ヤンク/削除/貼り付け機能の場合、<code>"</code>レジスタが使われます。この場合、<code>*</code>レジスタが同じ機能に使用されるため、<code>y</code>や<code>p</code>と入力するだけで十分になります。</p><p>繰り返しになりますが、上のオプションを使用することで、同じVimのウィンドウで使用する場合でも、全てのヤンク・ペーストでクリップボードは変更されます。これが便利かどうかは使い手次第です。</p><p><code>y</code>とタイプするのさえ面倒な人は、設定を次のようにすることで全てのビジュアル選択をクリップボードに送ることができます。</p><p>関連するヘルプファイル：</p><p>
</p>
<p>お使いのOSが<a href="http://www.x.org/wiki" rel="nofollow" title="" class="ext-link">X</a>の場合、クリップボートの使い方は若干変わってきます。Xは<a href="http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html" rel="nofollow" title="" class="ext-link">X Window System Protocol</a>のオープンソース実装で、1987年から提供されており、現在バージョン11が提供されています。そのため、X11とも呼ばれます。</p><p>以前、X10のバージョンで<a href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Cut_Buffers" rel="nofollow" title="" class="ext-link">カットバッファ</a>が導入されました。これは、<em>クリップボード</em>のようなもので、コピーされたテキストはXによって格納され、全てのアプリケーションからアクセスが可能でした。この仕組みは今でもXに存在しますが、今では使用が反対され、多くのソフトウェアではもう使用されていません。</p><p>現在はアプリケーション間のデータの移動は、<a href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Selections" rel="nofollow" title="" class="ext-link">セレクション</a>機能で実行されます。定義された3つの<em>セレクションアトム</em>の中でも、実際使用されているのはプライマリ選択とクリップボード選択の2つのみです。</p><p>この2つのセレクションは次のように機能します。</p><p>
</p>
<p>注：セレクションがXサーバに格納されることは絶対にありません（クリップボードセレクションでさえ格納されません）。そのため、アプリケーションを終了すると<code>ctrl+c</code>でコピーしたものは失われます。</p><p><code>"*p</code>を使用してプライマリ選択したものをペーストするか、<code>"+y1G</code>を使用して、クリップボード選択へファイル全体をヤンクしてください。</p><p>もし、この2つのレジスタにアクセスする頻度が高い場合は、次を使うのも良いでしょう。</p><p>(<code>^=</code>はデフォルト値の<code>:h :set^=</code>を追加するときに使います)</p><p>これで全てのヤンク/削除/貼り付け機能は、無名の<code>"</code>レジスタの代わりに<code>*</code>か<code>+</code>で使用することができます。これによって、後で<code>y</code>や<code>p</code>でX選択に簡単にアクセスすることができます。</p><p>関連するヘルプ：</p><p>
</p>
<p>この機能がないと、ファイルを開くとカーソル位置は一行目に戻ります。この機能があれば、カーソルの位置はファイルを閉じる前に作業していたところに復元します。</p><p>次をvimrcに追加してください。</p><p>これを追加することで、作業していた場所が存在すれば（他のプログラムによってファイルの行数が減っている場合があります）、<code>g`"</code>（ジャンプリストを変更することなく、最後に作業していた場所にカーソルが移動します）が実行されます。</p><p>これをするには、<code>:h viminfo-'</code>というviminfoファイルを使用する必要があります。</p><p>
</p>
<p>オプションによっては、Vimは最大で4つの作業ファイルを作成します。</p><p><strong>バックアップファイル</strong></p><p>Vimに元のファイルをバックアップするように指定できます。デフォルトでVimはバックアップを自動的に作成しますが、元のファイルの書き込みが成功するとバックアップを削除してしまいます(<code>:set writebackup</code>)。最新のバックアップファイルを取っておく場合は、<code>:set backup</code>を使います。あるいは、<code>:set nobackup nowritebackup</code>でバックアップを作成しないよう設定することもできます。</p><p>では、私が最後にvimrcに追加したものを見てみましょう。</p><p>関連するヘルプ：<code>:h backup</code></p><p><strong>スワップファイル</strong></p><p>例えば、最高のサイエンスフィクション小説を書くアイデアが浮かんだとします。何時間も没頭して何千のも文字を書き続けて、停電になってしまったとします。そして、<code>~/wicked_alien_invaders_from_outer_space.txt</code>を保存していなかったことに気が付きます。</p><p>絶望的ではないのでご安心を。ファイルを編集する際、Vimはオリジナルに保存されていない変更箇所を保持するスワップファイルを作成します。試してみましょう。ファイルを開いてみて<code>:swapname</code>で現在のスワップファイルがあることを確かめてみてください。<code>:set noswapfile</code>をvimrcに追加することでスワップファイルも作成されないよう設定できます。</p><p>デフォルトで、スワップファイルは編集したファイルと同じディレクトリに<code>.file.swp</code>のような名前で作成されます。スワップファイルの更新は200文字が変更された場合または4秒間タイプしていない場合にされます。ファイルの編集が終了するとスワップファイルは削除されます。更新の設定は<code>:h 'updatecount'</code>や<code>:h 'updatetime'</code>を使用して変更することが可能です。</p><p>停電のせいでスワップファイルは削除されることはありませんでした。Vimで<code>~/wicked_alien_invaders_from_outer_space.txt</code>を入力すれば、Vimはファイルを復元してくれます。</p><p>関連するヘルプ：<code>:h swap-file and :h usr_11</code></p><p><strong>アンドゥファイル</strong></p><p><a href="http://postd.cc/vim-galore-2/#undo-tree">アンドゥファイル</a>はメモリに格納され、Vimを終了すると削除されます。残しておきたい場合は、<code>:set undofile</code>にします。すると、<code>~/foo.c.un~</code>にアンドゥファイルを<code>~/foo.c</code>として保存することができます。</p><p>関連するヘルプ：<code>:h 'undofile'</code>および<code>:h undo-persistence</code></p><p><strong>Viminfoファイル</strong></p><p>バックアップファイルやスワップファイル、アンドゥファイルはどれもテキストの状態に関するものでした。viminfoファイルはそれ以外のもの、Vimを終了すると失われてしまうものを保存するために使用します。viminfoファイルには履歴（コマンドライン、検索、入力）、レジスタ、マーク、バッファリスト、グローバル変数などが格納されます。</p><p>デフォルトでviminfoは<code>~/.viminfo</code>に書き込まれるよう設定されています。</p><p>関連するヘルプ：<code>:h viminfo</code>および<code>:h 'viminfo'</code></p><p>私のように、上記全てのファイルを同じ場所、例えば<code>~/.vim/files</code>に格納したい場合は次のとおりです。</p><p><code>~/.vim/files</code>ディレクトリは前もって作成する必要があります。作成しておかないとエラーが生じます。頻繁に新しいホストで作業をする場合は、これを自動化した方がいいでしょう。</p><p>注：共有のシステムで編集をしていて、スワップファイルがすでにあるとVimが知らせてきた場合、他の人がファイルを編集している最中であることを意味します。この”機能”は、スワップファイルをホームディレクトリに保存してしまうと失われてしまいます。</p><p>
</p>
<p><!--  --><br>
Vimにはリモートファイルの編集を可能にするnetrwプラグインが付いてきます。実際には、リモートファイルをローカルtempファイルにscp経由で移動し、そのファイルを使用してバッファを開き、変更をリモートファイルに書き込み、保存します。これは、ローカル設定で使用したい場合は、サーバにSSHしたり、管理者に指示されたものを使ったりするよりも、遥かに便利です。</p><p><code>~/.ssh/config</code>がすでに設定されている場合は、自動的に次のことが実行されます。</p><p>これが、<code>~/.ssh/config</code>の中にあれば、下も可能です。</p><p><code>~/.netrc, see :h netrw-netrc</code>を使用しても同じようなことができます。</p><p><code>:h netrw-ssh-hack</code>と<code>:h g:netrw_ssh_cmd</code>は必ず読むようにしてください。</p><p>また、<a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" rel="nofollow" title="" class="ext-link">FUSE</a> を使用する<a href="https://wiki.archlinuxjp.org/index.php/Sshfs" rel="nofollow" title="" class="ext-link">sshfs</a>を使用してリモートファイルシステムをローカルファイルシステムに搭載する方法もあります。</p><p>
</p>
<p><a href="https://github.com/tpope/vim-pathogen" rel="nofollow" title="" class="ext-link">Pathogen</a>は、プラグインを管理するための最初の人気のあるツールです。実際に行っていることは、全てを適したディレクトリの下に含めるように<em>ランタイムパス</em>（<code>:h 'rtp'</code>）を調整する、というものです。プラグインのレポジトリを、自分の手でクローニングしなくてはいけません。</p><p>実際のプラグインマネージャはVimの中からプラグインをインストールしアップデートするコマンドを提供します。以下に挙げるのは、一般的に使われるマネージャのリストをアルファベット順に並べたものです。</p><p>私のお気に入りはplugです。でも皆さんの役に立つのは、様々かもしれません。</p><p>
</p>
<p>これは複数の連続した行に、同じテキストを同時に挿入するテクニックです。こちらの<a href="https://raw.githubusercontent.com/mhinz/vim-galore/master/media/block_insert.gif" rel="nofollow" title="" class="ext-link">デモ</a>を見てください。</p><p><code>&lt;c-v&gt;</code>でビジュアルブロックモードに切り換えます。その後、数行ほど下へ移動したら、<code>I</code>あるいは<code>A</code>を押して、テキストを入力し始めましょう。</p><p>最初は少し当惑するかもしれませんが、テキストはいつも現在の行に挿入され、現行の挿入が終わった後にだけ、先のビジュアルセレクションの行すべてに同じテキストが適用されます。</p><p>簡単な例としては、<code>&lt;c-v&gt;3jItext&lt;esc&gt;</code>になります。</p><p>もしも異なる長さの行があり、各行の終わりに同じテキストを付け加えたいのなら、次のことを実行しましょう。<code>&lt;c-v&gt;3j$Atext&lt;esc&gt;</code></p><p>時には、現在の行の終わりのどこかにカーソルを置く必要があることもあります。これはデフォルトでは行えませんが、オプションの<code>Virtualedit</code>を設定することができます。</p><p>その後で、行の最後であっても<code>$10l</code> あるいは<code>90|</code>が働きます。</p><p>さらに情報が欲しい方は、<code>:h blockwise-examples</code>を参照してください。最初は複雑に思えるかもしれませんが、すぐに習慣づくでしょう。</p><p>もしも本当に手の込んだものがお望みなら、<a href="https://github.com/terryma/vim-multiple-cursors" rel="nofollow" title="" class="ext-link">マルチカーソル</a>を見てみましょう。</p><p>
</p>
<p>免責事項：Vimはシングルスレッドなので、外部のプログラムをフォアグラウンド処理で実行すれば、他のものも全部ブロックされてしまいます。もちろん、LuaなどのVimのプログラミングインターフェースや、そのスレッドのサポートを使うことができます。しかしそれでも、その間Vimのプロセスはブロックされます。Neovimは適したジョブAPIを加えることで、この問題を解決します。</p><p>（どうやらBramはVimにもジョブコントロールを加えることを検討しているようです。最新のバージョンを持っているなら、<code>:helpgrep startjob</code>を見てください。）</p><p>ジョブを始めるために、<code>:!</code>を使いましょう。現在稼働しているディレクトリでファイルをリスト化したいのなら、<code>:!ls</code>を使いましょう。通常どおりシェルの中で命令するためには、<code>|</code>を使います。例えば、<code>:!ls -1 | sort | tail -n5</code>のような感じです。</p><p>範囲がないのなら、<code>:!</code>のアウトプットはスクロールできるウィンドウで見られるでしょう。その一方、範囲が与えられているのなら、これらの行は<a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)" rel="nofollow" title="" class="ext-link">フィルタに</a>になるでしょう。つまり、フィルタプログラム上で<a href="https://ja.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0#.E6.A8.99.E6.BA.96.E5.85.A5.E5.8A.9B_.28stdin.29" rel="nofollow" title="" class="ext-link">標準入力</a>によって命令されているということです。そして処理はフィルタの<a href="https://ja.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0#.E6.A8.99.E6.BA.96.E5.87.BA.E5.8A.9B_.28stdout.29" rel="nofollow" title="" class="ext-link">標準出力</a>によって置き換えられます。例えば、次の5行のために数字を用意するためには、次を使いましょう。</p><p><code>:.,+4!nl -ba -w1 -s' '</code></p><p>手動で範囲を加えることはかなり面倒なので、Vimは便利なヘルパーも用意しています。範囲にはよくあることですが、ビジュアルモードで行を選択することもでき、それから<code>：</code>をヒットします。また、動作を行う<code>!</code>オペレータもあります。例えば、<code>!ip!sort</code>は、現在のパラグラフの行をソートします。</p><p>フィルタリングの良いユースケースとしては、<a href="https://golang.org/" rel="nofollow" title="" class="ext-link">Go programming language</a>があります。このインデントは独断的ですが、Goのソースコードを適切にインデントする<code>gofmt</code>と呼ばれるフィルタも付いてきます。ですからGoのためのプラグインは、しばしば<code>:Fmt</code>と呼ばれるヘルパーコマンドを提供します。それは基本的には<code>:%!gofmt</code>を行い、ファイルの全ての行をインデントします。</p><p>現在の行より下でプログラムのアウトプットを取り出すために、しばしば<code>:r !prog</code>が使われます。これはスクリプトには問題ありませんが、実行中の場合には代わりに<code>:r !prog</code>を使う方が簡単だと思います。これは現行の行と置き換わるものです。</p><p>
</p>
<p>VimはC言語内で書かれたものなので、多くの特徴はC言語に似た構文と考えられます。デフォルトでは、カーソルが<code>{</code>あるいは<code>#endif</code>にある時、<code>%</code>を使ってそれぞれ対応する<code>}</code>や<code>#ifdef</code>にジャンプすることができます。</p><p>Vimにはmatchit.vimと呼ばれるプラグインがバンドルされています。デフォルトでは有効になっていません。また、<code>%</code>をHTMLタグに循環させ、VimLなどでifやelse、endifなどを構築し、新しいコマンドをいくつか導入します。</p><p>プラグインを常に読み込むには、vimrcに以下を追加しましょう。</p><p>Matchitのドキュメンテーションはかなり広範囲に渡るので、次のものも1回試してみることをお勧めします。</p><p>これでプラグインを使う準備ができました。サポートされているコマンドは<code>:h matchit-intro</code>を、サポートされている言語は<code>:h matchit-languages</code>を参照してください。</p><p>対応したペアを定義するのは簡単です。</p><p>その後で、<code>%</code>（前）や<code>g%</code>（後ろ）を使うことで、Pythonmのどのファイルでもこの3つのステートメントを循環させることができます。</p><p>関連するヘルプ</p>
