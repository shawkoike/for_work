<p><a href="https://github.com/DrkSephy/es6-cheatsheet" rel="nofollow" title="" class="ext-link">es6-cheatsheet</a>(2016-02-08時点) by <a href="https://github.com/DrkSephy" rel="nofollow" title="" class="ext-link">David Leonard</a> and contributers</p><p>日々の仕事の中で役に立つES2015（ES6）のティップス、コツ、ベストプラクティス、プログラムの見本をご紹介します。コントリビューション歓迎です！</p><p><code>var</code>の使用例です。</p><p>しかし、<code>var</code>を<code>let</code>へ置き換えると以下のようになります。</p><p>上記の挙動の変化で明確になるのは、<code>var</code>を使った過去のプログラムをリファクタリングする際には注意しなければならないということです。やみくもにインスタンスの<code>var</code>を<code>let</code>に置き換えると、予想外の挙動を引きおこします。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES6のブロックを使います。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>レキシカルスコープから<code>this</code>のコンテキストを守るために、今まではよく関数をネストしていました。下記のような例です。</p><p>この問題の一般的な解決法は、<code>this</code>コンテキストを変数として格納することです。</p><p><code>this</code>の正しいコンテキストを受け渡すこともできます。</p><p>下記のようにコンテキストを結びつけることもできます。</p><p><strong>アロー関数</strong>を使うと、<code>this</code>の値を隠さずに上記を書き換えることができます。</p><p>単純に値を返す関数式として使う場合、アロー関数はもっと簡潔になります。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES6では、標準ライブラリが膨大に増えました。この変更にともない、<code>.includes()</code>や<code>.repeat()</code>のような、文字列にも使える新たなメソッドも追加されています。</p><p>文字列が含まれているかどうかを明らかにするために戻り値が<code>&gt; -1</code>か否かを確認する代わりに、ブーリアン値を返す<code>.includes()</code>を使うだけで足ります。</p><p>ES6では、もっと簡単に実装できます。</p><p><strong>テンプレートリテラル</strong>を使うと、特殊文字を明示的にエスケープしなくても文字列内で使うことができます。</p><p>また、<strong>テンプレートリテラル</strong>は補間をサポートしているので、文字列と数値を結びつけるタスクもできます。</p><p>もっと簡単にします。</p><p>ES5では、改行を次のように追加していました。</p><p>あるいは、こんな感じです。</p><p><strong>テンプレートリテラル</strong>では明示的に改行を示す必要がありません。</p><p>テンプレートリテラルでは式も同じように扱えます。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>デストラクチャリングによって、配列やオブジェクトから（深くネストされていたとしても）値を抽出し、より便利な構文で変数の中に保存することができます。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES6以前は、クライアント側にモジュールを作るためには<a href="http://browserify.org/" rel="nofollow" title="" class="ext-link">Browserify</a>のようなライブラリを、<strong>Node.js</strong>では<a href="https://nodejs.org/api/modules.html#modules_module_require_id" rel="nofollow" title="" class="ext-link">require</a>を使っていました。ES6では、全てのタイプのモジュール（AMDとCommonJS）を直接使うことができます。</p><p>ES6では、いろいろなエクスポートが可能で、<strong>名前付きエクスポート</strong>を実行することができます。</p><p>オブジェクトの<strong>リストのエクスポート</strong>もできます。</p><p>また、関数やオブジェクト、値（など）も、<code>export</code>というキーワードを使うだけでエクスポートできます。</p><p>最後に、<strong>デフォルトのバインディングもエクスポート</strong>できます。</p><p>ES6は、様々なインポート機能を提供してくれます。以下に示すように、ファイルを丸ごとインポートすることができます。</p><p>Pythonと同様に、名前付きインポートがあります。</p><p>また、名前付きインポートの名前を変更することもできます。</p><p>それに加え、<strong>全てをインポート</strong>することもできます（名前空間インポートと呼ばれることもあります）。</p><p>最後に、モジュールから値のリストをインポートすることもできます。</p><p>デフォルトのオブジェクトをインポートする時は、どの機能をインポートするか選択することができます。</p><p>以下のように、これをさらに簡略化することもできます。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES5では、<strong>デフォルトの値</strong>、<strong>不定の引数</strong>、<strong>名前付きパラメータ</strong>を必要とする関数を扱うために様々な方法をとっていました。ES6を使えば、より簡潔な構文でES5以上のことができます。</p><p>ES6では、関数の中でパラメータにデフォルトの値を簡単に与えることができます。</p><p>ES5では、引数の個数が定まっていない場合このように扱いました。</p><p><strong>rest</strong>オペレータを使うことで、個数の定まっていない引数を渡すことができます。</p><p>ES5で名前付きパラメータを扱うパターンの1つには、jQueryから適用された、<strong>options object</strong>パターンを使うというものがありました。</p><p>これと同じ機能性を、関数の正式なパラメータとしてデストラクチャリングを使うことによって成し遂げることができます。</p><p>全ての値をオプションにしたい場合は、空のオブジェクトをデストラクチャリングすることによってできます。</p><p>ES5では、以下のように<code>Math.max</code>で<code>apply</code>メソッドを使うことで、配列内の最大値を見つけることができていました。</p><p>ES6では、関数のパラメータとして使うための値の配列を渡すためにspread演算子を使うことができます。</p><p>理解しやすい構文を使って、簡単にリテラルの配列を連結することができます。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES6より前でクラスの実装を行う時は、プロトタイプを拡張してプロパティを追加し、コンストラクタ関数を生成していました。</p><p>そして下記のように拡張したクラスを生成していました。</p><p>ES6ではこれを内部で処理してくれる糖衣構文が提供されているため、直接クラスを生成することができます。</p><p>キーワード <code>extends</code>を使って拡張できます。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES6以前もシンボルは存在していましたが、ES6ではシンボルを直接扱えるパブリックインターフェースを備えています。シンボルは変更不可能かつユニークで、どのハッシュにおいてもキーとして使うことができます。</p><p><code>Symbol()</code>または<code>Symbol(description)</code>をコールすれば、グローバルに参照のできないユニークなシンボルを生成できます。<code>Symbol()</code>のユースケースでは、あなたのロジックにサードパーティのオブジェクトや名前空間をパッチすることができますが、ライブラリのアップデートと衝突しないという確信がある場合だけにしてください。例えば、クラス<code>React.Component</code>にメソッド<code>refreshComponent</code>を追加したい場合、後のアップデートの時にメソッドを侵害しないことを確認してください。</p><p><code>Symbol.for(key)</code>も不変でユニークなシンボルを生成しますが、こちらはグローバルに参照できます。<code>Symbol.for(key)</code>を同じように2回コールすると、同じシンボルのインスタンスを返します。注：<code>Symbol(description)</code>の場合は違います。</p><p>シンボルに共通のユースケース、特に<code>Symbol.for(key)</code>を使うのは相互運用性のためです。これを行うには、既知のインターフェースを含むサードパーティのオブジェクト引数上で、コードにシンボルのメンバを探させます。以下のようになります。</p><p>他のライブラリでも同様です。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p><strong>マップ</strong>はJavaScriptにおいて非常に重要なデータ構造です。ES6以前はオブジェクトを介して<strong>ハッシュ</strong>マップを生成していました。</p><p>しかしこの場合、過って関数をプロパティ名で上書きしてしまう危険性があります。</p><p><strong>マップ</strong>を使えば、値の<code>set</code>や<code>get</code>そして<code>search</code>が（もっと多くのことも）できます。</p><p>マップの最も素晴らしい点は文字列以外も使えるということです。キーとしてあらゆる型を、文字列に型変換せずに使えます。</p><p><code>.entries()</code>を用いてマップを反復処理させることもできます・</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES6以前のバージョンでプライベートデータを保存するには様々な方法がありましたが、その1つに命名規則を用いる方法がありました。</p><p>しかし命名規則はコードベースに混乱をきたしかねず、規則の一貫性を保つのも難しいものです。代わりに、WeakMapを使って値を保存しましょう。</p><p>プライベートデータを保存する時にWeakMapを使う利点は、キーによってプロパティ名が表に出ないところです。プロパティ名は<code>Reflect.ownKeys()</code>を使って参照します。</p><p>WeakMapを使うデータ保存のより実用的な例としては、DOMそのものを汚さずにDOM要素に関連したデータの保存ができるということが挙げられます。</p><p>ガベージコレクションによってオブジェクトが破棄されたら、WeakMapはそのオブジェクトが指定したキー値のペアを自動的に削除します。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>Promiseは下記のような階層の深いコード（コールバック地獄）を解消します。</p><p>次のような縦型のコードにしてくれます。</p><p>ES6以前は<a href="https://github.com/petkaantonov/bluebird" rel="nofollow" title="" class="ext-link">bluebird</a>や<a href="https://github.com/kriskowal/q" rel="nofollow" title="" class="ext-link">Q</a>を用いていましたが、今はPromiseがネイティブに実装しています。</p><p>2つのハンドラがあり、<strong>resolve</strong>（Promiseが解決された時に呼ばれる関数）と、<strong>reject</strong>（Promiseが拒否された時に呼ばれる関数）です。</p><p>Promiseを使用した具体例を挙げます。</p><p><code>Promise.all()</code>を使えば、Promiseを<strong>並列化</strong>して非同期処理の配列を扱うこともできます。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p><a href="#promises">Promise</a>がどのようにして<a href="http://callbackhell.com/" rel="nofollow" title="" class="ext-link">コールバック地獄</a>を解消するのに役立つかという話とも似ているのですが、ジェネレータはコードをフラット化するのに役立ちます。つまり、非同期コードを同期的に処理できます。ジェネレータは本質的に、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="nofollow" title="" class="ext-link">実行を一時停止</a>する関数で、結果的に式の値を返します。</p><p>ジェネレータを利用したシンプルな例を下記に挙げます。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next" rel="nofollow" title="" class="ext-link">next</a>はジェネレータを更に押し進め、新しい式を評価します。上記の例は非常によく練られていますが、ジェネレータを使えば、同期的な手法で非同期コードを書くことができます。</p><p>ここではデータを返すジェネレータ関数を書いています。</p><p><code>yield</code>の力によって、<code>entry1</code>がパースに必要なデータを備え、<code>data1</code>に保存されることが保証されます。</p><p>ジェネレータを用いれば同期的な方法で非同期コードが書けます。しかし、エラー伝搬に対する明確で簡単なパスはありませんから、Promiseでジェネレータを補います。</p><p>それから<code>next</code>を使ってジェネレータをたどっていく関数を書きます。この時、今度は上記のメソッド<code>request</code>を活用してPromiseを生成します。</p><p>Promiseでジェネレータを補うことにより、Promiseの<code>.catch</code>と<code>reject</code>を使ってエラーを伝搬する明確な方法が手に入りました。新しく補強されたジェネレータの使用法は以前と同様に簡単です。</p><p>以前と同じようにジェネレータを使い、実装を再利用することができ、とても便利ですね。ジェネレータとPromiseを使えば同期的な方法で非同期コードを書くことができ、優れたエラー伝搬の能力を取得できますが、同等のメリットがある、もっとシンプルな構造もご紹介しましょう。<a href="https://github.com/DrkSephy/es6-cheatsheet#async-await" rel="nofollow" title="" class="ext-link">async await</a>です。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p><p>
</p>
<p>ES2016から搭載予定の機能<code>async await</code>を使えば、ジェネレータとPromiseを使って達成したのと同等の内容を、より少ない労力で達成することができます。</p><p>内部的にはジェネレータと似たような挙動ですが、ジェネレータとPromiseの組み合わせよりもこちらの利用を強くお勧めします。ES7とBabelをすぐ活用したいなら、優れた資料が<a href="http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html" rel="nofollow" title="" class="ext-link">こちら</a>にあります。</p><p>（<a href="#table-of-contents">目次へ戻る</a>）</p>
