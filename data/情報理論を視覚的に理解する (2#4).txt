<p><a href="http://colah.github.io/posts/2015-09-Visual-Information/" rel="nofollow" title="" class="ext-link">Visual Information Theory</a> （2015-10-14） by <a href="http://colah.github.io/about.html" rel="nofollow" title="" class="ext-link">Christopher Olah</a></p><p><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)'],['\\[','\\]']], processEscapes: true  },  CommonHTML: { matchFontHeight: false }});</script><br>
<script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script></p><p>コードの長さが1ビットなら使用できるコードは0と1の2つ、長さが2ビットなら00、01、10、11の計4つです。つまり1ビット増えるごとに、使用できるコードの数は2倍になります。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/CodeSpace.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-171"><br>
では、コードワードによって長さが異なる可変長コードの場合はどうなるでしょうか。3ビット長のコードワードが8つという単純なケースだけでなく、2ビット長のコードワードが2つと3ビット長のコードワードが4つなど、より複雑な組み合わせも考えられます。このような長さの異なるコードワードをいくつ使用できるかは、何を基に決まるのでしょうか。</p><p>前述のとおり、Bobは各単語をコードワードに置き換えて、それらを連結することで、メッセージをエンコードされた文字列に変換しています。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/encode.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-172"><br>
<em>注釈：<br>
エンコードされた文字列<br>
コードワード<br>
元のシンボル</em></p><p>可変長コードを作成する際は、少々厄介な問題があるため注意が必要です。具体的には、エンコードされた文字列を分割してコードワードに戻す方法です。コードワードの長さが一律であれば、単純に文字列を等間隔で分割すれば済みます。しかし、さまざまな長さのコードワードが混在する場合は、その中身についても考慮しなくてはなりません。</p><p>ここでの目標は、単一の方法で文字列をデコードし、各コードが一意的にデコードされるようにすることです。エンコードされた文字列に含まれるコードワードが一意に決まらない状態は避ける必要があります。この課題は、「コードワードの区切り」を表す符号を使えば、簡単に解決できるでしょう。<sup id="fnref:2"><a href="#fn:2" class="footnote-ref">1</a></sup>　しかし、今回はこの方法を取らず、0と1のみを送信します。そのため、連結されたコードワードを調べて、各コードワードの区切りを見極める方法が必要になります。</p><p>作成したコードが一意的にデコードできないケースは非常に多くあります。たとえば0と01がともにコードワードだとしましょう。この場合、エンコードされた文字列0100111の最初のコードワードを特定することはできません。0の場合も、01の場合もあり得ます。よって、「ある特定のコードワードに対して、それを長くしたバージョンのコードワードが存在してはならない」という性質が必要になります。言い換えると、どのコードワードも、他のコードワードの接頭部であってはならないということです。この性質は語頭属性と呼ばれ、これを満たすコードを接頭コードと言います。</p><p>「あるコードワードを使用することで、ある範囲のコードワードが使用できなくなる」と考えると分かりやすいでしょう。例えば01というコードワードを使う場合、これを接頭部に持つコードワードは使えなくなります。010や011010110などは、どのコードワードなのか一意に定まらないため使用できなくなるのです。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/CodeSpaceUsed.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-173"><br>
コードワード全体の4分の1は01から始まるため、4分の1のコードワードは使用できなくなります。2ビット長の短いコードワードを1つ使うためには、こうした代償を払わなくてはならず、結果的に他のコードワードを少し長くする必要が生じます。さまざまな長さのコードワードを使用する場合は、この種のトレードオフが常に存在します。あるコードワードを短くすると、使用できるコードワードの範囲が狭まり、他のコードワードを短くできなくなるのです。よって、適当なトレードオフを見極めることが重要になります。</p><p>この内容については、限られた予算で短いコードワードを入手すると考えてみるとよいでしょう。1つのコードワードを得るには、そのコストとして一部のコードワードを犠牲にしなくてはなりません。</p><p>長さが0のコードワードのコストは1で、これは利用可能な全てのコードワードになります。つまり、コードワードの長さが0だと、他のコードは使用できません。次に、長さが1のコードワード「0」の場合は、取り得るコードワードの1/2は「0」から始まるため、コストは1/2になります。同様に長さが2のコードワード「01」の場合は、取り得るコードワードの1/4は「01」から始まるため、コストは1/4です。まとめると、コードワードのコストは、コードワードの長さが増すにつれて<em>指数関数的に</em>減少します。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-costonly.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-174"><br>
上のように、コストが（自然対数を底とする）指数関数的に減少する場合、それは高さと面積の両方に当てはまる点に注目してください。<sup id="fnref:3"><a href="#fn:3" class="footnote-ref">2</a></sup></p><p>では、メッセージ長の平均値を短くするために、コードワードを短くしましょう。各コードワードを使用すると、メッセージ長の平均値は「そのコードワードの発生確率×コードワード長」倍だけ長くなります。例えば発生確率が50％の4ビット長のコードワードを送信する場合は、このコードワードを送信しない場合に比べて、メッセージ長の平均値は2ビットだけ長くなります。図にすると以下の長方形のようになります。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-lengthcontrib.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-175"><br>
<em>注釈：<br>
メッセージ長の平均値の増分</em></p><p>コードワードのコストとメッセージ長の平均値は、コードワード長で関連付けられています。つまり、投じるコストによってコードワード長が決まり、コードワード長によってメッセージ長の平均値の増分が決まります。これらをまとめて図示すると以下のようになります。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-cost.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-176"><br>
<em>注釈：<br>
メッセージ長の平均値の増分<br>
コードワードのコスト</em></p><p>コードワードが短くなると平均のメッセージ長も短くなりますが、コストがかさみます。逆にコードワードが長くなると平均のメッセージ長も長くなりますが、コストは抑えられます。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-cost-longshort.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-177"><br>
<em>注釈：<br>
コードワードが短く、コストが高い<br>
コードワードが長く、コストが低い</em></p><p>では限られたコストを有効に使うにはどうしたらよいのでしょうか？　各イベントで、どれだけの予算をコードワードに費やすべきかを考えてみましょう。</p><p>使用頻度の高いツールに投資するように、発生頻度の高いコードワードに予算をかけたいと思うのは、ごく自然なことです。つまりイベントの発生頻度に比例して、予算を割り当てます。例えば発生頻度が50％のイベントには、予算の50％を割いて短いコードワードを得ます。一方で発生頻度が1％のイベントには、予算の1％しか割り当てません。使用頻度の低いコードワードは、長くてもそれほど気にする必要がないからです。</p><p>これは実に自然な方法に思えますが、本当に最善策なのでしょうか？　答えはイエスです。それをこれから証明しましょう。</p><p><em>以下の証明は、画像を使用して分かりやすく説明していますが、この記事で一番難しい部分なので、理解するのに苦労するかもしれません。よって、この内容と前提として受け入れて、次のセクションに飛んでいただいても構いません。</em></p><p>では具体例として、2つのイベントが発生する会話について考えてみましょう。イベント<span class="math">\(a\)</span>の発生する頻度を<span class="math">\(p(a)\)</span>、イベント<span class="math">\(b\)</span>の発生する頻度を<span class="math">\(p(b)\)</span>とします。予算は上記の自然な方法で割り当てます。コードワード<span class="math">\(a\)</span>を短くするために予算の<span class="math">\(p(a)\)</span>割を、コードワード<span class="math">\(b\)</span>を短くするために予算の<span class="math">\(p(b)\)</span>割を費やします。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-auction-balanced-noderivs.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-178"><br>
<em>注釈：<br>
長さの増加分<br>
コスト</em></p><p>ここでは、コストと長さの増分の境界はピッタリとそろっています。これは何を意味するのでしょうか？</p><p>まず、コードワードの長さをわずかに変えた時の、コストと長さの増分への影響を見てみましょう。コードワードを少しだけ長くすると、メッセージ長の増分は境界の高さに比例して増加します。一方でコストは境界の高さに比例して減少します。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-derivs.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-179"><br>
コードワード<span class="math">\(a\)</span>を短くするためのコストは<span class="math">\(p(a)\)</span>です。この時、各コードワードの長さはどれも同等に重要なわけではなく、重要度はそれぞれの使用量に比例します。<span class="math">\(a\)</span>を使用する割合は<span class="math">\(p(a)\)</span>なので、<span class="math">\(a\)</span>のコードワードを少し短くする利益は<span class="math">\(p(a)\)</span>ということになります。</p><p>興味深いことに、同じ値が導かれました。つまり元々の予算には面白い性質があって、よりコストをかけるほど、その投資額に応じてコードワードを短くしたことによる利益が得られるのです。つまり、コストに対する利益の比を考慮して、より多く投資する対象を決めればよいということです。ここでは、その比は<span class="math">\(\frac{p(a)}{p(a)}\)</span>なので1になります。<span class="math">\(p(a)\)</span>の値によらず、常に1です。同じことが、もう1つのイベントについても言えます。利益/コストの値は常に1なので、どのコードワードへの投資を少し増やしても同じ価値があるということになります。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-auction-balanced.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-180"><br>
ごくわずかであれば、予算を変えても意味がないと言えます。しかし、これだけでは最適な予算だという証明にはなりません。では証明をするために、一方のコードワードの予算の一部を他方のコードワードに当てる予算パターンを考えましょう。<span class="math">\(b\)</span>の予算をε減らして、その分を<span class="math">\(a\)</span>に当てます。これにより<span class="math">\(a\)</span>のコードワードが少し短くなり、<span class="math">\(b\)</span>のコードワードが少し長くなります。</p><p>ここでは、より短い<span class="math">\(a\)</span>のコードワードを買うコストは<span class="math">\(p(a) + \epsilon\)</span>、より短い<span class="math">\(b\)</span>のコードワードを買うコストは<span class="math">\(b\)</span>になります。しかし利益は変わりません。よって、<span class="math">\(a\)</span>のコストに対する利益の比は<span class="math">\(\frac{p(a)}{p(a) + \epsilon}\)</span>となり、1よりも小さくなります。一方で<span class="math">\(b\)</span>のコストに対する利益の比は<span class="math">\(\frac{p(b)}{p(b) – \epsilon}\)</span>となり、1よりも大きくなります。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/code-auction-eps.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-181"><br>
そうなると価格の均衡は崩れ、<span class="math">\(a\)</span>よりも<span class="math">\(b\)</span>の方がお得になります。投資家は「<span class="math">\(b\)</span>を買え、<span class="math">\(a\)</span>を売れ」と言うでしょう。実際にそのようにすると、元の予算案に戻るわけです。つまり、元々の予算案に近づけることで、全体的な予算案が改善されるのです。</p><p>元々の「各コードワードには使用頻度に比例した額を投資する」という予算案は、自然であるだけなく、最適な方法だったのです（上記の証明は2つのコードワードに限定されるものですが、より多くのコードワードに対応するよう簡単に一般化することができます）。</p><p>（注意深い読者の方は、最適な予算によって決まるコードで、コードワードの長さが小数になる可能性があることに気づいたかもしれません。そうなると、非常に厄介な状況になります。一体どういうことでしょうか？　現実的には、1つのコードワードを送信して通信をしたい場合は、当然ながら整数に丸める必要があります。しかし後述のように、一度に多くの情報を送る場合は、実は小数のコードワードを送ることができます。これについては後ほど説明しますので、そちらをご覧ください。）</p><p>前述のとおり、長さが<span class="math">\(L\)</span>のメッセージのコストは<span class="math">\(\frac{1}{2^L}\)</span>です。この関係から、逆にコストが分かれば<span class="math">\(\log_2\left(\frac{1}{\text{cost}}\right)\)</span>を計算することで、メッセージ長を求めることができます。<span class="math">\(x\)</span>のコードワードに使うコストは<span class="math">\(p(x)\)</span>だったので、長さは<span class="math">\(\log_2\left(\frac{1}{p(x)}\right)\)</span>になります。この値が採用すべき最適な長さです。</p><p><img src="http://colah.github.io/posts/2015-09-Visual-Information/img/entropy-def-notitle.png" alt="" data-disqus-identifier="/posts/2015-09-Visual-Information/disqussion-182"><br>
先ほど議論したように、イベントを送受信するための平均メッセージ長をどこまで短くできるかは、本質的に確率分布<span class="math">\(p\)</span>によって決まります。最適なコードを使った際の平均メッセージ長の下限をpのエントロピーと言い、<span class="math">\(p\)</span>, <span class="math">\(H(p)\)</span>と表します。すでにコードワードの最適な長さは分かっているので、以下の式でエントロピーを計算できます。<br>
<span class="math">\[H(p) = \sum_x p(x)\log_2\left(\frac{1}{p(x)}\right)\]</span><br>
<em>一般的には、<span class="math">\(\log(1/a) = -\log(a)\)</span>という関係を使って、<span class="math">\(H(p) = – \sum p(x)\log_2(p(x))\)</span>と表現します。個人的には前者の方が感覚的に分かりやすいと思うので、この記事ではそちらを使います。）</em></p><p>いずれにせよ、イベント発生時に通信を行うには、最低でもこのビット数を送信しなければなりません。</p><p>何かを伝達する際に必要な平均情報量により、明確に圧縮方法が示唆されます。それ以外にも平均情報量について考慮すべき理由はあります。平均情報量は不確定度合い表すとともに、情報を定量化する方法を与えてくれるのです。</p><p>何が起こるか分かっていたら、メッセージを送る必要はありません。また、それぞれ50％の確率で発生する2つの事象があれば、1ビットを送るだけで済みます。しかし64個の事象が等しい確率で発生し得る場合は、6ビットを送信しなければなりません。発生確率が高いほど、平均メッセージ長が短く、より優れたコードを作成できます。一方、発生確率が低いほど、メッセージを長くせざるを得なくなります。</p><p>一般的に結果が不確かであるほど、何が起きたか判明した時に学ぶことは多いものです。</p>
