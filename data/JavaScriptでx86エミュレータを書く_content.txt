WRITING AN X86 EMULATOR IN JAVASCRIPT （2015-09-13） by Tadeu Zagalloコンピュータ・サイエンスのバックグラウンドを持たない者として、私は常々もっと低いレベルでプログラムのしくみを理解したい、そこに多くのエネルギーを費やしたいと考えてきました。そこで、まずは基本を身につけるためにプログラミングの入門書である『Programming from the Ground Up』を入手したのですが、なかなか学習を始められずにいました。そんな時、ちょうどブラジルまでの11時間にも及ぶフライトが予定されており、それがこの本を読み始めるにはもってこいの機会となったのです。読んでみると、この本がすっかり気に入ってしまいました。ただ、事例がLinux x86 GNUアセンブリ言語で書かれていたのです。私は64ビットのMac OS Xユーザでした…。アセンブラ、リンカフラグの例や、i386とx86_64間のシンタックスを理解するのにはインターネットが欠かせないほど悪戦苦闘しました…。（i386では、exitシステムコールへの戻り値は%ebxにではなく、スタックに格納されなければなりません。また、x86_64では、システムコール番号に0x2000000のオフセットを考慮する必要があることや、レジスタが異なること、int  $0x80ではなくsyscallを使わなくてはいけないことなどが分かりました…。こうしたことは、アセンブリ言語から始めた場合、いずれも容易なことではありません）。そのあたりは一旦考えないことにしようと思いましたが、やはりそうもいかず、とりあえずダミーとなるx86のパーサを書き始めることにしました。PCのバッテリーが切れるまでに、手始めとして行うにはちょうど良かったのです（機内では電源が使えないこと以上に不便なことはないですね）。数ヶ月後、英チェルシーのスタジアムでFacebookのハッカソンが予定されていたのですが、その機会に、実際にバイナリがどう実行されるのかを理解するため、x86エミュレータを実装してみようと思いました。このプロジェクトに取り組んでもらうため、関係者を説得するのは容易ではありませんでした。私がおかしくなったわけではないということ、そして私自身、正しいエミュレータを書くことがいかに難しいかを当然承知した上で言っているのだということを分かってもらうには時間がかかりました。さらに、あくまで楽しみのためだけにエミュレータを書くこと、非常に基本的なケースのみを対象にするつもりだということを説明するのにも苦労しました。それでも、最終的にはUri Baghinに参加できることになったのです。初期の目標は、x86の最もシンプルなプログラムを実行することでした。それは、単にコード0でプログラムを終了することです。Mac OS Xで上記のプログラムをビルドする方法は以下の通りです。テストするために、次のコマンドで実行と終了コードの確認ができます。そこで、私たちは問題を2つに分けることにしました。バイナリで実際のアセンブリ命令を見つけることと、それを実行することです。バイナリには単なるアセンブリコードよりも多くの情報が含まれています。レイアウトやアーキテクチャのサポート、仮想メモリへのロード、シンボルなどに関する情報です。<img src="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/art/mach_o_segments.gif" alt="Mach-O Binary
image">
注釈： バイナリのレイアウトをよりよく可視化するために、MachOViewをお勧めします。これは、バイナリ自体を調べるときに非常に便利です。バイナリのアセンブリコードを見つけるためには、ロードコマンドを読み取る必要があります。具体的にはLC_SEGMENTロードコマンドです。これにはバイナリのセグメントを仮想メモリにマップするための情報が含まれているのです。LC_SEGMENTロードコマンドには、いくつかのフィールドがあります。しかし、とりあえずはVMプロテクションとフラグを無視して、単にFile OffsetからFile Offset + File Sizeまでのバイナリのコンテンツを、VM AddressからVM Address + VM Sizeまでの仮想メモリ（このケースではシンプルなArrayBufferとして実装されている）にコピーします。次は、LC_UNIXTHREADロードコマンドです。これにより、プログラムのメインスレッドの実行についての初期状態が分かります。ここで重要なことは、%eip（命令ポインタ）の初期値です。これにより、最初のプログラム命令の仮想メモリにおける位置、つまりコードが実際に開始される位置が分かります（注釈：サンプルのコードでは、レジスタをシミュレートするのではなくPCと呼ばれるグローバル変数を使っています）。さて、仮想メモリにプログラムコードをマップできて、コードの初めにポインタを合わせるところまで来たので、あとはただ実行する必要があります。面白いのは、x86には可変サイズの命令があることです。そのため、どのくらいのバイトになるのか、最初にオペコードを読まなければなりません。<img src="http://securitydaily.net/wp-content/uploads/2015/01/cpu1.jpg" alt="x86 Instruction
Format">
“KISS”（Keep It Simple, Stupid）の原則に従い、生成されたバイナリをobjdumpで逆アセンブルしました。objdumpはbinutilsパッケージと共にインストールすることができるCLIです。すると次のようになります。機能を全て整えたエミュレータを実装しようとは思っていなかったため、とりあえず必要なオペコードのシンタックスを探したところ、x86向けの適切なリファレンスhttp://ref.x86asm.net/coder.htmlが見つかりました。そこで、オペコードから関数へのマップ（本当にプレーンなJavaScriptオブジェクトで実装しました）を作成しました。関数は、オペコードにより必要となれば、より多くのデータを読み取るための役割を担います。例えば次のようなものがあります。読み込んだオペコードが実はオペコードの接頭語だった場合は、次のバイトにある実際のオペコードを読み取らなければなりません。最後に取り上げたいのは、システムコールです。実際にシミュレートする必要があるため、システムコール番号から関数へのマップをもう一つ使います。バイナリのロードには、File APIを使いました。htmlのページは、バイナリをドロップするinputがあるエントリーポイントであり、そのアウトプットはコンソールに表示されます。ハッカソンの結果として出来上がったコードは、このgistで見ることができます。ここには、説明の通り3つのファイルがあります。ローダー（mach-o.js）、オペコードのロジック（x86.js）、そしてエントリーポイントとして機能するindex.htmlです。このコードは基本的なアセンブリ言語とC言語を実行させることができます。注釈：libcを実行させることはできませんので、C言語は-static –nostdlibでコンパイルし、カスタムアセンブリのブートストラップを提供する必要があります。なお、このコードは全てハッカソンの機会に書かれた、非常にシンプルなものだということを改めてご認識ください。そのため、もっと読みやすいものにする（または、そうした点をより良くする）というところにはあまり注力されておらず、それ以上の書き直しということもしていないものになっています。それでも、C言語で書いてclang -O3でコンパイルしたfibonacci(40)を実行するには十分でした。9分47秒という驚異的な実行時間を叩き出しましたが。追記：HackerNewsでこちらのコメントを読み、DataViewをUint8Arrayと交換したところ、今やfibonacci(40)は1分53秒と、断然速くなりました。こちらの比較によれば、Perlやruby 1.8よりも速いものになったようです。
