<p><a href="http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/" rel="nofollow" title="" class="ext-link">A fast alternative to the modulo reduction</a> (2016-06-27) by <a href="https://twitter.com/lemire" rel="nofollow" title="" class="ext-link">Daniel Lemire</a></p><p><em>N</em>個の要素セットの中からランダムに整数を1つ取り出すと仮定します。使っているコンピュータに32ビット整数の乱数を生成する機能がある場合、その数をどのように<em>N</em>より小さいインデックスに変換すればいいのでしょうか。例えば、サイズが<em>N</em>のハッシュテーブルがあると仮定します。このような場合でも、ハッシュ値（通常32ビットや64ビットの整数）を<em>N</em>より小さいインデックスに変換する必要があります。このような場合、大抵プログラマは解決の際、<em>N</em>が2のべき乗であるようにしますが、これは必ずしも理想的とは言えません。</p><p>任意の整数<em>N</em>をできるだけ公平にマッピングしたいとします。2<sup>32</sup>個存在する32ビットの整数全てから始める場合、{0, 1 ,…, <em>N</em> – 1}の値域に定められた値に、ちょうど2<sup>32</sup>/<em>N</em>個の値をマッピングできるようにするのが理想的です。</p><p>残念ながら、2<sup>32</sup>は<em>N</em>によって割り切れないため、公平にマッピングすることはできません。しかし、完璧にでなくても、floor(2<sup>32</sup>/N)かceil(2<sup>32</sup>/<em>N</em>)のどちらかの個数の値が、値域のそれぞれの値にマッピングされるように設定することはできます。</p><p>もし、2<sup>32</sup>より<em>N</em>が小さい場合、上記の方法で完璧に近いマッピングができるでしょう。</p><p>これらを解決する際、一般的に使用されるのがモジュロ演算で、<em>x</em> mod <em>N</em>と表現されます（特記がない限り、コンピュータサイエンスにおいて、モジュロ演算とは除算により求めた余りと定義されています）。</p><p>公平にできたかの確認はどのようにすればいいのでしょうか。<em>x</em>の値を0から始めてみましょう。すると、<em>x</em>の値が増えるにつれ、モジュロ演算の値は、0, 1, …, <em>N</em> – 1, 0, 1, …などをとることがわかります。そして、最終的に<em>x</em>の値は(2<sup>32</sup> – 1)に到達し、0, 1, …, (2<sup>32</sup> – 1) mod <em>N</em>の値はceil(2<sup>32</sup>/<em>N</em>)回登場し、その他の値はfloor(2<sup>32</sup>/<em>N</em>)回登場します。小さい値にバイアスがかかった公平なマッピングとなっています。</p><p>これでもいいのでしょうが、モジュロ演算は除算を行い、除算は安価な演算ではありません。乗算より高くなります。32ビットの除算を最近のx64プロセッサで実行すると、命令スループットは1命令毎6サイクルで、レイテンシは26サイクルとなります。対照的に、乗算の場合、1命令毎1サイクルで、レイテンシは3サイクルとなります。</p><p><em>N</em>が事前に分かっていれば、工夫を凝らした方法でモジュロ演算を複数の乗算や他の演算に変身させ、”事前計算”することができます。コンパイル時に<em>N</em>が分かっていれば、コンパイラはこれらの演算を事前に実行してくれます。そうでなければ、ソフトウェアライブラリあるいは独自の公式を使って事前計算することができます。</p><p>しかし、もっといい方法が実はあるのです。それは、パフォーマンスに影響せず、簡単に実装でき、モジュロ演算で提供されるマップと同等のものを出してくれます。</p><p>まず、<em>x</em>と<em>N</em>を32ビットの整数と想定し、64ビットの<em>x</em> * <em>N</em>を見てみましょう。(<em>x</em> * <em>N</em>) div 2<sup>32</sup>は値域内に収まっており、公平にマップされています。</p><p>(<em>x</em> * <em>N</em>) div 2<sup>32</sup>の演算は64ビットのプロセッサを使えば、非常に高速にできます。この計算は、乗算をした後ビットをシフトしています。最近のIntelプロセッサでは、恐らくレイテンシは約4サイクルで、スループットは最低でもコール上は毎2サイクルだと思います。</p><p>では、32ビットのモジュロ演算に比べてどれだけマッピングは早くなるのでしょうか。</p><p>これはテストするために、サイズ<em>N</em>の配列のインデックスにランダムに繰り返しアクセスするようベンチマークを実装しました。インデックスはモジュロ演算か上記の方法で取得できます。最近のIntelプロセッサ（Skylake）を使うと、毎アクセスでのCPUサイクルは次のとおりになります。</p><p>結果は4倍速となります。悪くないです。</p><p>いつもどおり、<a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/blob/master/2016/06/25/fastrange.c" rel="nofollow" title="" class="ext-link">私のコードは自由に利用できるようになっています</a>。</p><p>これは何に役に立つのか。例えば、除算を高価にしないため、今まで配列とハッシュテーブルに2のべき乗の容量を無理やり持たせていた場合、上記の高速処理マップを使うことで、パフォーマンスを犠牲にすることなく、任意の容量をサポートすることができます。さらに、乱数の生成も速くなり、高速の乱数発生器を使っている場合は、大いに役に立ちます。</p><p>では、マップが公平かをどうのように確認すればいいのでしょうか。</p><p><em>N</em>を掛けることで[0, 2<sup>32</sup>)の整数値を[0, <em>N</em> * 2<sup>32</sup>)の<em>N</em>の倍数にマッピングします。2<sup>32</sup>で割ることで、[0, 2<sup>32</sup>)にある<em>N</em>の倍数全てを0にマッピングし、[2<sup>32</sup>, 2 * 2<sup>32</sup>)にある<em>N</em>の倍数を1にマッピングする……といったことができます。公平にマッピングされているか確認するには、長さ2<sup>32</sup>の区間での<em>N</em>の倍数の個数をカウントすればいいのです。カウントは、ceil(2<sup>32</sup>/<em>N</em>)かfloor(2<sup>32</sup>/<em>N</em>)になるべきです。</p><p>例えば、「区間の最初の値が<em>N</em>の倍数」という、区間中に存在する倍数の数が最大であることが明白なシナリオを仮定します。いくつあるでしょう。ceil(2<sup>32</sup>/<em>N</em>)となります。長さ<em>N</em>の部分区間を設定すると、全ての完全な区間は<em>N</em>の倍数で始まり、剰余がある場合は<em>N</em>の倍数が1つ追加されます。最悪のシナリオでは、区間内で最初<em>N</em>の倍数が現れるのは<em>N</em> – 1の位置になります。この場合、倍数はfloor(2<sup>32</sup>/<em>N</em>)個になります。ここでも、なぜこのような結果になるのかを見る場合は、長さ<em>N</em>の部分区間を設定します。全ての完全な区間は<em>N</em>の倍数で終わります。</p><p>これで、マップが公平であることを証明できました。</p><p>では、もう少し正確にしてみましょう。「<em>N</em>の倍数の数を最大化できるのは、長さ2<sup>32</sup>の区間の最初の値が<em>N</em>の倍数である場合である」と前に述べました。その区間の最後には、不完全な長さ2<sup>32</sup> mod <em>N</em>の区間ができることになります。しかし、<em>N</em>の倍数が区間の最初に現れるようにするのではなく、インデックス2<sup>32</sup> mod <em>N</em>の位置に現れるようにすれば、不完全な部分区間ができることはありません。つまり、2<sup>32</sup> mod <em>N</em>より前に<em>N</em>が現れると、ceil(2<sup>32</sup>/<em>N</em>)個の倍数が得られ、そうでない場合はfloor(2<sup>32</sup>/<em>N</em>)個の倍数を得られるのです。</p><p>どの結果がfloor(2<sup>32</sup>/<em>N</em>)の頻度で現れ、どの結果がceil(2<sup>32</sup>/<em>N</em>)の頻度で現れるのかを知る術はあるのでしょうか。あります。<em>k</em>という値を出力したと想定します。まず、<em>N</em>の倍数のうちk 2<sup>32</sup>以上のものがどこにあるのか探す必要があります。これはceil(k 2<sup>32</sup> / <em>N</em>) <em>N</em> – k 2<sup>32</sup>にあるのですが、これを2<sup>32</sup> mod <em>N</em>と比較するだけです。もし、2<sup>32</sup> mod <em>N</em>よりも小さければ、カウントはceil(2<sup>32</sup>/<em>N</em>)になり、そうでない場合のカウントはfloor(2<sup>32</sup>/<em>N</em>)となります。</p><p>（更新：Kendall Willetsのコメントを受け、証明をより直感的なものにしました）</p>
