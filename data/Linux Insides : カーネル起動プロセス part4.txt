<p><a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-4.md" rel="nofollow" title="" class="ext-link">Kernel booting process. Part 4.</a> （2015-10-20） by <a href="https://github.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a></p><p><code>Kernel booting process</code>もパート4になりました。4回目の今回は、<a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89" rel="nofollow" title="" class="ext-link">プロテクトモード</a>での最初の一歩についてご紹介します。CPUがサポートする<a href="https://en.wikipedia.org/wiki/Long_mode" rel="nofollow" title="" class="ext-link">ロングモード</a>、<a href="https://ja.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="nofollow" title="" class="ext-link">SSE（ストリーミングSIMD拡張命令）</a>、<a href="https://ja.wikipedia.org/wiki/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E6%96%B9%E5%BC%8F" rel="nofollow" title="" class="ext-link">ページング方式</a>、そしてページテーブルの初期化やロングモードへの移行のお話しです。</p><p><strong>注：このパートでは、アセンブリ言語のソースコードが頻出しますので、知識がない方は、事前に参考書を読むなどして理解を深めておいてください。</strong></p><p>前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" rel="nofollow" title="" class="ext-link">パート</a>では、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/pmjump.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/pmjump.S</a>内にある32ビットのエントリーポイントにジャンプするところで終了しました。</p><p><code>eax</code>レジスタには、32ビットのエントリーポイントのアドレスが含まれていたことを思い出してください。この点は、Linuxカーネルのx86ブートプロトコルから読み込むことができます。</p><p><em>訳：bzImageを使うとき、保護モードのカーネルは0x100000に再配置されました</em></p><p>これが正しいか確認します。32ビットエントリーポイントでのレジスタ値を見てみましょう。</p><p>ここで、<code>cs</code>レジスタに<code>0x10</code>（前回のパートで説明したグローバルディスクリプタテーブルにある2つ目のインデックスです）が、<code>eip</code>レジスタに<code>0x100000</code>、そしてコードセグメントを含む全てのセグメントのベースアドレスにゼロが含まれているのが分かります。つまり、ブートプロトコルにあるように、<code>0:0x100000</code>もしくは<code>0x100000</code>といった物理アドレスを取得することができます。では、32ビットエントリーポイントから始めていきましょう。</p><p>32ビットエントリーポイントの定義は、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/head_64.S</a>から見つけることができます。</p><p>まず、なぜ<code>compressed</code>ディレクトリなのでしょう？　実は<code>bzimage</code>は、gzip圧縮された<code>vmlinux + header + kernel setup code</code>です。カーネルのセットアップコードは、これまでの全てのパートにも出てきました。<code>head_64.S</code>の主な目的は、ロングモードに入る準備、ロングモードへ移行、そしてカーネルを展開することです。カーネルの展開と併せて全てのステップをこのパートで説明していきます。</p><p>なお、<code>arch/x86/boot/compressed</code>ディレクトリには、2つのファイルがあることに注意してください。</p><p>ここでは、<code>x86_64</code>のLinuxカーネルを学ぶので、<code>head_64.S</code>だけを使用します。<code>head_32.S</code>は、今回のケースではコンパイルしていません。では、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/Makefile" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/Makefile</a>を見ていきましょう。以下のターゲットがあります。</p><p><code>$(obj)/head_$(BITS).o</code>に注目してください。これは、head_{32,64}.oのコンパイルが<code>$(BITS)</code>値に左右されることを示しています。他のMakefileにも同様のコードがあります – <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/Makefile" rel="nofollow" title="" class="ext-link">arch/x86/kernel/Makefile</a>。</p><p>どこから始めればいいのか分かったので、早速実践してみましょう。</p><p>上の項目で記載したように<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/head_64.S</a>から始めます。まず、<code>startup_32</code>の定義の前を見ます。</p><p><code>__HEAD</code>は、<a href="https://github.com/torvalds/linux/blob/master/include/linux/init.h" rel="nofollow" title="" class="ext-link">include/linux/init.h</a>で定義されており、以下のようになっています。</p><p>このセクションについては、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/vmlinux.lds.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/vmlinux.lds.S</a>リンカスクリプトから見つけられます。</p><p>ここで、<code>. = 0;</code>に注目してください。<code>.</code>は、ロケーションカウンタと呼ばれるリンカの特殊変数です。これに割り当てられる値は、セグメントのオフセットからのオフセットとなります。ここでは0を割り当てていますが、コメントには以下のように書かれています。</p><p><em>訳:Startup_32の一部は、head_64.Sがアドレス0（ゼロ）であると見なすことに注意する</em></p><p>これで、今どこにいるのかがわかります。。次に<code>startup_32</code>関数を見ていきましょう。</p><p><code>startup_32</code>の最初に<code>DF</code>フラグを消去するための<code>cld</code>命令があります。この後、<code>stosb</code>といった文字列オペレーションや他のものが<code>esi</code>または<code>edi</code>インデックスレジスタをインクリメントします。</p><p>次に<code>loadflags</code>から<code>KEEP_SEGMENTS</code>フラグのチェックを見ます。<code>arch/x86/boot/head.S</code>（ここでは<code>CAN_USE_HEAP</code>フラグをチェックしました）内にあった<code>loadflags</code>を覚えていますか？　ここでは、<code>KEEP_SEGMENTS</code>フラグをチェックする必要があります。このフラグの説明は、linuxブートプロトコルに掲載されています。</p><p><code>KEEP_SEGMENTS</code>が設定されていない場合は、以下のように<code>ds</code>、<code>ss</code>、そして<code>es</code>レジスタをベース0（ゼロ）のフラットセグメントに設定する必要があります。</p><p><code>__BOOT_DS</code>が<code>0x18</code>（グローバルディスクリプタテーブルにあるデータセグメントのインデックス）であることを忘れないでください。<code>KEEP_SEGMENTS</code>が設定されていない場合は<code>1f</code>ラベルにジャンプするか、<code>__BOOT_DS</code>フラグが設定されている場合のみ、これと併せてセグメントレジスタをアップデートします。</p><p>前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" rel="nofollow" title="" class="ext-link">パート</a>を読んだ方は、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/pmjump.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/pmjump.S</a>内のセグメントレジスタがアップデートされているのを覚えているでしょう。ではなぜ、再度設定する必要があるのでしょうか。実際、Linuxカーネルは32ビットブートプロトコルを持っています。ですから、ブートローダがコントロールからカーネルへ移行した直後に実行される最初の関数は、<code>startup_32</code>となります。</p><p><code>KEEP_SEGMENTS</code>フラグをチェックし、正しい値をセグメントレジスタに置いたら、次は実行するために配置した場所とコンパイルした場所の差を計算します（セクションの最初には<code>. = 0</code>が<code>setup.ld.S</code>に含まれていることを思い出してください）。</p><p>ここでは、<code>esi</code>レジスタに<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/bootparam.h#L113" rel="nofollow" title="" class="ext-link">boot_params</a>構造のアドレスが含まれており、<code>boot_params</code>にはオフセットである<code>0x1e4</code>と併せて特殊フィールドである<code>scratch</code>が含まれています。<code>scratch</code>フィールドのアドレス + 4バイトを取得し、これを<code>esp</code>レジスタに置きます（これらの計算のスタックとして使用します）。その後、コール命令とそのオペランドである<code>1f</code>ラベルを見ることができます。さて、<code>call</code>とはどういう意味でしょうか。これは、<code>ebp</code>値をスタック、<code>esp</code>値、そして関数の引数にプッシュし、最後にあるアドレスに返します。この後、スタックからのリターンアドレスを<code>ebp</code>レジスタにポップし（<code>ebp</code>にはリターンアドレスが含まれます）、先のラベル<code>1</code>のアドレスを差し引きます。</p><p>そうすると、<code>ebp</code>（<code>0x100000</code>）に配置した場所にアドレスが入ります。</p><p>次に、スタックをセットアップし、CPUがロングモードと<a href="https://ja.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="nofollow" title="" class="ext-link">SSE</a>をサポートしていることを検証したいと思います。</p><p>カーネルを展開するための新しいスタックをセットアップするアセンブリ言語のコードを見ていきます。</p><p><code>boots_stack_end</code>は、<code>.bss</code>セクションにあります。この定義は、<code>head_64.S</code>の最後にあります。</p><p>まずは、<code>boot_stack_end</code>のアドレスを<code>eax</code>レジスタに置き、それを<code>ebp</code>の値に追加します（ここでは、<code>ebp</code>に<code>0x100000</code>を配置したアドレスが含まれていることを思い出してください）。最後に、<code>eax</code>値を<code>exp</code>に置きます。これで、正しいスタックポインタが得られます。</p><p>次はCPUの検証です。CPUが<code>long mode</code>と<code>SSE</code>をサポートしていることをチェックする必要があります。</p><p><code>cpuid</code>命令に対していくつかの呼び出しを含んでいる<a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/verify_cpu.S" rel="nofollow" title="" class="ext-link">arch/x86/kernel/verify_cpu.S</a>から<code>verify_cpu</code>関数を呼び出すだけです。<code>cpuid</code>はプロセッサに関する情報を入手するために使われる命令です。今回の場合は、これでロングモードとSSEのサポートをチェックし、成功すれば<code>0</code>を、失敗すれば<code>1</code>を<code>eax</code>レジスタに返します。</p><p><code>eax</code>がゼロでなければ、<code>no_longmode</code>ラベルにジャンプします。これによって<code>hlt</code>命令がCPUを停止させ、どんなハードウェア割り込みもができなくなります。</p><p>スタックのセットアップ、CPUの検証ができたので、次のステップに進みましょう。</p><p>ここでは、展開が必要だった場合の再配置されたアドレスの計算について説明していきます。アセンブリ言語のコードは以下のようになります。</p><p>まずは、<code>CONFIG_RELOCATABLE</code>マクロに注目してください。この設定オプションは、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/Kconfig" rel="nofollow" title="" class="ext-link">arch/x86/Kconfig</a>で定義されており、以下の説明が記載されています。</p><p>簡単に言うと、このコードはカーネルを移動させるためのアドレスの計算になります。カーネルは展開のために、カーネルが再配置可能、もしくはbzimageが<code>LOAD_PHYSICAL_ADDR</code>の上で展開するのであれば<code>ebx</code>レジスタにそれを置きます。</p><p>コードを見てみましょう。カーネルの設定ファイルに<code>CONFIG_RELOCATABLE=n</code>があれば、<code>ebx</code>レジスタに<code>LOAD_PHYSICAL_ADDR</code>を置き、<code>ebx</code>に<code>z_extract_offset</code>を追加します。今は<code>ebx</code>がゼロなので、これには<code>z_extract_offset</code>が含まれます。では、これら2つの値を理解していきましょう。</p><p><code>LOAD_PHYSICAL_ADDR</code>は、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/boot.h" rel="nofollow" title="" class="ext-link">arch/x86/include/asm/boot.h</a>で定義されたマクロです。以下のようになります。</p><p>ここでは、アラインされたアドレスを計算します。これは、カーネルが読み込まれた（<code>0x100000</code>もしくは、この場合では1メガバイト）アドレスです。<code>PHYSICAL_ALIGN</code>は、カーネルがアラインされるべきアライメント値です。その値の領域は、x86_64であれば<code>0x200000</code>から<code>0x1000000</code>となります。デフォルト値では、<code>LOAD_PHYSICAL_ADDR</code>で2メガバイトを得ることができます。</p><p>アライメントユニットを抽出したら、2メガバイトに<code>z_extract_offset</code>（この場合は、<code>0xe5c000</code>となります）を追加します。最終的に、17154048バイトのオフセットを得ることができます。<code>z_extract_offse</code>は、<code>arch/x86/boot/compressed/piggy.S</code>にあります。このファイルは、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/mkpiggy.c" rel="nofollow" title="" class="ext-link">mkpiggy</a>プログラムによってコンパイル時に生成されます。</p><p>では、<code>CONFIG_RELOCATABLE</code>が<code>y</code>である場合のコードを理解していきましょう。</p><p>まず、<code>ebp</code>値を<code>ebx</code>に置きます（<code>ebp</code>は、読み込んだアドレスが含まれていることを思い出してください）。そして、カーネルセットアップヘッダの<code>kernel_alignment</code>フィールドを<code>eax</code>レジスタに配置します。<code>kernel_alignment</code>は、カーネルで必要とされるアライメントの物理アドレスです。次に、前のケース（カーネルが再配置できない場合）と同様のことを行いますが、アラインユニットとして、<code>kernel_alignment</code>フィールドの値を、<code>CONFIG_PHYSICAL_ALIGN</code>と<code>LOAD_PHYSICAL_ADDR</code>の代わりにベースアドレスとして<code>ebx</code>（読み込んだアドレス）を使います。</p><p>アドレスを計算したら、<code>LOAD_PHYSICAL_ADDR</code>で比較し、これに再度<code>z_extract_offset</code>を追加するか、もし計算されたアドレスが必要以下の値であれば、<code>ebx</code>に<code>LOAD_PHYSICAL_ADDR</code>を置きます。</p><p>これらの計算を行うことで、読み込んだアドレスを含む<code>ebp</code>と、展開のために移動させられたカーネルのアドレスがある<code>ebx</code>が得られます。</p><p>64ビットモードに移行する前の最後の準備です。まずは、グローバルディスクリプタをアップデートする必要があります。</p><p>ここでは、<code>ebp</code>からのアドレスを<code>gdt</code>でオフセットしたものを<code>eax</code>レジスタに置きます。次に、そのアドレスを<code>gdt+2</code>でオフセットしたものを<code>ebp</code>に置き、<code>lgdt</code>命令でグローバルディスクリプタテーブルを読み込みます。</p><p>グローバルディスクリプタテーブルの定義は以下の通りです。</p><p>これは<code>.data</code>セクションと同じファイル内に定義されており、中には5つのディスクリプタが含まれています。nullディスクリプタ、カーネルコードセグメント用のディスクリプタ、カーネルデータセグメント用のディスクリプタ、そして2つのタスクディスクリプタです。GDTは前の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-3.md" rel="nofollow" title="" class="ext-link">パート</a>と同様の方法で読み込みますが、64ビットモードで実行するため、ディスクリプタのビットは<code>CS.L = 1</code>、<code>CS.D = 0.</code>とします。</p><p>GDTを読み込んだ後は、<a href="https://ja.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E6%8B%A1%E5%BC%B5" rel="nofollow" title="" class="ext-link">PAE（物理アドレス拡張）</a>モードを有効にしないといけません。それには、以下のように<code>cr4</code>レジスタの値を<code>eax</code>に置いて、5ビット目を設定してから、再度<code>cr4</code>の中に読み込みます。</p><p>ここまで来れば、64ビットモードに移行する準備はほとんど終わりです。最後のステップはページテーブルの作成ですが、その前にロングモードについて少し説明しましょう。</p><p>ロングモードはx86_64プロセッサ用のネイティブモードです。まずは<code>x86_64</code>と<code>x86</code>の違いについて見てみましょう。</p><p>ロングモードでは、以下のような機能がサポートされています。</p><p>*<code>r8</code>から<code>r15</code>までの8つの新しい汎用レジスタと全ての汎用レジスタは64ビットです。<br>
* <code>RIP</code>（64ビットの命令ポインタ）<br>
* ロングモード（新しいオペレーティングモード）<br>
* 64ビットのアドレスとオペランド<br>
* RIP相対アドレス指定（次のパートで例を紹介する予定です）</p><p>ロングモードはレガシーのプロテクトモードを拡張したもので、以下の2つのサブモードから構成されます。</p><p>64ビットモードに切り替えるには、次の処理が必要です。</p><p>既に<code>cr4</code>レジスタ内でPAEビットを設定しているので、<code>PAE</code>は有効になっています。次はページングについて説明します。</p><p>64ビットモードに移行する前に、ページテーブルを作成する必要があります。では、初期の4Gブートページテーブルの作成について見ていきましょう。</p><p><strong>注：ここでは仮想メモリの理論については説明しません。詳細を知りたい方は、本ページの一番下にあるリンクをご覧ください。</strong></p><p>Linuxカーネルは4レベルのページングを使用しているので、通常は以下の6つのページテーブルを作成します。</p><p>では、実装を見ていきましょう。まずはメモリ内のページテーブル用のバッファをクリアします。各テーブルは4096バイトなので、24キロバイトのバッファが必要です。</p><p><code>ebx</code>に保存されているアドレスと（<code>ebx</code>には、カーネルを再配置して展開するためのアドレスが含まれています）オフセットの<code>pgtable</code>を<code>edi</code>レジスタに置きます。<code>pgtable</code>は以下のような内容で、<code>head_64.S</code>の最後に定義されています。</p><p>これは<code>.pgtable</code>セクションにあり、サイズは24キロバイトです。アドレスを<code>edi</code>に置いた後は、<code>eax</code>レジスタをゼロアウトし、<code>rep stosl</code>命令でバッファにゼロを書き込みます。</p><p>これで、以下のようにするとトップレベルページテーブル<code>PML4</code>が作成できます。</p><p>ここでは、オフセットの<code>pgtable</code>と<code>ebx</code>に格納されたアドレスを取得し、それを<code>edi</code>に置いています。次に、このアドレスを<code>0x1007</code>でオフセットして<code>eax</code>レジスタに置きます。<code>0x1007</code>は4096バイト（PML4のサイズ） + 7（PML4エントリーフラグの<code>PRESENT+RW+USER</code>）です。そして、<code>eax</code>を<code>edi</code>に置きます。この処理の後、<code>edi</code>には<code>PRESENT+RW+USER</code>フラグの設定された最初のページ・ディレクトリ・ポインタ・エントリーのアドレスが格納されている状態になります。</p><p>次のステップでは、ページ・ディレクトリ・ポインタ・テーブル内に、4つのページディレクトリを作成します。ここでは、最初のエントリーには<code>0x7</code>のフラグが、その他のエントリーには<code>0x8</code>のフラグが設定されます。</p><p>ページ・ディレクトリ・ポインタ・テーブルのベースアドレスを<code>edi</code>に、最初のページ・ディレクトリ・ポインタ・エントリーのアドレスを<code>eax</code>に置きます。そして<code>ecx</code>レジスタに4を置くと、これは以下のループ内のカウンタになり、最初のページ・ディレクトリ・ポインタ・テーブルのアドレスを<code>edi</code>レジスタに書き込みます。</p><p>これで<code>edi</code>には、<code>0x7</code>フラグが設定された最初のページ・ディレクトリ・ポインタ・エントリーのアドレスが入ります。そして、以下の<code>0x8</code>フラグが設定された以下のページ・ディレクトリ・ポインタ・エントリーのアドレスを計算して、そのアドレスを<code>edi</code>に書き込みます。</p><p>次のステップでは、2メガバイトを使って<code>2048</code>ページ・テーブル・エントリーを作成します。</p><p>ここでは前の例とほぼ同じ処理をしています。1つ違うのは、最初のエントリーにはフラグ<code>$0x00000183</code>、つまり<code>PRESENT + WRITE + MBZ</code>が、他のエントリーには<code>0x8</code>が設定されていることです。これで、2メガバイトの2048ページが完成します。</p><p>作成した初期ページテーブルは、4ギガバイトのメモリをマッピングするので、<code>cr3</code>コントロールレジスタにあるハイレベルページテーブル<code>PML4</code>のアドレスを格納できます。</p><p>必要な処理は全て完了したので、これでロングモードに移行できます。</p><p>まずは<a href="http://en.wikipedia.org/wiki/Model-specific_register" rel="nofollow" title="" class="ext-link">MSR</a>にある<code>EFER.LME</code>フラグを、<code>0xC0000080</code>に設定する必要があります。</p><p>ここでは<code>MSR_EFER</code>フラグ（<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/msr-index.h#L7" rel="nofollow" title="" class="ext-link">arch/x86/include/uapi/asm/msr-index.h</a>で定義されています）を<code>ecx</code>レジスタに格納し、<code>rdmsr</code>命令を呼び出して、<a href="http://en.wikipedia.org/wiki/Model-specific_register" rel="nofollow" title="" class="ext-link">MSR</a>レジスタを読み込みます。<code>rdmsr</code>が実行されると、<code>ecx</code>値に応じて、<code>edx:eax</code>にあるデータが結果として得られます。<code>btsl</code>命令で<code>EFER_LME</code>ビットをチェックし、<code>wrmsr</code>命令で<code>eax</code>のデータを<code>MSR</code>レジスタに書き込みます。</p><p>次のステップでは、カーネルセグメントコードのアドレスをスタック（GDTの中に定義されています）にプッシュして、<code>startup_64</code>ルーチンのアドレスを<code>eax</code>に格納します。</p><p>その次は、このアドレスをスタックにプッシュして、<code>cr0</code>レジスタにある<code>PG</code>ビットと<code>PE</code>ビットを設定して、ページングを有効にします。</p><p>そして、以下の呼び出しをします。</p><p>前のステップでは、<code>startup_64</code>関数のアドレスをスタックにプッシュしました。そして、この<code>lret</code>命令の後は、CPUがそのアドレスを抽出して、そこにジャンプします。</p><p>これらのステップを全て終えると、最終的に64ビットモードに移行できます。</p><p>これでおしまいです！</p><p>カーネル起動処理 パート4の記事は以上です。</p><p>質問やご意見がありましたら、<a href="https://twitter.com/0xAX" rel="nofollow" title="" class="ext-link">Twitter</a>や<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/anotherworldofworld@gmail.com" rel="nofollow" title="" class="ext-link">Eメール</a>でメ<br>
ッセージを送信していただくか、こちらから<a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2F0xAX%2Flinux-insides%2Fissues%2Fnew" rel="nofollow" title="" class="ext-link">issue</a>を作成してください。</p><p>次のパートでは、カーネルの展開などについて説明します。</p><p>英語は私の第一言語ではないことをご承知おきください。誤りを見つけた方は<br>
<a href="https://github.com/0xAX/linux-internals" rel="nofollow" title="" class="ext-link">linux-internals</a>に、プルリクエストを送ってください。</p>
