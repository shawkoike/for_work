<p><a href="http://bouk.co/blog/monkey-patching-in-go/" rel="nofollow" title="" class="ext-link">Monkey Patching in Go</a> （2015-03） by <a href="http://bouk.co/" rel="nofollow" title="" class="ext-link">Bouke van der Bijl</a></p><p>モンキーパッチを、RubyやPythonのような動的言語のみを扱うものと思っている人は多いようですが、それは違います。コンピューターは単独では何もできないマシンで、私たちが指示を与えることで動くものなのです。それでは、Go言語の関数がどのように機能して、実行時にどのように変更することができるのかを見ていきましょう。この記事では、インテルのアセンブリの構文が多く出てきますので、アセンブリ言語を読めない方は<a href="https://software.intel.com/en-us/articles/introduction-to-x64-assembly" rel="nofollow" title="" class="ext-link">リファレンス</a>を使いながら読み進めてください。</p><p><strong>もしモンキーパッチがどのように機能しているかには興味がなく、単に使えるようになればいいと思っている方はライブラリがあるので<a href="https://github.com/bouk/monkey" rel="nofollow" title="" class="ext-link">こちら</a>をご覧ください。</strong></p><p>注意：サンプルはgo build -gcflags=-lで作成し、インライン展開を無効にしています。この記事の内容は、アーキテクチャが64bitsで、Mac OSXやLinuxバリアントなどのUNIX系OSをご使用の方を対象としています。</p><p>逆アセンブルをすると、以下のコードが何を生成するか見てみましょう。</p><p><script src="https://gist.github.com/bouk/17262666fae75dd24a25.js"></script><br>
コンパイルして<a href="http://hopperapp.com/9" rel="nofollow" title="" class="ext-link">Hopper</a>を使って見てみると、上記のコードは以下のアセンブリコードを生成します。</p><p><img src="https://monosnap.com/image/9YuCc2avXnkWhkPQpyvv8blrhSeoDD.png" width="566"><br>
この記事では、様々な命令の左側に表示されたアドレスを参照します。</p><p>このコードはmain.mainというプロシージャから始まっていて、0x2010から0x2026までの行の命令でスタックをセットしています。これに関しては<a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite" rel="nofollow" title="" class="ext-link">こちら</a>でより詳しく説明をしていますので、今回の記事ではこのコードの説明は省きます。</p><p>0x202aの行は、0x2000の行にある関数main.aの呼び出しです。これは単に0x1をスタックに移動させ、戻しているだけです。そして、0x202fから0x2037の行は、その値をruntime.printintに渡しています。</p><p>何てシンプルなのでしょう！　では続いて、関数値をどうやってGo言語で実装するかを見ていきましょう。</p><p>以下のコードで考えてみましょう。</p><p><script src="https://gist.github.com/bouk/c921c3627ddbaae05356.js"></script><br>
行11ではaをfに代入していますが、これはf()を実行するとaを呼び出すようになるということです。次にGoパッケージ<a href="http://golang.org/pkg/unsafe/" rel="nofollow" title="" class="ext-link">unsafe</a>を使って、fに保存されている値を直接読み出します。C言語の経験を持つ人なら、fを単純にaへの関数ポインタと考えて、このコードは0x2000（上のアセンブリコードでmain.aの位置）と出力するだろうと思うかもしれません。このコードを私のマシンで実行すると0x102c38と出力されますが、これはコードから遠く離れたアドレスです。逆アセンブルしてみると、上のコードの行11で次のような動作が起こっていることが分かります。<br>
<img src="https://monosnap.com/image/rlXiQvaQVt018lDDKahQXgSNK0W1vM.png" width="488"><br>
ここでは、main.a.fという名前のものを参照しています。その位置のコードを見ると、次のようになっています。<br>
<img src="https://monosnap.com/image/djPms4Lvx16Y7d3yocvuldCWiseZpK.png" width="398"><br>
なるほど。main.a.fは0x102c38にあって値0x2000を持ち、この値はmain.aの位置です。fは関数へのポインタではく、関数へのポインタへのポインタだと思われます。コードを変更して補正しましょう。<br>
<script src="https://gist.github.com/bouk/c470c4d80ae80d7b30af.js"></script></p><p>これで、期待したとおり0x2000と出力されます。なぜこのように実装されるのかについてのヒントは<a href="https://github.com/golang/go/blob/e9d9d0befc634f6e9f906b5ef7476fbd7ebd25e3/src/runtime/runtime2.go#L75-L78" rel="nofollow" title="" class="ext-link">こちら</a>にあります。Goの関数値には、クロージャと結合インスタンスメソッドがどのように実装されるかに関する、追加情報を含むことができます。<br>
関数値の呼び出しがどのように動作するのかを見ましょう。コードを変更して、fを代入してから呼び出すようにします。<br>
<script src="https://gist.github.com/bouk/58bba533fb3b742ed964.js"></script></p><p>逆アセンブルすると、次のようになります。<br>
<img src="https://monosnap.com/image/fIGwJMjcvl7chLtQ0xuw7F9jEnop1I.png" width="442"><br>
main.a.fがrdxにロードされ、rdxが指しているものがrdxにロードされてから呼び出されます。関数値のアドレスは常にrdxにロードされます。呼び出されるコードは、追加情報が必要な場合に、このアドレスを使って情報をロードすることができます。この追加情報は、結合インスタンスメソッドのインスタンスと無名関数のクロージャへのポインタです。さらに詳細を知りたい方は、逆アセンブラを用意して、深く調べてみることをお勧めします。<br>
では、ここで得られた新しい知識を使って、Goでモンキーパッチを実装しましょう。</p><p>これから行うのは以下のコードで2を出力することです。</p><p><script src="https://gist.github.com/bouk/713f3df2115e1b5e554d.js"></script><br>
さて、replaceをどのように実装しましょうか。関数a本体が実行されるのではなく、関数aがbのコードにジャンプするようにコードを変更する必要があります。基本的にはbの関数値をrdxにロードしてからrdxが指す位置にジャンプするように置き換えなければなりません。</p><p><script src="https://gist.github.com/bouk/e886664740906bfffd76.js"></script></p><p>アセンブル後に各行で生成される、対応するマシンコードを隣に配置しました（アセンブリは、オンラインのアセンブラを使用して<a href="https://defuse.ca/online-x86-assembler.htm" rel="nofollow" title="" class="ext-link">このように</a>簡単に試すことができます）。このコードを生成する関数を書くことが今のところ正攻法です。次のようになります。</p><p><script src="https://gist.github.com/bouk/4ed563abdcd06fc45fa0.js"></script></p><p>これでaの関数本体をbへのジャンプに置き換えるために必要なことを全て準備できました。以下のコードは、関数本体の位置にマシンコードを直接コピーしようとしています。</p><p><script src="https://gist.github.com/bouk/305264604c38a8815def.js"></script></p><p>しかし、このコードは実行しても動かず、セグメンテーション違反が発生します。これは、ロードされたバイナリは、<a href="https://en.wikipedia.org/wiki/Segmentation_fault#Writing_to_read-only_memory" rel="nofollow" title="" class="ext-link">デフォルトでは上書きできない</a>ためです。この保護を解除するにはmprotectシステム呼び出しを使用します。このコードの最終バージョンが正確に実行されると、関数aが関数bに置き換えられ、‘2’が出力されます。</p><p><script src="https://gist.github.com/bouk/55900e1d964099368ab0.js"></script></p><p>上記のコードを<a href="https://github.com/bouk/monkey" rel="nofollow" title="" class="ext-link">使いやすいライブラリ</a>に置きました。このコードは32ビットに対応し、リバースパッチとインスタンスメソッドのパッチをサポートしています。また、いくつかの例をREADMEに置きました。</p><p>「為せば成る」というものです。モンキーパッチのように、実行時にプログラムが自ら変更を行うような便利な方法を取り入れることも、可能なのです。</p><p>私が楽しみながら書いたこの投稿が、皆さんのお役に立てば幸いです。</p>
