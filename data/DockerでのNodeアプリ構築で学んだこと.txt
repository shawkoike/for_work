<p><a href="http://jdlm.info/articles/2016/03/06/lessons-building-node-app-docker.html" rel="nofollow" title="" class="ext-link">Lessons from Building a Node App in Docker</a> by <a href="https://twitter.com/jdleesmiller" rel="nofollow" title="" class="ext-link">John Lees-Miller</a></p><p>以下に紹介するのは、<a href="https://www.docker.com/" rel="nofollow" title="" class="ext-link">Docker</a>を使って<a href="https://nodejs.org/" rel="nofollow" title="" class="ext-link">node.js</a>用のWebアプリケーションを開発、およびデプロイする際に、私が四苦八苦しながら学んだ秘訣やコツです。</p><p>このチュートリアル記事では、Dockerで<a href="http://socket.io/get-started/chat/" rel="nofollow" title="" class="ext-link">socket.ioのチャットサンプル</a>を白紙の状態から本番状態へとセットアップしていきます。このプロセスを通じて、そうした秘訣などを簡単に習得していただければ幸いです。特に、以下のような内容について見ていきます。</p><p>このチュートリアルは、読者の皆さんがDockerやnode.jsにある程度、慣れ親しんでいることを前提としています。「Dockerとは何ぞや」という方は、<a href="http://jdlm.info/ds-docker-demo/" rel="nofollow" title="" class="ext-link">私が以前に作成したDockerについてのスライド</a>（<a href="https://news.ycombinator.com/item?id=8630451" rel="nofollow" title="" class="ext-link">Hacker Newsでの議論はこちら</a>）を見ていただいてもいいですし、その他にも、探せば多くの解説記事が見つかるはずです。</p><p>今回は、ゼロからの作業です。最終的なコードは<a href="https://github.com/jdleesmiller/docker-chat-demo" rel="nofollow" title="" class="ext-link">github</a>上で閲覧可能で、ステップごとにタグが付けられています。<a href="https://github.com/jdleesmiller/docker-chat-demo/tree/01-bootstrapping" rel="nofollow" title="" class="ext-link">最初のステップのコードがこちらにありますので</a>、参考にされたい方はご覧ください。</p><p>Dockerがなければ、まずはNodeやその他のdependenciesをホストにインストールし、<code>npm init</code>を実行して新規パッケージを作成することから始めるでしょう。この作業は避けては通れませんが、最初からDockerを使えば話は変わります（これらのものをホストにインストールしなくていいというのは、Dockerを使う大きなポイントです）。その場合、始めにNodeがインストールされた「起動コンテナ」を作成し、それを使ってアプリ用のnpmパッケージをセットアップします。</p><p>ここで用意する必要があるのは<code>Dockerfile</code>と<code>docker-compose.yml</code>の2ファイルで、これらには後からもっと手を加えます。まず、起動用の<code>Dockerfile</code>から見てみましょう。</p><p>このファイルは比較的、短いですが、いくつか重要なポイントがあります。</p><p>では次に、起動構成ファイル、<code>docker-compose.yml</code>に移ります。</p><p>これは<code>Dockerfile</code>から構築される単一のサービスを定義したもので、現時点の動作は<code>ready</code>をechoしexitするのみです。volumeの行の<code>.:/home/app/chat</code>は、ホスト上のアプリケーションフォルダ<code>.</code>をコンテナ内の<code>/home/app/chat</code>フォルダにマウントするようDockerに指示しているため、ホストのソースファイルに加えられた変更はコンテナ内部に自動で反映されますし、逆もまたしかりです。このことは開発時のテスト-編集-リロードサイクルを短くするのに非常に重要となりますが、npmがdependenciesをインストールする際にある問題を生みます。それについては後ほど触れます。</p><p>ここまでは非常に順調です。docker-compose upを実行すると、Dockerは指定されたとおりに<code>Dockerfile</code>内でnodeをセットアップしてイメージを作成し、そのイメージを有するコンテナを立ち上げてechoコマンドを実行します。すべてが問題なく設定されていることが分かりますね。</p><p>これで、同じイメージから作成されたコンテナ内で対話型シェルを実行し、それを使用して最初のパッケージファイルをセットアップすることができるようになります。</p><p>ファイルはホスト上にあるため、バージョン管理を行えます。</p><p><a href="https://github.com/jdleesmiller/docker-chat-demo/tree/02-bootstrapped" rel="nofollow" title="" class="ext-link">ここまでの結果のコードをgithubで</a>確認してみてください。</p><p>次のステップは、アプリのdependenciesのインストールです。<code>docker-compose up</code>を最初に実行した時にアプリの使用準備が整うよう、dependenciesは<code>Dockerfile</code>を経由してコンテナ内にインストールされるようにします。</p><p>これを行うには<code>Dockerfile</code>で<code>npm install</code>を実行する必要がありますが、その前に、それがイメージに読み込む<code>package.json</code>と<code>npm-shrinkwrap.json</code>ファイルを取得しなければなりません。変更は以下のようになります。</p><p>変更点はわずかですが、ここでも重要なポイントがいくつかあります。</p><p>最後のポイントは、コンテナの<code>$HOME/chat</code>をホストのアプリケーションフォルダにバインドしているため、開発中のイメージを使う時にはいくつかの問題を引き起こします。残念ながら<code>node_modules</code>フォルダがホスト上に存在しないため、このバインドがインストールしたnode_modulesを見事に「非表示」にしてしまうのです。</p><p>この問題には<a href="https://github.com/docker/example-voting-app/blob/7629961971ab5ca9fdfeadff52e7127bd73684a5/result-app/Dockerfile#L8" rel="nofollow" title="" class="ext-link">いくつか</a><a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" rel="nofollow" title="" class="ext-link">の</a><a href="https://semaphoreci.com/community/tutorials/dockerizing-a-node-js-web-application" rel="nofollow" title="" class="ext-link">解決策</a>がありますが、一番スマートだと思うのは<code>node_modules</code>を含むようバインド内で<a href="http://stackoverflow.com/questions/30043872/docker-compose-node-modules-not-present-in-a-volume-after-npm-install-succeeds" rel="nofollow" title="" class="ext-link">ボリュームを使う</a>方法です。これをするには、docker-composeファイルの最後尾に1行を付け加えればいいだけです。</p><p>作業としては単純ですが、裏では複雑なことが行われています。</p><p>1. ビルド中、<code>npm install</code>がイメージ内の<code>$HOME/chat/node_modules</code>にdependencies（次のセクションで追加します）をインストールします。イメージ由来のファイルには青で色付けしています。</p><p>
</p>
<p>2. 後でcomposeファイルを使ってイメージからコンテナを立ち上げる際、Dockerはまず<code>$HOME/chat</code>以下にあるコンテナ内のホストからアプリケーションフォルダをバインドします。ホスト由来のファイルには赤で色付けしています。</p><p>
</p>
<p>厄介なのは、イメージの<code>node_modules</code>はバインドによって非表示となっているため、コンテナ内においてホスト上で見えるのは空の<code>node_modules</code>フォルダのみだということです。</p><p>3. ただし、まだ終わりではありません。Dockerは次に<code>$HOME/chat/node_modules</code>のコピーを含むボリュームをイメージ内に作成し、コンテナにマウントします。これによりホスト上では、バインドから<code>node_modules</code>が隠された状態になり影響を受けなくなります。</p><p>
</p>
<p>これで希望どおりになりました。ホスト上のソースファイルはコンテナ内部にバインドされているため、高速な変更が可能です。また、コンテナ内部でdependenciesが利用できるため、それらを使ってアプリケーションを実行することもできます。</p><p>（補足事項：これらの依存ファイルが、実際にボリューム内のどこに保存されるのか不思議に思われるかもしれません。端的に言えば、Dockerが管理するホスト上の別のディレクトリに保存されています。詳しくは<a href="https://docs.docker.com/engine/userguide/containers/dockervolumes/" rel="nofollow" title="" class="ext-link">ボリュームに関するDockerの文書</a>をご覧ください。）</p><p>それではイメージを再構築して、パッケージをインストールしましょう。</p><p>チャットアプリにはexpress@4.10.2が必要なので、それを<code>npm install</code>し、<code>--save</code>で<code>package.json</code>に依存関係を保存します。必要に応じて<code>npm-shrinkwrap.json</code>をアップデートしてください。</p><p>なお、ここでは具体的なバージョンを指定する必要はなく、<code>npm install --save express</code>を実行して最新のバージョンを取得するだけで構いません。<code>package.json</code>とshrinkwrapは、次にビルドが実行された時に、そのバージョンで依存関係を保持します。</p><p>npmの<a href="https://docs.npmjs.com/cli/shrinkwrap" rel="nofollow" title="" class="ext-link">shrinkwrap</a>機能を使う理由は、<code>package.json</code>では直接の依存関係があるバージョンの修正はできるものの、あやふやに指定された可能性のある依存関係のバージョンについては修正ができないからです。もし、あなたや他の誰かが将来的にイメージを再構築する場合、（shrinkwrapを使わない限り）それが間接的な依存関係の異なるバージョンをプルダウンし、アプリケーションを破壊しないという保証はありません。経験上、これは皆さんが想像するよりもはるかに頻繁に起こることのように思えるため、私はshrinkwrapの使用を推奨しています。Rubyには優れた依存管理マネージャの<a href="http://bundler.io/" rel="nofollow" title="" class="ext-link">Bundler</a>がありますが、比較すると、<code>npm-shrinkwrap.json</code>は<code>Gemfile.lock</code>のようなものかと思います。</p><p>最後に注目したいのは、ここでは1回限りの<code>docker-compose run</code>としてコンテナを実行しているため、インストールした実際のモジュールは消滅します。しかし次にdocker buildを行うと、Dockerは<code>package.json</code>とshrinkwrapに変更があること、そして<code>npm install</code>の再実行が必要であることを検出します。これはとても重要なことで、必要なパッケージはその後、イメージにインストールされます。</p><p><a href="https://github.com/jdleesmiller/docker-chat-demo/tree/03-dependencies" rel="nofollow" title="" class="ext-link">ここまでの結果のコードはgithub</a>をご覧ください。</p><p>やっとアプリケーションをインストールする準備ができました。まずは<a href="https://github.com/rauchg/chat-example" rel="nofollow" title="" class="ext-link">残りのソースファイル</a>、つまり<code>index.js</code>と<code>index.html</code>をコピーします。それから、前のセクションでやったように<code>npm install --save</code>を使って<code>socket.io</code>のパッケージをインストールしてください。</p><p>これで<code>Dockerfile</code>では、<code>node index.js</code>のイメージを使ってコンテナを起動した時に、どのコマンドを実行するのかをDockerに伝えることができるようになりました。なお、<code>Dockerfile</code>からのコマンドをDockerが実行するように、ここでdocker-composeファイルからダミーのコマンドを削除しておいてください。最後に、ホスト上のコンテナの3000番ポートを開放するようdocker-composeに指示すれば、ブラウザでアクセスできるようになります。</p><p>最後のビルドをすれば、<code>docker-compose up</code>による実行の準備が完了です。</p><p>これで（Macの場合は、boot2docker–vmからホストに3000番ポートを転送させるために少しばかりいじる必要があります）、<code>http://localhost:3000</code>で実行しているのが確認できるはずです。</p><p><img src="http://jdlm.info/assets/docker_chat_demo/chat.png" alt="Docker chat demo working!"></p><p><a href="https://github.com/jdleesmiller/docker-chat-demo/tree/04-the-app" rel="nofollow" title="" class="ext-link">ここまでの結果のコードはgithub</a>をご覧ください。</p><p>やっとアプリをdocker-composeの開発環境下で実行させることができました。素晴らしいですね。では、次なるステップは何かを見ていきましょう。</p><p>本番環境にアプリケーションイメージをデプロイしたい場合、アプリケーションソースを前述のイメージにビルドすることになります。これを行うには、<code>npm install</code>の後、コンテナにアプリケーションフォルダをコピーすればいいだけです。これでDockerは、ソースファイルに変更があった時ではなく、<code>package.json</code>または<code>npm-shrinkwrap.json</code>に変更があった場合のみ<code>npm install</code>を再実行します。なお、rootとしてファイルをコピーする<code>COPY</code>の問題については、ここでも回避が必要です。</p><p>これで、ホストからのボリュームなしに、スタンドアロンでコンテナを実行できるようになります。docker-composeは、composeファイル内でコードの重複を避けるため、<a href="https://docs.docker.com/compose/extends/" rel="nofollow" title="" class="ext-link">複数のcomposeファイルを構成</a>できますが、今回のアプリケーションは非常にシンプルなので、単純に2つめのcomposeファイル、<code>docker-compose.prod.yml</code>を追加して、本番環境でアプリケーションを実行させます。</p><p>以下により、「本番モード」でアプリケーションが実行できます。</p><p>同様に、例えばソースファイルに変更があった時にコンテナ内を自動リロードする<a href="https://github.com/remy/nodemon" rel="nofollow" title="" class="ext-link">nodemon</a>の下でアプリケーションを実行させれば、コンテナを開発用に特化できます（ただしDocker Machineを使ったMacでは、virtualboxのsharedフォルダがinotifyでは動かないため､完全に動作するとは言えません。この状況が早く改善されるといいのですが）。また、コンテナで<code>npm install --save-dev nodemon</code>を実行し再構築すれば、開発用途としてより適切な設定のコンテナ内でデフォルトのproductionコマンド、<code>node index.js</code>をオーバーライドすることが可能です。</p><p>なお、<code>nodemon</code>に関しては、パス上ではなくnpmの依存関係としてインストールされるので、フルパスを与える必要があります。npmスクリプトをセットアップして<code>nodemon</code>を実行することもできますが、私自身はそのアプローチで問題に遭遇しました。npmスクリプトを実行しているコンテナでは、<code>npm</code>が<code>TERM</code>シグナルをDockerから実際のプロセスに転送しないため、シャットダウンに10秒間ほどかかる傾向があります（デフォルトのタイムアウト）。したがって直接コマンドを実行させた方が、より良い結果が得られるようです。（追記：この問題はnpm 3.8.1以上で<a href="https://github.com/npm/npm/pull/10868" rel="nofollow" title="" class="ext-link">修正されたようです</a>。これで、npmスクリプトをコンテナで使えるようになりますね！）</p><p>docker-composeファイルを特化すれば、同一のDockerfileやイメージを複数の環境にわたって使用できるようになります。本番環境にdevDependenciesをインストールするため、スペース的には最も効率的とは言えませんが、開発環境と本番環境のより良い等価性にとっては、わずかな犠牲ではないかと思います。ある<a href="http://llis.nasa.gov/lesson/1196" rel="nofollow" title="" class="ext-link">賢人がかつて言ったように</a>、「test as you fly, fly as you test（飛ぶようにテストし、テストするように飛ぶ）」ということです。そういえば今回はテストをしていませんが、実行するのは簡単です。</p><p>（補足事項：<code>--silent</code>を指定して<code>npm</code>と実行すると、余分な出力が取り除かれます。）</p><p><a href="https://github.com/jdleesmiller/docker-chat-demo" rel="nofollow" title="" class="ext-link">github上の最終的なコード</a>はこちらです。</p><p>ここまで読んでくださった方は、ぜひ<a href="https://twitter.com/jdleesmiller" rel="nofollow" title="" class="ext-link">私のtwitterもフォロー</a>していただければ幸いです。また、<a href="https://www.overleaf.com/" rel="nofollow" title="" class="ext-link">Overleaf</a>では求人も募集していますよ<code>:)</code></p><p>原稿のチェックをしてくれた<a href="https://twitter.com/mmazour" rel="nofollow" title="" class="ext-link">Michael Mazour</a>と<a href="https://twitter.com/DrHammersley" rel="nofollow" title="" class="ext-link">John Hammersley</a>に感謝します。</p>
