<p><a href="https://labs.spotify.com/2015/11/16/monitoring-at-spotify-the-story-so-far/" rel="nofollow" title="" class="ext-link">Monitoring at Spotify: The Story So Far</a> （2015-11-16） by <a href="https://twitter.com/udoprog" rel="nofollow" title="" class="ext-link">John-John Tedro</a></p><p><img width="730" height="219" src="https://spotifylabscom.files.wordpress.com/2015/11/monitoring-banner.png" class="attachment-full size-full wp-post-image" alt="monitoring-banner" scale="0"></p><p>これはSpotifyのモニタリングについて<a href="http://postd.cc/monitoring-at-spotify-introducing-heroic/">2回に分けてご紹介</a>するシリーズの第1回です。この記事では、これまでの経緯や、直面した難題とそれに対する取り組みをお話ししたいと思います。</p><p>Spotifyの運用のモニタリングは、2つのシステムを組み合わせて始まりました。Zabbixと、<a href="https://en.wikipedia.org/wiki/RRDtool" rel="nofollow" title="" class="ext-link">RRDベース</a>の自前で作成したグラフ作成システム「sitemon」です。sitemonは、データ収集に<a href="http://munin-monitoring.org/" rel="nofollow" title="" class="ext-link">Munin</a>を使っていました。ZabbixはSREチームが所有し、sitemonはバックエンドのインフラチームが運用していました。当時は小さな会社だったので、各自で問題を解決するのが普通でした。この方式を採用した理由は何よりも、最初に問題に取り組んだ担当者が選んだためでした。</p><p>2013年の終わりには、<a href="http://www.slideshare.net/johnjohnted/monitorama-pdx-monitoring-for-distributed-operational-responsibility" rel="nofollow" title="" class="ext-link">セルフサービスと運用責任の分担</a>に力を入れ始めます。私たちは、個々のホストを監視するのはやめて、サービスの全体を論理的に見るようにしたいと考えました。しかし、個々のホストに重点を置くZabbixはそれに向いておらず、Zabbixを運用できるのはSREチームのメンバーだけでした。インフラは<em>大きく</em>成長しており、負荷が増大するにつれ、システムに問題が生じ始めていました。</p><p>自分たちでできるだけの手当てを試み、チーフアーキテクトが現状の負荷で約1カ月分のメトリクスを保持できるインメモリのsitemonの置換プログラムを書きました。それで<em>一息</em>つく時間は取れましたが、遅くとも1年後にはシステムが持たなくなると予想できました。この経験から生まれたのが、新しいチーム「Hero」です。Heroの目的は、Spotifyのモニタリングシステムを”改修”して、将来に対応できるようにすることでした。そのためには何でもやりました。取り組みの過程を以下にご紹介します。</p><p>最初に手をつけた問題がアラートです。</p><p>私たちは、Zabbixをさらに開発することを考えました。Zabbixは、アラート条件のチェックに<a href="https://www.zabbix.com/documentation/3.0/manual/config/triggers/expression" rel="nofollow" title="" class="ext-link">トリガ条件式</a>を用いています。システムでは多くのビット腐敗が生じており、理解しがたいトリガや、不完全または不正なトリガが多数実行されていました。この状況を受けて、次期アラートシステムの要件の1つを決めました。理解を深めリグレッションを避けるため、トリガのテストを簡単に行えるということです。Zabbixのスケーラビリティも懸念の1つでした。今後2年に予想されるシステムの規模でZabbixを運用できる確信がなかったのです。</p><p>私たちは<a href="http://monitorama.eu/" rel="nofollow" title="" class="ext-link">Monitorama EU</a>に参加して<a href="https://riemann.io/" rel="nofollow" title="" class="ext-link">Riemann</a>に出会い、ヒントを得ました。Riemannとは、分散システムをモニタリングするツールです。Riemannはスケーラビリティをすぐに提供してくれるわけではありませんが、ステートレスの原則が取られているため、負荷を分割して分散しやすくなります。そこで、サービスにおける全てのホストを、同じルールを実行している少なくとも2つのインスタンスに組み合わせました。</p><p><img class="wp-image-1118 size-full" src="https://spotifylabscom.files.wordpress.com/2015/11/monitoring-host-to-riemann.png?w=730" alt="monitoring-host-to-riemann" originalw="730" width="256" height="111" scale="1.5"><br>
<em>全てのホストは、少なくとも2つのRiemannインスタンスと通信する</em></p><p>Riemann上に<a href="https://github.com/spotify/lyceum" rel="nofollow" title="" class="ext-link">Lyceum</a>というライブラリを構築したことで、全てのチームが隔離された名前空間にルールを入れられるgitリポジトリをセットアップできるようになりました。このセットアップなら、エンジニアは再現可能な結合テストの検討と定義に集中できます。そして、リポジトリを公開して本番環境に変更を直接デプロイする自信がつき、「テストに合格すれば、きちんと動くと確信できる」というスタンスに変わりました。これは非常にうまくいきました。Clojureはトリガ条件式よりもはるかに分かりやすい言語であり、gitベースのレビュープロセスは私たちの開発方法により適していたのです。</p><p>これについては試行を繰り返しました。初期のスタックは、収集したデータ全てに対応するMunin型のプラグインでした。標準のメトリクスもありましたが、最も重要なのはサービスメトリクスでした。</p><p>エンジニアが扱いやすいように、プッシュ型のアプローチに切り替えるのが望ましいということになりました。メトリクスを定義する複雑な過程のために採用が遅れてしまうということが、Muninで得た経験から分かりました。プル型のアプローチでは、何をどこで読みこむかを設定しておく必要があります。プッシュ型では、なるべく一般的なプロトコルを使って、最も近いAPIにサンプルを送りこむだけです。コレクタに発見される間もないほど、短時間の一時的なタスクを考えてみましょう。プッシュ型にとって、これは問題ではありません。なぜなら、メトリクスを送るタイミングをタスク自体が制御するからです。</p><p>もっと詳しく知りたい方は、<a href="http://blog.sflow.com/2012/08/push-vs-pull.html" rel="nofollow" title="" class="ext-link">sFlow</a>と<a href="http://www.boxever.com/push-vs-pull-for-monitoring" rel="nofollow" title="" class="ext-link">Alan Giles</a>の記事がこのテーマを掘り下げているので、ご覧ください。</p><p>私たちの最初の実験は、経験を積むために、<a href="https://collectd.org/" rel="nofollow" title="" class="ext-link">collectd</a>と<a href="http://graphite.wikidot.com/" rel="nofollow" title="" class="ext-link">Graphite</a>に基づいた一般的な解決策をデプロイすることでした。パフォーマンステストによれば、1つのGraphiteノードから取り出せる垂直方向のスケーラビリティでは不十分でした。</p><p><a href="http://graphite.wikidot.com/whisper" rel="nofollow" title="" class="ext-link">whisper</a>の書き出しパターンは、<a href="http://aosabook.org/en/graphite.html#fig.gra.queue" rel="nofollow" title="" class="ext-link"><em>多くの</em>ファイルに対するランダムな検索と書き出し</a>を伴いました。1つがそれぞれの系列に対して行います。また、全てをがむしゃらにダウンサンプリングすると、償却コストが高くなります。</p><p>Graphiteはシャーディングとリバランスが難しいため、コストが非常に高くなりました。近頃は、バックエンドの<a href="https://github.com/pyr/cyanite" rel="nofollow" title="" class="ext-link">Cyanite</a>を使用することにより、こうした問題のうちいくつかは解決されたかもしれません。しかし私たちにとって、Graphiteにはまだ理論的なハードルがあります。それは、階層的なネーミングです。</p><p>Graphiteでは、典型的な時系列は以下のようにネーミングされます。</p><p><img class="size-full wp-image-1116 aligncenter" src="https://spotifylabscom.files.wordpress.com/2015/11/monitoring-hierarchy.png?w=730" alt="monitoring-hierarchy" originalw="730" width="188" height="56" scale="1.5"></p><p>実際には様々なスタイルがありますが、上記のネーミングは、固定階層と見なされます。この方式が非常に有効な場合もありますが、本質的に階層的ではないものもあります。しかし、特定の<em>サイト</em>で全てのサーバを選択したいならば、よく考えてみる必要があります。</p><p>私たちの選択肢は2つです。サーバ名がインフラに対して一貫していると期待して、ワイルドカード検索を行うことです。もしくは、この問題に対処するべく、ネーミングの階層を改編するという方法もあります。</p><p><img class="aligncenter wp-image-1115 size-full" src="https://spotifylabscom.files.wordpress.com/2015/11/monitoring-hierachy-add.png?w=730" alt="monitoring-hierachy-add" originalw="730" width="263" height="75" scale="1.5"></p><p>このタイプのリファクタリングは<em>難しい</em>と言えます。</p><p>正解はありません。<em>サイト</em>がフィルタリングの主要な手段であるべきと考えるチームもあれば、<em>ロール</em>に関心があるチームもあるでしょう。どちらの要件も、メリットは同じくらいあるかもしれません。ですから、弱点はネーミング体系なのです。</p><p>ここで、全く異なる発想からこの問題を180度転換させて、時系列のアイデンティティがタグのセットで構成されると考えてみます。</p><p>前出の例を見てみると、既存の階層をタグのセットにマッピングすることもできます。</p><p><img class="aligncenter wp-image-1117 size-full" src="https://spotifylabscom.files.wordpress.com/2015/11/monitoring-hierarchy-mapping.png?w=730" alt="monitoring-hierarchy-mapping" originalw="730" width="449" height="221" scale="1.5"><br>
このことが考慮されているフィルタリングシステムでは、エンジニアが、時系列の大きなプールを付属するコンポーネントによって”様々な切り口から詳細に分析”できます。相互運用性の増大を図っているのです。</p><p>このように、厳密に順守しなければならない階層はありません。ルール（「サイト」と「ホスト」は必ずあります）によって、構造の一部には階層がある<em>かもしれません</em>が、必須ではなく、遵守する必要もありません。</p><p><a href="https://github.com/Netflix/atlas" rel="nofollow" title="" class="ext-link">Atlas</a>、<a href="http://prometheus.io/" rel="nofollow" title="" class="ext-link">Prometheus</a>、<a href="http://opentsdb.net/" rel="nofollow" title="" class="ext-link">OpenTSDB</a>、<a href="https://influxdb.com/" rel="nofollow" title="" class="ext-link">InfluxDB</a>、<a href="http://kairosdb.github.io/" rel="nofollow" title="" class="ext-link">KairosDB</a>は全て、タグを使用するデータベースです。AtlasとPrometheusは十分に検討対象となったでしょうが、当時は入手できませんでした。OpenTSDBは、私たちのHBaseの操作経験が足りないため却下となりました。InfluxDBは未成熟で、セルフサービスを推進する上で必要な機能が欠けていました。KairosDBは最高の候補と思われたので、大掛かりな試験運用を行いました。しかしパフォーマンスと安定性に問題があることが分かり、試みは不成功に終わりました。私たちは、このプロジェクトがコミュニティへの関与に欠けている上に、進むべき方向へ向かっていないと感じていました。</p><p>KairosDBに触発されて、私たちは新しいプロジェクトを開始しました。小さな概念実証により予想通りの結果が得られたので、実証を続けるとともに名前を付けました。それが「Heroic」です。</p><p>引き続き次回の投稿もご覧ください。次回は、私たちのスケーラブルな時系列データベースであるHeroicをご紹介します。</p><p><img style="border-width:0;" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License" scale="0"><br>
バナー写真はMartin Parmが撮影し、<a href="https://creativecommons.org/licenses/by-sa/2.0/" rel="nofollow" title="" class="ext-link">Creative Commons Attribution-ShareAlike 2.0 International License</a>の下に提供されています。</p>
