JavaScript inheritance patterns （2015-07-29） by Peter Jaszkowiak
プログラミングやその他いろんなことを楽しむイチ学生。
JavaScriptはとても強力な言語です。強力がゆえ、実はプロトタイプをデザインしたり、オブジェクトのインスタンスを生成したりするのに何種類もやり方があります。それぞれの方法には長所も短所もあります。そこでJavaScript初心者の皆さんのために私がそのあたりを整理して説明したいと思います。今回の投稿は、以前私が書いた「JavaScriptを分類するな」の続編です。前回の投稿でたくさんのコメントをいただき、コードの例を出してほしいをいう反応をいただいたので、今回はそれらにお応えします。つまり、JavaScriptでは、オブジェクトは別のオブジェクトを継承することができます。{ }波括弧を使って生成されるJavaScriptの基本的なオブジェクトは、唯一のプロトタイプとしてObject.prototypeをプロトタイプに持ちます。Object.prototypeはそれ自身もオブジェクトであり、Object.prototypeのメンバ全てが、全てのオブジェクトからアクセスが可能です。 [ ] 角括弧を使って生成された、基本的な配列は、Object.prototypeやArray.prototypeなどの数種類のプロトタイプを持ちます。つまり、Object.prototypeとArray.prototypeの全てのメンバは、配列のメンバ同様にアクセス可能なのです。.valueOfやtoStringのように、重複するメンバは一番近いプロトタイプによってオーバーライドされます。今回の場合はArray.prototypeです。JavaScriptは、コンストラクタ関数という特殊な関数を持っています。これは他の言語のコンストラクタと似た働きをします。コンストラクタは強制的にnewキーワードをつけて呼び出され、コンストラクタ関数によって生成されたオブジェクトにthis キーワードをbindします。典型的なコンストラクタは以下です。このコンストラクタは、別の言語のインスタンス化のやり方に似ています。barkとprintは全てのDogに適用されるプロトタイプのメソッドです。nameとbreedのプロパティはコンストラクタによって設定された自身のプロパティです。通常は、全てのメソッドがプロトタイプ内に設定され、全てのプロパティはコンストラクタによって設定されます。classは、初期のころからずっと、将来的に使用されるJavaScriptの予約済みキーワードという位置づけでしたが、今では実際に使われるようになりました。JavaScriptにおけるclassの定義は、他の言語での定義と大変よく似ています。このシンタックスは多くの人が好んで使います。理由は、このシンタックスがコンストラクタ、スタティック、プロトタイプメソッド宣言を、1つの優れたブロックの中に兼ね備えているからです。使い方はコンストラクタメソッドと全く同じです。このメソッドでは、classシンタックスの後に、プロトタイプ継承を実際に表示することができます。また、newキーワードを省くことが可能です。このシンタックスは大変優れていて、プロトタイプがとても明示的に定義されます。どちらがプロトタイプのメンバで、どちらがオブジェクトのメンバかがはっきりと分かります。また、Object.createの優れている点は、ある特定のプロトタイプからオブジェクトを生成できるところです。どちらの場合も、.isPrototypeOfによるチェックは可能です。使い方は異なりますが、大きな違いではありません。これはメソッド3をわずかに変えたメソッドです。このメソッドでは、ファクトリはクラス、対クラスはファクトリメソッドを含むオブジェクトとなっています。コンストラクタの例（メソッド1）に似ていますが、代わりにファクトリとObject.createを使います。このメソッドの優れている点は、使い方はメソッド1と似ているのに、newキーワードを要求せず、instanceof.を使うところです。newを用いないで、メソッド1と同じやり方をすれば使えます。メソッド4ではなくメソッド1を使う理由はほとんどありません。メソッド1では,
コード内でnewを使うか、コンストラクタで以下のようにチェックしなければいけません。この場合も、ファクトリ内でObject.createを使うだけでいいかもしれません。また、thisがめちゃくちゃになってしまうので、コンストラクタ関数上でFunction#callやFunction#applyを使うこともできません。上記のチェックをすれば、この問題が是正されますが、可変長の引数を用いたい場合は、ファクトリを使わなければいけません。コンストラクタとnewに関し、上記で適用したのと同じ理由がこの比較にも適用されます。instanceofチェックは、classシンタックスをnewなしで、あるいはFunction#applyとFunction#callを用いて使う場合に不可欠です。プログラマは明瞭なコードを追求すべきです。メソッド3の明示的なシンタックスは、非常にはっきりと何が行われているのかを表しています。またそれは容易な複数継承と連結継承を可能にします。newキーワードの使用は、applyやcallと適合せず、開放/閉鎖原則を破ることになるので、避けましょう。classキーワードは、プロトタイプを使うJavaScriptの継承の性質を、古典的なシステムに見せかけて隠しています。Object.createは、bindされたthis変数とnewよりもさらに直感的で明確です。また、プロトタイプはファクトリそのもののスコープ外にあるオブジェクトの中に格納され得るので、修正と改善がより簡単です。ちょうどES6クラスのようにメソッドと定義シンタックスを使うこともできます。不必要な、場合によっては破壊的な何かを追加し、言語の本来の性質に逆らうのは間違った動きです。
あなたがclassの利用を選ぶなら、私は自分がそのコードのメンテナンスに携わらなくて済むように願います。私の考えでは、開発者はコンストラクタ、class、newの利用を避け、より密接に言語の構造に沿った継承メソッドを使うべきです。Object.assign(a, b)は、オブジェクトbの全てのenumerableなプロパティをオブジェクトa上にコピーし、オブジェクトaを返します。
Object.create(proto) は、protoをプロトタイプに持つ新規オブジェクトを生成します。
Object.setPrototypeOf(obj, proto) はobjの内部[[Prototype]]プロパティを、protoに設定します。
