<p><a href="http://blog.vullum.io/nodejs-javascript-flow-fibers-generators/" rel="nofollow" title="" class="ext-link">Node.js Flow (part 2) – Fibers and Generators</a> （2015-02-16） by <a href="http://blog.vullum.io/author/eirik-vullum/" rel="nofollow" title="" class="ext-link">Eirik Vullum</a></p><p>Eirik Vullum<br>
美しいものが好きです。コード。ビジュアル。自然。音楽。このブログには技術と生活についての発見や、とりとめのない事を書いています。</p><p>この記事は、<a href="http://postd.cc/javascript-flow-callback-hell-vs-async-vs-highland-part1/">以前投稿したJavaScript/node.jsでの非同期フローに関する記事</a>の続編です。</p><p>今回は以下について取り上げます。</p><p><strong>ここでも私の書いた、Expressフレームワークを使った以下のルート処理（お粗末ですが）を例に見てみましょう。</strong></p><p>fiberを使用することで、フローは同期的なコードのようになります。非同期関数が値を返すようになるからです。これは、fiberがもたらす”マジック”のような効果の一部です。関数あるいはオブジェクトのメソッドは全て、これを可能にする.syncバージョンを持つことになります。</p><p>generatorはES6で新しく導入された仕組みで、function *()というキーワードを使ってgenerator関数を作り出すことができます。generator関数は（var iter = genFun();）という記述で呼び出され、iteratorを返します。iteratorには、新しく導入されたyieldというキーワードが出現するまでコードの処理を進めることができる特別な機能があります。また、yield式は実行中のアプリケーションを終了させず、戻り値を待つ間だけ一時的に停止させます。</p><p>詳細については<a href="http://davidwalsh.name/es6-generators" rel="nofollow" title="" class="ext-link">こちら</a>をご覧ください。</p><p>iteratorの実行関数runの部分</p><p>thunkifyは基本的にカリー化の2つのステップと同等の処理を行う関数なので、最初の呼び出しで入力データを渡し、2回目でコールバックを渡します。</p><p>generator関数にyieldを入れてPromiseを使うには、それをサポートするために、iteratorの実行関数runを修正する必要があります。</p><p>独自のiteratorの実行関数を構築する代わりに、<a href="https://twitter.com/tjholowaychuk" rel="nofollow" title="" class="ext-link">T.J Holowaychuck</a>が作成したcoモジュールを使うことができます。このモジュールは、promiseで実行全体をラップしている間、promise、thunk、配列、オブジェクトなどといったいくつかのオプションをyieldするサポート機能があります。</p><p>このコードをさらに簡潔にするには、mzと呼ばれるヘルパーライブラリを使うことができます。mzは、Promiseを戻すように全てのネイティブな非同期APIを修正します。</p><p>このシリーズのPart 1は<a href="http://postd.cc/javascript-flow-callback-hell-vs-async-vs-highland-part1/">こちら</a></p>
