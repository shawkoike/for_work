Diving Into Other People's Code （2016-03-15） by Li Haoyiこの記事の前編はこちら：他人の書いたコードに挑もう – Part 1前にも言ったように、よく知らないプロジェクトのコードを探索する時は、段階を追って進めます。第一段階は、通常、様々なファイルやフォルダを大まかに見ていくことです。何がどこにあって、そのプロジェクトがどんな「モノ」を持っているのかを把握します。それを終えてやっと、自分の見たい特定の「何か」を詳細に見ていくことができるのです。Spyderにあると思われる主なトップフォルダは下記のものです。他にやるべきこととしては、単純にリポジトリ内にあるコードの行カウントを行うことです。これで詳細な情報が山ほど得られるわけではありませんが、これをすることによって、自分が今どんな怪物を見ているのかがよく分かります。何千行のコードでしょうか、何万行というコードでしょうか、それとも何百万でしょうか。5万8,000行のPythonのコードですね。膨大というわけではありませんが、決して小さなコードベースだとは言えません。大部分の”モノ”がspyderlib/のフォルダ内にあることがすぐに確認できます。

ファイルブラウザでspyderlib/の中をのぞいてみると、含まれている主なフォルダの内容が把握できました。現時点で押さえておく概要としては、これで十分でしょう。慣れるための次の段階では、実行したい具体的な変更について詳しく見ていきます。コードベースを眺めて得たばかりの知識を実際に用いてみると共に、さらに理解を深めることもできるはずです。

コードを動かして大まかな状況も把握できましたので、次のステップでは「Hello World」の例題で、自分で本当にコードを変更しそのコードが実行できることを確認します。Hello Worldの練習としてよく行われるのは、アプリケーション中のテキストの変更です。例えば、ウィンドウのタイトルは以下のようになっています。このSpyder 3.0.0dev (Python 3.5)の部分を、Spyder Hello World...に変えてみましょう。見た感じ、タイトルっぽいですよね。HTMLやJava Swingなど、私が今まで使ってきた他のGUIフレームワークではいずれも、ウィンドウ上部のラベルはtitleと呼ばれていましたので、今回もきっとtitleだと思います。コードベースをtitleで検索してみましょう。
460件見つかりました。多い気もしますが、実はそうでもありません。460件なら、5分以内でざっと調べられるはずです。多くは各種モーダルにタイトルを設定するもので、他にはHTMLなど他言語のタイトルもあります。とはいえ、ヒットしたものは全てチェックした方がいいでしょう。というのも、「タイトルが.iniや.jsonなどの設定ファイルから生成されているため.pyのコード中では明示的には全くセットされていない」ということも十分あり得るからです。このケースでは幸い、目的の箇所が見つかったようです。
あいにく見つからなかった場合は、別のキーワードを試すか、GUIのインスタンス生成が始まる場所を知るためにコードの実行をトレースしてみることも必要でしょう。ですが今回は運良く、5分以内に関連コードが見つかりました。このファイルは見たところ、Spyderが起動するエントリポイントと、Spyder IDEの動作に関連する膨大なロジックの両方の役目を持っているようです。3,168行のコードは、決して単なるイニシャライズ用のスタブではありません。self.register_shortcutにショートカットの登録を行ったり、OSのシグナルをいじったり、セッション（IDEでの意味合いは不明）を扱ったり、env変数をいじったりしているようなのですが、この3,000行のはるか終わりの部分で、Pythonプログラムのエントリポイントの印を見つけました。発見したコードのスニペットに戻り、文字列を微調整すれば、タイトルをSpyder Hello World...に変えられるはずです。そしてpython bootstrap.pyを再度実行すると、次のようになりました。最初の変更がうまくいきました。

初めに課題として挙げたのは、画面上部にある既存のHelpメニューの隣に、新しいドロップダウンメニューを追加することでした。
これらのメニューが定義されている場所を見つける1つの方法は、menuというキーワードでコードベース内を検索することです。開発者が私たちの予想どおりの語彙を使っていると想定して、比較的大きな概念を用いた網羅的な検索で引っ張ってくることになります。もう1つの方法は、メニューの中で使われている文字列で検索することです。一意的に特定可能な長さの文字列であれば、その文字列が定義されている箇所をすぐに見つけられるはずです。今回は、Consolesのキーワードで、大文字と小文字を区別してコードベースを検索することにしました。Consolesという文字列が出現する箇所はそれほど多くないだろうと期待したのです。というのも、Pythonの変数やモジュール名には全て小文字が使われているでしょうし、Python以外での使用（HTML文書など）やコメントは簡単に無視できるからです。実行してみると10数件の結果が得られ、その多くは.md、.rst、.poのファイルでした。
珍しいことに、一見したところ、どれも求めていた箇所ではなさそうです。大体が長大なヘルプページやコメントの一部なのです。しかし、1つ気になるコメントがありました。コードを見てみましょう。まさに、探していた箇所ではないでしょうか。このコードが、各ドロップダウンメニューをツールバーに追加するハードコード部分です。なぜかどの名前にも、先頭か途中に奇妙な&amp;の記号が含まれていますが、これはどうやら、次の文字をそのメニューのショートカットキーとするための不思議なシンタックスであるようです。OS-Xでは機能しないでしょうが、Windows版と思われるオリジナルのスクリーンショットを見ると、ショートカットキーを表す下線付きの文字の位置とちょうど一致しています。
あとは割と簡単に、メニューバーに新しいメニューを追加できそうです。すると、Miscメニューが現れました。
現時点では、このメニューからは何も実行できず、クリックしてもメニュー項目の表示さえできません。まだ項目を1つも追加していないので、メニュー内に何も存在しないためでしょう。次のステップは、既存のメニューが項目を追加している方法を突き止め、それを流用して独自のメニュー項目を加えることです。

見ての通りこの時点では、メニュー項目は上記の場所にまだ追加されていません。各ドロップダウンメニューに名前を付けて初期化しただけです。メニュー項目を追加するコードを書かなければなりません。メニューが使われている場所を探せば、どこでそのメニューが使われるのか、誰かそのメニューに項目を追加しようとしているのかどうかは、簡単に分かります。例えば、console_menuが使われている場所を探してみましょう。
すぐにこんなものが見つかりました。self.consoles_menuの初期化を行っているだけでなく、そのメニューをNoneに設定するコード、self.console_menu_actionsをNoneに設定するコード、さらには今回の目的に関係がありそうな、add_actions関数をself.consoles_menuとself.consoles_menu__actionsから呼び出すコードがあります。これはすばらしい。同様の呼び出しを実行することにしましょう。ただし、consoles_menu_actionsは今のところ空っぽです。ここにどんなコードを書けばいいのでしょう。これも検索すれば簡単に見つけることができます。
どう見てもこれは、interpreter_actionを含むリストです。これはどこから来ているのでしょう。どちらかといえば豆知識ですが、このファイルに対してCmd-Fキーを叩けば、その答えが見つかります。比較的分かりやすいコードです。create_actionを呼び出し、self（中身は何であれ）に渡すのは、_(...)でラップした文字列、None、何かのアイコン、そしてtriggered引数です。これがどうやらコールバックのようです。create_actionの定義にジャンプ（またはgrepで検索）するとすぐに、spyderlib/utils/qthelpers.pyにあることが確認できます。その定義を次に示します。Noneが渡されている先はどうやら、このショートカットのようです。ということは、Open a Python Consoleへのショートカットはもしかして存在しない？　それに、dataやmenurole引数の役割が私には分からないのですが、恐らくこの時点では、まだ理解する必要がないのでしょう。次に注目するのは、ここに渡されるself.open_interpreter関数です。@Slot(str)が何なのか、手掛かりは何もありませんが、それぞれのコールバック（例えば上記のスニペットに含まれているrun_action）には全て、コールバックが取る引数の数に見合う@Slots修飾子が含まれるようです。その規則に従ってコードを書けば、なんとか動作するものになるでしょう。修飾子の部分を除けば、このコードは比較的分かりやすいものです。何か動作をするメソッドを呼び出しているだけです。これで完成です。何かを実行するメソッドを呼び出す関数の書き方を理解することができました。

ここまでに学んだのは、foo_menu_actionsリストをどこで作成すればいいか、このリストをどこに追加すればいいのか、このリストをどのようにしてadd_actionsに渡せば、メニューにそのリストの処理が追加されるのか、ということでした。ここまでできれば、元のプログラムを真似たうえで、独自の処理をフローに組み込むことは難しくありません。あとはpython3 bootstrap.pyを実行すれば…と思いきや、このコードはうまく動作しません。私たちが作成したMiscメニューをクリックしても、コマンドを選択するための、クリック可能なドロップダウンメニューが表示されないのです。既存のコードをそっくりコピーしたつもりでしたが、途中に幾つか抜けがあったことが分かりました。これで動くようになりました！
メニューをクリックすることはできます。ただし、printステートメントが行き場を失っているようです。少なくとも、コンソールには表示されません。コンソールの表示は次の通りです。追加したアクションをクリックしても、コンソールの表示には変化がありません。IDEであるSpyderがprintステートメントをどこかのログファイルにリダイレクトしている可能性がありますが、とにかくリポジトリツリーの中にはprintステートメントは見当たりません。私のホームディレクトリには次の通り~/.spyder-py3フォルダが確かに存在するのに、くどいようですがログファイルには表示されないのです。私たちが書いたコードが動作していることを確認するには、stdoutに出力するのではなくファイルに書き出すというのも一手です。しかし、それを実行してDo somethingをクリックしたのですが、find / -name "logfile.txt"で私のファイルシステムを検索しても、ログファイルがどこにも見当たりません。これはつまり、ここまでこんなに苦労して書き上げたコールバックが動作しないということでしょうか？　では1語ずつopen_interpreterの呼び出しをコピーするようにしたらどうでしょう？間違いなく、Do somethingをクリックすると新規のインタープリタペインが開くようになりました！　ではここでprintステートメントを追加したらどうなるのでしょう？ようやくDo somethingで新規のインタープリタペインが開くようになりましたが、プリント処理はまだうまく動作しません。私たちが書いたコード自体は正常に動作しているのですが、恐らくSpyderがprintステートメントやファイル出力をどこかにリダイレクトしているのでしょう。この状態からどのようにデバッグを進めればいいのか、まだ確信が持てませんが、少なくともコードが動作するようになったことは確認できました。

当初の目標を達成するために必要な最後の作業は、コードエディタの修正です。ファイルシステムをざっと調べると、widgets/editor.pyという期待できそうな名前のファイルが見つかります。EditorWidgetという期待できそうな名前のクラスがあります。編集すべきコードは確かにここに入っています。問題は、これがどこで作られるのか、そして、どうすれば使えるか、です。どうやら、EditorMainWindow内で作られるようです。EditorMainWindowそのものは、plugins/Editor.py内のEditor内に作られています。いろいろなファイルを調べて回るのは、PyCharmなどのスマートエディタを使えば簡単ですが、そのようなエディタを使わなくても、grepやack、agなどを使ってプロジェクト全体でEditorMainWindowという名前を探せば、見つかります。Editorそのものは、MainWindowのsetupメソッドの一部としてspyder.py内に見つかります。よし、これでメインウィンドウからの経路が分かりました。この経路は、ちょっとハズレだったみたいですね。widgets/sourcecode/codeeditor.pyの下にCodeEditorという名前の別のクラスがあって、実際にはこれがテキストエディタの機能を実装しているようです。CodeEditorクラスにはset_textというメソッドがあって、これが、私たちが求めている動作をしているようです。set_textのスーパークラスTextEditBaseWidgetにはtoPlainTextというメソッドがあって、修正すべき現在のテキストを取得するメソッドとして期待できそうです。ここのDocstringに何が書いてあるのか私には分かりませんし、奇妙なunicodeのreplace呼び出しが何をするのかも、toPlainTextのsuperバージョンが何をするのかも全く分かりません。でも、このメソッドがreplaceを呼び出すとPython strが返されるのなら、探していたものは、これだと思われます。それが、先ほど見たエディタとどのように関係するのでしょうか？　エディタはEditorStack.create_new_editorの中で作られるようです。このエディタはEditorStack.newの中で呼び出され、EditorStack.newそのものはEditor.newの中で呼び出されています。こういったものが、私が使えるアトリビュートとして最終的にセットされるかは分かりませんが、こうした数少ないエディタ関連のファイルを見て回るうちに、EditorStackの中にget_current_editorというメソッドを見つけました。これこそ、私が求めている動作をするメソッドです。この実装が何をするのか、他のメソッドがどこに定義されているのかは分かりませんが、その名前から推測すれば、私のやりたい動作をする可能性が高く、現在IDEがフォーカスしているエディタが手に入ると思われます。コードをきちんと調べていないので間違った推測かも知れず、このコードは何か別のことをするのかも知れません。でも、もし、これが現在フォーカスされているウィンドウではないとしたら、この名前でそんなコードを書く人は大馬鹿者です。普通は、ほとんどのプログラマは良識ある人たちなので、たぶん間違いありません。さて、self.main.editor.get_current_editor()をmisc_actionの中で呼び出せば、現在のエディタを手に入れることができますが、手に入るのは、どのエディタなのでしょうか？　名前から推測すれば、次の候補があります。どれにも”Editor”という語が含まれており、get_current_editorメソッドからの戻り値は、どれもそれらしいタイプです！　どうすれば、手に入れたエディタが何なのかを知ることができるでしょうか？　misc_actionメソッドが実行しているのが分かっていながら、このメソッドから何かプリントすることもできないのに。これがJavaなどの静的型付け言語なら、メソッドが何を返すかすぐに分かるのですが…
闇の中を手探りするしかありません。何かプリントしたりファイルに書き込んだりすることができなくても、何が起こっているのかを調べるためにmisc_actionからのデバッグ出力を得る方法があることが判明しました。1つは、QMessageBox.warningメソッドを使う方法です。実は、このメソッドは、misc_actionのすぐ下のstart_ipykernelメソッドで使われています。これをmisc_actionメソッドで利用して、何が起こっているかを知るために役立てることができます。こうすれば、アクションを選択すると、get_current_editorから返されるもののタイプがプリントアウトされるので、やりたいことをするために、5つの候補のうちどれで、どのメソッドまたはアトリビュートを呼び出せるのかを知る手掛かりとして期待できます。では、ドロップダウンでDo somethingをクリックしましょう。結果は下の画像です。これを見ると、5つの候補のうちget_current_editorがspyderlib.widgets.sourcecode.codeeditor.CodeEditorオブジェクトを返し、それ以外の候補は返さないことが分かります。それでも、これはPythonなので、今回はCodeEditorオブジェクトを返しても、別のときには別のものを返す可能性はあります。最初にこれを書いたプログラマが大馬鹿者で、毎回違うタイプのものを返すように作っているかも知れませんが、今は、その人が良識ある人だと仮定して、戻り値のタイプが密かに変わることはないと考えてもいいでしょう。そう仮定すれば、このエディタ上でset_textを呼び出すことができます。結果の画像はこうなります。
次に、toPlainTextを、spyderlib.plugins.editor.Editorの便利なget_current_filename()メソッドと一緒に試してみます。私はEditorのように見える5つの似たクラスを調べていたときに、このメソッドに気付いていました。作業を始めてから5時間で、ついに完成しました。
githubのmasterから分岐するブランチからの、コミットdf9577cfc279d2b6f2c07c7ba4e8e7aebfdd1835の書き込み時点での最終的なdiffは、次のようになりました。プロ並みの貢献をしたかという点でいえば、まだ「やりきった」とは言えません。今回、できる変更を加え、機能するパッチを実際にやって見せましたが、どのような変更をすべきなのか、そしてそれらをどう扱うのかをよく知るために、基本的なコードベースを理解することは、完全に別問題です。例えば、externalconsole.pyにmisc__actionコマンドをダンプしても機能はします。しかし、これは明らかに正しい方法ではありませんし、コードレビューは決してできないでしょう！ともあれ、この問題に取り組むことによって私たちは、プロの環境でのコードレビュープロセスのスタート地点に立たされるのだと思います。私たちが加える変更を、どのように幅広いコードベースに適合するのかについて合理的な議論を行うために、また、洗練された完成品を作るための土台として、（なんとなく動く程度の）パッチを完成させるために、コードベースの全体的なアーキテクチャについて十分な理解を得ることができました。5時間を費やしただけあって、悪い結果ではありません！私たちは、何も分からない状況から、大規模な既存のデータベースに対して、奮闘を続け、問題を理解し、そして進歩してきました。今回学んだいくつかの興味深い教訓を以下に挙げます。これが、初めて目にする他人が書いたコードに挑み、数時間あまり分かってない状態で作業しながらも、重要な変更を加える方法です。是非、皆さんの経験や技、技術などを下にあるコメントに投稿してください！article originally written by Li Haoyi on http://www.lihaoyi.com/post/DivingIntoOtherPeoplesCode.html
