<p><a href="http://eev.ee/blog/2015/09/17/the-sad-state-of-web-app-deployment/" rel="nofollow" title="" class="ext-link">The sad state of web app deployment</a> （2015-09-17） by <a href="https://twitter.com/eevee" rel="nofollow" title="" class="ext-link">Eevee</a></p><p>ここ4日間というもの、インターネットWebフォーラムをインストールしようとして大いに時間を無駄にしました。説明書きには30分でセットアップ可能と書いてあったんですけどね。</p><p>コンピュータは得意なほうだと思っているのですが、一体、何が悪かったのでしょうか？　これからお教えしましょう。</p><p>辱めるのは本意ではないので製品名は言わないでおきます。この製品でひどい目にあったのは今回が初めてではありませんが、製品単体の問題というよりはもっと大きな問題だからです（”ピス・ホース（馬におしっこ）”に音が似ているとだけ言っておきましょう）。</p><p>30分でセットアップ可能と説明されている根拠は、Dockerによるインストールが正式にサポートされていて、それ以外の手段がないからです。Dockerは輝かしくも新しいコンテナ管理ソフトウェアで、それだけでも危険な香りがします。相互運用可能なデスクトップ環境全体をインストールするのに、Dockerを使わなくても問題なかったのですが、Webフォーラムは疑似仮想化OSを必要とするほど複雑なのでしょうか？　うーん。</p><p>私はベンダ版のDockerをインストールしようとしましたが（私が使用しているのはUbuntu 14.04の最新のLTSリリースです）、これのバージョンは1.0で、Dockerは1年半のうちに1.7になっていました。このソフトウェアは最低でも1.2を必要としていました。このWebフォーラムはあまりにも最先端を行っているため、2年前は存在していなかったテクノロジを使わないとインストールさえ拒否するのかとイライラしました。</p><p>そこでオフィシャルに認可された方法で最新のDockerをインストールしようとしました。こうすると、もちろん、シェルに<code>curl</code>をパイプすることになります。これは最悪の方法ですが、<a href="http://reventlov.com/advisories/using-the-docker-command-to-root-the-host" rel="nofollow" title="" class="ext-link">Dockerのセキュリティはひどいもの</a>ですからね。もちろんインストールは失敗し、<code>E: Unable to locate package docker-engine</code>（docker-engineというパッケージが見つかりません）という意味のないメッセージだけが返されました。こんなパッケージマネジメントの悪夢から救ってくれるためにDockerが存在してくれていて涙が出るほどありがたいです。<br>
少し調査してみると、32ビット版のDockerは存在しないようでした。彼らは<em>問題ないはず</em>だと言っている（標準の32ビットUbuntuパッケージが存在しているからという理由で）のにです。このことをREADMEにも、インストールマニュアルにも、rootとして実行した時のシェルスクリプトにも、記述する気はないようです。<br>
この時点で私はもうDockerにうんざりして、マニュアルでインストールしてみようと決めました。所詮はRailsアプリですし、Railsアプリは以前にもインストールしたことがあります。そんなに大変なことにはならないでしょう。<br>
ハハ。<code>git clone</code>を実行した後（どうしてRubyGemsに入っていないんでしょうね）、私はおそらく<em>6時間</em>はRVM（Ruby Version Manager）と格闘しました。（読者の中にはこれを読んで、Rubyの環境が違うんじゃないかと助言したい人がいるでしょうが、黙っていてください。すでにRVMをインストールして色々動かしているんです）。</p><p>アプリの依存ファイルをインストールするための<code>bundle install</code>を実行している時に、非常に分かりづらいエラーが出たのです。<code>.a</code>ファイルがビルドディレクトリに存在しない、といくつかのライブラリがエラーを返してきましたが、理屈に合いません。そして、パスには<code>x86_64-linux</code>があったので、ますます訳が分かりませんでした。</p><p>私は実は64ビットカーネルを使っていますが、ユーザ空間は32ビットです（これにはちゃんとした理由があります）。そしてRVMがビルドしたRubyのバイナリは、もちろん32ビットです。Libcと他全てが32ビットなので、そうでなければ動作しません。しかし、これらのバイナリは自分たちが64ビットのシステム上で稼働していると<em>思っていた</em>のです（実際そうですけどね）。一方RubyGemsはネイティブ拡張をビルドするのに、何だかバカみたいな理由で<em>システム</em>アーキテクチャを使うので、全てが64ビットとしてビルドされてしまいました。ある意味この<em>1つの</em>パッケージが異常終了してくれてラッキーだったかもしれません。他はちゃんとビルドされていたので、最悪の場合、実行時に気付く羽目になっていたでしょうから。</p><p>私はあらゆる環境変数を試し、ファイルを手動で編集してみたり、他にもいろいろ試してみたりして、実際は32ビットだとRubyに分からせようとしましたが、無駄な努力でした。ついに私はRVMのソースコードを読むしかないと覚悟を決め、そして<code>--32</code>フラグが魔法のように全てを解決することを発見したのです。これはドキュメントに記述されていませんが、心配要りません。 <a href="https://github.com/rvm/rvm/issues/623#issuecomment-5201721" rel="nofollow" title="" class="ext-link">半年前、GitHubで起こった問題についての3人からのコメントに、RVM2.0でドキュメントを修正する</a>という返信を見つけましたから…。</p><p>さあこれでRubyが無事稼働したので、面倒なリビルドさえ終わればバッチリなはずです。最高ですね。</p><p>さて、今度はこのバカげたアプリをどう設定するかを解明する番です。READMEには「Dockerを使え」としか書いていないので、なかなか厄介です。<code>config/app.conf.sample</code>ファイルは存在していましたが、これはUpstart、つまりUbuntuのサービスマネージャのためのサンプルだということがわかりました。Ubuntu上へのインストールマニュアルを最終的に発見<em>できました</em>が、どこからもリンクされていませんでした。</p><p>次はデータベースの認識を”存在していない”から”存在している”にマイグレートします。Railsでは楽勝のはずです。と言うのは冗談で、私は地獄のような悪夢を経験せずには一度も成功したことがありませんが、今回も例外ではありませんでした。マニュアルにはこのアプリはスーパーユーザとして実行するように書いてあります。ちなみにPostgreSQLのマニュアルにスーパーユーザに関してどう書いてあるか見てみましょうか。</p><p>はい、まさにこれがWebフォーラムが必要としているもののようです。私はデータベース全体にroot権限を<em>与えない</em>ことを選択していましたが、その結果、もちろんマイグレーションは失敗しました。サーバ上にバイナリの機能拡張を読み込むのに<code>CREATE EXTENSION</code>を使うからです。<em>データベースマイグレーション</em>がこれを行うのは大変理にかなっています。私は必要な機能拡張さえもインストールしていませんでしたが、もちろんマニュアルにはそれが必要だとは書いていませんでした。それでともかくインストールしたのです。</p><p><code>postgresql-contrib</code>をインストールしたらおかしなことになりました。なるべく手短に説明しますね。私の環境ではPostgres のバージョンは9.1で、Ubuntuの最新バージョンは9.3です。元々<code>postgresql</code>パッケージをインストールしていて、デスクトップでArch Linuxを利用していたので、常に最新のバージョンなっているものと思い込んでいました。しかしUbuntuは「サーバ全体を破壊しない」などと言う些細なことを気にして、常に9.1にしていてくれたのです。しかし<code>postgresql-contrib</code>はこれを認めず、<em>現在の</em>最新バージョンの9.3が必要だとして、サーバ全体をインストールしてしまいました。やれやれ。それで、私は回り道をして9.3にアップグレードしました。これは以前やったことがあったので<em>比較的</em>楽でした。</p><p>オーケー！　データベースが設定できました。</p><p>ここまで来てもまだ、マニュアルにはBluepillと呼ばれるRubyのプロセスマネジメントライブラリをインストールし、山のような”コンフィギュレーション”（もちろん、実際にはこれはただのRubyのコードです）をコピーし、そしてそれを使ってアプリを実行し、そして更にBluepillをユーザのcrontabに<code>@reboot</code>として追加し、などと他にも何だかんだと書いてありました。</p><p>（私は「マトリックス」からの引用かと思っていたのですが、後から誰かがこれは<em>bluepill</em>と呼ばれるもので、<em>ツールをモニタするもの</em>だと教えてくれました。ステキな名前ですが、<a href="http://unethicalblogger.com/2011/11/13/ten-poorly-chosen-gem-names.html" rel="nofollow" title="" class="ext-link">Rubyでは平均的</a>かもしれません。</p><p>いずれにせよ、これを全て<em>行わない</em>と選択し、<code>rails server</code>で直接実行しました。</p><p>これでほとんど出来たはずです。今度はこれにnginxをプロキシする必要があります。アプリは親切にもコンフィギュレーションを提供してくれるのですが、これが<em>200行の長さ</em>でした。中身のほとんどは入り組んだルールで、どのURLが静的アセットで、どれがプロキシされるべきかなどといったようなことが書いてありました。私はクソくらえと思い、全部をプロキシしてしまい、後で気が向いたら修正しようと思いました。</p><p>これで準備完了です。でもなぜかサインアップのeメールも来ません。<em>今回は</em>、ジョブプロセッサの”sidekig”も実行する必要があったということが分かりました。<em>今度こそ</em>、準備完了です。</p><p>なぜ私がこの話を書いているかといえば、<strong>完全にバカバカしい体験だ</strong>ということを伝えるためです。</p><p>風変りなツールが使い物にならないことはさておき、<a href="https://github.com/discourse/discourse/blob/master/docs/INSTALL-ubuntu.md" rel="nofollow" title="" class="ext-link">指示</a>（訳注：リンク切れです）にそのまま従うとすれば、このWebフォーラムでは更に以下のことが必要になります。</p><p>このアプリには驚くような機能はないはずです。HTTP接続をして、データベースを使い、eメールを送信する程度ですよね。どうしてこんなにも複雑なんでしょうか。</p><p>その訳をお教えしましょう。</p><p>私の経験は確かに限定されていますが、私に分かる範囲で言えば、<em>Railsアプリをインストールするのは不可能です</em>。ソースディレクトリからコンフィギュレーションを読み込み、ソースディレクトリにログを出力するのです。手動でこれら全てのアセットをプリコンパイルしなくてはなりません。もちろんこれもソースディレクトリに書き込まれます。</p><p>Railsは世界でも最もポピュラーなWebフレームワークの1つであり、あちこちの開発者から支持されています。それなのに、Railsで書かれたものはまったく<em>インストール</em>できないのです。ふざけてますよね。</p><p>ずっと前、Windowsがマルチユーザに対応しておらず、管理者権限を持つアカウントで全ての操作を実行していた時代、Unixオタク（私自身も含みます）は、ユーザ毎にアカウントをいくつも作ることができるUnixの素晴らしさについて、得意気に語っていたものでした。</p><p>そう思っていた自分自身を、とても恥ずかしく思います。要点をまとめてみましょう。</p><p>現在のLinuxデスクトップはマルチユーザで使う分には非常によくできています。まあ、基本的には誰も使っていませんが。サーバサイドではどうでしょう。そうですね、サーバであれば、誰もがroot権限を持っていると想定できるでしょう。そのため全てがごちゃごちゃな状態です。ユーザが異なるRubyのバージョンを複数インストールできるように設計されているRVMでさえも、<code>sudo apt-get install</code>か何かを実行するために、パスワードを求めてきました。</p><p>私たちは依存関係を列挙したり対処したりすることが本当に苦手です。</p><p>つまり、私たちは自分たちのソフトウェアでさえ、依存関係を表現することができません。システムパッケージマネージャがその処理を行っており、その仕事は申し分ないものです。しかし、私は開発者であり、パッケージをひたすら作る人ではありません。CライブラリをラップするPythonライブラリを書く場合、その依存関係を表現する<em>方法はありません</em>。そんなものあるわけがないのです。C/C++の公式に認められたリポジトリなんか、どこにも存在しないのですから。たとえ依存関係を表現できたとしても、どんないいことがあるのでしょう？　<code>LD_LIBRARY_PATH</code>や<code>LDFLAGS=-rpath</code>みたいなものを使って、C言語の共有ライブラリをローカルにインストールするのは、非常にうんざりすることです。私だって、よく分かりません。実際、本当に面倒な作業なので、誰もそんなことはしないでしょう。</p><p>そのため、<em>サービス</em>上に依存関係を列挙するものが何<em>も</em>なくても、何の驚きもありません。Webアプリなら“Postgresが必要で、Redisはオプションで必要”と書かれたメタデータくらい持っているだろうと、あなたは思うかもしれませんが、そんなものは存在しないのです。一方、ユーザが使えるサービスを列挙できるシステムも、同様に存在しません。ないものは見つけることもできませんね。もしアプリで必要とするサービスがないものの、ドキュメント化に失敗したか、誤って設定してしまったとしたら、最初の段階でそれを調査するしかないのです。</p><p>では、次の話題に移りましょう。</p><p>うまくいく部分/うまくいかない部分全体を通じて、失敗時のレポートが決定的に欠如しているのです。私の場合、問題がある場合は、基本的にみんなが私にツイートしてきてくれる情報か、IRC（インターネット・リレー・チャット）で投げかける質問に頼って解決します。この特定のアプリはジョブキューに決定的に依存しているものの、<em>実行中でないことに気づかなかった</em>などといったことです。</p><p>クラッシュログをメールで送ってくるウィジェットも数個ありますが、いったいどこのマヌケがそんなものを考えたのでしょう？　何の役にも立ちません。私自身、私の完璧で実用的、かつ落ち着いたトラフィック量があるWebサイトのクラッシュをレポートした2000通以上のeメールが未読のまま放置されています。そのほとんどが、どこかの誰かが誤ったURLを打った結果をレポートしたものであり、私自身、修正する気もないものです。</p><p>しかし、アプリが<em>ダウン</em>して完全に起動できない状態に陥った場合に、私が受信するeメールの数は<em>ゼロ</em>です。アプリが動いているものの各リクエストを処理するのに20秒費やしている場合も、eメールの数は<em>ゼロ</em>です。そして全てのページで404エラーが出ているとしても、eメールの数は<em>ゼロ</em>なのです。そうしているうちに、本当に実際のページが壊れ始めたとしたら、大量のeメールを受けることになりますが、もはやメール自体を見なくなっているため、そのメールに私が気づくことはありません。</p><p>このような問題はよくあります。それにもかかわらず、私がこれまでに見てきた唯一の解決策は、手作業でいくつものグラフを見比べることくらいなのです。</p><p>私たちに必要なのは、コマンド1つでインストールができて、設定は5分で終わり、かつ複数サーバへの拡張や<em>共有ホスティングへの縮小</em>が可能なアプリです。DreamHost上にインストールできない<em>Webフォーラム</em>は、完全なる失敗作です。</p><p>しかし私たちは、この課題に挑戦すらしてきませんでした。これを解決できる優秀な人はいても、彼らは皆TwitterやAmazonのサーバを1000万台に拡張するといった類いの作業で手一杯なのです。基本的なWebソフトウェアは日に日にインストールしづらくなり、共有ホスティングの有用性は下がる一方です。そして2つのアプリで、同じデータベースを利用する方法を思いつかないWeb開発者たちは、基本的に仮想マシン上で動作するDockerようなガラクタに群がっています。</p><p>私が欲しいのは、Webアプリのインストールと管理に特化した仲介用のWebアプリです。実装方法は見当がつきませんが、cPanelのようなものから、人気のアプリに対する間に合わせのサポートを除いたものが理想です。あとはアプリの最小必要条件を教えてくれるプロトコルもあるとうれしいですね。</p><p>そして、「”ピス・ホース”というRubyアプリをインストールしろ」と言えるようになりたいのです。そうすると、あとは上記の夢のアプリが、gemの検索やアプリの動作に必要なRubyバージョンの確認、該当バージョンのRVM環境のインストールを行ってくれます。新規にgemsetを作成して、gemのインストールもするでしょう。そして”代表的な場所”にあるメタデータファイルをチェックし、そのファイルがPostgreのデータベースとRedisのインスタンスを必要としていることを確認します。PostgreやRedisに接続するために、どんな一般的な方法が使えるかも調べてくれます。そして私にPostgreやRedisがある場所を確認し、見つけたものは全てデフォルトとして提供するのです。<code>postgresql:///pisshorse</code>などの簡潔なものは受け付けてくれますが、TCP接続していない限り無意味な、10個に分かれたフィールドなどはダメでしょう。あとは、これらに問題がないかダブルチェックした上で、その内容を<code>~/.config/webapps/pisshorse</code>など、どこかに存在する非常に小さな設定ファイルに書き込みます。この間に、データベース接続のTTL（有効期間）などの、どうでもいい値を設定するよう私に求めてくることはありません。そんな値は<em>誰も</em>気にしませんし、コンピュータならそのくらい自動で判断できますからね。</p><p>共有ホストで、Postgreデータベースが1つだけの場合は、これで万事うまくいくでしょう。なぜならそれは、Postgreのスキーマについて私たちが理解した上で使用し、アプリがそれを実際にサポートしている夢のような世界だからです。</p><p>メタデータファイルにも、必須の（もしくは、あると望ましい）システムレベルのライブラリとバイナリが全てリストアップされ、その中に未インストールのものがあれば、インストールをするよう私たちに要求します。<code>apt-get</code>や<code>yum</code>、<code>packer</code>などのコマンド１つで、私たちは自ら検査や実行といった処理ができます。繰り返しますが、共有ホストの場合は、自身でソフトウェアのインストールはできません。その場合は、インストローラがローカルでインストールを試みるか、単に断念するかのどちらかです。いずれにせよ、実際のところWebフォーラムは<code>optipng</code>を必要としておらず、なくても続行可能だと分かるので、全く問題はありません。</p><p>その後は、ユーザ領域のデーモンマネージャにアプリを追加します。デーモンマネージャがない場合は、<code>@reboot</code>というワザを使えば、それが存在するかのように振る舞ってくれます。アプリにジョブキューの稼働が必要だと判断すると、それも追加します。使用するサーバはGunicornやUnicorn、uWSGIなどですが、どれを使うか私たちが気にすることは、あまりないでしょう。もしこだわりがある場合は、違うものを指定することもできます。デフォルト設定では使用者は2人だけですが、負荷を監視して、必要に応じで子プロセスを生成し、現状の平均的なトラフィックも把握してくれます。その際、マシンのメモリを食い過ぎていると判断すると、私たちにメールを送信したり、IRC上でpingを打ったりするのです。</p><p>アプリがバインドされるのは<code>~/.config/webapps/pisshorse/pisshorse.sock</code>なので、あまり便利とは言えません。この部分は私もまだ、どうしたらいいか悩んでいます。というのも、実際のところHTTPバーチャルホストのセットアップをどのようにするか決める手立てがなく、nginxを使っている場合は、いまだルート化する必要があるからです。ですが（複雑な）次善策なら、いくつかあります。ここで、ルート化することなく、リバースプロキシを設定してもらえる素晴らしい世界を想像してみてください。そこでは、静的アセットをキャッシングするためのルールが追加され（メタデータファイル内にも定義され）、私たちがCDN（コンテンツ・デリバリー・ネットワーク）を持っている場合には、それを要求してくるでしょう。</p><p>アプリが動いていても、ユーザがいなければ、まだ確認メールを受信していないので、ログインはできません。でもコマンドラインから実行できる管理者用コマンドが、メタデータファイルにも何個か指定されているので大丈夫です。もちろん魔法のようなWeb GUIでも同様の対処をしてくれます。</p><p>ここから先は基本的に、管理GUIのことは忘れて構いません。でも裏ではログや統計データを収集しているので、要求すればグラフを見せてくれます。そして、アプリが起動に失敗する、動作していたページで不具合が急増している、要求に対応しきれていない、ジョブキューに異常が発生した、といった事態が発生すると必ずpingが送信されます。</p><p>結局はアップグレードが必要になりますが、うれしいことに、ボタンをワンクリックするだけで済みます。その際、既存のインスタンスは読み取り専用モードになります。でも全てのアプリはこのモードに対応しているので、面倒なことにはなりません。ジョブキューは終了し、データベースは<em>コピーされて</em>から更新され、新たなアプリのインスタンスが別で立ち上がります。新規リクエストの対象は新しいコードになり、古いインスタンスが終了すると、古いデータベースはアーカイブされます。新しいインスタンスが、いきなりエラーを吐き出した場合は、古いコードが保持され、お叱りメールが自動でアプリの管理者に送信されます。いずれにせよ、大きな混乱を招くことはありません。</p><p>これはアプリ側にもメリットがあります。というのも、GunicornやuWSGIなど、どのサーバでアプリが動作中かを確認できる小規模なライブラリを使用しており、自身の負荷測定や再起動、要求外の単純なコードの実行など、簡単なタスクがこなせるからです。</p><p>夢は膨らみますね。</p><p>私たちは20年間も、このようなことをしています。正しく動作し、プラガブルで依存性がなく、全てを<em>完璧に</em>こなすアプリが、そろそろ完成していてもいい頃です。WebのGUIを捨て去れば、自動生成された汚いものではなく、手動で設定された整然としたシステム管理者のようなアプリができるはずです。</p><p>ところが私たちは、既存のものに、複雑なゴミの層をひたすら積み上げています。修復方法が、もう分からないのです。そして昨日登場したパッとしないアプリをデプロイするために、ThinからMongrel、Passenger、Heroku、Bitnami、Docker、そして更なる新しいものへと、せわしなく乗り換えています。もしくはフレームワークに、より良いSasSのインテグレーションを導入することに執着していたりします。</p><p>RubyやRail、または特定のアプリを非難するつもりは全くありませんよ。私は、ただ<em>自分の</em>Webソフトウェアをどうしてもデプロイしたくないのです。システム内には、互いの機能をほとんど把握していない部分が多くあるので、一部が故障すると、システム全体が停止してしまうのです。私は今、少なくともログの確認や再起動が簡単にできるように、最低でも5つの処理を<code>tmux</code>で走らせています。</p><p>これは悲惨で、恥ずべき状況です。PHPに人気が集中するのも、うなずけます。私はどうやって新人のWeb開発者たちに、「これが、君らが期待していたものだよ」と伝えればいいのでしょう。</p>
