Learn Docker by building a Microservice （2016-04-19） by Dave Kerr前編はこちら：Node.jsのマイクロサービスの構築を通してDockerを学ぶ – 前編さて、ここからがお楽しみです！私たちには、互換性のあるNode.jsバージョンがインストールされている開発マシン上で実行できるマイクロサービスがあります。やりたいことは、Dockerイメージを作成できるように、サービスをセットアップすることです。そうすれば、Dockerをサポートしているあらゆる場所にサービスをデプロイすることができます。これを行うにはDockerfileを作成します。Dockerfileは、イメージを構築する方法をDockerエンジンに指示するレシピです。users-serviceディレクトリに簡単なDockerfileを作成し、それを私たちのニーズに適応させる方法を探ることから始めましょう。users-service/ディレクトリに以下の内容を持つDockerfileいう名前の新しいテキストファイルを作成してください。次に以下のコマンドを実行することで、イメージを構築して、そこからコンテナを実行します。それでは、まず、ビルドコマンドを見てみましょう。コンソールに幾つか出力された後、新しいイメージが作成されたことが表示されます。docker imagesを実行するとシステム上の全てのイメージを見ることができます。2番目のコマンドdocker runは、ある程度説明してきたので、だいぶ慣れているはずです。このイメージを実行すると、Node REPLが立ち上がります。現在のバージョンが以下のように表示されるので、確認してください。これは、あなたの現在のマシン上のNodeバージョンと異なる可能性があります。Dockerfileを見れば、何が行われているかを非常に簡単に知ることができます。次のように、さらにコマンドを幾つか追加すれば、私たちのサービスを実行するようにDockerfileを更新することができます。ここで追加した部分を説明します。ADDコマンドを使って、app/というコンテナの中のフォルダにカレントディレクトリにあるものを全て1コピーします。次に、RUNを使って、イメージの中のコマンドを実行します。それによって、私たちのモジュールがインストールされます。最後に、サーバポートをEXPOSEして、8123でインバウンド接続をサポートするつもりであることをDockerに伝えます。その後、私たちのサーバコードを実行します。test-databaseサービスが実行されていることを確認してください。その次に、以下の通りに再度イメージを構築し、実行してください。ブラウザでlocalhost:8123/usersにアクセスすると、エラーが表示されるので、コンテナから報告されている問題をコンソールで確認してください。エラーは次の通りです。うわー！　users-serviceコンテナからtest-databaseコンテナへの接続が拒否されています。docker psを実行して、実行中の全てのコンテナを表示してみましょう。コンテナは両方ともありますね。一体どうなっているのでしょうか？先ほど見た問題は、実は予想されていたことです。Dockerコンテナは隔離すべきものですから、私たちが明確な許可を出していないにも拘らずコンテナ間に接続を作れてしまっては、あまり意味はありません。そうです。私たちのコンピュータ（ホスト）からコンテナへ接続することはできます。そのためにポートを開けてあるからです（例えば、-p 8123:8123という引数を使います）。もしもコンテナに、お互いに同じ方法で通信することを許せば、開発者が意図していなかったとしても同じコンピュータで実行されている2つのコンテナは、通信できてしまうのです。これは特に、異なるアプリケーションからコンテナを実行するのが仕事のコンピュータがいくつもある場合は大失敗の元になります。もしもコンテナを他のコンテナと接続させるなら、リンクさせる必要があります。これにより、Dockerに「2つのコンテナの間のコミュニケーションを明白に許可したい」と伝えられます。これを行う方法は2つあります。1つは”昔ながらの”非常にシンプルな方法です。2つ目はもう少し後で見ましょう。コンテナを実行する時は、linkパラメータを使って他のコンテナと接続する意図があることをDockerに伝えることができます。今回の場合では、以下に示すようにすれば、サービスを正しく実行できます。これでlocalhost:8123/usersとしてみれば、全てが機能します。サービスのための設定ファイルを覚えていますか？　それによって環境変数を使ってデータベースのホストを特定できるのです。コンテナを実行する時、この環境変数をDBに設定します。つまり、DBというホストに接続するということです。これは、コンテナにリンクした時にDockerエンジンによって自動的にセットアップされます。これが実際に機能しているのを見るには、docker psを実行して動いているコンテナを全てリストアップさせてみてください。そしてusers-serviceを実行しているコンテナを探してください。trusting jangというような、ランダムな名前になっているでしょう。これで、コンテナ上で利用可能なホストが見られるようになりました。docker execはどのように機能するか覚えていますか？　コンテナの名前を選べば、その後に続くのが何であれ、それがコンテナで実行するコマンドになります。今回の場合では、cat /etc/hostsになります。hostsファイルに、通常は含まれない# linking magic!!というコメントがあることに気付きましたね。Dockerがhostsファイルにdbを加えたので、ホスト名を使ってリンクされたコンテナを参照することができます。これは、リンクすることによる結果の1つです。他の例も挙げておきましょう。Dockerがコンテナにリンクする時には、このコメントからも見ることができますし、いくつかの有益な情報と共に環境変数も与えてくれます。ホストとTCPポート、コンテナの名前が分かりました。これでステップ3が完了しました。コンテナ内で快適に実行されるMySQLデータベースができ、ローカルで実行することも自身のコンテナ内で実行することもできるnode.jsのマイクロサービスもあり、これらをどのようにリンクさせるかも分かりました。この段階でコードがどのようになっているのかは、ステップ3のブランチに行くことで確認できます。これで、実際のサーバを呼び出す統合テストを書くことができるようになりました。そして、Dockerコンテナとして実行し、コンテナ化されたテストデータベースを呼び出します。統合テストは、常識の範囲内で、あなたが書きたいと思うどの言語、どのプラットホームで書いても構いません。しかし、状況を単純にしておくため、私たちのプロジェクトで既にMochaとSupertestを見てきたように、Node.jsを使っています。integration-testsと名付けた新しいフォルダの中に、以下のような内容を持つindex.jsファイルが1つだけ入っています。これはAPI呼び出しをチェックして、テストの結果を示します2。users-serviceとtest-databaseが動いている限り、テストは合格するでしょう。しかしこの段階では、サービスは少々扱いづらくなっています。今は、少しDockerに詳しくなったので、こういった問題を解決することができます。今のところ、私たちはテストデータベースのために以下のファイルを用いています。Dockerについてさらに詳しくなっているので、これを改善することができます。Docker HubのMySQLイメージのドキュメンテーションに目を通していただければ、イメージの/docker-entrypoint-initdb.dフォルダに追加した.sqlと.shという拡張子のファイルはどれも、そのDBをセットアップする際に実行されるという解説が記されています。これは次のように、スクリプトファイルstart.shとstop.shをDockerfileに置き換えることができることを意味しています。では、以下のようにテストデータベースを実行してみましょう。各コンテナを構築し、実行するのは、いまだに時間がかかる作業です。Docker Composeツールを使って、更にもう一歩前に進むことができます。Docker Composeはシステムの各コンテナと、コンテナ間の関係性を定義するファイルを作成し、全てのファイルを構築・実行します。まず、Docker Composeをインストールします。さて、あなたのプロジェクトのルートディレクトリに以下の内容をもつdocker-compose.ymlという名前の新しいファイルを作ってください。さて、以下を確かめてみて下さい。Docker Composeはアプリケーションに必要となるイメージを全て構築し、そこからコンテナを作成し、正しい順番でコンテナを実行ました。これで、全部の作業が開始されました。以下に示すように、docker-compose buildというコマンドはdocker-compose.ymlファイルに記載された各イメージを構築します。それぞれのサービスに対するbuildの値は、Dockerfileをどこで見つければよいかをDockerに伝えます。docker-compose upと実行すると、Dockerは全サービスを開始します。Dockerfileから、ポートと依存パッケージを特定できることにご注意ください。実のところ、私たちが変更できる設定がこのファイルの中にたくさん含まれています。別のターミナルで、docker compose downと実行すれば、円滑にコンテナを終了します。この記事の中で、Dockerについて多くのことを見てきました。しかし、まだまだたくさんあります。あなたの業務においてDockerを使えるような興味深く役に立つことをご紹介できていればいいのですが。いつものように、質問やコメントは大歓迎です！　Dockerがどのように機能するかという理解をより深めるために、Dockerを理解するという文書も一読されることを強くお勧めします。この記事でご紹介したプロジェクトの最終的なソースコードは、以下のWebサイトから入手できますgithub.com/dwmkerr/node-docker-microservice。
