<p><a href="https://kozikow.com/2016/07/10/visualizing-relationships-between-python-packages-2/" rel="nofollow" title="" class="ext-link">Visualizing relationships between python packages</a> （2016-07-10） by <a href="https://kozikow.com/" rel="nofollow" title="" class="ext-link">Robert Kozikowski</a></p><p>私は、<a href="https://github.com/blog/2201-making-open-source-data-more-available" rel="nofollow" title="" class="ext-link">BigQueryのGitHubデータ</a>を使って、GitHubリポジトリにある上位3,500個のPythonパッケージの共起を抽出し、<a href="https://github.com/d3/d3-force" rel="nofollow" title="" class="ext-link">速度ベルレ積分を使ってd3のForceレイアウト</a>を可視化してみました。また、<a href="https://pypi.python.org/pypi/python-igraph" rel="nofollow" title="" class="ext-link">python-igraph</a>にあるアルゴリズムを使ってグラフをクラスタ化し、<a href="http://graphistry.com/" rel="nofollow" title="" class="ext-link">http://graphistry.com/</a>にアップデートしました。</p><p>以下のスクリーンショットは、d3の可視化にあるNumPyのクラスタです（画像をクリックするとライブ版をご覧いただけます）。</p><p><img src="https://kozikow.files.wordpress.com/2016/07/screenshot1.png?w=1140" alt="screenshot.png" originalw="1140" scale="1.5"></p><p>以下は、graphistrynによって抽出されたNumPyのクラスタです（画像をクリックするとライブ版をご覧いただけます）。<img src="https://kozikow.files.wordpress.com/2016/07/graphistry1.png?w=1140" alt="graphistry.png" originalw="1140" scale="1.5"></p><p>グラフの特徴：</p><p>私のアプリケーションは、<a href="http://clustering.kozikow.com/?center=numpy" rel="nofollow" title="" class="ext-link">http://clustering.kozikow.com/?center=numpy</a>でご覧いただくことができます。以下のことが可能です。</p><p>graphistryのビューで興味深いものについては、次のセクションである<a href="#Analysis-of-specific-clusters">特定のクラスタの分析</a>でご紹介します。</p><p>グラフの可視化は、見た目が恰好いいということを除いては、時に実用的な洞察を得られないこともあります。使用できる実用的な洞察は以下のとおりです。</p><p><a href="https://github.com/kozikow/kozikow-blog/blob/master/clustering/clustering.org" rel="nofollow" title="" class="ext-link">この投稿の編集履歴はgithubで閲覧可能</a>であり、これは<a href="https://kozikow.com/2016/05/21/very-powerful-data-analysis-environment-org-mode-with-ob-ipython/" rel="nofollow" title="" class="ext-link">org mode</a>になっています。</p><p>d3の可視化結果に加え、更に<a href="https://pypi.python.org/pypi/python-igraph" rel="nofollow" title="" class="ext-link">python-igraph</a>にある<code>community_infomap().membership</code>を使ってデータをクラスタ化し、それをgraphistryにアップロードしました。クラスタによる除外機能やフィルタ機能は、とても便利です。</p><p>当然のことですが、それはNumPyが中心です。面白いことに、統計学とマシンラーニングでは相違が見られます。</p><p>Webフレームワークは興味深い機能群です。</p><p>クラスタ化のアルゴリズムの結果を見てみると、”中間サイズ”のクラスタだけに興味を引き付けられます。真っ先に目を引くことが明らかなものを挙げると、osやsysのようなパッケージが多数を占めるクラスタです。クラスタが非常に小さいと、これに興味を引き付けられることはありません。<a href="https://labs.graphistry.com/graph/graph.html?dataset=PyGraphistry/5R2115KURX&amp;type=vgraph&amp;splashAfter=1468271796&amp;info=true&amp;static=true&amp;contentKey=topclusters&amp;play=0&amp;center=true&amp;menu=false&amp;goLive=false&amp;left=-1.44e+3&amp;right=973&amp;top=-478&amp;bottom=657&amp;poi=true" rel="nofollow" title="" class="ext-link">こちらの図は、サイズが5～30のクラスを表示させたものです</a>。</p><p>以下にその他のクラスタを記載しておきました。</p><p>今回のコードの大部分は、Phytonに特化したものではありません。最初のステップである<a href="#Create-a-table-with-packages">パッケージでテーブルを作成する</a>だけがPhytonに特化したコードです。</p><p>グラフの見栄えが良くなるように、<a href="#Simulation-parameters">シミュレーションパラメータ</a>でパラメータを調整するのに相当な時間を費やしました。各言語のグラフは、異なる特徴を持っているので、恐らく、他の各言語に対しても同様の適合を行う必要があるのでしょう。</p><p>この次にはJavaとScalaの分析を行おうと思います。</p><p>例えば、Pythonの可視化データパッケージを全て一緒にクラスタ化したら面白いのではないでしょうか。</p><p>直観的に、このようなパッケージは似たようなコンテキストで使用されますが、一緒に使用されることはあまりありません。「グラフはNpmiの同時発生行列Mで表現される」と仮定すると、パッケージxとyにおいては、ベクトルxとyの相関性は高くなりますが、M[x][y]は低くなるでしょう。</p><p>あるいは、<code>M^2 /. M</code>にも可能性があるかもしれません。<code>/.</code>は要素ごとの商で、<code>M^2</code>は、グラフ上で”2つのホップ”を大まかに表現しています。</p><p>隣同士の重みだけでも相関性は高いのですが、直接的なエッジは低くなります。</p><p>これは、多くの状況で機能しますが、うまく機能しない場合もあります。以下がその例です。</p><p>従って、django ORMとsqlalchemyは近隣の重み付けが相関されることはありません。私はあまりWeb開発を行わないので、ORMの詳細が間違っている可能性はあります。</p><p>また、<a href="http://arxiv.org/abs/1607.00653" rel="nofollow" title="" class="ext-link">node2ved</a>の実験や、隣接行列の2乗を行う予定です。</p><p>現在、私は同じファイル内でのインポートだけを見ています。”同じリポジトリ内”の関連性を使って構築した同じグラフを見たり、”同じリポジトリ内”と”同じファイル内”の関連性を体系的に比較してみたりするのも面白いと思います。</p><p>PyPIダウンロードとGitHub上の使用量を比較しても面白いでしょう。<a href="https://mail.python.org/pipermail/distutils-sig/2016-May/028986.html" rel="nofollow" title="" class="ext-link">PyPIはBigQueryからもアクセスが可能です</a>。</p><p>以下のコードを、wide-silo-135723:github_clustering.packages_in_file_pyに保存します。</p><p>このSQLにより生成されるテーブルは、2つのフィールドを持ちます。つまり、ファイルを示すidと、1つのファイル内にあるパッケージによる繰り返しのフィールドです。繰り返しのフィールドは、配列に似ています。<a href="http://stackoverflow.com/questions/32020714/what-does-repeated-field-in-google-bigquery-mean" rel="nofollow" title="" class="ext-link">このページに、繰り返しのフィールドのベストな表現を見付けました</a>。</p><p>このステップのみpython特有のものです。</p><p>いくつか<a href="https://github.com/sunzhxjs/JobGIS/blob/master/lib/python2.7/site-packages/pandas/core/format.py" rel="nofollow" title="" class="ext-link">ファイルを無作為に選び</a>、インポートがここまで正しくパースされているか確認してください。</p><p>少なくとも200回出現するパッケージが3,501個あり、そこで頭打ちとなるようです。フィルタリングされたテーブル、wide-silo-135723:github_clustering.packages_in_file_top_pyを作成します。</p><p>結果は、「wide-silo-135723:github_clustering.packages_in_file_top_py」に格納されます。</p><p>では、エッジを生成してテーブル「wide-silo-135723:github_clustering.packages_in_file_edges_py」に保存します。</p><p>上位10個のエッジは以下のSQLで求められます。</p><p>エッジの重みの分位は以下のように求めます。</p><p>最初の実行時には、全てのカウントに基づいてエッジをフィルタリングしました。これは良いアプローチではありませんでした。極端に小さいパッケージ間にある強い関連性よりも、大きなパッケージ2つの間にある弱い関連性の方が、残ってしまう傾向があるためです。</p><p>wide-silo-135723:github_clustering.packages_in_file_nodes_pyを作成します。</p><p>テーブルpackages_in_file_edges_top_pyを作成します。</p><p><a href="https://docs.google.com/spreadsheets/d/1hbQAIyDUigIsEajcpNOXbmldgfLmEqsOE729SPTVpmA/edit?usp=sharing" rel="nofollow" title="" class="ext-link">googleドキュメントに全ての結果を保存しておきました</a>。</p><p>Pandasによって、合計16個のエッジが求められました。</p><p><a id="DataFrame-with-nodes"></a></p><p>dfとedges_dfは、同じ長さになるはずです。つまり、11122と11122です。</p><p>全体のシミュレーションは、安定するまで1分かかります。単純に画像をダウンロードすることは出来ますが、その場合はノードを押すとPyPIを開くといったような、追加の機能はありません。</p><p>次のコードで、javascriptコンソールからシミュレーション後のすべての座標をダウンロードします。</p><p>座標xとyをエッジのデータフレームに結合すると、d3に渡すことができます。</p><p>物理的シミュレーションSimulationは、<a href="https://github.com/d3/d3/blob/master/API.md#forces-d3-force" rel="nofollow" title="" class="ext-link">d3のバージョン4.0で新しく速度ベルレ積分のforce graph</a>を利用しています。Simulationは安定するまで大体1分ほどかかります。このためグラフを表示させる目的の場合は、私は自分のマシン上でシミュレーションを実行した後で、ノードの座標をハードコードしています。</p><p>シミュレーションのコアコンポーネントは、以下の通りです。</p><p>シミュレーションを再実行する場合は、以下の手順が必要です。</p><p><a id="Simulation-parameters"></a></p><p>しばらくシミュレーションパラメータを微調整してみました。かなり密度の高いグラフの”中心”では、グラフのエッジ上でクラスタ間が衝突しています。</p><p>最新のグラフからも分かるように、中心のノードはたまに重複しています。これは、グラフのエッジにおけるノード間の距離が大きいためです。</p><p>出来る限り衝突パラメータを求めさらに増加させてみましたが、それは得策ではありませんでした。潜在的には、中心に向かって重みは増します。しかしそのため、いくつかの価値ある”クラスタ”が、グラフのエッジから中心の大きな”核”に向かって集中していったのです。</p><p>複数の大きなクラスタを分離してプロットすることは、この課題を解決するのに役立ちます。</p><p>興味がありましたら、GitHubのデータを分析した他の記事も読んでみてください。</p>
