<p><a href="http://danluu.com/postmortem-lessons/" rel="nofollow" title="" class="ext-link">Lessons Learned From Reading Postmortems</a> （2015-08-20） by <a href="http://danluu.com/about/" rel="nofollow" title="" class="ext-link">Dan Luu</a></p><p>私はポストモーテム（事後分析）の記録を読むのが大好きです。ポストモーテムを読むと勉強になりますが、大抵の教材的資料とは違って、興味深いストーリーが含まれているのです。相当な時間をかけてGoogleとMicrosoftのポストモーテムを読みました。大きな障害を招く最大の原因について、私は（まだ）きちんと分析していませんが、何度も繰り返し目にするポストモーテムのパターンがいくつかあります。</p><p>適切なエラーハンドリングのコードを書くのは難しいものです。エラーハンドリングのコードに含まれるバグは、<em>大きな</em>問題を引き起こす主な原因となっています。つまり、エラーによってバグのあるエラーハンドリングのコードが実行されるということは、単に個々のエラーが重なるだけという事態にはとどまらないのです。障害が重なって重大なシステム停止につながることはよくあります。それはある意味明らかなことで、エラーハンドリングは一般的に難しいものと考えられていますが、その話をすると相手からこう言われます。「深刻なポストモーテムのほとんどは、不適切なエラーハンドリングで障害が重なり、その対応にもミスが続いたため書かれている。そんなのはいかにも明らかなことだ」と。ただ、”明らかな”とは言っても、エラーハンドリングが適切か確認するためにテストや静的解析が十分に行われるほど、重大性が認識されているわけではありません。</p><p>このテーマを詳しく扱っているのが、Ding Yuanらの優れた論文と講演<a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/yuan" rel="nofollow" title="" class="ext-link">「Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems」</a>です。この論文はまさにタイトルどおりの内容です。著者は、クラスタ全体を破壊したりデータの破損を引き起こしたりする状態のことを重大な障害と定義し、Cassandra、HBase、HDFS、MapReduce、Redisで見られた約200個のバグを調べて、48件の重大な障害を特定しました。その原因を調査した結果、実に92％は不適切なエラーハンドリングが原因であったことが分かったのです。</p><p><img class="center" src="http://danluu.com/images/postmortem-lessons/osdi_error.png" width="530" height="142" title="Graphic of previous paragraph"><br>
<em>注釈：<br>
Initial faults：最初の障害（例：ハードウェア障害、バグ、設定ミス）<br>
Incorrect handling of errors explicitly signaled in s.w.：ソフトウェアで明示されるエラーに対する不適切なエラーハンドリング<br>
Latent error：潜在的なエラー<br>
Trivial mistakes：軽微なミス<br>
System-specific：システム特有のもの<br>
Errors ignored：エラーの無視<br>
Abort in over-caught exceptions：過大な例外処理による強制終了<br>
“TODO” in handler：ハンドラ内の”TODO”<br>
Easily detectable：容易に検出可能なもの<br>
Complex bugs：複合的なバグ<br>
Catastrophic failures：重大な障害</em></p><p>更に内訳を見ると、バグの25％は単純にエラーを無視していたこと、8％は誤った例外処理、2％は不完全な”TODO”が原因でした。そして23％は「容易に検出可能なもの」、つまり「致命的でないエラーに対するエラーハンドリングのロジックに誤りがあり、開発者が命令網羅のテストやもっと慎重なコードレビューを行っていれば発見できたバグ」でした。ちなみに、私がGoスタイルのエラーハンドリングも嫌いではない理由の1つがこれです。エラーチェックコードのせいでメインコードの流れが分かりにくくなるという不満の声も多いようですが。エラーに強いシステムを構築したいなら、エラーチェックコードこそがメインコードです！</p><p><a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf" rel="nofollow" title="" class="ext-link">この論文</a>には、ここで書ききれない貴重な情報がたくさん含まれています。例えば、<a href="https://aphyr.com/tags/jepsen" rel="nofollow" title="" class="ext-link">Jepsen</a>が大変有効な理由が説明されています（重大な障害の98％は3ノードクラスタで再現可能）。また、非決定性の障害の割合（論文のサンプルでは26％）やその原因、障害を引き起こしがちなエラーを検出できる静的解析ツールの作成についても述べられています。</p><p>コードではなく設定のバグは、重大なシステム停止の原因として私が最もよく見てきたものです。公開されているポストモーテムで大規模なシステム停止について調べてみたところ、約50％は設定の変更が原因でした。公開されているポストモーテムでシステム停止の全体的な状況を把握することはできませんが、ポストモーテムのデータベースからランダムに抽出したデータを見ても、設定変更は重大なシステム停止の原因として圧倒的割合を占めていることが分かります。エラーハンドリングの場合と同様に、設定変更がリスクを伴うのは明らかだという声もよく聞きますが、多くの企業がコード変更時と同様に設定変更のテストやステージングを行うほどには、重大性が認識されていないのです。</p><p>非常に緊急なケースを除いて、リスクを伴うコード変更は、企業全体のサービス停止につながる恐れがあるため、全てのマシンに一斉配信されることは基本的にありません。ですがどの企業も、軽微に見える設定変更でも企業全体のサービス停止を引き起こす場合があると、苦い経験から学ぶ必要がありそうです。例えば、2014年11月にAzureのサービスが停止したことはよく知られていますが、これも設定変更が原因でした。ここでMicrosoftを責めようとしているわけではありません。なぜなら、大手の競合サービスも似たような原因で停止したことがあり、同様の事態が再び発生するリスクを減らすため、いずれも適切な手順を踏むようになったからです。</p><p>クラウドサービスの大企業を責めようとしているわけでもありません。むしろ、多くのスタートアップや巨額の資金を有するスタートアップと比べても、そうした大企業のサービスの方が望ましい状況にあります。私の知る限り、”ユニコーン”と呼ばれるスタートアップの多くは、リスクを伴う設定変更を検証できる適切なテスト環境やステージング環境を持っていません。その理由は分かっていて、設定変更が検証できるほど十分に本番環境を反映したQA環境を用意するのは難しいことが多く、シートベルトをしないで車を運転するのと同様に、ほとんどの場合はそれで何の問題も起きないからです。もし運転する前に自分でシートベルトを作らなければならないとしたら、私もシートベルトをして運転することはなくなるかもしれません。とはいっても、シートベルトなしでの運転が設定変更と同じぐらい危険なら、シートベルトを作ることを考えるかもしれません。</p><p><a href="http://research.microsoft.com/en-us/um/people/gray/papers/TandemTR85.7_WhyDoComputersStop.pdf" rel="nofollow" title="" class="ext-link">かつて1985年にJim Gray</a>は「オペレータの操作、システム設定、そしてシステムメンテナンスが障害の主な原因であり、42％を占める」と報告しており、それ以降、類似の結果を示す様々な論文が発表されています。例えば、<a href="http://asrabkin.bitbucket.org/papers/software12.pdf" rel="nofollow" title="" class="ext-link">RabkinとKatz</a>は、障害の原因として以下を報告しています。</p><p><img class="center" src="http://danluu.com/images/postmortem-lessons/rabkin_katz.png" width="303" height="234" title="Causes in decreasing order: misconfig, bug, operational, system, user, install, hardware"><br>
<em>注釈：<br>
misconfiguration：設定ミス<br>
bug：バグ<br>
operational：操作<br>
system problem：システムの問題<br>
install：インストール<br>
user bug：ユーザによるバグ<br>
hardware problem：ハードウェアの問題</em></p><p>基本的に、マシンのあらゆるパーツは故障する可能性があります。多くのコンポーネントも、宣伝されているよりはるかに高い確率でデータの破損を引き起こすかもしれません。例えば、<a href="http://research.google.com/pubs/pub35162.html" rel="nofollow" title="" class="ext-link">Schroeder、Pinheiro、Weber</a>は、DRAMのエラー率は伝えられていた数値よりも10倍以上高かったと報告しています。サイレントエラーの数は膨大なもので、実際にGoogleでもECC RAMに切り替える前は、そのことが問題になっていました。ハードウェアがエラーを検出できる場合でも、問題が起きる可能性があります。例えば、<a href="http://noahdavids.org/self_published/CRC_and_checksum.html" rel="nofollow" title="" class="ext-link">データをエラーから保護するためのイーサネットのチェックサムも安心できるものではなく</a>、私自身、不正なパケットが有効なパケットとして通過するのを見たことがあります。もっと大きなレベルの話でいえば、ハードウェア検査でデータの破損がチェックできると思っていても、検出されていなかったエラーが想像以上の頻度で発生することもあり得ます。</p><p>コンポーネントに異常が発生した時のフェイルオーバーにも、障害が起きる可能性があります。<a href="https://aws.amazon.com/message/67457/" rel="nofollow" title="" class="ext-link">こちらのAWSの障害は典型的な事例です</a>。発電機の電力のフェイルオーバー処理は定期的にテストされるよう、妥当と思われる対策がとられていたにもかかわらず、暴風で停電になったところバックアップの発電機が負荷時にきちんと電力を供給できず、AWS US Eastリージョンの相当な部分のサービスが停止したのです。</p><p>以下の内容はヒューマンエラーではなく、プロセスエラーの話だと言った方がいいでしょう。というのも私は、誤って大惨事を引き起こす可能性がある状況に人間を置くこと自体が、プロセス上の問題だと思っているからです。一般的に認識されていることですが、大規模なシステムを運用する場合、ハードウェアの故障に耐え得るシステムにする必要があります。マシンの故障頻度を計算してみると、ハードウェアの故障に弱いシステムは間違いなく信頼性が低いことが分かります。そして、マシンよりも更に多くのエラーを引き起こしているのが、我々人間です。誤解がないように言っておきますが、私は人間嫌いではありませんし、人間の親友もいますよ。でも、大規模障害を起こし得る環境にずっと置かれた人間は、いつか大惨事を起こすものです。それにもかかわらず、以下のようなケースが後を絶ちません。</p><p>ポストモーテムの中には、「作業リスクが高いため、某ハイリスク用手順を採用した」というくだりで始まるものが大量にあります。こういったものを見ると、ヒューマンリスクを軽減するために人間が講じる特別な措置こそが、オペレーションシステムの問題点のように感じられます。いくつかの一般的な手順書には、複数の人間に作業の監視や確認をさせる、大規模障害に備えてシステムオペレータを待機させる、という内容が含まれています。もちろん合理的な内容ですし、これによって、ある程度はリスクを低減できます。しかし私が読んだポストモーテムには、自動化をしていればリスクを大幅に削減できた、あるいは完全に排除できたはずだ、というものが多くありました。一連の指示を完璧に実行しなくてはいけない人間がミスを犯し、その結果システムが停止した事例は多くあります。このミスなく処理を実行するということは、まさにプログラムの得意分野です！　一方、人間が手作業でエラーを確認しなければならないケースもあります。そのような場合、自動化が難しいこともあるので、人間とプログラムのどちらが勝っているかは明確ではありません（プログラムが見逃したエラーケースを、人間が発見することもありますから）。それでも、私が見てきたケースにおいては、ほぼ自動化する方に軍配が上がっています。</p><p><img class="center" src="http://danluu.com/images/postmortem-lessons/idc2013_downtime.png" title="Causes in decreasing order: human error, system failure, out of IPs, natural disaster"><br>
<em>注釈：<br>
Problems in the Datacenter：データセンターにおける不具合<br>
Downtime due to human error：ヒューマンエラーによるダウンタイム<br>
Downtime due to system failure：システム障害によるダウンタイム<br>
Run out of IP addresses：IPアドレスの枯渇<br>
Downtime due to natural disasters：自然災害によるダウンタイム<br>
Security breaches：セキュリティ違反<br>
Regulatory or compliance issues：規定や順守の問題<br>
Insufficient bandwidth：バンド幅不足<br>
Latency issues：潜在的な問題<br>
% of respondents：全回答者数に対する割合<br>
IDC’s Enterprise Datacenter Survey, December 2013(N=410)：<br>
2013年実施のIDCによるデータセンターの調査結果（回答件数 410）</em></p><p>IDCの調査では、データセンターで発生する問題において、一番厄介な原因はヒューマンエラーだという回答結果が出ています。</p><p>私は公開されたポストモーテムに載っているヒューマンエラーの件数が、実際よりもどれだけ少ないかという点に関心を持っています。私の知る限り、GoogleとMicrosoftは共に、他の企業に比べて、かなり自動化が進んでいます。なので、この2社のポストモーテム用のデータベースの中身と、他社が公開しているポストモーテムとでは、前者の方がシステム停止の原因におけるヒューマンエラーの割合がずっと少ないだろうと推測していました。ところが実際は逆でした。私が推測するに、障害の根本原因が、リスクの高い手作業によるヒューマンエラーであった場合、どの企業も公開用のポストモーテムを書きたがらないのだと思います。そして彼らは、「技術的改善を行った結果、人的要因による軽微な問題の割合が増加した」という感じで、もっともらしい理由を持ち出すのです。これは航空業界などでは、あり得ることでしょう。でも多くの企業が、数えきれないほどの手作業を行っているIT業界では、通用しない話です。とはいえ、多くの企業のポストモーテムのデータベースにアクセスできない限り、断言はできません。もしこの分析（や他の分析）に協力していただける企業があれば（可能な限り匿名にしますので）、ご連絡ください。</p><p>適切にモニタリングできていないことだけが原因で、問題が発生することはあり得ません。しかし、それが重大な要因になるケースは多くあります。ヒューマンエラーと同様に、モニタリングの問題もポストモーテム上では、実際の件数より少なく報告されているように思います。他社で働いている人に、それぞれの企業で起きた最悪の障害ついて尋ねたところ、原因の大半は適切な警告設定ができていないことでした。つまり公開用のポストモーテムを書かざるを得ない深刻な障害から、幾度となく人々を救ってきたのは、システムオペレータたちの勇敢な行動なのです。しかし彼らの行為は、拡張性のあるソリューションではありません。</p><p>時には、わずかなコーディングのバグが、大規模障害を引き起こすこともあるでしょう。しかし、ほとんどの場合、原因は一目で分かるプロセス上の問題です。例えば、障害全般に関するエスカレーションパスが明確になっていない、というような問題です。これにより、無関係なチームが半日もデバッグをしている、もしくはオンコールのバックアップ体制ができていないという状況が生まれます。そして誰かが気付くまで、何時間もシステム上でデータ損失やデータ破壊が発生するという事態に陥ります。（もちろん）オンコールで呼び出された人々は、事態が悪化していることに気付いていません。</p><p><a href="https://ja.wikipedia.org/wiki/2003%E5%B9%B4%E5%8C%97%E3%82%A2%E3%83%A1%E3%83%AA%E3%82%AB%E5%A4%A7%E5%81%9C%E9%9B%BB" rel="nofollow" title="" class="ext-link">2003年の北アメリカ大停電</a>は、この典型的な例です。これは小規模なシステム停止か、もっと言えば若干のサービス品質の低下で済むはずのことでした。しかし警告を何度も無視したことが（主な）原因で、史上最悪レベルの大停電が発生してしまいました。</p><p>本来は、そろそろ結論を書くべきなのでしょう。でも結論を書いて、読者に行動を呼びかける前に、私はどうしても本格的なデータ分析をしておきたいのです。私は一体何を求めているのでしょう？　主にどの分野で、頻繁に起こるエラーについて検討すべきなのでしょう？　自問しているのではありませんよ。私は、これから検討すべき他分野について、心から皆さんの意見を聞きたいのです。<a href="https://twitter.com/danluu" rel="nofollow" title="" class="ext-link">よければTwitterで気軽に連絡してください</a>。<a href="https://github.com/danluu/post-mortems" rel="nofollow" title="" class="ext-link">GitHub上で、公開されたポストモーテム</a>も集めています。</p><p>そして、いつか時間を見つけて、徹底的に分析をしようと考えています。でも、すでに多くのポストモーテムを読んでいるので、更に膨大な数の資料を読んで分析をしなくても、今までとはちょっと違った分析ができる気がします。これからはコードをレビューする時に、エラーやエラーハンドリングのコードにより多くの時間を割くので、あまり楽しい時間を過ごせなくなるでしょう。更に、”明らかな”プロセス上のバグをチェックして、それを修正するよう人を説得する作業に、より時間を取られることになりそうです。</p><p>ここで、故障モードに関して私が不思議に感じていることを1つお話ししましょう。それは、自分が気付いたことを誰かに話すと、少なくとも1人からは、私が見つけたプロセス上の問題はどれも明らかだと言われるということです。でも、その”明らかな”問題が、いまだに多くの障害を引き起こしています。また、ある人からは「君の指摘は実に”明らか”だ。僕の会社ではちょうど、君と話したことが原因でシステムが全面的に停止して、数十億ドル単位の損害が出た」と言われたこともあります。つまり、明らかだからと言って、それが実施されているとは限らないのです。</p><p>Richard Cookの<a href="http://web.mit.edu/2.75/resources/random/How%20Complex%20Systems%20Fail.pdf" rel="nofollow" title="" class="ext-link">「How Complex Systems Fail」</a>という記事では、より一般的なアプローチを取っています。この記事から着想を得た<a href="http://www.amazon.com/gp/product/0312430000/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0312430000&amp;linkCode=as2&amp;tag=abroaview-20&amp;linkId=2VKSNUT3M4W7KUMR" rel="nofollow" title="" class="ext-link">『The Checklist Manifesto』</a>という本もあります。</p><p>AllspawとRobbinsの<a href="http://www.amazon.com/gp/product/1449377440/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449377440&amp;linkCode=as2&amp;tag=abroaview-20&amp;linkId=U7MG5A2J6OLQG627" rel="nofollow" title="" class="ext-link">『Web Operations: Keeping the Data on Time』</a>は、Webアプリの分野でこのテーマを扱っています。Allspawの記事でも、<a href="http://www.kitchensoap.com/2011/04/07/resilience-engineering-part-i/" rel="nofollow" title="" class="ext-link">他の分野の関連資料を紹介しています</a>。</p><p>私が慣れ親しんでいる分野に近いところでは、長きにわたり障害の原因が調査されています。以下に、主要なものを挙げましょう。<a href="http://www.hpl.hp.com/techreports/tandem/TR-85.7.pdf" rel="nofollow" title="" class="ext-link">Jim Grayの「Why Do Computers Stop and What Can Be Done About It?」</a>（1985）、<a href="https://www.usenix.org/legacy/event/usits03/tech/full_papers/oppenheimer/oppenheimer_html/" rel="nofollow" title="" class="ext-link">Oppenheimer らの「Why Do Internet Services Fail, and What Can Be Done About It?」</a>（2003）、<a href="http://danluu.com/postmortem-lessons/Understanding%20and%20Dealing%20with%20Operator%20Mistakes%20in%20Internet%20Services" rel="nofollow" title="" class="ext-link">Nagarajaらの「Understanding and Dealing with Operator Mistakes in Internet Services」</a>（2004）、<a href="http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024" rel="nofollow" title="" class="ext-link">Barrosoらの「The Datacenter as a Computer」</a>（2009）の一部、<a href="http://asrabkin.bitbucket.org/papers/software12.pdf" rel="nofollow" title="" class="ext-link">RabkinとKatzの「How Hadoop Clusters Break」</a>（2013）、<a href="http://cseweb.ucsd.edu/~tixu/papers/sosp13.pdf" rel="nofollow" title="" class="ext-link">Xuらの「Do Not Blame Users for Misconfigurations」</a></p><p>航空機においても、その信頼性が理解されるまでには長い歴史がありました。<a href="https://en.wikipedia.org/wiki/Reliability-centered_maintenance" rel="nofollow" title="" class="ext-link">何十年にもわたってプロセスがどのように変化を遂げたのかという話</a>は、この教訓を一般化する方法は置いておくとして、興味をそそられる内容です。</p><p>余談ですが、アップタイムと信頼性を向上させるのが、どれほど困難であったかを知るのも面白いかと思います。1974年に<a href="http://web.eecs.umich.edu/~prabal/teaching/eecs582-w13/readings/ritchie74unix.pdf" rel="nofollow" title="" class="ext-link">RitchieとThompson</a>は、アップタイムが98％で、”わずか4万ドル（当時の為替レートで約1,000万円）”のシステムについて論文を書いています。更にその10年後にはJim Grayが、99.6％のアップタイムを妥当なベンチマークとして用いました。現在、さらにアップタイムを改善することは可能ですが、それにはシステムを相当複雑にする必要があります。</p><p>この記事の草案に対して意見をくれたLeah Hanson、Anonymous、Marek Majkowski、Nat Welch、Julia Hansbroughに深く感謝します。匿名の方の中で、名前を出してもいいという方がいれば、zulipでご連絡ください。念のため書きますが、該当するのはGoogleの方3名と、Cloudflareの方1名、そしてコメントをくれた匿名の読者が1名です。なお、この記事に関するコメントや批評はいつでも受け付けています。特に、小規模な企業で働いている方からのご意見をお待ちしています。改めて、ご協力いただいた皆様に感謝します。</p><p>最後に、本件を引き受け、記事の誤りを指摘してくれたgwernとDan Reifに心から感謝いたします。</p>
