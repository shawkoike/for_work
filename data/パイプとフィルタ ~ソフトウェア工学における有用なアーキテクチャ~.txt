<p><a href="http://blog.petersobot.com/pipes-and-filters" rel="nofollow" title="" class="ext-link">Pipes and Filters</a> by <a href="https://twitter.com/psobot" rel="nofollow" title="" class="ext-link">Peter Sobot</a></p><p><strong>パイプライン</strong>は、最近のソフトウェアエンジニアリングにおいて、非常に便利な（そして驚くほど活用されていない）アーキテクチャパターンです。ソフトウェアでデータの流れを制御するためにパイプとフィルタを用いる考え方は、最初のUNIXシェルが作られた1970年代からあります。もしターミナルエミュレータでパイプ”<code>|</code>”を使ったことがあるなら、”パイプとフィルタ”を活用できていることになります。以下の例を見てみましょう。</p><p>このパイプラインを<code>bash</code>で実行すると、LinuxのマスコットであるペンギンのTuxのASCIIアートが返され、辞書の中から”purple”を含む一番長い単語を言います。</p><p>実は、この数行のコードが実行されると、かなり多くのことが行われます。Enterキーを押した瞬間、以下のステップが走るのです。</p><p>このタスクにパイプラインを使用するのは、非常に簡単なように思えます。ここで行われている全てのタスクはデータを<em>フィルタリング</em>しています。元のデータセットが各ステップで変更されています。各プロセスはそれぞれのはたらきをしており、<a href="http://ja.wikipedia.org/wiki/UNIX%E5%93%B2%E5%AD%A6" rel="nofollow" title="" class="ext-link">UNIX哲学</a>の教えを的確になぞらえています。どのプロセスも簡単に他のものと入れ替えることができるでしょう。</p><p>bashが自動的に行うパイプラインの機能を可視化すると、以下のようになります。</p><p><img src="http://petersobot.com/blog/images/body/pipeline_diagram.png" alt="Thank you, bash!"></p><p>パイプラインのもう1つの利点は、<strong>本質的にパフォーマンスが優れている</strong>点です。先ほど実行したコマンドの修正バージョンを使い、パイプライン中の各フィルタコンポーネントのメモリとCPUの使用量を見てみましょう。</p><p>（<em>余談ですが</em>、私は自分のシェルに内蔵されている<code>time</code>コマンドの使用を避けるため、ここでは<code>/usr/bin/time</code>を呼び出しています。内蔵の<code>time</code>コマンドは詳しい統計を表示する<code>-l</code>オプションをサポートしていないのです。もしあなたがLinuxを使用しているのであれば、<code>-v</code>オプションを使うといいでしょう。同じように統計を表示します。stdinがパイプを指した状態のまま、<code>2&gt; (cat, grep他).time.txt</code>の文で、<code>stderr</code>をファイルにリダイレクトします）</p><p>このコマンドを実行し、最大常駐セットサイズと自発的及び非自発的コンテキストスイッチの回数を確認すると、重要なことがいくつか見えてきます。</p><p>
</p>
<p class="bleed_image"><img src="http://petersobot.com/blog/images/body/pipeline_graphs.png" alt="Memory usage, thanks to time -l." class="bleed"></p><p>この例に挙げているパイプラインは大変シンプルですが、これらのプロセスのどれか1つでも複雑な計算をしていたら、複数のプロセッサ上で<em>自動的に並列処理</em>することもできます。パイプラインってすごいでしょう？　</p><p>確かにパイプラインは素晴らしいです。メモリやCPU時間を効率的に使用し、データのアベイラビリティに基づいて黙って自動的に実行のスケジューリングもします。また作成するのも非常に簡単です。なのに、できることならいつでも使いたいと思わないのはなぜでしょう？　</p><p>答えは、<strong>エラーハンドリング</strong>のせいです。パイプラインのどこか一部で間違いが起きたら、パイプライン全体が完全に機能しなくなります。</p><p>私がPythonで書いたコマンドを追加して、このパイプラインを試してみましょう。<code>fail.py</code>は標準入力を標準出力にそのまま表示させますが、50パーセントの確率で行を読む前にクラッシュします。</p><p>fail.pyのソース：</p><p>この場合、何が起こるでしょうか？　<code>fail.py</code>が入力を読んでいる途中で失敗すると、<code>stdin</code>と<code>stdout</code>のパイプは閉じます。これによって<strong>パイプラインが半分に切断されます</strong>。失敗したプロセスからさらに先へ行くと各プロセスがどうなるのかを見ていきましょう。</p><p>その結果は？</p><p>Tuxは先ほどのように”unimpurpled”と言っていません。間違っていますね。コマンドパイプラインの出力が<strong>正しくないのです</strong>。フィルタの1つがクラッシュしても反応が戻ってきて、その後のパイプラインの全てのステップが、尚も予想通りに実行されました。</p><p>さらに悪いことに、パイプラインのリターンコードを確認すると以下のようになります。</p><p>bashは親切にもパイプラインは<em>正常に実行された</em>と報告しています。bashはパイプラインの<em>最後の</em>プロセスの終了ステータスのみ報告するためです。パイプラインの中でより早く問題を見つけ出す唯一の方法は、比較的知られていないbashの$PIPESTATUS変数を確認することです。</p><p>この配列が、前の連結したパイプにおけるあらゆるプロセスのリターンコードを保存し、先ほどクラッシュしたフィルタはここでしか確認することができません。</p><p>これは従来のUNIXのパイプを使う上で大きな欠点の1つです。パイプラインがまだデータを処理している間にエラーを検知するには、何らかの形で失敗した処理を見つけ、他のプロセスにメッセージを送る<strong>帯域外の</strong>シグナルが必要となります（1つのフィルタに対し複数の入力パイプがあればこれは簡単ですが、UNIXのパイプだけを使用していたら難しくなります）。</p><p>良い感じです。ASCIIアートでペンギンを描くためのメモリ効率の良いパイプラインを作れます。でもこんな質問が聞こえてきそうです。</p><p>いい質問です。データを<strong>非常に小さな塊</strong>に分けられる場合や<strong>処理を徐々に終わらせられる</strong>場合は、パイプを使うと非常に便利です。例をいくつか挙げてみましょう。</p><p>例えば、とても高品質な音声フォーマットである.flacのファイルでいっぱいのフォルダがあるとしましょう。これらのファイルを自分のMP3プレイヤーに入れたいのですが、そのMP3プレイヤーは.flacをサポートしていません。そして、どういうわけかコンピュータは10MBのRAMしか使えないのです。ここでパイプラインを使ってみましょう。</p><p>このコマンドは今まで見てきたものよりも少し複雑ですね。まず、whileループの条件式にreadコマンドがある、ビルトインのbashコンストラクトを使っています。この条件式では、入力された各行を読み込み（lsの結果をパイプで送っています）、1行ごとに内部のコードを1回実行します。そして、内部のループでsongをデコードするためのflacを呼び出し、songをMP3にエンコードするためのlameを呼び出します。</p><p>このパイプラインはどのくらいメモリ効率が良いのでしょうか？　このコードを115MBのflacファイルでいっぱいのフォルダに対して実行してみると、使用したメモリはたったの<strong>1.3MB</strong>でした。</p><p>では、あるWebアプリケーションを利用するために、自分のお気に入りのWebフレームワークを使っているとしましょう。ユーザがそのWebアプリケーションにフォームをサブミットする場合、バックエンドでは非常にコストの高いプロセスを実行しなければなりません。フォームデータに対してはサニタイジングを行い、外部のAPIを使って検証し、PDFファイルとして保存する必要があります。これら全てのプロセスは重すぎるので、Webサーバでは実行できません（<em>その通り、この例は少し不自然ですが、今まで私が見てきたユースケースから大きく外れてはいません</em>）。ではここで、パイプラインを使ってみましょう。</p><p>ユーザがmy_webserverにフォームをサブミットするとすぐ、stdoutにJSONの文字列を送ります。こんな感じの文字列です。</p><p>パイプラインにおける次のプロセスのline_sanitizerでは、各行に対して以下のコードを実行します。</p><p>その次のプロセスではフォームから入力された組織が存在するかどうかを検証します。</p><p>そして最後のプロセスでは、残った文字列をPDFファイルに書き込みます。</p><p>これでお分かりかと思いますが、たった数行のコードで大量のデータを処理することが可能な、非常にメモリ効率の良い<em>非同期の</em>パイプラインができました。</p><p>でも、この例では疑問が1つ残ります。もしエラーが発生したら、どう処理するのか？　という疑問です。Eric IdleがこのWebサイトにフォームをサブミットしたとして、サイトがそのフォームを受け付けなかったら、どのようにエラーが通知されるのでしょうか？　とてもUNIXっぽいやり方ですが、以下のように<strong>名前付きパイプ</strong>を作ってエラー処理を行うという方法があります。</p><p>どんなプロセスでもカスタマイズされたerrorという名前のパイプから読み込みが可能で、パイプラインの各プロセスはエラーになる入力値をパイプに出力します。エラーについての電子メールを送信するリーダを、そのパイプにつけることも可能です。</p><p>そして、line_sanitizerが文字列に対してエラーを返す場合は、このように動きます。</p><p>このパイプラインは、通常とは少し違いますね（赤線がstderrの出力を表します）。</p><p>
</p>
<p><img src="http://petersobot.com/blog/images/body/pipeline_stderr.png" alt="Red lines are stderr." class="no-resize"></p><p>UNIXのパイプは便利ですが、もちろん欠点もあります。全てのソフトウェアがUNIXのパイプの枠組みを直接使えるわけではなく、最新式のWebトラフィックで見られるスループットにUNIXのパイプがうまく合うわけではないのです。しかし、違う方法が使えます。</p><p>マシン間で基本的なFIFOキューを使うことを可能にした、最新式の”ワークキュー”ソフトウェアパッケージが、ここ数年で次々と作られてきました。<a href="http://kr.github.io/beanstalkd/" rel="nofollow" title="" class="ext-link">beanstalkd</a>や<a href="http://www.celeryproject.org/" rel="nofollow" title="" class="ext-link">celery</a>といったパッケージは、プロセス間で任意のワークキューを作成できます。これらのパッケージは従来のUNIXのパイプを簡単にシミュレート可能で、多くのマシンに分散されているという大きな利点もあるのです。一方で、非同期のタスク処理に極めて適しており、メッセージを送信しようとしているプロセスがキューによってブロックされることはありませんが、UNIXのパイプではできた暗黙の実行制御ができません。サービスは、コルーチンというよりも、メッセージングシステムやワークキューとして動いています。</p><p>そこで、同期性の欠如や分散型パイプラインシステムに対処するため、Redisベースで信頼性のある分散型同期パイプラインのライブラリを自分で作り、<a href="https://github.com/psobot/pressure" rel="nofollow" title="" class="ext-link"><strong>pressure</strong></a>と名付けてみました。<strong>pressure</strong>を使うと異なるプロセス間でパイプをセットアップすることが可能ですが、パイプのバッファを<strong>保つ</strong>機能と<strong>複数のマシン間で</strong>使える機能が加えられています。安定したメッセージブローカとしてRedisを使うことによって、このライブラリは全ての内部プロセスのコミュニケーションを処理し、<strong>OSやプラットフォームに依存しない</strong>ものになりました（Redisには他にも、信頼性やレプリケーションといった数多くの役立つ機能があります）。</p><p><strong>pressure</strong>のリファレンス実装はPythonにあり、まだ初期段階です。性能を見るため、この投稿の初めから使ってきたパイプラインの例を、<strong>pressure</strong>のUNIXのパイプアダプタを使うことでレプリケートしてみましょう（putやgetは、従来のUNIXのパイプとRedisで保たれる分散型<strong>pressure</strong>キューの間のブリッジとして動く、Cプログラムのコードです）。</p><p>最初の注意点は、このメソッドにおいては何メガバイトものファイルをフィルタリングしているので、<strong>極めて</strong>重い処理になるということです。最終的には235,912メッセージをRedisで送ることになり、処理に4分ほどかかります（catのすぐ後、かつRedisにデータを送る前にgrepを実行する場合は、この1,200倍よりも速い処理速度となります）。どうであれ、最終的には、求めている正しい答えが得られます。</p><p>しかし、Redisのコマンドラインツールであるredis-cliを実行してみると、妙なプロパティが見られる場合があります。大量のデータ入力をしているにもかかわらず、パイプラインでは非常に少ないメモリしか使われていないことになっているのです。</p><p><strong>pressure</strong>はまだアルファ版であり、広範囲に渡る製品デプロイメントには間違いなく<strong>時期尚早</strong>です。とは言っても、ぜひ<a href="https://github.com/psobot/pressure" rel="nofollow" title="" class="ext-link">使ってみて</a>ください。</p><p>ソフトウェアにおいてパイプラインは、リソースの使用量を低減させる手段になり得る、非常に便利なツールです。パイプラインは必要時に演算をするためだけに<strong>コルーチン</strong>として動き、リアルタイムのオーディオ処理のような特定のアプリケーションにとっては極めて重要なツールになります。<a href="https://github.com/psobot/pressure" rel="nofollow" title="" class="ext-link"><strong>pressure</strong></a>は複数のマシンで信頼性を持ってパイプラインを簡単に使う方法を提供します。ソフトウェアアーキテクチャの問題を解決するためにパイプとフィルタの枠組みを使い、これがどんなに簡単で効果的なものかを体験してみてください。</p>
