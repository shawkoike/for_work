Profiling CSS for fun and profit （2012-1-4） by Juriy Zaytsev私はここ最近、いわゆるシングルページWebアプリケーションのパフォーマンスの最適化に取り組んでいます。そのアプリケーションは非常に動的かつインタラクティブで、新しいCSS3の利点が詰め込まれたものです。単に角丸やグラデーションの効果にとどまらず、影やグラデーション、要素の変形がふんだんに使われており、加えてtransition効果（時間的変化）や多彩な半透明色、疑似要素をベースにしたCSSの巧妙なトリック、それに実験的なCSSの特徴がちりばめられています。分析する際には、Javascript/DOM側のボトルネックだけではなく、CSSの領域にも踏み込んでみました。上に挙げたすばらしいUIの要素が、パフォーマンスにどのような影響を及ぼしているかを見たかったからです。このアプリケーションのベースにあるJavascriptのロジックは以前（表面的な装飾のないバージョン）からさほど変わってはいませんが、前のバージョンでは動作がとてもスムーズでした。それに比べると、新しいバージョンでのスクロールやUIアニメーションの動きは、それがあるべき姿からはかけ離れているように思えます。これはスタイリングのせいなのでしょうか？幸いにも、少し前にOperaの開発者から実験的な「Style profiler」が公開されました（その後すぐにWebKitのチケット＋パッチも出ました）。このプロファイラを使えば、CSSセレクタのマッチング、文書のリフロー（レイアウトの再計算）、リペイント（再描画）、更には文書やCSSのパース（構文解析）時間などが調べられます。完璧ですね。
少し気掛かりなのは1種類の環境でプロファイリングし、1つのエンジン（特に1種類のブラウザでのみ使われるエンジン）に従って最適化するということですが、まあ、とにかくものは試しです。詰まるところ問題のあるスタイルやルールといったものは、どのエンジン、ブラウザでもある程度は共通しているでしょうし、いずれにしても使えるものと言えば、ほぼこれしかありませんからね。似たようなもので唯一あった他のツールとしては、WebKitディベロッパツールの「Timeline」タブがあります。ただし使い勝手はさほどよくありません。リフロー／リペイント／セレクタマッチングのトータル時間も示せないですし、情報を抽出するにはJSON形式でデータをエクスポートしてから手動でパースしなくてはなりません（これについては後ほど触れます）。以下では、これら2つ、WebKitとOpera両方のツールによるプロファイリングを通じて得た私の所見の一部を挙げていきたいと思います。長くて読むのがしんどい場合は、最後のまとめの項をご覧ください。これは別段、新しい発見というわけでもなく、PageSpeed Insightsはこのことに注意するよう常に呼びかけを行ってきました。ただ、私自身これほどまでにレンダリング時間に影響するとは思っていなかったので、ある意味驚きを隠せません。私の場合は、未使用のCSSルールを取り除いただけで、セレクタマッチングの時間を（Operaのプロファイラによると）～200-300ミリ秒カットできましたし、レイアウトや描画の時間も同様に短縮されました。この最適化の大きな欠点は柔軟性が失われるということでしょうか。マークアップを変える場合、CSSの変更も必要になるため、将来的にボタンの実装を別のものに単純に置き換えることはできなくなります。そのため、私としては上記の置き換えに多少の疑問も持っています。パフォーマンスのために有益な抽象化を排除する形になりますからね。これについては、私たちが心配しなくてもエンジンがそうしたセレクタを最適化できるようになるまでは、ご自身の状況に応じてちょうどいい妥協点を見つけるしかないでしょう。これはprototype.jsのArray#pluckとArray#uniq拡張機能に依存しています。（ES5とセレクタAPIに依存した）プレーンなバージョンの場合、次のようにすればいいでしょう。こちらのテストページをご覧ください。そこに400個のボタンを含む文書を作成しました。
設定するスタイルの種類によって、レンダリングのパフォーマンスがどのような影響を受けるか（プロファイラでの再描画時間がどのように変化するか）を検証しました。基本となるボタンには以下のスタイルのみを適用しています：
この基本のスタイルにボタン、400個を再描画するのに掛かった時間は、合計でわずか6ミリ秒でした（Operaを使用した場合）。ここから少しずつスタイルを加えていき、それぞれの場合でリペイントにかかる時間の変化を記録しました。最終的に加えられたスタイルは以下のとおりで、リペイントに177ミリ秒掛かりました。標準スタイルと比べると、何と30倍近い時間がかかっています。
それぞれのプロパティごとの分析結果は以下のとおりです： {"dataSourceUrl":"//docs.google.com/spreadsheet/tq?key=0Aqj_mVmuz3Y8dEg0S2pmOW0xbll3OUhkcFN6TFJaaVE&#038;transpose=0&#038;headers=0&#038;range=A2%3AB9&#038;gid=0&#038;pub=1","options":{"height":371,"width":600,"hAxis":{"viewWindowMode":"pretty","viewWindow":{}},"hasLabelsColumn":true,"isStacked":false},"state":{},"view":"{\"columns\":[0,1]}","chartType":"BarChart","chartName":"Chart 1"} text-shadowとlinear-gradientは最も負荷の低いプロパティに分類されます。この2つと比べると、透明度を指定するopacityとcolor: rgba()が与える負荷は少し高くなりました。また、「box-shadow」では、内側に影を付けるinset0 1px 1px 0の方が、外側に影を付ける場合0 2px 3px 0よりも処理時間が短くなります。そして、予想外に負荷が高かったのはborder-radiusです。更に「transform: rotate(1deg)」を加えたところ、非常に高負荷であるという結果が得られました。わずかに傾いた400個のボタンがあるページをスクロールしようとすると、動作がとぎれとぎれで不安定になります。ページ内のある要素を任意に変形させるのは容易ではありませんね。または、この角度が最適ではないケースだったのかもしれません。好奇心から、傾きの角度を変化させて検証すると、以下のような結果が得られました。 {"dataSourceUrl":"//docs.google.com/spreadsheet/tq?key=0Aqj_mVmuz3Y8dGN2M21jWjR1akpnQVE0OFJrLXlhOVE&#038;transpose=0&#038;headers=0&#038;range=A2%3AB7&#038;gid=0&#038;pub=1","options":{"hAxis":{"viewWindowMode":"pretty","viewWindow":{}},"hasLabelsColumn":true,"isStacked":false,"width":600,"height":371},"state":{},"view":"{\"columns\":[0,1]}","chartType":"BarChart","chartName":"Chart 1"} まず、わずか0.01度傾けるだけでも、負荷は非常に高いことが分かりました。そして傾きが大きくなるにつれてパフォーマンスは低下していきますが、直線的ではなく山型に変化しました（45度で最高値を示し、90度ではまた低めの値を示します）。
transformプロパティが処理速度に与える影響については、他にも検証できる内容がたくさんあります。transformプロパティで使用する様々な関数（translate, scale, skewなど）を使って、様々なブラウザ上でどのようなパフォーマンスを示すか見てみたいものです。ズームと言えば、フォントサイズを下げて、アプリ全体のパフォーマンスに与える影響を見るテストがありましたが、それはまだ有効なのでしょうか？
検証に使用したスクリプト（ページのリロード）：Webkit（Chrome）上でページのリロードがパフォーマンスに影響を与えるかは検証しませんでした。13.パフォーマンスを低下させる要因として興味深いものに、下記のようなSASSのコードのチャンクがありました。これは以下のようなCSSに変換できます：追加されたie7というセレクタに着目し、どのような一般法則があるかを考えてください。ブラウザが右に書かれたセレクタから順々に確認するという法則のために、IE7（おそらく下記のコードは更に意図的ではなく悪影響を与えます。これをCSSに変換すると以下のようになります。この場合でも、これ以上コードを検索しても「ie7」クラスを割り振られた要素は存在しないと判明するまで、ブラウザのエンジンは「steps」クラス内の各&lt;li&gt;要素を検索し続けなければなりません。私の場合は、最終的なスタイルシートで.ie7や.ie8などをベースとするセレクタが100個近くありました。その中のいくつかはユニバーサルセレクタでした。解決方法は簡単です。IE関連のスタイルは条件分岐のコメントを介したものも含んで、全て別のスタイルシートに分ければいいのです。こうすると、パース、マッチング、適用させるセレクタの数を大幅に減らすことができます。残念ながらこのような最適化の実行には、代償を伴います。IE関連のスタイルをオリジナルのスタイルの隣に併記した方が、保守が容易になることに気付きました。将来的にどこかを変更、追加、または削除することになったときに、編集する箇所はただ1カ所のみなので、IE関連の修正をうっかり忘れる確率が少なくなるからです。将来はおそらく、SASSのようなツールで、メイン処理のファイルから条件分岐を含むファイルに至るまで、このような宣言を最適化できるようになるでしょう。ただ惜しいことに、彼のスクリプトでは「レイアウト」時間の中に「スタイルの再計算」も含めていました。私としては、これを含めたくありません。また、私はページのリロード（とその平均所要時間の取得）も避けたいと思いました。そこで私は手直しをして、ずっとシンプルなバージョンにしました。このスクリプトはデータ全体をひととおり見て、再描画、レイアウト、スタイルの計算に関するエントリを抽出し、エントリごとの実行時間を集計します。Timelineデータを保存してスクリプトを実行すると、次に示すような情報が得られるでしょう。Chromeの「Timeline」とこのスクリプトを使って、私は先述のとおりOpera上で実行した、オリジナルのボタンのテストを改めて実行しました。結果は次のとおりです。 {"dataSourceUrl":"//docs.google.com/spreadsheet/tq?key=0Aqj_mVmuz3Y8dHNncTEtTHRUZGlVazNaUmxHdWJhRXc&#038;transpose=0&#038;headers=0&#038;range=A2%3AB7&#038;gid=0&#038;pub=1","options":{"hAxis":{"viewWindowMode":"pretty","viewWindow":{}},"hasLabelsColumn":true,"isStacked":false,"width":600,"height":371},"state":{},"view":"{\"columns\":[0,1]}","chartType":"BarChart","chartName":"Chart 1"} Operaと同様に、border-radiusの処理効率が良くありません。ただし、linear-gradientはOperaの場合よりも処理効率が悪く、box-shadowもtext-shadowに比べてはるかに高い値になっています。
ここでTimelineについて指摘しておきたいのは、こちらでは「レイアウト」情報だけが得られるという点です。一方Operaのプロファイラには、「レイアウト」に加えて「リフロー」情報もあります。WebKitの「Layout」には、Operaのリフローデータに似たものが既に含まれているのか、それともリフローデータは破棄されるのかは、分かっていません。正当なテスト結果を得るためにも、状況を把握した方がいいでしょう。
さほど綿密なテストはできなかったものの、興味深い事実を1つ見つけました。WebKitのセレクタマッチングは、Operaよりも少しばかり速いのです。同じドキュメント、つまり私がテストで使っていた、シングルページアプリ（最適化する前の状態）を処理した場合で比べると、Operaではセレクタマッチングに1,144ミリ秒を要したのに対して、WebKitではわずか18ミリ秒でした。約65倍もの違いです。どちらかのエンジンで計算時に何かを無視しているか、WebKitではセレクタマッチングがずば抜けて速いかの、いずれかの理由が考えられます。ChromeのTimelineでは、スタイルの再計算は全体で37ミリ秒弱（WebKitにかなり近い値）、リペイントは52ミリ秒です（Operaはペイントの総計で225ミリ秒でした。Operaの処理は厳密にはChromeとは異なりますが、極めて似ています）。WebKitではTimelineのデータを保存できなかったので、リフローやリペイントの値はチェックしていません。覚書の最後に、CSSのパフォーマンスに関して私が抱いている数多くの疑問の中で、ここで取り上げられなかったものを挙げておきます。
* 属性値を指定する場合、引用符の有無は処理効率に影響するのか？　例えば[type=search]と[type="search"]は違うのか？　引用符の有無は、セレクタのマッチング処理の効率にどう影響するのか？
* box-shadow、text-shadow、backgroundなどの指定を複数にすると、パフォーマンスにはどのような特徴が現れるのか？　text-shadowを1回指定するのは、3 回指定する場合と比べてどうか？　さらに5回の場合と比べてどうか？
* 疑似セレクタ（:before、:after）のパフォーマンスはどうなのか？
* border-radiusの値を変えると、パフォーマンスにどう影響するのか？　radiusの値を高くすると処理に時間がかかるようになるのか？　値と処理時間は直線的な関係にあるのか？
* 「!important」宣言は、パフォーマンスに影響するのか？　影響があるとすればどの程度なのか？
* ハードウェアを高速化すると、パフォーマンスに影響があるか？　あるとすればどの程度なのか？
* スタイルを指定すると、組み合わせに関係なく一様に負荷が上がるのか？　例えばtext-shadowとlinear-gradientを指定する場合と、単色の背景色にtext-shadowを指定する場合とで、処理速度に差はないのか？Webページやアプリは、インタラクティブな動作を増やす方向に進化しているため、CSSはより複雑になっています。またブラウザは“高度な”CSSの機能をサポートするようになっています。こうなると、CSSのパフォーマンスは恐らく、ますます重要になるでしょう。既存のツールでは、上っ面をなでることしかできません。モバイル版ブラウザ上でテストを実行するためのCSSが必要ですし、より多くのブラウザ（IE、Firefoxなど）でCSSを動作させるためのツールも必要でしょう。私はMozilla用のチケットを作成した ので、きっと近いうちに、何かを公開できるでしょう。CSSのパフォーマンスのデータを公開するスクリプトが登場するのを強く望んでいます。そうすれば、jsperf.comのようなツール（cssperf.com？ ）で、そのスクリプトが利用できるからです。それはそうと、現時点のプロファイラで実行したいテストは、ほかにも山ほどあります。さあ、何をぐずぐずしているのですか？
