<p><a href="http://blog.vullum.io/javascript-flow-callback-hell-vs-async-vs-highland/" rel="nofollow" title="" class="ext-link">Node.js Flow (part 1) – Callback Hell vs. Async vs. Highland</a> （2015-01-04） by <a href="http://blog.vullum.io/author/eirik-vullum/" rel="nofollow" title="" class="ext-link">Eirik Vullum</a></p><p><strong>Eirik Vullum</strong></p><p>美しいものが好きです。コード。ビジュアル。自然。音楽。このブログには技術と生活についての発見や、とりとめのない事を書いています。</p><p>（このシリーズのPart 2はこちら: <a href="http://postd.cc/nodejs-javascript-flow-fibers-generators-part2/">Node.jsフロー制御 Part 2 – FiberとGenerator</a>）</p><p>今回は、JavaScript/node.jsアプリケーションのフロー制御に対するアプローチを、いくつか取り上げて比較してみたいと思います。</p><p>Expressフレームワークを使った以下のルート処理（お粗末ですが）を例に見てみましょう。</p><p>たったこれだけの（比較的）単純なステップで、すでに読みづらく、かつ論理的に考察しづらくなっています（少なくとも私は）。このルート処理が何をしているのかすぐに把握できません。</p><p>実行ステップ数が増えれば増えるほど、ひどいコードになり、アプリケーションの理解や保守、拡張がとても困難になっていくでしょう。</p><p>その上、各ステップのエラー処理で同じコードを使いまわすのはDRY原則から外れています。</p><p>この例はpmuellr（<a href="https://twitter.com/pmuellr" rel="nofollow" title="" class="ext-link">@pmuellr</a>）が提供してくれました。</p><p>少なくともこのアプローチでは、継続が深くネストされることはありません。しかし、フローの各ステップでエラー処理がDRYの原則に反することで生じる問題があります。また、ステップが増えるほど、フローを追うのが大変になる可能性もあります。</p><p>以下は、asyncライブラリとwaterfallメソッドを使用した同じルート処理です。</p><p>このアプローチだと、処理の手順として何をしているかが分かりやすくなり、少なくともエラー処理での重複を防ぐことができます。</p><p>また、フロー中で処理関数を直接使用することもでき（これは引数がフロー関数のものと同じためです）、最終処理のための名前付きコールバックを作成することもできます。</p><p>“コールバック地獄”に比べれば、格段に良くなりました。でも、まだ十分とは言えません。</p><p>最近は、<a href="https://github.com/caolan" rel="nofollow" title="" class="ext-link">@caolan</a>の<a href="http://highlandjs.org/" rel="nofollow" title="" class="ext-link">highland</a>ライブラリを活用しています。これはネイティブのnode.jsのstreamとの完全な互換性を目指した、高度なstreamのライブラリです。今回はこのライブラリについて触れませんが、以下はhighland streamを使用した同じルート処理です。</p><p>このアプローチは読みやすく拡張性があると思います。これは関数的アプローチで、アプリケーションはさらに保守しやすく考察しやすいものになります。あと50ステップ追加しても、アプリケーションのフローを簡単に素早く把握できるでしょう。JavaScriptのアプリケーションを作るなら、<a href="https://github.com/caolan/highland" rel="nofollow" title="" class="ext-link">このライブラリ</a>を、また一般に、<a href="http://nodejs.org/api/stream.html" rel="nofollow" title="" class="ext-link">node.js stream</a>を一読されることを強くお勧めします。</p><p>Esailija – <a href="https://twitter.com/PetkaAntonov" rel="nofollow" title="" class="ext-link">@PetkaAntonov</a>（<a href="https://github.com/petkaantonov/bluebird" rel="nofollow" title="" class="ext-link">bluebird</a>の作者）の、promiseを使用した例に賛同し、感謝します。</p><p>この例から分かるように、promiseはstreamとよく似ていますが、単一の値だけを出すという点で異なります。promiseの.then()メソッドはnode streamの.pipe()と同等と考えられます。</p><p>その結果、私は先週、勉強のためにpromises(A+)を一から実装することに時間を費やしましたが、これがとても面白くて役に立ちました。</p><p>Lewis Ellis – <a href="https://twitter.com/LewisJEllis" rel="nofollow" title="" class="ext-link">@LewisJEllis</a>（<a href="https://github.com/caolan/highland" rel="nofollow" title="" class="ext-link">highland</a>のcontributorの1人）の巧みな例に感謝します。</p><p>この記事のパート2(<a href="http://postd.cc/nodejs-javascript-flow-fibers-generators-part2/">Node.jsフロー制御 Part 2 – FiberとGenerator</a>)には、さらに、generatorとfiberを使った非同期フローの例があります。</p>
