<p><a href="http://mislav.uniqpath.com/2014/02/hidden-documentation/" rel="nofollow" title="" class="ext-link">Every line of code is always documented</a> (2014-2-7) by <a href="https://twitter.com/mislav" rel="nofollow" title="" class="ext-link">Mislav Marohnić</a></p><p>コードには1行ごとに隠しドキュメントがあります。</p><p>次のコードスニペットの4行目を書いた人は、何か理由があってDOMノードの<code>clientLeft</code>プロパティにアクセスしたのでしょうが、結果的に何もしていません。これはかなり不可解です。なぜこうしたのか、あなたは説明できますか？　今後、この呼び出しを変更したり削除したりしても安全でしょうか？</p><p>私ではなく他の人があなたにこのコードを見せたとして、誰がこの行を記述したのか、どんな理由があったのか、このままの状態にしなければいけないのか、あなたはおそらく説明できないでしょう。ただし、プロジェクトを進めているときは大抵の場合、バージョン管理システムを使ってその履歴にアクセスできます。</p><p><strong>プロジェクトの履歴は最も有用なドキュメントです。</strong></p><p>この行について説明している次のコミットメッセージを読むと、謎が解けます。</p><p>今にしてみると、この行（もっと具体的に言うと、この行について説明した変更）は、なぜこの行が必要だったのか、なぜ以前の方法（コミットSHAで参照する方法）は機能しなかったのか、どのブラウザが影響を受けているのか、そして詳細のためのリンクといった情報が<strong>だらだらとドキュメント化</strong>されています。</p><p>そして実は、<a href="https://github.com/madrobby/zepto/pull/586" rel="nofollow" title="" class="ext-link">この不可解な行を書いたのは私です</a>。もっと良いコードを書く方法はありました。例えば、<code>triggerLayout()</code>のような<a href="https://signalvnoise.com/posts/3531-intention-revealing-methods" rel="nofollow" title="" class="ext-link">目的が明らかな名前</a>の関数に<strong>重要なプロパティアクセスをカプセル化</strong>することもできましたし、せめて<strong>コードのコメントを追加</strong>して、この行はアニメーションを開始するための行だと簡単に説明することくらいはできました。どういうわけか、私はその日、このコードを書くのに失敗したようです。<strong>コードを書いても、必ずしも完璧とは限りません。</strong></p><p>たとえこのコードがもっと理解しやすいものであったとしても、あるいはコードのコメント行が記述されていたとしても、プロジェクトの履歴の方がずっと充実した情報を提供することができます。</p><p>もちろん、コードの品質はとても重要です。しかし、コーディングをさらにもっと改善することを考えるなら、より良いコミットメッセージを書くことを目指すべきです。これはあなただけが目指すのではなく、あなたのチーム全体そして担当者全員が目指す必要があります。<strong>ソフトウェアのストーリーというのは、その最新のチェックアウトと同じくらい重要です。</strong></p><p>コマンドラインから<code>git blame</code>を使用する方法は上ですでに説明しました。Gitのローカルリポジトリにアクセスできない場合は、<a href="https://github.com/madrobby/zepto/blame/2ed0123eaddc023a8579df0a3a084a70a392d792/src/fx.js#L90" rel="nofollow" title="" class="ext-link">GitHub上で任意のファイル</a>の“blame”ビューを開くこともできます。</p><p>ファイルの履歴を効率良く調べるには、Vimと<a href="https://github.com/tpope/vim-fugitive" rel="nofollow" title="" class="ext-link">Fugitive</a>を使用します。</p><p><img width="827" height="445" style="max-width:100%" alt="git blame view in vim Fugitive" src="http://f.cl.ly/items/070G0J0P3T0O3G2u2f0i/Screen%20Shot%202014-02-07%20at%203.38.20%20PM.png"></p><p>詳細については、<code>:help Gblame</code>を参照してください。</p><p>git blameを使えば、変更内容を説明したコミットSHAを取得できるかもしれません。ただしコミットメッセージは、変更の根本的な理由を説明できるだけの情報やコンテキストを必ずしも伝えるわけではありません。しかし、チームがプロジェクトで<a href="http://guides.github.com/overviews/flow/" rel="nofollow" title="" class="ext-link">GitHub Flow</a>を実践している場合、プルリクエストのやり取りの中でコンテキストが見つかる場合があります。</p><p>このように、pull request #42による変更だということがコミットSHA 1つだけで分かりました。</p><p>もうなくなっているもの（例えば、もはやどこからも呼び出されない関数呼び出しなど）を探したい場合もあるでしょう。特定のキーワードが追加されたり削除されたりしたコミットを探す最も良い方法は、<code>git log</code>に‘pickaxe（つるはし）’引数を使うことです。</p><p>この方法で、特定の関数の呼び出しを削除したコミットや、特定のCSSのクラス名を追加したコミットを発掘することができます。</p><p>プロジェクトの履歴を利用すると、コミットを個別に確認できるだけでなく、<strong>変更のセットを全体的に分析できる</strong>ので、有益な見解が得られます。例えば、<a href="https://github.com/garybernhardt/dotfiles/blob/f0c0ff92209e5aed4fa3ef6faf056eb9944a8f12/bin/git-churn" rel="nofollow" title="" class="ext-link">git-churn</a>はシンプルですが、<code>git log</code>をラップして、どのファイルが一番変更されているかについてステータスをまとめる便利なスクリプトです。次のコマンドは、過去6か月間にどのアプリ開発が重点的に行われたかを確認できます。</p><p>ちなみに、このような分析はプロジェクト内の潜在的な技術上の問題を浮き彫りにすることもあります。特定のファイルがあまりにも頻繁に変更されているのは、ほとんどの場合、危険信号です。そのファイルのコードは頻繁にバグ修正が必要になっているか、もしくはそのファイルで行っている処理が大きすぎるため、もっと小さなユニットに分割する必要がある可能性があります。</p><p>同様の方法で履歴分析を行えば、コードベースの特定部分を最近開発していた担当者を確認することができます。例えば、アプリケーションのAPI部分に最も関与した人を確認するには、以下のコマンドを実行します。</p><p>今あなたが作成しているものはすべて、プロジェクトの履歴に登録されて、永遠に残されるということを頭に入れておいてください。一緒に作業している他の人たちにとって親切になるように（たとえ1人のプロジェクトであっても、3ヶ月後のあなた自身も作業者です）、コミットするときは以下の基本ルールに従います。</p><p>
</p>
<p><img width="470" style="max-width:100%" alt="messy git history before rebase" src="http://f.cl.ly/items/2U0d0K2Q2C300Q1X3P1S/Image%202013-04-04%20at%201.38.33%20AM.png"></p><p>どうしてこのコーディングスタイルにする必要があるのでしょう？　<code>git blame</code>を使おうとする人のことをいつも考えるようにしてください。このJavaScriptの例で、コミット済みの値<code>"baz"</code>を追加したのがあなただったとしたら、誰かが<code>"bar"</code>を追加した行でblameを使ったときに自分の名前が表示されるのは嫌ですよね。この2つの変数に関連性はないかもしれないからです。</p><p>ここまで読んでもらったお礼に、おまけのスクリプトをお見せしましょう。私はこれに<a href="https://github.com/mislav/dotfiles/blob/7ac8cbfcd56cfa6c39b5719ea183e87878ea6ed5/bin/git-overwritten" rel="nofollow" title="" class="ext-link">git-overwritten</a>という名前を付けて、任意のブランチで変更または削除した行の元の担当者についてblameの情報を表示しています。</p><p>これは<a href="http://guides.github.com/overviews/flow/" rel="nofollow" title="" class="ext-link">GitHub Flow</a>でプルリクエストを開くときに便利です。同僚に自分のプルリクエストを確認してほしくても、誰にメッセージを送ればいいか分からない場合があります。<code>git-overwritten</code>を使えば、あなたが変更した行を書いた元の人たちの名前が分かるので、プルリクエストを開くときに相手先を把握できます。</p>
