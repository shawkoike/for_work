I Do Not Know C （2015-03-03） by Dmitri Gribenko(注：2017/04/27、いただいたフィードバックを元に翻訳を修正いたしました。)この記事では、皆さん（特にC言語のプログラマ）に「自分はCを分かっていなかった」と気付いてもらうことを目標にしています。Cの落とし穴は、思っているよりもずっと身近なところにあります。ちょっとしたコードにも未定義の動作が潜んでいることを以下で示しましょう。この記事はQ&amp;A形式になっており、それぞれの例題は独立したソースコードとして扱ってください。Q: これは正しいコードでしょうか？　（変数の二重定義エラーが発生するでしょうか。上述の通り、これは独立したソースファイルであり、関数本体や複合ステートメントの一部ではありません）解答A: 正しいコードです。1行目は仮定義であり、2行目でコンパイラが処理した後に “定義” になります。Q: ｘがNULLポインタであってもbar()が呼び出されました（プログラムはクラッシュしません）。これはオプティマイザのエラーでしょうか。それとも何も問題はないのでしょうか？解答A: 何も問題はありません。もしxがNULLポインタなら、1行目の未定義の動作が発生するので、プログラマには何も保証されません。つまり、この1行目でプログラムがクラッシュするとは限りませんし、2行目でプログラムが制御を返すとも限りません。コンパイラが従う一連の処理ルールについても説明しましょう。まず、コンパイラでは1行目を解析します。そしてxがNULLポインタになり得ないことを確認すると、2行目と3行目の実行されないコードを削除します。変数yは未使用なので削除されます。また、*x型はvolatile型修飾子とは見なされないため、メモリから読み取られた値も削除されます。このようにして、未使用の変数によってNULLポインタのチェックが取り除かれます。以下の関数があるとしましょう。これを次のように最適化します。Q: 元の関数と最適化した関数を呼び出して、zpで異なる結果を得ることはできるでしょうか？解答A: yp == zpとすると可能です。Q: この関数でinfが返されることはあるでしょうか？　浮動小数点数は（ほとんどのマシンで）IEEE 754に従って実装されており、assertが有効（NDEBUGは未定義）であると仮定します。解答A: はい、あります。1e-309などの非正規化した値をxに渡せば十分です。Q: 上記の関数は、ヌル(文字)で終わる行の長さを返す必要があります。バグはどこでしょうか？解答A: オブジェクトのサイズを格納するためにint型を使用することは間違っています。なぜならintがオブジェクトのサイズを格納できるという保証はないからです。 size_tを使うべきでしょう。Q: 上記のコードは無限ループになります。なぜでしょうか？解答A: size_tは符号なしのデータ型です。iも符号なしなので、i &gt;= 0が常にTRUE（真）となるため、上記は無限ループになります。このプログラムを2つの異なるコンパイラにかけて、リトルエンディアンのマシンで実行しました。すると、次の通り実行結果が一致しませんでした。Q: 2番目の結果が得られる理由を説明してください。解答A: 上記のプログラムは未定義の動作となります。例えば、エイリアス（別名）の厳格な規則に違反しているためです。コードの2行目でintの値を変更していますね。すると、longの値は変わらないと仮定することができます（互換性のないデータ型を持つ別のポインタのエイリアスは、逆参照できません）。従ってコンパイラは、1行目を実行して読み取った値をそのまま、3行目のlongへ渡します。Q: このコードは正しいですか？　未定義の動作ではないとすると、print文で何が出力されるでしょうか？解答A: はい、正しいです。ここではコンマ演算子が使われていますね。まず、コンマの左側の引数が計算されて廃棄されます。次に、右側の引数が計算されて、演算子全体の処理結果として使われます。出力結果は「10 2 10」となります。ここで、関数呼び出しにもコンマ記号が使われることに注意してください（例えばf(a(), b()))。これはコンマ演算子ではありません。従って関数呼び出しの場合は、計算の順序は保証されません。a()とb()は任意の順序で呼び出されます。Q: add(UINT_MAX, 1)の実行結果はどうなりますか？解答A: 符号なしの数値のオーバーフローが定義されていますね。これは2^(CHAR_BIT * sizeof(unsigned int))で計算されます。結果は0となります。Q: では、add(INT_MAX, 1)の実行結果はどうなるでしょうか？解答A: 符号付きの数値がオーバーフローするので、未定義の動作となります。Q: このコードは、未定義の動作となるでしょうか？仮にそうだとすれば、どの引数でそれが起こるでしょうか？解答A: neg(INT_MIN)です。ECMが追加コード（2の補数）で負の値を表す場合、INT_MINの絶対値はINT_MAXの絶対値よりも大きく、その差は1となります。この場合、-INT_MINが符号付きのオーバーフローとなるため、未定義の動作になります。Q: このコードは、未定義の動作となりますか？仮にそうだとすれば、どの引数でそれが起こるでしょうか？解答A: ECMが追加コードで負の値を表す場合、 div(INT_MIN, -1)で未定義の動作となります。理由については、直前の質問の解答を参照してください。— Dmitri Gribenko gribozavr@gmail.com
この作品はクリエイティブ・コモンズ 表示-継承 3.0 非移植ライセンスの下に提供されています。
