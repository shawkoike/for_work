<p><a href="http://prl.ccs.neu.edu/blog/2016/05/24/measuring-gc-latencies-in-haskell-ocaml-racket/" rel="nofollow" title="" class="ext-link">Measuring GC latencies in Haskell, OCaml, Racket</a> （2016-5-24） by <a href="http://prl.ccs.neu.edu/blog/tags/by-Gabriel-Scherer.html" rel="nofollow" title="" class="ext-link">Gabriel Scherer</a></p><p>James FisherはGHCのランタイムシステムが彼らのHaskellのプログラム上でレイテンシに悪影響を及ぼしたケースを、ブログに投稿しています。</p><p>この記事では、その問題（基本的に、レイテンシはコピー時間の影響を受ける）を示す非常にシンプルな合成ベンチマークを提案していて、さらに「50ミリ秒のレイテンシは過剰」と言っています。それで、他のGCがどのようにこの問題を処理しているかを見るため、OCamlとRacketで合成ベンチマークを再現したら面白いだろうと思いました。</p><p>細かい話は抜きにすると、要点は次のとおりです。OCamlのGCは古い世代にある大きなオブジェクトに関しては問題はありません。コレクションをコピーするのではなくマーク &amp; スイープで処理するためで、このベンチマークではワーストケースでも停止は3ミリ秒以下です。</p><p>Racket GCも古い世代をコピーしませんが、インクリメンタルGCは（うまく機能するスループット指向の設定と比較した場合）まだ初期段階にあり、結果は劣ります。現状、後述する “Ramp-up” 効果の負荷を被っており、それがベンチマークの始まりで長い停止時間（最大120ミリ秒のレイテンシ）を起こす原因になっています。しかし、安定した状態の停止時間は最長でも22ミリ秒です。</p><p>元のベンチマークは、非常に具体的なワークフローを実行するように設計されていて、それはGHCのガベージコレクタにおけるワーストケースの振る舞いを起こし得ることに留意してください。一般にGHCのレイテンシが悪い、他のテスト済み言語のレイテンシのほうが低い、と言っているわけではありません。</p><p>今回は、実行と解析のロジックをカプセル化するMakefieを使って実装しました。Gitlabレポジトリで入手できます。</p><p>James FisherによるHaskellのベンチマークは、とてもシンプルです。関連テーブルを生成し、その中にミディアム長の文字列を繰り返し、100万回挿入します。チャネルが200_000メッセージに到達すると、全体のワーキングサイズを一定に保つため、1つの文字列が生成されるたびに1つの文字列が削除されます。</p><p>以下のように、プログラムをコンパイルし、実行します（私のレポジトリでは<code>make run-haskell</code>も走ります）。</p><p>私のマシンでは、プログラムの実行に約1.5sかかります。総合的な実行時間（アルゴリズムのスループット）は置いておき、GCが誘発した停止時間に注目しましょう。ワーストケースの停止時間は51ミリ秒であり、これは先のブログ記事で報告されていた数字と同じです。予測するワーストケースのレイテンシでも「数ミリ秒」であり、それは過剰だとも書かれていました。</p><p>（私はGHC 7.8でテストを行ないました。Fischerの報告は7.10によるものですが、どちらも根本的には同じです）</p><p>このHaskellコードは、ベンチマークをさらに他の言語に移植しにくくする<code>Map</code>データ構造（不変連想マップ）について2つのことを前提としています。要素の総数はデータ構造に前もってキャッシュされているため、<code>Map.size</code>は一定であること。OCaml、Racketにとってもそれはリニアです。そして最小のキーを取り除きやすくするキー配列を使っていること。OCamlも同様ですが、Racketは代わりにハッシュを使います。</p><p>最初、このために総数と最小限のキー情報を移植したバージョンに格納する作業を行ないました。実際には、同じ振る舞いで、ベンチマークの変数を書くほうがずっと良く、これらの細かい機能も必要ありません。</p><p>この変数は同じ実行時間で、元のプログラム同様、ワーストケースの停止時間は50ミリ秒でした。</p><p>James Fischerはレイテンシがこれほど高い（50ミリ秒は高いとみなされている）理由を、GHCのガベージコレクタが世代間に渡り、古い世代がなおストップ &amp; コピーのスキームを使用しているからだと説明しています。つまり、大きなオブジェクトを多く内包している場合、それらのコピーにたくさんの時間が費やされるということです。</p><p><a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/" rel="nofollow" title="" class="ext-link">先のブログ記事</a>には問題に関するより詳細な記述と、考えられる様々な最適化の方法が書かれています。残念ながら現状では、コードやGCのパラメータをチューニングしても、その手の作業負荷を最適化することはできないようです。古いヒープの振る舞いをコピーしても大して解決にはならないでしょう。</p><p>言ってみれば、このような設計が選ばれた理由を説明するとすれば、Haskellには並列ミューテータ（マルチコアのランタイム）のサポートに多大な労力が払われているということです。この極度に難しく有益な条件に伴うさらなる複雑さのために、ランタイムのオーサーはGCの全体の設計概念を可能な限りシンプルかつ合理的にせざるを得なかったのではないでしょうか。これで、全ての世代のスペースで同じコレクション方法を使うことも説明できるでしょう。</p><p>コードはOCamlに簡単にポートできます。以下がその例です。</p><p>スループットの評価は重要ではなく、HaskellとOCamlで使われる安定したマップは、明らかにそれぞれ少々別の方法で実装されているので、パフォーマンスが異なっても説明がつきます。それでもなお、全体の実行時間が1.5sと、基本的に同じであるのは面白いと思うのです。</p><p>最大の停止時間を測るには、2つの方法があります。</p><p>新たに測定用のランタイムを使うには、OCamlコンパイラのバージョン 4.03.0で、<code>--with-instrumented-runtime</code>設定時オプションを用いてコンパイルする必要があります。その後、計測有効の状態でコンパイルする、実行時間の<code>i</code>変数（ “instrumented” の<code>i</code>）が使えるようになります（私のMakefileルール、<code>make run-ocaml-instrumented</code>はこの作業を代行しますが、測定用のランタイムでコンパイルした際のオプションだけは必要です）。</p><p>ログファイル<code>ocaml.log</code>には、GCが関わる全実行時間の呼び出しの低レベルログが、ナノ秒単位で、かつ人間向けではなくマシン向けのフォーマットで書き出されています。<code>ocaml-instr-report</code>ツールと<code>ocaml-instr-graph</code>ツールは、OCamlソースのディストリビューションであり（初期設定ではインストールされていないため、ソースをチェックアウトする必要があります）、ログを解析してテーブルやグラフを表示します。ワーストケースの場合のレイテンシにとって重要なエントリポイントは<code>dispatch</code>で、全てのGCのアクティビティで費やされた時間を含みます。<code>ocaml-instr-report</code>と関連のあるセクションのアウトプットは次のように表示されます。</p><p>見てのとおり、多くの停止時間は220マイクロ秒から1ミリ秒の間で、最長は2.7ミリ秒です。</p><p>その他に、測定用のランタイムなしに古いOCamlバージョンで動くこのプログラムのレイテンシを測るには、明示的なタイミングコールを挿入し、ループのワーストケースの時間を計算するやり方もあります。実際の挿入、削除の時間は小さいと仮定し、最大の停止時間を超える近似値を出すのです。</p><p>このバージョンを走らせると、私のマシンではワーストケースのレイテンシは2ミリ秒と出ました（科学的記数法の<code>%E</code>フォーマッタを使ったので、<code>2.03E-03</code>と表示されます）。これは測定用のランタイムのせいでオーバーヘッドが加わっているため、実際には多少それよりも低くなります。</p><p>この気の毒な、ワーストケースのレイテンシ計測方法の不都合な点は、ワーストケースの時間以外は、他のいかなる時間の分布も分からないというところです。</p><p>OCamlのGCには、信頼に足るインクリメンタルフェーズが元から実装されています。そしてその古い世代にもコピーを使いません。マーク &amp; スイープ処理でパフォーマンスも良く、始めからこの具体的なベンチマークがOCamlのワーストケースのケースではないことは予測できます。</p><p>OCamlの最新バージョン、OCaml 4.03.0では、Damien Doligezの手によって、いくつかの状況でワーストケースの場合のレイテンシが改善されています。Jane Streetの業務利用による後押しが大きかったのでしょう。とりわけ、上記で使ったレイテンシ計測ツールはDamienがこの機会に開発したものです。私は2つ目の計測方法で、レイテンシが以前のOCamlバージョンと同様に良いことを確認しました。この特殊なユースケースは4.03以前には改善の必要がなかったものです。</p><p>Max Newは、このベンチマークのRacketポートの最初のバージョンを記述しました。彼は、マップの総数と最小のキーを、オリジナルのGHCバージョンに合致するように明示的にトラッキングする必要がありました。彼のコードを簡素化した変数に適用すると、他の計測により近づきました。</p><p>最初に私は、明示的なタイミングコールでレイテンシを測るという惨めなやり方をとりましたが、その後により良い2つの方法に切り替えました。</p><p>Racketは、現在は実験段階にあるインクリメンタルGCを持っており（スループットを低下させる可能性があるため、初期設定では有効になっていません）、環境変数<code>PLT_INCREMENTAL_GC=1</code>を設定すれば有効になります。インクリメンタルGCのある場合とない場合で比べたところ、一般にレイテンシのヒストグラムをより低いレイテンシに近づけるようでした。しかし、後述の理由により、さらにチューニングをしない限り、ワーストケースのレイテンシの改善には大して助けにならないことが分かりました。下記の全ての報告はインクリメンタルGCを用いたものです。</p><p>最新のRacket 6.5を使っている私のマシンでは、<code>gcstats</code>がレポートする最長停止時間は約150ミリ秒であり、GHCの最長停止時間50ミリ秒よりもかなり悪い結果です。</p><p>私は、GCのレイテンシを下げるべくコードを改善するための説明や助言をもらえたらと思い、Racket開発者のメーリングリストに<a href="https://groups.google.com/forum/#!topic/racket-dev/AH6c-HGgzJ0" rel="nofollow" title="" class="ext-link">eメール</a>を送りました（GHCベンチマークの問題点は、ユーザがコードをいじって同じワークフローでより低いレイテンシを実現するための正規の方法がないということです。私たちは、初期値のレイテンシだけではなく、それを調整できるかどうかも評価のポイントにしているのです）。すると、非常に良い結果が得られました。</p><p>まず、Matthew FlattがRacketのコードベースで、すぐさまコミットを数回送信し、ベンチマークで問題となっていた幾つかの動作を改善しました。Racket 6.5ではなく開発版を使用すると、ワーストケースのレイテンシは私のマシンで150ミリ秒から120ミリ秒まで改善します。これ以後の時間は全て開発バージョンを用いた報告になります。</p><p>Matthew Flattはその結果についても分析を行い、ベンチマークの開始時点、チャネルが200,000メッセージの最大値に達したすぐ後に、ワーストケースのレイテンシが、体系的に発生することに気づきました。これはデフォルトのベンチマークパラメータでは見つけるのは困難です。チャネルが満杯になる “Ramp-Up” 期間は、全ての反復回数の1/5を占めています。このことを分かりやすくするため、反復回数を1,000,000回から10,000,000回に増やし、<code>make run-racket-instrumented</code>を実行しました。<code>grep MAJ racket.log</code>を実行すれば、メジャーコレクションの停止時間を見ることができます。私のマシンでの結果は以下のようになりました。</p><p>メジャーGCの停止時間の発生状況を見てください。<code>140ミリ秒</code>で早いピークがありますが、その後の停止時間は短くなります。定常状態では約<code>22ミリ秒</code>の妥当な長さの停止時間を示しています。各GC中に解放されたメモリ容量を見れば、そのピークは多くのメモリを解放する最初のメジャーGCに対応していることが分かるでしょう。つまりメジャーGCとは、チャネルが最大サイズに達した後の最初のGCで、多くのメッセージを削除し始めます。</p><p>私の認識では、インクリメンタルGCはプログラムのメモリ割り当てのパターンを観察するランタイムパラメータを幾つか保持し、次のGCがいつ、どれくらいの作業をすべきかを予測しようとします。Matthew Flattは、この監視ロジックは今のところプログラムの状況の変化にうまく適応できず、現時点では大きなピーク停止時間を招くと説明しています。</p><p>これは、私たちのベンチマークにとっては朗報です。というのもプログラムの初めに非常に長い停止時間が発生しますが、一度だけだからです。これはJames Fischerの記事で話題に上っているレイテンシの最後の十分位数にはあまり影響しません。また実際のメッセージパッシングアプリケーションの定常状態においても問題になりません。</p><p>Matthew Flatt氏は、GCに明示的な呼び出しを挿入すれば、Racketのヒューリスティック的な要求よりも頻繁にコレクションを実行し、停止時間の大きなピークを少しは回避できると述べています。しかし、あまりにも頻繁に明示的なGCを行うと、プログラムのスループットが低下します。</p><p>状況が変化する周辺、つまり最大チャネルサイズを繰り返し数える箇所で、GCに明示的な呼び出しを挿入して、少し試してみたところ、停止時間の問題がやや改善されていることが分かりました。私が定義した関数は以下のようなものです。</p><p>これは、実験的に<code>#t</code>を明示して設定できる<code>gc-during-rampup</code>のパラメータによって制御されます。明示的なGCの呼び出しは、私のベンチマークコードではデフォルトで無効になっています。それから、main loopの中に<code>（maybe-gc i）</code>コールを挿入しました。</p><p>追加したGCの呼び出しはRamp-Up中にだけ発生するので、定常状態のパフォーマンスは変化せず、スループットに対する全体的なコストは適当です（2,000,000回の繰り返しを行った私の実験では、20%でした）。これは停止時間のピーク問題を軽減するのに効果的なようです。私のマシンでのワーストケースの時間は現状ではわずか38ミリ秒です。また、定常状態での停止時間は22ミリ秒程度です。</p><p>もちろん、これは応急処置にすぎません。長期的な解決策は、Racketの開発者がRamp-Upの問題を回避する、よりよい動的コントロールの方法を考え出してくれるのを待つことです。どうやら、インクリメンタルGCは、例えばゲームループの1サイクル毎に一時的なメモリが割り当てられるような、もっと簡単な割り当てプロファイルを持つゲームにおいて、そのようなRamp-Up段階が無い状態で、あらかじめテストされたようです。しかし、私は熟練のユーザーがコードを少し手直しして、ワーストケースの停止時間を大幅に短縮できるという点に依然として興味がありました。</p><p>要約すれば、RacketのインクリメンタルGCは、優秀ではないが適切な定常状態の振る舞いを見せ、この時の最大レイテンシは22ミリ秒程度です。しかし今のところ、ベンチマークのRamp-Up時にはるかに長い停止期間を生じるGCコントロール問題を抱えています。明示的なGCの呼び出しにより、それを少しは緩和することができます。</p>
