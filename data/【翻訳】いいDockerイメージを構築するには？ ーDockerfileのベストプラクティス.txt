<p><a href="http://jonathan.bergknoff.com/journal/building-good-docker-images" rel="nofollow" title="" class="ext-link">Building good docker images</a> （2014-10-3） by <a href="http://jonathan.bergknoff.com/about" rel="nofollow" title="" class="ext-link">Jonathan Bergknoff</a></p><p><a href="https://registry.hub.docker.com/" rel="nofollow" title="" class="ext-link">Dockerレジストリ</a>は、今やあふれんばかりの状況です。これを書いている時点で、”node”と検索すれば、1000件弱の結果がヒットします。どうやって選べばいいのでしょうか？</p><p>いい悪いは主観ではありますが、私がいいと考えるDockerイメージには、いくつかの基準があります。</p><p>残念ながらDockerレジストリでは、”いい”イメージを見分けるのは容易ではありませんし、特定のイメージを判別するのにも手間がかかる状況です。<code>docker pull &lt;...&gt;</code>の問題であることが多いですが、なぜ10メガバイトの<code>node</code>のバイナリに10ファイルのシステムレイヤが必要で、最終的には700メガバイトの仮想環境になるのか理由が分からなくなってきます。</p><p>何が”いい”Dockerイメージかという普遍的な尺度はなく、Dockerレジストリに新たなイメージを追加する障壁も非常に低いため、状況は<a href="http://xkcd.com/927/" rel="nofollow" title="" class="ext-link">xkcd #927</a>と全く同じです。つまり、それぞれが好き勝手にやっています。そこで、<a href="https://github.com/docker-library/official-images" rel="nofollow" title="" class="ext-link">言語に特化した”オフィシャル”のDocker開発環境</a>の導入は、いいスタートになると思います。この中に、私が愛用している手法（下記参照）のいくつかが含まれているのはうれしいですね。しかし、”数千ものnodeのイメージ”という状況は、Dockerレジストリの検索と評価メカニズムが強化されるまでは、恐らく改善しないでしょう。</p><p>そういう訳で、ここでは私が考えるDockerfileのベストプラクティスをまとめてみることにします。私もエキスパートという訳ではないので（Dockerがまだ出てきたばかりのサービスであることを考えると、現時点ではまだ誰もエキスパートではないとは思いますが）、どんなご意見やフィードバックも大歓迎です。</p><p>このブログを書いている時点では、<code>Ubuntu</code>（バージョン14.04）は195MB、<code>debian:Wheezy</code>だと85MBになります。このUbuntuでの100メガバイトちょっとの超過分には実際なんの意味もありません（私が見る限り）。極端なケースだと、<code>busybox</code>を使えば更に2MBほど削減することができます。これは、静的にリンクされたバイナリと一緒に使う時のみ現実的な手法でしょうか。<code>progrium/logspout</code><a href="https://github.com/progrium/logspout" rel="nofollow" title="" class="ext-link">リンクはこちら</a>は14MBにまで小さくまとめられています。<code>busybox</code>を使ったDockerイメージの良い例です。</p><p>ビルドツールは大きなスペースを必要としますし、ソースコードを使うのでたいてい時間がかかります。既に普及しているソフトウェアを利用するだけの場合、普通はソースからビルドする必要はないでしょう。むしろお勧めしません。従って例えば、最新のnode.jsをアップしてDebianホストで動かすためだけに、PythonやGCCまでインストールする必要もありません。Node.jsソースコードのバイナリtarballなら、<a href="http://nodejs.org/download/" rel="nofollow" title="" class="ext-link">Node.jsのダウンロードサイト</a>から手に入ります。同様にRedisについてもパッケージマネージャを使ってインストールすることができます。</p><p>ビルドツールを使った方がいいのは、少なくとも次のような理由がある時だけです。</p><p>このうち2番目のケースにあたる場合には、本当に実行するべきかしっかり検討してください。3番目の理由によってビルドツールをインストールする場合には、最小のnode.jsイメージを素材にした別の”npm installer”イメージとしてインストールすることをお勧めします。</p><p>この<code>Dokerfile</code>は、109MBものイメージサイズになっています。</p><p>一方、同じように見えるこの<code>Dokerfile</code>を確認すると、イメージサイズは99MBです。</p><p>要するに、<code>Dokerfile</code>上の各ステップでディスクにファイルを残したままにした場合、その分のスペースは後でファイルを消しても戻ってこないのです。コマンドのアウトプットをパイプで繋ぐだけで、テンポラリファイルを全く作らずにコマンド実行することも可能です。例えば、</p><p>を実行した場合、ファイルシステム上にファイルを保存することなく、直接tarballを抽出することができます。</p><p>コンテナのセットアップ時に<code>apt-get update</code>を実行すると、イメージが完成した時点で不要になるデータが<code>/var/lib/apt/lists/</code>に移動します。このディレクトリを安全に空にして、数メガバイト節約することができます。</p><p>次の<code>Dockerfile</code>は99MBのイメージを生成します。</p><p>一方、こちらは90MBのイメージを生成します。</p><p>Dockerイメージは不変ですが（その点は非常に優れていますが）、<code>Dockerfile</code>が実行時に毎回同じ出力結果が得られる保証はありません。問題はもちろん外部の状況なので、私たちにはほとんどどうすることもできません。ベストなのは、<code>Dockerfile</code>に関する外部の状況の影響を可能な限り最小限に抑えることです。そのためのシンプルな方法は、パッケージマネージャを通じてアップデートするときに、パッケージのバージョンをピンすることです。以下にその方法の例を示します。</p><p>パッケージのリポジトリが来年の今頃もこのバージョンを提供していればいいのですが、そういう保証はありません。いずれにせよ、あなたのイメージが依存しているソフトウェアのバージョンを明確に示すことは間違いなく有用です。</p><p>もし関連性のあるコマンドが続く場合は、1つのRUNコマンドで連結するのがベストです。これはより重要なビルドキャッシュに効果的で（論理的にグループ化されたステップが1つのキャッシュステップにまとめられます）、ファイルシステムのレイヤ数を抑えます（一般的に望ましいことだと考えられますが、客観的に優れているかどうかは分かりません）。</p><p>以下のバックスラッシュ（\）は、読みやすいように使用しています。</p><p>これは”オフィシャル”のnode.js Dockerイメージの<code>Dockerfile</code>（<a href="https://github.com/docker-library/node/blob/51b1dd1984e287189106884c453ca506737eed78/0.10/Dockerfile" rel="nofollow" title="" class="ext-link">リンクはこちら</a>）を読んでいて気付いたコツです。余談ですが、この<code>Dockerfile</code>は優れています。1つだけ難点を言うと、巨大な<code>buildpack-deps</code>（<a href="https://github.com/docker-library/buildpack-deps/blob/69f0b516b5515939bef6170f1e82362174143d13/wheezy/Dockerfile" rel="nofollow" title="" class="ext-link">リンクはこちら</a>）イメージの上に私には不要なありとあらゆるものと一緒にあることです。</p><p>ENV NODE_VERSION 0.10.32</p><p>RUN curl -SLO “http://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz” \<br>
    &amp;&amp; tar -xzf “node-v$NODE_VERSION-linux-x64.tar.gz” -C /usr/local –strip-components=1 \<br>
    &amp;&amp; rm “node-v$NODE_VERSION-linux-x64.tar.gz”<br>
“`</p><p>この記事については、<a href="https://news.ycombinator.com/item?id=8483102" rel="nofollow" title="" class="ext-link">こちらのHacker Newsの投稿</a>でさらに検討しています。</p>
