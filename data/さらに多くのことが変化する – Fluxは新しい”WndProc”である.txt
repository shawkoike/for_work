<p><a href="http://bitquabit.com/post/the-more-things-change/" rel="nofollow" title="" class="ext-link">The More Things Change</a> （2015-10-13） by <a href="https://twitter.com/bitquabit" rel="nofollow" title="" class="ext-link">Benjamin Pollack</a></p><p>たまたま今まで知らなかったという方のために言いますと、ReactはWebプログラミングにおける最先端の新技術です。そのアイデアはシンプルです。それは、Reactの各コンポーネントは、JavaScriptにおいて、ビューを冪等（べきとう）に描画します。ビューは、コンポーネントが内部に保持している少量のステートのみに基づいてレンダリングされます。同じステートにすれば、その状態におけるコンポーネントは常に同じようにレンダリングされます。これは、データが変われば、Reactは<em>その変更のみを</em>ブラウザのDOMに適用できるということでもあり、ページ全体の再レンダリングを省略できます。実際、何かを変更するかどうかという決定は<em>全て</em>、コンポーネントの内部状態に完全に左右されます。それが、なぜReactが非常に早いのかという根本的な理由です。</p><p>しかし実際のところ、React自体には、変更をどのように<em>伝える</em>かという解決策がありません。そのため、最も一般的な解決策としてFacebookの他のフレームワークであるFluxを使います。Fluxには、データを格納する<em>ストア</em>があります。また、<em>アクション</em>を処理し、関連するアクションが処理された際にはパーティに適切に通知する<em>ディスパッチャ</em>があります。この一連の流れは間接的に行われます。つまり、ユーザはディスパッチャのアクションのきっかけとなるアクションを起こし、ディスパッチャはストアを更新し、ストアはビューを更新し、それによって、場合によっては再レンダリングが起こる、といった具合です。私の説明よりも、この<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc#structure-and-data-flow" rel="nofollow" title="" class="ext-link">的確な図</a>を見た方が理解しやすいかもしれません。実際のアプリケーションを構築するには、通常、多くのReactのビューとFluxのディスパッチャを全体的に密接に組み合わせ、各部品が互いにうまく機能するように構成します。</p><p>上記のアイデアは素晴らしいように思えますが、Fluxを使ったWebサイトのコーディングを見ると、私はいつも感じるのです…何というか、どこか<em>奇妙</em>だなと。このパターンを以前見たことがあるような気がするのです。それが全て”新しい”ものであるにもかかわらず、ドラゴン退治の物語<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup>のように思えるのです。しかしなぜそのように感じるのかはっきりと指摘することができませんでした。</p><p>今までは。</p><p>ここで、ある思考実験をしてみようと思います。Web用のプログラムではなく、リソースが不足しているグラフィカルコンピューティング環境用のプログラムを書いているとします。恐らく、こうしたよくある埋め込み型のマイクロコントローラは、今ではとても一般的ですが、処理能力がRaspberry Piより劣るものもあります。そのようなフレームワークをどのようにデザインしたらよいでしょうか。</p><p>リソースが不足していると言いましたが、そのため、OS　Xで行うように各個のウィジェット用にオフスクリーンのバッファを保持するかわりに、必要に応じてのみウィジェットを再描画させるようにします。そうすると、ウィジェットの描いたコードが冪等であるように命令する必要が生じます。さらに（繰り返しますが）リソースが不足しているので、実行時間等をいたずらに大きくしたくありません。全てをシンプルにしておくために、各ウィジェットを1つのプロシージャに関連付けて、そのプロシージャに2つの引数を与えます。たった今、ユーザがどのようなアクションを起こしたのかを表す整数値と、（もし適用できれば）付加的な、アクション固有のデータのポインタです。そうすれば、各ウィジェットは可能な限り最も効果的な方法で各メッセージを扱うことができます。最後に、ユーザのアクションがウィジェットの再描画を要求するかもしれないので、変更が必要になったら、ウィジェットが私たちに通知できるようにします。描画は冪等なので、再描画しなければならないものが何であれ、再描画するだけでCPUの使用量を最小限にできます。最後に、プログラマの心の平穏のために、これらのウィジェットをネスト可能にし、互いにカスタムメッセージを送れるようにします。</p><p>やりましたね！　これでWindowsのデザインが完成しました。</p><p>具体的に言うと、1985年のWindows 1.0です。</p><p>これは掛け値なしに本当のことですが、上で説明した方法が、少なくとも、Windows7までのWindowsをプログラムしていた、まさにそのやり方なのです。さらに言うと、最近のWindowsプログラムの多くは内部的に、今もこの方法で機能しています<sup id="fnref:2"><a href="#fn:2" class="footnote-ref">2</a></sup>。<code>WM_PAINT</code>メッセージを通して要求を受けると、ビューが描画されます。処理を早くするため、<code>WM_PAINT</code>メッセージは通常ビューの中でローカルにストアされるステートだけを使い<sup id="fnref:3"><a href="#fn:3" class="footnote-ref">3</a></sup>、繰り返せるようにしておきますが、ステートの操作は禁止されています。描画はステートの変更とは分けられているので、Windowsは実際に再描画が必要なスクリーンの一部分しか再描画できません。各ビューはそれぞれ関連付いた<code>WndProc</code>と呼ばれる関数を持っており<sup id="fnref:4"><a href="#fn:4" class="footnote-ref">4</a></sup>、4つのパラメータがあります。実際のビューが更新される時、<code>uMsg</code>は、整数で表されるのメッセージ型です。<code>uMsg</code>と<code>lParam</code>という2つのパラメータは、メッセージ固有のデータを格納しています<sup id="fnref:5"><a href="#fn:5" class="footnote-ref">5</a></sup>。<code>WndProc</code>はメッセージにレスポンスする際に（多くの場合、追加的なアプリケーション固有のメッセージを送ることにより）どんなデータストアも更新します。次に、もし適用できれば、データストアはスクリーンの関連部分を無効なものとしてマークすることができ、新たな描画サイクルを引き起こします。最後に、プログラマの心の平穏のために必要なことですが、多くのビューを、他のビューの内部と組み合わせることができます。仮想上は、Windowsで見られるどのウィジェット（あらゆるリスト、チェックボックス、ボタン、メニュー）もそれぞれが、実際には小さな<code>WndProc</code>とメッセージを持った小さな再利用可能なビューです。</p><p>これはまさにFluxが行っていることです。Fluxの公式レポジトリのサンプルアプリケーションを見ると、このデザインがはっきりと分かります。これまで旧Windowsのプログラミングで行ってきたような、<a href="https://github.com/facebook/flux/blob/master/examples/flux-todomvc/js/constants/TodoConstants.js" rel="nofollow" title="" class="ext-link">enumとして定義されているメッセージ<sup id="fnref:6"><a href="#fn:6" class="footnote-ref">6</a></sup></a>が確認できます。<a href="https://github.com/facebook/flux/blob/master/examples/flux-todomvc/js/stores/TodoStore.js#L120" rel="nofollow" title="" class="ext-link">全てのメッセージに対する大きなスイッチ宣言</a>が見られますし、メッセージの<code>actionType</code>に基づいて異なるデータが抽出されていることに気づきます。そしてもちろん、少量の内部状態に基づいて<a href="https://github.com/facebook/flux/blob/master/examples/flux-todomvc/js/components/MainSection.react.js" rel="nofollow" title="" class="ext-link">冪等にレンダリング</a>するコンポーネントも確認できます。</p><p>全ての古いものは再び、新しいものとなるのです。</p><p>Fluxが<em>有効</em>であるのは明らかです。それだけではありません。明らかに<em>スケール</em>します。Facebookが代表的なものですが、プログラマや企業はこのスタイルで巨大で機能的なアプリケーションを書いています。</p><p>しかし、それは驚くに値しません。結局、多くの企業が、古いバージョンのWindowsでも同様に、巨大で機能的なアプリケーションを書きました。Fluxが<em>有効</em>で、有効なだけではなくさらに<em>以前のものよりも優れている</em>からといって、それがWeb開発の最終的な形であるとは言えません。</p><p>Windowsが<code>WndProc</code>に由来するコードにずっと縛り付けられていたわけではないように、Web開発の進歩がここで止まることはないと信じています。私たちはInterface Builderと Morphicを再発見するでしょう。VisualAgeや Delphi、そしてVisualBasicに関して新たなWebベースの考え方を持つようになるでしょう。その内部でFluxが息づいていたとしても、そうしたことについて、日単位で考える必要はありません。そうしたことは、いずれ起きると分かっています。これまで何度となく、多くのプラットフォームで起きたことだからです。歴史的に見ると、多くの前例があります。ただ、待てばよいのです。</p><p>ただし、今、過去を振り返ってみることの利点があるとすれば何でしょうか。それは、単に1980年代半ばの手法をWeb開発にあてはめただけに過ぎないと認識することによって、私たちは、前回よりも少しだけ早くこのフェーズを乗り越えられるだろう、ということです。</p><p>そうなることを期待しています。</p>
