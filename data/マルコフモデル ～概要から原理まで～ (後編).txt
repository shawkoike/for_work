<p><a href="https://hackernoon.com/from-what-is-a-markov-model-to-here-is-how-markov-models-work-1ac5f4629b71" rel="nofollow" title="" class="ext-link">From “What is a Markov Model” to “Here is how Markov Models Work”</a> （2017-01-29） by <a href="https://github.com/alexander-dejeu" rel="nofollow" title="" class="ext-link">Alexander Dejeu</a></p><p><span class="trans-notice">本記事は、元記事を翻訳した記事の後編となります。</span><br>
<span class="trans-notice">A節については<a target="blank" href="http://postd.cc/from-what-is-a-markov-model-to-here-is-how-markov-models-work-1/">前編</a>をご参照ください。</span></p><p>＊＊免責事項＊＊ 🦊 上で説明したマルコフモデルを作る時と同じプロセスで進めますが、いくつかのステップは省きます。もし、何か分からないことが出てきたら、最初のセクションを参照してください🔥</p><p>最初のドクター・スースの言葉はそのまま取っておき、私が更に見つけた、ドクター・スースの<strong>不朽の</strong>名言を4つご紹介します。</p><p>最初の文章と、これらの新しい文章の最も大きな違いは、いくつかの<strong>キー</strong>においては、異なるキーが<strong>不規則な回数</strong>、続いている点です。例えば “more” は “the” の後に4回続いています。では新たに加わった複雑さは、マルコフモデルにどのような影響を与えるのでしょうか？　🤔 全体としては、文章の論理的結論を<strong>改善できる</strong>でしょう。つまり何が言いたいかというと、英語という言語では、ある単語が他の単語より多く出現するということです（これについては、どんな言語でも同じことが言えます）。例えば、毎日の会話の中で “a” は “wizard” よりもずっと多く出てきます🎩　世の中の仕組みと同じです。これを考えると、あるキーの出現回数が他のキーよりも多く出現するということは、原文により近づけるために<strong>非常に重要</strong>なことです😊　マルコフモデルでは、次のステップを決める際に<strong>重み付け</strong>を考慮することが知られています。</p><p>各<strong>キー</strong>に続く、<strong>キー</strong>とその出現回数が保存されたウィンドウをプログラム上💻で示す方法があります。これがディクショナリの使用で、ディクショナリの<strong>キー</strong>は<strong>現在のウィンドウ</strong>を示します。そして<strong><em>ディクショナリのキー</em></strong>の値を、<strong>キー</strong>として追従する<strong>固有のトークン</strong>を保存する別のディクショナリに変えます。そして、それらの値が<strong>出現回数</strong>となります。これを聞いて、すでに説明した内容を思い出しませんか📊？　<strong>ヒストグラム</strong>！　その通りです。<em>内部のディクショナリ</em>は単独で<strong>キー</strong>と出現回数の記録を行うヒストグラムに分割されます。そう、驚くほどたくさんのキー🔑とディクショナリが出現します。もしコードに興味があれば、以下をチェックしてください👇。しかし興味がない場合でも認識だけはしておいてください。これは、より高度なモデルを作成する上で、どの<strong>キー</strong>がどの<strong>キー</strong>に続くかを追跡し、そしてそれらのキーの<strong>出現回数</strong>を記録する必要があります。</p><p>それでは、短い余談の後、実際の例を見て説明していきましょう😋🍴　優れたコーパスにするには<strong>とても</strong>小さいですが、このデータセットはクールです。なぜかって？　異なる言葉の分布を得ることができる素晴らしい点がありますし、構造全体に影響を与えることができるからです。しかし、<strong>固有で自然</strong>に生成された文を生成することを目的とした大きなスコープの場合には、<strong>最低でも20,000</strong>トークンはあった方がいいでしょう。最低<strong>100,000</strong>トークンあれば、なおいいと思います。そして、驚くほど素晴らしいモデルを作りたいなら、<strong>500,000</strong>以上のトークンを目指してください🚀</p><p>では、以下のように大規模な例を使って、単語の分布がどのように<strong>1つのキーウィンドウ</strong>に配置されるかについて見ていきましょう。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1200/1*e8mGc21E4cK5A-gixEoFoA.png" src="https://cdn-images-1.medium.com/max/1200/1*e8mGc21E4cK5A-gixEoFoA.png"><br>
<span class="center">色分けされたキーの分布</span></p><p>これは素晴らしいですね😎　全データを見てください。事前にデータをきれいに整理しておいたので、コーパスの各一意の<strong>キー</strong>には、それに続く<strong>キー</strong>と<strong>出現回数</strong>が含まれた配列が表示されています。いいですね！</p><p>ここで秘密をお教えしましょう😏　今回のマルコフモデルと最初のモデルとでは、少し違いがあります。どちらの場合も<strong>単に現在の状態に基づいて</strong>次のステップが決められていますが、単語の分布を保存することは、次のステップの重み付けを可能にします。実際の例を使って説明しましょう。</p><p>素晴らしい！👏　マルコフモデルの現在の状態が “more” であった場合、次に続く単語は、 “things” 、 “places” または “that” のどれかがランダムに選択されることになります。しかし “that” の出現回数は、 “things” や “places” の2倍です。つまり、 “that” が選択される可能性は50％、 “things” もしくは “places” が選択される可能性は25％ということになります！😃</p><p>☝️☝️☝️いいですね。では、上記に似た例を見てみます。今回のように、 “think” が現在の状態であった場合、 “high” 、 “up” 、 “right” 、 “low” 、そして “left” の単語が次の状態として選択される可能性は、それぞれ20％となります。理解できましたか？💭</p><p>これまでは、<em>ウィンドウ</em>のサイズが1つの場合のマルコフモデルを見てきました。それでは、より <strong>“正確”な文</strong> を取得するために、ウィンドウのサイズを増やしてみたいと思います。ここで言う正確とは、モデルによって生成される文のランダム性を軽減するということです。そうすることで、コーパスにある原文により近づけることができるのです。ただし、この処理が良い場合もあれば悪い場合もあります😇 😈　と言うのも、マルコフモデルの目的が一意のランダムな文を忠実に生成することである場合、小さなウィンドウにする必要があるからです。大きなウィンドウを使用するのは、<strong>100,000以上のトークン</strong>を含む<em>著しく</em>大きなコーパスの場合にのみ有効的です。</p><p>ウィンドウのサイズを増やすことを、マルコフモデルでは<strong>“高次”</strong>と呼んでいて、これまでの例で示してきたモデルは<strong>一次マルコフモデル</strong>と言います。つまり二次マルコフモデルと言った場合は、ウィンドウのサイズが2つということになります！　同様に、三次であればウィンドウサイズは3つです。</p><p>ウィンドウとはマルコフモデルの現在の状態があるデータのことで、意思決定をする際に使用されます。小さなデータセット内に大きなウィンドウがあった場合、1つのウィンドウから起こるであろう結果に対する、大きな一意の分布があることは考えにくくなります。そのため、<strong>同じ文が改めて生成されるだけ</strong>でしょう。</p><p><strong>二次マルコフモデル</strong>、つまりウィンドウのサイズが2つある場合のモデルを使ったオリジナルの例を見てみましょう！</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1200/1*PXimcZKB-1y82tQJNTZ94g.png" src="https://cdn-images-1.medium.com/max/1200/1*PXimcZKB-1y82tQJNTZ94g.png"><br>
<span class="center">二次マルコフモデル</span></p><p>とても興味深いですね！　何か気付いたことはありますか？🕵️　一意のウィンドウサイズが2つである全ウィンドウには、<strong>起こるであろう結果が1つ</strong>しかないことに気付いたでしょう。つまりこれは、どの単語から開始したとしても、常に同じ文を取得するということになります。なぜなら、オリジナルの過程から外れてしまう可能性がないからです。同じ文が生成される確率は100％となります👎　よくないですね。これは、マルコフモデルが持つ潜在的な問題を明らかにしています。十分に大きなサイズのコーパスを持っていないと、一意の文を生成することのないコーパス内で、単に文を生成するだけということなります。<strong>500,000以上のトークンを含む大規模なデータセット</strong>を入手し、<strong>異なる高次</strong>マルコフモデルを使って<strong>色々と試してみてください</strong>👍</p><p>Dictogramの目的は、ヒストグラムと同様の働きをさせることですが、こちらの場合は起動が非常に早く💨、データセットの大きさにかかわらず、一定の時間で検索を行ってくれます。簡単に言うと、Dictogramはディクショナリを使ったヒストグラム構築と言えます。なぜならディクショナリには、一定の検索時間O(1)を持つ一意のプロパティがあるからです！</p><p>Dictogramクラスは、単語リストや書籍全体といった、繰り返し使用が可能なデータセットを使って作成することができます。私は、Dictogramクラスを作成する際に<strong>トークン</strong>数と<strong>キー</strong>数を記録しておき、全データセットを調べることなく、これらの値にアクセスできるようにしておきました🤓</p><p>また、ランダムな単語を返す2つの関数も作成したので、こちらも覚えておくといいでしょう。1つは、<strong>ランダムなキーを選択する</strong>だけの関数で、もう1つは、各単語に対する出現回数を考慮し、<strong>重み付けされたランダムな単語</strong>を返す関数です🏋️♀️</p><p>マルコフモデルが<strong>何なのか</strong>から話を初めて、ここまでくるのに随分と長い旅でした。ここからは、マルコフモデルを<strong>どのように</strong>実装するかについて話していきたいと思います🌄</p><p>私の実装では、<strong>Key-Valueペアにあるキー</strong>として<em>ウィンドウ</em>を保存する<strong>ディクショナリ</strong>を持っており、各<em>キー</em>の<em>値</em>が<strong>Dictogram</strong>となります。つまり、各ウィンドウに単語のヒストグラムを保存することで、現在の状態に基づいた次の状態が何であるかを知ることができます😌　現在のウィンドウにデータが存在する場合は、キーに対するDictogram内のデータをインクリメントします。</p><p><strong>高次マルコフモデルをどのように実装するのか</strong>気になっている方もいると思います。私がどのように行ったのか、以下で説明しましょう😏</p><p>☝️☝️☝️☝️☝️ 一次マルコフモデルと非常によく似ていますが、この場合、<strong>Key-Valueペア</strong>内に<strong>キー</strong>として<em>タプル</em>を<strong>ディクショナリ</strong>に保存しています。その理由は、シングルリストを表すには<em>タプル</em>が最適な方法だからです。また、リストの代わりにタプルを使うのは、ディクショナリ内のキーが変更されるべきではないからです。タプルは不変なので、変更されることはありません🤷‍♂️</p><p>やりました！！🎉👏 🎉 Dictogramの実装が完了しました。しかし、<strong>現在の状態</strong>に基づくコンテンツを生成してから、新しい状態へのステップはどうなるのでしょう？👇👇👇以下のモデルを使って説明します🚶</p><p>さて、個人的には、有効な最初の文の単語だけを使いたいと思っていたので、<strong>END</strong>キーのDictogram内を全て確認しました🐶　他の方法としては、（有効な最初の文から生成された）<strong>最初の状態</strong>を使って生成されたデータから開始し、<strong>現在の状態に続く可能性のあるキー</strong>を（Dictogram内で）探し続けます。そして<em>確率</em>と<em>ランダム性</em>（<strong>重み付けされた確率</strong>）に基づいて決断を下します。これを<em>length</em>回行うまで何度も繰り返します💯</p><p>マルコフモデルの典型的な例には、天気予報や証券取引、ツイートの生成に基づいた人々の行動があります！🐣　<strong>マルコフモデル</strong>に基づいた<strong><em>新規コンテンツ</em></strong>を作成し、<em>生成する</em>ために、どのように<strong>コーパス</strong>を活用することができるか考えてみてください。また、どういった変化があるでしょう？<br>
ヒント：マルコフモデルがどういうもので、なぜそれが必要なのか、そしてどのようにそれが機能し、作成されるのかをしっかりと理解できていれば、大きな変化がないことは分かるでしょう。<strong>唯一、違い</strong>があるとすれば、<em>マルコフモデルをどのように解析するか</em>という点と、<em>一意の制限</em>を加えるかどうかです。</p><p>例えば、私の粋な<a href="http://tweet-generator-alex.herokuapp.com/" rel="nofollow" title="" class="ext-link">シリコンバレー・ツイート・ジェネレータ</a>では、大きなウィンドウを使用し、生成されるコンテンツを140文字までと制限しました。不定量の文が存在する可能性があったので、文の “シード” を設定するために既存の文の最初のウィンドウだけを使用しました🌱</p><p>マルコフモデルがどういうものであるかについてよく理解できたと思いますので、次は、隠れマルコフモデルについて理解を深めてみるといいでしょう。今回新しく学んだ知識を使って何かを作成したいと考えているのであれば、マルコフモデルを使ったHBOシリコンバレー・ツイート・ジェネレータの構築に関する私の記事を読んでみてください（近日中に投稿予定）！</p><p>私は常にフィードバックをお待ちしていますので、この記事の構成や内容、取り上げた例、その他何でもいいので、皆さんの考えを共有してください😊　マルコフモデルは素晴らしいツールですし、このモデルを使って何か構築してみることをお勧めします。独自のツイート・ジェネレータを構築してみるのもいいですね😜　それでは！🤗</p><p><em>この記事を気に入っていただけたようであれば、以下に表示されている💚をクリックしてください。Mediumに登録している方にも閲覧していただくことが可能になります。</em></p><p><span class="trans-notice">訳注:元記事へのフィードバックは、<a href="https://hackernoon.com/from-what-is-a-markov-model-to-here-is-how-markov-models-work-1ac5f4629b71" rel="nofollow" title="" class="ext-link">元記事</a>から行ってください。</span></p>
