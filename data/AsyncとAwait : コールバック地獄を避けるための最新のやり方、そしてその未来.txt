<p><a href="https://zeit.co/blog/async-and-await" rel="nofollow" title="" class="ext-link">Async and Await</a> （2016-06-02） by <a href="https://twitter.com/zeithq" rel="nofollow" title="" class="ext-link">Guillermo Rauch</a></p><p><small>(2016/7/7、いただいたフィードバックを元に記事を修正いたしました。)</small></p><p>JavaScript、特にNode.jsといえば、<em>コールバック地獄</em>がよく連想されます<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup>。たくさんの非同期I/Oを扱うコードを書いたことがある方には、おそらく以下のようなパターンはおなじみでしょう。</p><p>このコードは、もっと簡単で安全に書けることが分かっています。</p><p>以下では、<code>Promise</code>に<code>async</code> / <code>await</code>を組み合わせて書く方法をご紹介しますが、これらの新しい機能を本番環境で使った経験から得た教訓についてもお話ししたいと思います。</p><p>まずは、上記の例に潜む落とし穴を見ていきましょう。</p><p><em>エラーは、次の処理に渡す</em>だけでいいという場合が大多数です。</p><p>ですが上記の例では、何度も繰り返し書いています。また、<code>return</code>を入れ忘れてしまい、実際にエラーが起きて初めて（それとないデバッグをしてみて）気づくことが多いでしょう。</p><p>エラーが発生すると、一般的なライブラリは大抵、<code>Error</code>パラメータと共にコールバックを呼び出し、成功した場合には代わりに<code>null</code>を使います。</p><p>ただ残念ながら、必ずしもそうなるとは限りません。<code>null</code>ではなく<code>false</code>を使う場合もあるのです。これを完全に省略するライブラリもあります。いくつものエラーが起きたら、コールバックが何度も呼び出されるかもしれません。これは次の問題を引き起こしてしまいます。</p><p>コールバックは直ちに開始されるのでしょうか？　それとも別の<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="nofollow" title="" class="ext-link">マイクロタスク</a>上で？　または別のティック（tick）上で？　時々？　常に？</p><p>それは誰にも分かりません。自分が書いたコードを読んでもきっと分からないでしょう。ライブラリのドキュメントを読めば、運が良ければ分かる<em>かも</em>しれません。</p><p>コールバックが、予期せず<strong>複数回</strong>開始されることもあり得ます。やはり、この場合もほぼ間違いなく、<em>デバッグが極めて難しい</em>コードになってしまうでしょう。</p><p>コードが動き続ける場合もあるかもしれませんが、見込まれたとおりの動作はしないでしょう。そうでない場合は、スタックトレースが得られるかもしれませんが、それが根本的原因を必ずしも明らかにしてくれるとは限りません。</p><p>こうした問題の解決策となるのが、<code>Promise</code>での標準化です。</p><p>promiseは、明確な取り決めとAPIを提供します。その取り決めの細部やAPIが最善のものであるかは意見が分かれるでしょうが、定義は厳密になされています。</p><p>したがって、エラー処理やスケジューリングが指定されていないという前述の問題については、<code>Promise</code>を用いたコードを扱っている際は心配する必要がありません。</p><p>以下のコードは、<code>setTimeout</code>に相当する処理が<code>Promise</code>を使うとどのように書けるかを示したものです。</p><p>promiseには、resolved、rejectedという2つの確定された状態があります。上の例で分かるように、resolvedの値とrejectedの値を得るために1組のコールバックを設定することができます。</p><p><em>コールバックをpromiseに渡す</em>ということは、誤った二分法のような状況になりがちです。言うまでもなく、promiseが意味のある動作をするにはコールバックが必要です。したがって、本当の比較対象となるのはpromiseと、JavaScriptコミュニティが<em>暗黙のうちに</em>了解しているコールバック<strong>パターン</strong>なのです<sup id="fnref:2"><a href="#fn:2" class="footnote-ref">2</a></sup>。</p><p>promiseは<em>単一の</em>値を表現します。前述のコールバックパターンとは異なり、エラーを得たあとで特定の呼び出しを成功させることはできません。ある値を得たあとにエラーを得ることもできません。</p><p><code>Promise</code>の<code>resolve</code>は<code>return</code>に相当し、<code>reject</code>は<code>throw</code>に相当すると見なすことができます。後ほど見ていきますが、この意味上の等価性は<code>async</code>、<code>await</code>というキーワードで<strong>構文的に実現</strong>されます。</p><p>スケジューリングに関しては、<code>Promise</code>の仕様はコールバックを必ず”未来の時点”（例：次のマイクロタスク）で呼び出すように<em>定めて</em>います。このため、<code>Promise</code>の挙動は、状態が<em>確定済み</em>か否かにかかわらず、<code>then</code>や<code>catch</code>を呼び出す際には常に非同期的になります。</p><p>最初の例をこのAPIで書くと、以下のようになります。</p><p>既にずっと良くなっていますね。とはいうものの、ロジックを変えるとすれば、コードのリファクタリングがたちまち複雑になってしまいます。</p><p>仮に、上記のコードでは、<code>filterUsersWithFriends</code>の特定のエラー型については異なる処理が必要だとしましょう。</p><p>“便利な仕組み”をどんなに連鎖させても効果は上がりません。解決策を見ていきましょう。</p><p>C#とF#の<a href="http://tirania.org/blog/archive/2013/Aug-15.html" rel="nofollow" title="" class="ext-link">世界</a>では以前から知られているように、この問題を解決する見事な方法があります。</p><p>上記を機能させるために必要なのは、依存対象のI/Oを実行する関数（<code>getUsers</code>など）が確実に<code>Promise</code>を返すようにしておくことだけです。</p><p>これでコードが（前述の連鎖した例よりも）読みやすくなるだけでなく、エラー処理の挙動が通常の同期的なJavaScriptコードと全く同じになります。</p><p>すなわち、関数を<code>await</code>すると、エラーは（もしあれば）表に出てthrowされます。上記の<code>getLikes</code>関数が呼び出される場合、エラーはデフォルトで発生します。特定のエラーについては異なる処理をしたいという場合は、<code>await</code>の呼び出しを<code>try</code>/<code>catch</code>でラップすればいいのです。</p><p>こうすれば、<code>if (err) return fn(err)</code>を至る所に書く（または、もっと悪い対処としては無視する）ことがなくなるので、生産性と正確さが向上するでしょう。</p><p>今後の見通しは、どの程度立っているのでしょうか？</p><p><strong>▲ZEIT</strong>ではこれらの機能をもう何カ月も使ってきましたが、非常に満足していますし、作業の生産性も上がっています。</p><p>私は最近、BabelとNode 6を用いたトランスパイル用<a href="https://gist.github.com/rauchg/8199de60db48026a6670620a1c33b700" rel="nofollow" title="" class="ext-link">ガイドを公開</a>しました。これはES6のサポートに優れているため、今や<strong>変換プラグインを2つ</strong>しか必要とせず、コンパイルの性能も素晴らしいものとなっています。</p><p>ブラウザや古いバージョンのNodeへのサポートが必要な場合は、<code>es2015</code>プリセットもインクルードすることを推奨します。そうすれば、ジェネレータではなくステートマシンへとコンパイルすることができます。</p><p>この機能を最大限に活用するにはエコシステムから、コールバックだけでなく、<code>Promise</code>を使用するモジュールを使うべきでしょう。</p><p>以上に加えて、Nodeでは標準ライブラリにおいて<code>Promise</code>を直接返すことが検討されています。その<a href="https://github.com/nodejs/node/pull/5020" rel="nofollow" title="" class="ext-link">議論はこちら</a>でご覧いただけます。</p><p>同じく強調しておきたいのは、この構文によって<code>Promise</code>がコードベースからなくなるわけではないということです。実際、<strong>頻繁に必要になり</strong>ますので、完全に理解していなくてはなりません。</p><p><code>Promise</code>が出現する一般的な例としては、ループの一部で複数の値を必要とするコードが挙げられます。その際、複数の値は同時に要求されます。</p><p>また、前述の例（<code>async getLikes()</code>）で、<code>return await getUserLikes()</code>ではなく<code>return getUserLikes()</code>としていることにも注目してください。</p><p><code>async</code>というキーワードの目的は、関数が<code>Promise</code>を返すようにすることですので、これら2つのスニペットは等価です。</p><p>つまり、以下のコードは完全に有効であり、「<code>await</code>付きで呼び出された場合は<em>次のマイクロタスクで</em>処理の解決を行う」という点を除けば、相当する同期処理<code>const getAnswer = () =&gt; 42</code>と等価なのです。<code>await</code>なしで呼び出された場合は<code>Promise</code>を返します。</p><p>上記で、コールバックを使うと遭遇しがちな多くの問題を解決するために定められた<code>Promise</code>の仕様を述べてきました。</p><p>次に、未解決の問題と新たに生まれた問題について説明するとともに、まだ仕様が定まっていないものの我々のニーズにとって重要な挙動について説明します。</p><p><code>Promise</code>を使うときにエラーハンドラを付けないと、多くの環境ではエラーに関する情報は決して得られないでしょう。</p><p>これはコールバックパターンで<code>err</code>パラメータを無視することと同じですが、目的の値にアクセスしようとすると<code>TypeError</code>が発生する可能性があるという点が違います。</p><p>コールバックパターンでは、なんとかして<code>err</code>を<em>無視</em>することができても、そのエラーが後で実際に発生したときにクラッシュして判明するでしょう。</p><p>でも普通、<code>async</code>と<code>await</code>を使ってエラーを無視するのは非常に困難です。例外的に、非同期コードの<em>エントリポイント</em>が使えるでしょう。</p><p>幸いなことに、この問題には回避策と、おそらく決定的な解決策があります。</p><p>最後に、先に私は「<code>Promise</code>は1回しか解決されないので、コールバックのように期待に反して何度も繰り返されることはない」と書きました。</p><p>ここにも問題があるのです。<code>Promise</code>はその後の解決を帳消しにし、さらに問題なことにrejectionも帳消しにしてしまいます。ログに記録されることのないエラーが存在するかもしれません。</p><p>元々の<code>Promise</code>仕様では、ある値の非同期の読み込みが進行しているときに、それを<em>キャンセル</em>することの意味は考慮されていませんでした。</p><p>運命の巡り合わせか、ブラウザのベンダーは、HTTPリクエストのように昔からキャンセルの必要があった関数の戻り値として、このキャンセルを実装するようになりました。</p><p>つまり、<code>XMLHttpRequest</code>を使えば、結果のオブジェクトに<code>abort</code>を呼び出すことができるのに、ピカピカの新機能<code>fetch</code>では……なんと、呼び出せないのです。</p><p>TC39は現在、第3の状態、つまり「キャンセル済み」を追加することを検討しています。第一段階の案について、詳しくは<a href="https://docs.google.com/presentation/d/1V4vmC54gJkwAss1nfEt9ywc-QOVOfleRxD5qtpMpc8U/edit?usp=sharing" rel="nofollow" title="" class="ext-link">こちら</a>を参照してください。</p><p><code>Promise</code>には改めて付け加えられることになるのですが、キャンセルは、次に説明する抽象化、<code>Observable</code>の必須な属性なのです。</p><p>この記事では既に、<code>Promise</code>で解決を待つことは、ある関数が何らかの動作を行いながら同期的に値を返すことに似ているということを明らかにしました。</p><p><code>Observable</code>は、<strong>ゼロ個以上の値</strong>を返すことのできる関数呼び出しを表す、より一般的な（したがって、より強力な）抽象化です。</p><p><code>Promise</code>とは異なり、<code>Observable</code>オブジェクトは同期的（同一ティック）または非同期的に値を返すことができます。</p><p>このような設計によって、<code>Observable</code>は幅広い使用事例に適しています。</p><p>下記の例では前記の例の趣旨に沿って、<code>Observable</code>を<code>setInterval</code>と共に使用して、時間が経過した後に値を返します。</p><p>前述したように、<code>Observable</code>は幅広い可能性に対応します。この観点から見れば、<code>Promise</code>は単に、単一の値を返す<code>Observable</code>なので、次のようになります。</p><p><code>Observable</code>のセットアップで返される値はクリーンアップを行う関数だということに注意してください。そのような関数は、残りのサブスクリプションがなくなると実行されます。</p><p>このことは、<code>Promise</code>に欠けている別の役割、つまりキャンセルを<code>Observable</code>が担うということを意味します。このモデルでは、キャンセルは、単に<em>observationが終わったこと</em>の結果です。</p><p>そうは言っても、非同期の動作の多くは<code>Promise</code>サブセットだけで表現しても上手くいきます。実際、Node.jsのコアライブラリのうち多くでは、それしか必要ありません<br>
（例外は<code>Stream</code>と、いくつかの<code>EventEmitter</code>インスタンス）。</p><p><code>async</code>と<code>await</code>に関してはどうでしょうか？　ある<code>Observable</code>の挙動を<code>Promise</code>と同じに制限する演算子（RxJSなどのライブラリには<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/topromise.md" rel="nofollow" title="" class="ext-link">既にあります</a>）を実装して、<code>await</code>することもできます。</p><p>この例は、動作の一般化を示します。<code>timer</code>関数は<code>delay</code>と同じ使い勝手がありますが、さらにインターバル<em>にも</em>使えます。</p><p><code>async</code>と<code>await</code>を使えば、コードベースを著しく改善することができます。</p><p>私たちのオープンソースライブラリ<a href="https://github.com/zeit/micro" rel="nofollow" title="" class="ext-link">micro</a>は、リクエスト応答サイクルをどれほど単純明快にできるかの良い例です。</p><p>下記のマイクロサービスは、あるデータベースの<code>JSON</code>エンコードされたユーザ配列を返します。<br>
ハンドラのいずれかがスローすれば、応答はアボートされて<code>err.statusCode</code>が返ります。<br>
未処理の例外が発生すると、応答<strong>500</strong>が生成され、エラーがログ記録されます。</p><p>前述したように、ES6モジュールに最上レベルの<code>await</code>を認めるための提案がなされています。Node.jsでは、これは次のようなコードが書けることを意味します。</p><p>では、これをラッパーなしで（そして、簡単明瞭なエラー処理を使って）実行してみましょう！</p><p>同時に<code>Observable</code>は、この言語の主要な構成体になるように、TC39で<a href="https://github.com/zenparsing/es-observable" rel="nofollow" title="" class="ext-link">進歩</a>し続けています。</p><p>同時性と同期性を管理するための、この新しいプリミティブ群がJavaScriptエコシステムに非常に深い影響を及ぼすと私は確信しています。<strong>その時がやってきました。</strong></p>
