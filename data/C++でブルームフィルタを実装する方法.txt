<p><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/" rel="nofollow" title="" class="ext-link">How to write a Bloom filter in C++</a> （2016-04-11） by <a href="http://blog.michaelschmatz.com/" rel="nofollow" title="" class="ext-link">Michael Schmatz</a></p><p>ブルームフィルタとは、「ある要素が集合のメンバである可能性があるか、それとも確実に集合のメンバではないか」を効果的に確認することのできるデータ構造です。この記事では、C++でブルームフィルタを実装する簡単な方法をご紹介します。<a href="http://billmill.org/bloomfilter-tutorial/" rel="nofollow" title="" class="ext-link">ブルームフィルタとは何なのか</a>、また、<a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AB%E3%83%BC%E3%83%A0%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF" rel="nofollow" title="" class="ext-link">その背後にある多くの数学的要素</a>については紹介していませんので、ご了承ください。これらのトピックに関しては、素晴らしいリソースがあるので、そちらを参考にしてください。</p><p>まずは、ブルームフィルタを定義していきましょう。ここでは、3つのパブリック関数を定義していきます。</p><p>また、フィルタの状態を保持するビットの配列を含んだ、メンバ変数についても定義します。</p><p>1つ覚えておいていただきたいのは、<code>std::vector&lt;bool&gt;</code>は<code>std::vector</code>の空間効率性に特化したもので、1つの要素に対して1ビットしか必要としないことです（一方、通常の実装では1要素に1バイトが必要）。</p><p><strong>アップデート：HNの<code>nate_martin</code>は、拡張としてこの構造体をテンプレート化することを勧めています。キーの型やハッシュ関数をハードコード化する代わりに、例えば以下のようなコードと一緒にクラスをテンプレート化することができます。</strong></p><p><strong>これにより、より複雑なデータ型にブルームフィルタを一般化することが可能になります。Nateありがとう！</strong></p><p>ブルームフィルタを構成する上で使われたパラメータは以下の2つです。</p><p>フィルタサイズ<em>m</em>、ハッシュ関数の数<em>k</em>、そして挿入された要素の数<em>n</em>を基に、公式を使って、偽陽性によるエラー率<em>p</em>を割り出すことができます<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup>。</p><p><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d_1.jpg" alt="d_1" width="254" height="94"></p><p>現在の形式のままでは、この公式は役に立ちません。与えられた推定集合濃度とエラー許容範囲を元に、望ましいフィルタサイズはどれぐらいか、使用するハッシュ関数がいくつなのかを知ることができる計算式にしたいと思います。これらのパラメータを計算するには2つの方程式を使うことができます。</p><p><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d_2.jpg" alt="d_2" width="267" height="236"></p><p>もう1点だけ、必須の理論があります。ハッシュ関数<em>k</em>は一体どう実装するのかと思われたかもしれません。偽陽性の確率に影響を与えることなく、<em>k</em>のハッシュ値を生成するには、<a href="https://en.wikipedia.org/wiki/Double_hashing" rel="nofollow" title="" class="ext-link">ダブルハッシュ法</a>が使えます。これは以下の公式で表せます。<em>i</em>が序数であるなら、<em>m</em>はブルームフィルタのサイズで、<em>m</em>はハッシュされる値です。</p><p><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d_3.jpg" alt="d_3" width="707" height="96"></p><p>より詳しい証明は、<a href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=4060353E67A356EF9528D2C57C064F5A?doi=10.1.1.152.579&amp;rep=rep1&amp;type=pdf" rel="nofollow" title="" class="ext-link">このペーパー</a>を読んでください。</p><p>まず、コンストラクタを記述しましょう。単純にパラメータを記録し、ビット配列のサイズを変える役割があります。</p><p>次に、指定されたアイテムの128bitのハッシュを計算する関数を記述します。128bitのハッシュ関数で、パフォーマンス、分布、雪崩のふるまい、衝突耐性の間の最適なトレードオフを実現する<a href="https://github.com/aappleby/smhasher" rel="nofollow" title="" class="ext-link">MurmurHash3</a>を使います。この関数は128bitのハッシュ値を生成しますが、ここでは2つの64bitのハッシュが必要なので、ハッシュの戻り値を半分に分ければ<img src="http://postd.cc/wp/wp-content/uploads/2016/05/d_2b.jpg" alt="d_2b" width="93" height="28">と<img src="http://postd.cc/wp/wp-content/uploads/2016/05/d_1b.jpg" alt="d_1b" width="101" height="33">を取得できます。</p><p>これでハッシュ値が得られますので、<img src="http://postd.cc/wp/wp-content/uploads/2016/05/d_3b.jpg" alt="d_3b" width="36" height="27">ハッシュ関数<br>
の出力を返すための関数を書く必要があります。</p><p>あとは、指定されたアイテムのビットを設定またはチェックする関数を記述するだけです。</p><p>私のラップトップでは、4.3MBのブルームフィルタと13のハッシュ関数で、180万のアイテム挿入が1要素につきおよそ189ナノ秒でできました。偽陽性の確率も、理論上の値と適合しています。</p><p>より良い実装のアイデアがあれば、コメントを残すか、<a href="mailto:blog@michaelschmatz.com">メッセージを送ってください</a>。読んでくださってありがとうございます。</p>
