How I start Go by Peter BourgonGoは、信頼できる賢い人たちによって作られた愛すべきささやかなプログラミング言語で、現在も成長中の大規模なオープンソースコミュニティによって、継続的に改善が続けられています。Goの基本原則はシンプルであることですが、時折、約束事が分かりにくいこともありますね。以下では、私がどのようにしてGoのプロジェクトを始め、どのようにGoのイディオムを使っているかを紹介したいと思います。一緒に、Webアプリケーション用のバックエンドサービスを構築しましょう。最初のステップは、もちろんGoをインストールすることです。オフィシャルサイトに用意されている、お使いのオペレーティングシステム用のバイナリディストリビューションを使ってください。MacでHomebrewを使っている場合は、brew install goでうまくいくと思います。インストールが終わったら、次のように動作するはずです。インストール完了後にGOPATHの設定をしてください。GOPATHは、Goのコードや中間生成物を収めるためのルートディレクトリです。この設定をすると、GOPATH内には3つのサブディレクトリ（bin、pkg、src）が生成されます。人によっては、これに$HOME/goのような設定をする方もいますが、私はシンプルに$HOMEとしています。お使いの環境で、これがきちんとエクスポートされるかどうかを確認してください。bashを使っている場合は、次のようにしてもいいと思います。Goには様々なエディタやプラグインが使用できますが、個人的にはSublime Textと優秀なGoSublimeプラグインがお気に入りです。ただ、言語そのものが分かりやすいため、特に小規模のプロジェクトにおいては、シンプルなテキストエディタでも十分に事足りるかと思います。私と一緒に作業をしているフルタイムのGo開発者のプロは、いまだに通常のVimをシンタックスハイライトもせずに使っているほどです。だから、始めるのに大層なものは必要ありません。シンプル・イズ・ベストですよね。機能的な環境が整ったら、プロジェクトのために新しいディレクトリを作りましょう。Goのツールチェーンでは、全てのソースコードは$GOPATH/srcにあることが前提のため、そこがワークスペースとなります。また、ツールチェーンは、GitHubやBitbucketといったサイトにホストされているプロジェクトを、それらが正しい場所にありさえすれば、直接インポートしたり、やり取りをしたりすることも可能です。この例として、GitHubで空のレポジトリを新規に作成してみます。仮に名前を「hello」として、$GOPATH内にそのレポジトリを設定してください。いいですね。main.goを作成します。これがGoの最小限のプログラムです。go buildを呼び出して、カレントディレクトリ内の全てをコンパイルします。これにより、ディレクトリと同じ名前のバイナリが生成されます。簡単ですね。Goを書き始めて数年が経ちますが、私はいまだにこうやって新規プロジェクトを始めています。手始めに空のGitレポジトリ、続いてmain.goを作成し、あとはわずかなタイピング操作のみです。共通の規則に従っているため、このアプリケーションは自動的にgo getが可能な状態になります。このファイルをコミットし、GitHubにプッシュした場合、Goがインストールされた作業環境では、次のことができるはずです。このhello, worldをWebサーバに転化してみましょう。以下がその全プログラムです。手順は次の通りです。まずは標準ライブラリからnet/httpパッケージをインポートする必要があります。次に、main関数の中で、Webサーバのルートパスにハンドラ関数を設定します。http.HandleFuncは、正式にはServeMuxと呼ばれており、デフォルトのHTTPルータ上で動作します。関数helloは、http.HandleFuncで、特定の型シグネチャを持ち、HandleFuncに引数として渡すことができることを意味します。ルートパスにマッチした新しいリクエストがHTTPサーバに来る度に、サーバはhello関数を実行する新しいgoルーチンを生成するというわけです。hello関数は、シンプルにhttp.ResponseWriterを使い、クライアントにレスポンスを返します。http.ResponseWriter.Writeは、パラメータとして、より一般的な[]byte（byteスライス）を取るので、文字列を単純に型変換すれば大丈夫です。最後に、http.ListenAndServe経由で、デフォルトServeMuxのHTTPサーバをポート8080で開始させます。これは同期、またはブロッキングやコールで、割り込みがあるまではプログラムを起動し続けます。先ほどのようにコンパイルして実行してみましょう。別のターミナルかブラウザで、HTTPリクエストを出してみてください。簡単ですね。インストールすべきフレームワークもなく、ダウンロードすべき外部依存関係もなく、作成すべきプロジェクトスケルトンもありません。バイナリ自体でさえ、静的にリンクされたネイティブコードで、ランタイムの依存関係もないのです。さらに、標準ライブラリのHTTPサーバは、一般的な攻撃に対する耐性を持つ本番用の製品グレードで、何の仲介もなしにインターネットからのリクエストを直接、処理することができます。もちろん、単にhelloと言う以外にも、もっと面白いことができますよ。都市を入力して気象データAPIを呼び出し、気温と共にレスポンスを送ってみましょう。OpenWeatherMapは、現在の天気予報用のシンプルなフリーAPIを提供しており、都市名によってクエリができるようになっています。そして、次のようなレスポンスを返します（一部編集済みです）。Goは静的型付き言語であるため、このレスポンス形式を反映した構造を作成する必要があります。情報は全てではなく、必要な分だけ取得できれば大丈夫です。現状、都市名と（面白いことに）ケルビンで返される気温を取得してみましょう。ここで、気象データAPIから戻された必要データを表現するための構造体を定義します。typeは、新しい型を定義するキーワードです。名前をweatherDataとし、構造体として宣言します。構造体の各フィールドには名前（例：Name、Main）、型（string、別の無名struct）、そしてタグと呼ばれるものがあります。タグはメタデータのようなもので、構造体へのAPIのレスポンスを直接、展開するためにencoding/jsonパッケージを使えるようにするものです。PythonやRubyといった動的プログラミング言語に比べると、入力が多くなるものの、非常に理想的な形で型の安全性の特性が得られます。JSONとGoについてのより詳しい情報は、ブログのこの投稿やこちらのコード例をご覧ください。これで構造体は定義ができました。次は、そこにデータを投入する方法を定義する必要があります。そのための関数を書いてみましょう。この関数は都市を表す文字列を受け取り、weatherData構造体とエラーを返します。これはGoの基本的なエラー処理のイディオムです。関数は振る舞いをエンコードしますが、振る舞いは概して失敗する可能性があります。この例で言うと、OpenWeatherMapに対するGETリクエストが失敗する理由はいくらでもあり、返されたデータが期待したものではない可能性もあります。いずれの場合も、クライアントにはnil以外のエラーを返します。そうすればクライアントは、呼び出し元のコンテキストに従ってそれを処理するはずです。http.Getが成功すると、レスポンスボディをクローズするための呼び出しをdeferして保留します。この呼び出しは関数スコープを離れる時（クエリ関数から戻る時）に実行されます。これはリソース管理の洗練された形です。その一方で、weatherData構造体をアロケートし、json.Decoderを使用してレスポンスボディから直接この構造体に展開します。余談ですが、json.NewDecoderはGoの洗練された機能であるインターフェースを利用します。DecoderはHTTPレスポンスボディの実体を受け取らず、http.Response.Bodyの要件を満たすio.Readerインターフェースを受け取ります。Decoderは、型に対して他の振る舞い（Read）の要件を満たすメソッドを呼び出すことで機能する振る舞い（Decode）を提供します。Goでは、インターフェースで動作する関数単位で振る舞いを実装することが多いです。これにより、データ転送と経路制御を明確に切り離し、モックを使ったテストを容易にし、論理的で分かりやすいコードを書くことができます。最後に、デコードが成功したら、成功を意味するnilエラーを付けてweatherDataを呼び出し元に返します。それでは、この関数をリクエストハンドラまでつないでみましょう。ここでは、ハンドラを個別の関数ではなくインラインで定義しています。strings.SplitNを使用して/weather/以降のパス全てを受け取り、それを都市として扱います。クエリを行いエラーがあればクライアントにhttp.Errorヘルパー関数を使って伝えます。HTTPリクエストを完了するため、その時点で戻る必要があります。エラーがない場合は、JSONデータを送信することをクライアントに伝え、json.NewEncoderを使って直接weatherData をJSON形式にエンコードします。ここまで、コードはいい感じです。手順に沿い、理解しやすいものになっています。誤った解釈の心配はありませんし、一般的なエラーを見逃す恐れもありません。「hello, world」ハンドラを/helloに移動し、必要なインポートを行うと、プログラムが完成します:ビルドして実行しましょう。前回と同じです。コミットしてプッシュしましょう！複数の気象データAPIにクエリして平均値を出せば、その都市のより正確な気温を出せるかもしれません。残念ながらほとんどの気象データAPIは認証が必要です。ここでは自分でWeather UndergroundのAPIキーを取得して下さい。すべての気象データAPIで同じ振る舞いをしてほしいので、その振る舞いをインターフェースとしてエンコードします。これで、先ほどのOpenWeatherMapクエリ関数を、weatherProviderインターフェースの要件を満たす型に変換できるようになりました。HTTP GETを行うために状態を保存する必要がないので、空の構造体を使用します。そして動作を確認するために、ロギングを行うためのシンプルな行を追加しましょう。レスポンスからはケルビン温度を取り出したいだけなので、レスポンス構造体はインラインで定義できます。それ以外は、openWeatherMap構造体でメソッドとして定義したクエリ関数とほとんど同じです。このようにして、openWeatherMapのインスタンスをweatherProviderとして使用できます。Weather Undergroundでも同じことをしましょう。唯一の違いは、APIキーを提供する必要があることです。キーを構造体に保存して、メソッド内で使用します。非常に似通った関数になります。（Weather UndergroundはOpenWeatherMapほどあいまいさを排除しないことに注意してください。ここでは例を示すことを優先して、あいまいな都市名を扱うための重要なロジックをいくつか飛ばします。）これで気象データプロバイダが2つ揃いました。では両方にクエリし、平均気温を返す関数を書きましょう。ここでは複雑さをさけるために、エラーが発生したらあきらめることにします。この関数の定義はweatherProvider temperatureメソッドとほとんど同じであることにお気付きですか？　個々のweatherProvidersを型に集めて、その型にtemperatureメソッドを定義すれば、他のweatherProvidersから構成される包括的なweatherProviderを実装できます。完璧です。これで、weatherProviderを受け入れるところならどこへでもmultiWeatherProviderを渡すことができます。これで、HTTPサーバにつなぐことができるようになりました。前回とほとんど同じです。前回と同様に、コンパイルして、実行し、GETします。JSONレスポンスに加えて、サーバログに何か出力されるはずです。コミットしてプッシュしましょう！現時点では、APIを1つずつ同期的にクエリしているだけです。しかし、同時にクエリしてはいけない理由はありません。そうすればレスポンス時間を削減できるはずです。これを行うために、Goの並列処理命令であるgoルーチンとチャネルを使います。各APIへのクエリをそれぞれのgoルーチン内で生成すれば、並列で実行されます。レスポンスを1つのチャネルに集めて、全てが完了したら平均値を算出します。これで、リクエストは最も遅いweatherProviderにかかる時間で処理できるようになりました。multiWeatherProviderの振る舞いを変更するだけでできたのです。そして特筆すべきは、いまだにシンプルで同期的なweatherProvider インターフェースとしての要件を満たしていることです。コミットしてプッシュしましょう！「hello world」から始めて、並行処理のREST風バックエンドサーバまで、わずかなステップとGoの標準ライブラリだけを使ってやってきました。このコードはフェッチして、ほとんどすべてのサーバアーキテクチャにデプロイできます。結果として生成されるバイナリは自己完結型で高速です。そして最も重要なのは、このコードは読みやすく解釈が容易なことです。必要に応じて保守や拡張を簡単に行うこともできます。これらの特性は、シンプルさをあくまで最重要視したGoの哲学のおかげだと私は思います。Goの開発者の1人であるRob Pikeが記したように、少ないほど飛躍的に増加するのです。最終コードをgithubにフォークしましょう。別のweatherProviderを追加してみましょう（ヒント:forecast.ioはお勧めです）。multiWeatherProviderにタイムアウトを実装しましょう（ヒント:time.Afterを参照してください）。
