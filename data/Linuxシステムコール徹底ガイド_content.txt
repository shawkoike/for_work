The Definitive Guide to Linux System Calls （2016-04-05） by PackageCloudこの記事では、LinuxカーネルにてLinuxプログラムがどのように関数を呼び出すのかについて紹介していきます。システムコールを行う様々な方法、システムコールを行うための独自のアセンブリの作成方法（例あり）、システムコールへのカーネルエントリポイント、システムコールからのカーネルイグジットポイント、glibcのラッパ関数、バグなど多くの点について説明します。openやfork、read、write（その他多く）を呼び出すプログラムを実行する場合、あなたはシステムコールを行っていることになります。システムコールとは、プログラムがカーネルにアクセスしてタスクを実行する方法のことです。プログラムはシステムコールを使ってプロセスを作成したり、ネットワークの操作やファイルの入出力を行ったりと、様々なオペレーションを実行します。syscalls(2)のマニュアルページにシステムコール一覧が掲載されています。ユーザプログラムでシステムコールを行う方法はいくつかあり、それを行うための低水準命令はCPUアーキテクチャによって異なります。アプリケーション開発者は通常、どれだけ正確にシステムコールが行われているかということについて、深く考える必要はありません。通常の関数と同様に、単にヘッダファイルを適切にインクルードし、呼び出せばいいのです。glibcは、根本的なコードを抽象化するラッパコードを提供します。この根本的なコードは、あなたが渡した引数を配置しカーネルに入り込みます。どのようにシステムコールが行われるかを詳しく説明する前に、いくつかの条件を明確にし、後に出てくる核となる概念を検証していきましょう。この記事では、以下の条件を前提としています。この記事でのx86-64とは、x86アーキテクチャに基づいた、64ビットのIntelやAMD CPUを指します。ユーザプログラム（例えば、エディタやターミナル、sshデーモンなど）は、Linuxカーネルと対話する必要があります。独自で実行することができないユーザプログラムに代わって、カーネルが一連の操作を行うためです。例えば、ユーザプログラムがopenやread、writeといったシステムコールで入出力を行ったり、mmap``  `やsbrk“`などでアドレス空間を修正したりする必要がある場合、カーネルが起動され、ユーザプログラムに代わってそれらのアクションを完了させます。では、ユーザプログラム自身がそれらのアクションを行えないのは、何によるものでしょう？実は、x86-64CPUには、特権レベルと呼ばれる概念があります。特権レベルはそれだけで記事が書けるほど、複雑なトピックです。この記事では、この特権レベルの概念を以下のように（大幅に）簡素化しています。特権的な操作をユーザプログラムが行うには、”Ring 3″から”Ring 0″に特権レベルの変更を行い、カーネルが実行できるようにしなければなりません。特権レベルを変更し、カーネルがアクションを行えるようにするには、いくつかの方法があります。それでは、その一般的な方法の1つである、割り込みから見ていきましょう。割り込みは、ハードウェアやソフトウェアによって生成された（または”発生した”）イベントと捉えることができます。ハードウェア割り込みは、ハードウェアデバイスによって発生し、特定のイベントが起こったということをカーネルに通知します。この種の割り込みの一般的な例として、NICがパケットを受け取った時に生成される割り込みが挙げられます。ソフトウェア割り込みは、コードを実行することによって発生します。X86-64のシステムでは、ソフトウェア割り込みは、int命令を実行することによって発生させることができます。割り込みは通常、それぞれの割り込みに対して番号が付与されますが、これらの割り込み番号の中には、特別な意味を持つものがあります。CPUのメモリ内に存在する配列を想像してみてください。配列への各エントリが割り込み番号にマップされます。各エントリには、いくつかのオプションとともに割り込みが受信された際にCPUが実行する関数のアドレスが含まれています。このオプションは、どの特権レベルで割り込みハンドラの関数が実行されるべきかといった内容のものです。以下は、Intel CPUマニュアルに掲載されている画像で、この配列でのエントリのレイアウトを示しています。
注釈：割り込み/トラップゲート
予約済み
オフセット 63..32
オフセット 31..16
セグメントセレクタ
オフセット 15..0
DPL：ディスクリプタ特権レベル
オフセット：エントリポイントの手続きへのオフセット
P：セグメントPresentフラグ
セレクタ：行き先のコードセグメントのセグメントセレクタ
IST：割り込みスタックテーブル
図5-7. 64ビットIDTゲートディスクリプタ図をよく見てみると、DPL(Descriptor Privilege Level)とラベル付けされている2ビットのフィールドがあることが分かります。このフィールドの値は、ハンドラ関数が実行された時にCPUが得る最低限の特権レベルを決めます。このようにして、特定のタイプのイベントが受信された時にどのアドレスをCPUが実行すべきか、そのイベントに対するハンドラがどの特権レベルで実行されるべきかをCPUが判断します。実際、x84-64システムには、多くの異なる割り込み方法があります。詳細は、8259 Programmable Interrupt Controller（割り込みコントローラ）、Advanced Interrupt Controllers（高度な割り込みコントローラ）、IO Advanced Interrupt Controllers（高度なIO割り込みコントローラ）をご覧ください。この他にも、ハードウェア・ソフトウェア両方の割り込みを扱う際には、割り込み番号の衝突や再マッピングといったような、複雑な問題が含まれることになります。システムコールについて説明をする上で、これらの詳細を気にする必要はありません。MSRとして知られるモデル固有レジスタは、CPUの特定機能を制御する、特別な目的を持った制御レジスタです。CPUドキュメントは、MSRそれぞれのアドレスをリストしています。MSRを読み込んだり書き込んだりするには、個々に対して、CPU命令のrdmsr、wrmsfを使用することができます。また、MSRを読み込んだり書き込んだりすることができるコマンドラインツールがありますが、注意して行わなければなりません。値の変更（特にシステムが起動している最中）はとても危険なことなので、このツールを使用することはお勧めしません。システムを不安定にさせたり、元に戻せないほどデータを破壊したりすることを恐れないのであれば、msr-toolsをインストールし、msrカーネルモジュールをロードすることで、MSRを読み込みこんだり、書き込んだりすることが可能です。この後に紹介するいくつかのシステムコールの方法でMSRを活用します。独自のアセンブリコードを書いてシステムコールを呼び出すことはいいアイデアとは言えません。その大きな理由の1つは、いくつかのシステムコールには、システムコールの実行前後にglibcで実行される追加のコードがあるからです。以下の例では、exitシステムコールを使用します。atexitを使ったプログラムでexitが呼び出される時、実行するための関数を登録できることが分かっています。これらの関数はカーネルではなく、glibcから呼び出されます。ですから、以下のようにexitを呼び出すために独自のアセンブリを書くと、glibcを介していないため、登録されているハンドラ関数は実行されません。そうは言っても、アセンブリを用いて手動でシステムコールを行うことは、とてもいい勉強になります。前述の必要条件に関する情報から以下の2点が分かっています。この2つの概念を組み合わせることで、Linux上のレガシーシステムコールインターフェースへ導かれます。Linuxカーネルは、ユーザ空間のプログラムがカーネル内でシステムコールを実行するために使用できる特定のソフトウェア割り込み番号を確保します。Linuxカーネルは割り込み番号128 (0x80)に対するia32_syscallという割り込みハンドラを登録します。実際にこれを行っているコードを見てみましょう。以下は、arch/x86/kernel/traps.cにあるカーネル3.13.0のソース内のtrap_init関数です。IA32_SYSCALL_VECTORは、arch/x86/include/asm/irq_vectors.h内で0x80として定義されています。しかし、カーネルが単一のソフトウェア割り込みを確保し、ユーザ空間のプログラムがカーネルを動作させることができる場合、どのようにしてカーネルは多くのシステムコールのうち実行すべきシステムコールを知るのでしょうか。ユーザ空間のプログラムは、システムコール番号をeaxレジスタに格納することになっています。システムコール自体の引数は、残りの汎用レジスタに格納されるはずです。これは、arch/x86/ia32/ia32entry.Sのコメント内に記載されています。これで、システムコールを行う方法と引数の格納場所が分かりました。インラインアセンブリをいくつか書いてシステムコールを1つ行ってみましょう。ほんのわずかなインラインアセンブリを書くだけで、レガシーシステムコールを行うことができます。学習の観点からは興味深いことですが、読者の皆さんには独自のアセンブリを作ってシステムコールを行うことはお勧めしません。この例では、exitシステムコールを呼び出してみます。これは単一の引数として終了ステータスを受け取ります。まず、exitに対するシステムコール番号を探す必要があります。Linuxカーネルにはテーブル内に各システムコールのリストを格納したファイルが含まれています。このファイルはビルド時に様々なスクリプトによって処理され、ユーザプログラムが使用可能なヘッダファイルを生成します。arch/x86/syscalls/syscall_32.tblで見つけたテーブルを見てみましょう。1 i386 exit sys_exitexitシステムコールは、番号1です。前述のインターフェースに従って、システムコール番号をeaxレジスタへ移し、第1引数（終了ステータス）をebxへ渡すだけです。以下は、これを行うインラインアセンブリをいくつか用いたCコードの一部です。終了ステータスを”42″に設定してみましょう。（この例は簡易化できますが、少し必要以上に冗長にしても面白いと思いました。そうすれば、前にGCCインラインアセンブリを見たことがない人もこれを手本やリファレンスとして使用することができると考えたのです）次に、コンパイルして実行し、終了ステータスを確認してください。成功です。ソフトウェア割り込みを発生させることで、レガシーシステムコールメソッドを使用してexitシステムコールを呼び出しました。ここまでユーザ空間のプログラムからシステムコールを動作させる方法を見てきました。それでは、カーネルがシステムコール番号を使ってシステムコールコードを実行する方法を見ていきましょう。前のセクションでカーネルがia32_syscallと呼ばれるシステムコールハンドラ関数を登録したのを思い出してください。この関数はarch/x86/ia32/ia32entry.S内のアセンブリに実装されており、この関数内で起こっていることをいくつか見ることができます。その中で最も重要なのは実際のシステムコール自体への呼び出しです。IA32_ARG_FIXUPは、レガシー引数が現在のシステムコール層によって適切に判断されるように再配置するマクロです。ia32_sys_call_table識別子は、arch/x86/ia32/syscall_ia32.cで定義されているテーブルを参照します。コードの最後の方にある#include行に注意してください。以前、arch/x86/syscalls/syscall_32.tblで定義されたシステムコールテーブルを見たことを思い出してください。このテーブルを取得し、それからsyscalls_32.hファイルを生成するコンパイル時に実行するスクリプトがいくつかあります。生成されたヘッダファイルは有効なCコードで構成されています。上記の#includeを使ってこれを挿入しさえすれば、システムコール番号によるインデックス付き関数アドレスでia32_sys_call_tableを埋めることができます。これがレガシーシステムコールを介してカーネルを入れる方法です。ここまで、ソフトウェア割り込みを使ってカーネルに入る方法を見てきました。では、実行後、カーネルはどのようにしてユーザプログラムに戻り、その特権レベルが変更されるのでしょうか？Intelソフトウェア開発者向けマニュアルには、特権レベルが変更される際、プログラムスタックがどのように配置されるのかを示した分かりやすい図が載っています（大容量のPDFファイルですので、ご注意ください）。では、見てみましょう。
注釈
タイトル：特権レベルが変更される際のスタックの仕方
Interrupted Procedure’s Stack：割り込まれたプロシージャのスタック
Handler’s Stack：ハンドラのスタック
ESP Before Transfer to Handler：ハンドラへの移行前のESP
ESP After Transfer to Handler：ハンドラへの移行後のESPユーザプログラムからのソフトウェア割り込み実行を介して、実行がカーネル関数ia32_syscallに移行すると、特権レベルに変化が起こります。つまり、ia32_syscallが入力された際のスタックが上の図のようになるということです。これは、ia32_syscallが実行される前に、特権レベル（と、その他）をコード化するCPUフラグと復帰アドレス、そしてその他のものが全て、プログラムスタックに保存されているということを意味します。そのため、実行を再開するには、カーネルはこれらの値をプログラムスタックから元のレジスタにコピーし直す必要があります。それでユーザ空間で実行が再開されるのです。それは分かりました。では、どうやって行うのでしょうか？方法はいくつかありますが、特に簡単なのは、iret命令を使う方法です。Intel命令セットマニュアルでは、「iret命令は、復帰アドレスと保存されたレジスタ値を、用意した順にスタックからポップする」と説明されています。Linuxカーネルでこのコードを見つけるのは、複数のマクロに隠れているため、やや難しいと言えます。また、signalやptraceなどのシステムコールのexitを追跡するというような場合には広範囲に注意する必要があります。結局は、カーネルのアセンブリスタブにあるマクロ全てに、システムコールからユーザプログラムに戻るiretが隠れています。arch/x86/kernel/entry_64.Sのirq_returnは、以下のとおりです。ここで、INTERRUPT_RETURNはarch/x86/include/asm/irqflags.hではiretqとして定義されています。これで、レガシーなシステムコールの動きがどのようなものか、お分かりいただけたと思います。レガシーな方法はかなり合理的なものに思えますが、システムコールを行うには、ソフトウェア割り込みを使うよりもはるかに高速な、新しい方法があります。2通りのより高速な方法はそれぞれ、2つの命令で構成されています。1つはカーネルに入るもの、もう1つはカーネルから離れるためのものです。いずれも、Intel CPU資料には「Fast System Call（高速システムコール）」として記載されています。残念ながら、IntelとAMDの実装では、CPUが32ビットモードあるいは64ビットモードの場合に有効な方法は何かという点において、いくつか相違があります。IntelとAMD、両方のCPUでの互換性を最大に確保するため、以下のとおりとします。システムコールを行うためにsysenterを使うことは、レガシーな割り込みを使う方法よりも複雑であり、ユーザプログラム（glibcを介して）とカーネルの間の調整もより多く必要となります。では、1つずつ詳細を整理してみましょう。まずは、Intel命令セットリファレンス（大容量のPDFファイルですのでご注意ください）では、sysenterについて、そしてその使い方について、どのように説明されているのか見ていきましょう。それでは、以下をご覧ください。つまり、sysenterでカーネルに入ってくるシステムコールを受け取るために、カーネルは3つのモデル固有レジスタ（MSR）を設定しなければならないのです。今回扱っている環境で最も興味深いと言えるMSRは、IA32_SYSENTER_EIP（これはアドレス0x176を持っています）です。このMSRは、sysenter命令がユーザプログラムで実行される際、実行される関数のアドレスが指定される場所です。arch/x86/vdso/vdso32-setup.cでは、MSRに書き込むLinuxカーネルのコードを見ることができます。ここでのMSR_IA32_SYSENTER_EIPは、arch/x86/include/uapi/asm/msr-index.h内で0x00000176と定義されています。多くのレガシーなソフトウェア割り込みsyscallのように、sysenterでシステムコールを行うために定義された規約があります。これが文書化されている場所は、 arch/x86/ia32/ia32entry.Sでのコメントで、以下のとおりです。レガシーなシステムコールの方法には、割り込まれたユーザ空間プログラムに戻るためのメカニズムがあったことを思い出してください。それがiret命令です。sysenterを正常に動かすために必要となるロジックを捉えるのは難しいことです。なぜなら、ソフトウェア割り込みとは違って、sysenterでは復帰アドレスが格納されていないのです。sysenter命令を実行する前に、カーネルがこうした情報の記録を行う方法は、厳密には、時が経つにつれて変わり得るものです（以下のバグのセクションで分かるとおり、それは変わっています）。この先の変更に振り回されないよう、ユーザプログラムは__kernel_vsyscallという関数を使うようになっています。この関数はカーネルに実装されていますが、プロセスの開始時に各ユーザプロセスにマップされます。これは少し奇妙です。カーネルに付随しているコードなのに、ユーザ空間で動作しているのです。結局、__kernel_vsyscallは、プログラムがユーザ空間でカーネルのコードを実行できるようにするために存在している仮想動的共有オブジェクト（vDSO）と呼ばれるものの一部なのです。vDSOとは何か、何をするものか、そしてどのように機能するのか、後ほど徹底的に見ていくことにします。では、__kernel_vsyscallの内部を見ていきましょう。arch/x86/vdso/vdso32/sysenter.Sでは、sysenterの呼び出し規約をカプセル化する__kernel_vsyscall関数を見ることができます。__kernel_vsyscallは、動的共有オブジェクト（共有ライブラリとしても知られています）の一部なのですが、ユーザプログラムは実行時にその関数のアドレスの位置をどうやって特定するのでしょうか？__kernel_vsyscall関数のアドレスは、ユーザプログラムやライブラリ（一般的にはglibc）が見つけて、使うことができるELF補助ベクタに書かれています。ELF補助ベクタを検索するためには、いくつか方法があります。1つ目の選択肢は非常にシンプルですが、2.16以前のglibcに存在しません。ですから、以下に示すコードの例は2つ目の選択肢です。先に示したコードからお分かりいただけるとおり、__kernel_vsyscallはsysenterを実行する前に、いくつか情報の記録を行います。従って、sysenterを使って手動でカーネルに入るために必要となるのは、以下の作業だけです。絶対に、独自のsysenterのラッパ関数を書いてはいけません。カーネルがsysenterを使ってシステムコールに入ったり抜けたりするために使う規約は変わることがあり、そうした場合にコードが動かなくなるからです。必ず__kernel_vsyscallを通して呼び出すことにより、sysenterシステムコールから始めるようにするべきです。では、やってみましょう。これまでのレガシーなシステムコールの例を踏まえ、42の終了ステータスでexitを呼ぶことにします。exitのシステムコール番号は1です。前述のインターフェースによると、ただシステムコール番号をeaxレジスタに、最初の引数（終了ステータス）をebxに移動させる必要があります。（この例は簡易化できますが、少し必要以上に冗長にしても面白いと思いました。そうすれば、前にGCCインラインアセンブリを見たことがない人もこれを手本やリファレンスとして使用することができると考えたのです）次は、コンパイルして、実行し、終了ステータスをチェックします。成功しました。ソフトウェア割り込みを伴わずに、レガシーなsysenterを使った方法でexitシステムコールを呼び出すことができました。ここまで、__kernel_vsyscallを介し、sysenterでユーザ空間プログラムからシステムコールを呼び出す方法を見てきました。では、今度はカーネルがシステムコールのコードを実行するために、システムコール番号をどのように使っているのかを見てみましょう。前のセクションを思い出してください。カーネルはia32_sysenter_targetと呼ばれるsyscallハンドラ関数をレジスタに入れました。arch/x86/ia32/ia32entry.Sで、この関数がアセンブリに実装されています。eaxレジスタの値がシステムコールを実行するために使われている場所を見てみましょう。これは、レガシーなシステムコールのモードで見たものと、同一のコードです。つまり、システムコール番号と共にインデックス付けされているia32_sys_call_tableと名付けられたテーブルです。必要な情報の記録が全て行われた後、レガシーなシステムコールモデルとsysenterシステムコールモデルの両方が、システムコールをディスパッチするために、同じメカニズムとシステムコールテーブルを使っています。ia32_sys_call_tableが定義されている場所、そしてそれがどのように構築されているか学びたい方は、int $0x80のエントリポイントのセクションを参照してください。以上がsysenterシステムコールを介してカーネルに入る方法です。カーネルはユーザプログラムに戻って実行を再開するために、sysexit命令を使うことができます。この命令を使うやり方は、iretを使うやり方ほど分かりやすいものではありません。呼び出し側は、rdxレジスタに復帰アドレスを入れること、さらにrcxレジスタで使うためのプログラムスタックにポインタを置くことが求められます。これは、あなたのソフトウェアは実行が再開されるべきアドレスを計算し、その値を保持し、sysexitを呼び出す前にそれを復元しなければならないことを意味します。arch/x86/ia32/ia32entry.Sでは、この処理を行うコードを見ることができます。ENABLE_INTERRUPTS_SYSEXIT32は、sysexit命令を含む arch/x86/include/asm/irqflags.hで定義されているマクロです。さあ、これで32ビットの高速システムコールがどのように機能するか、お分かりいただけたと思います。次は、64ビットの高速システムコールを見ていきます。これらのシステムコールは、システムコールを起動するため、およびシステムコールから復帰するために、それぞれsyscallとsysret命令を使います。Intel命令セットリファレンス（大容量のPDFファイルですのでご注意ください）では、syscall命令がどのように機能するかについて、以下のように説明されています。つまり、カーネルに入ってくるシステムコールを受け取るために、カーネルはIA32_LSTAR MSRへアドレスを書き込むことによって、システムコールが出された時に実行されるコードのアドレスをレジスタに入れる必要があるのです。arch/x86/kernel/cpu/common.c では、そのカーネルのコードを見ることができます。MSR_LSTARは、arch/x86/include/uapi/asm/msr-index.h で0xc0000082として定義されています。レガシーなソフトウェア割り込みsyscallのように、システムコールをsyscallで呼び出すために定義された規約があります。ユーザ空間プログラムは、システムコール番号をraxレジスタに入れることが求められます。syscallの引数は、汎用レジスタのサブセット内に配置されることが求められます。以下は、セクションA.2.1のx86-64 ABIに記載されています。これは、 arch/x86/kernel/entry_64.Sのコメントにも記載されています。さあ、これでシステムコールの行い方、引数を置くべき場所が分かりました。それでは、インラインアセンブリをいくつか書いて試してみましょう。前述の例に沿って、インラインアセンブリを含んだ小さなCプログラムを書きましょう。アセンブリは、42という終了ステータスを渡すexitシステムコールを実行するものとします。まず、exitに対するシステムコール番号を見つけなくてはなりません。このケースでは、arch/x86/syscalls/syscall_64.tblにあるテーブルを読む必要があります。 60 common exit sys_exitexitのシステムコール番号は60です。前述のインターフェースによれば、やるべき作業は、60をraxレジスタに、最初の引数（終了ステータス）をrdiにそれぞれ移すことだけです。以下は、この作業を行うインラインアセンブリを含んだCコードです。前の例と同様、この例は、分かりやすくするため必要以上に冗長に記述しています。次に、コンパイルし、実行して、終了ステータスをチェックします。成功です。syscallシステムコールを使った方法で、exitシステムコールを呼び出すことができました。ソフトウェア割り込みの発生を避けられましたし、（マイクロベンチマークを測定していれば）実行速度もずっと速いことが分かります。ユーザ空間プログラムからシステムコールを行う方法を見てきましたので、今度はカーネルがどのようにシステムコール番号を使ってシステムコールのコードを実行するか見てみましょう。前のセクションでsystem_callという名前の関数のアドレスがLSTAR MSRに書き出されていたことを思い出してください。この関数に対するコードがどのようにraxを使って実際にシステムコールに実行を渡すのか、arch/x86/kernel/entry_64.Sから見てみましょう。レガシーなシステムコールの方法とよく似ているのですが、sys_call_tableはCファイルで定義されているテーブルであり、#includeを使って、スクリプトで生成されるCコードを読み込みます。以下はarch/x86/kernel/syscall_64.cの抜粋ですが、最後にある#includeに注目してください。先ほど、arch/x86/syscalls/syscall_64.tblで定義されたシステムコールテーブルを確認しました。レガシーな割り込みモードと全く同様に、スクリプトはカーネルコンパイル時に動作し、syscall_64.tblのテーブルからsyscalls_64.hファイルを生成します。上記のコードは、生成されたCコードを単純にインクルードしています。そのCコードは、システムコール番号でインデックス付けされた関数ポインタの配列を作成するものです。このようにして、syscallシステムコールを通じてカーネルに入ることができます。カーネルはsysret命令によって、ユーザプログラムがsyscallで実行を中断した場所に実行を戻すことができます。実行が再開されるべき場所のアドレスは、syscallが使われた時にrcxレジスタにコピーされているため、sysretはsysexitよりもシンプルです。その値をどこかに保持しておき、sysretを呼び出す前にrcxにリストアする限り、実行はsyscallが呼び出される前に中断した場所で再開されます。sysenterでは、さらなるレジスタを上書きすることに加えてこのアドレスを自分で計算する必要がありますから、これは便利です。実行するコードはarch/x86/kernel/entry_64.Sに含まれています。USERGS_SYSRET64は、sysret命令を含むarch/x86/include/asm/irqflags.hで定義されているマクロです。これで64ビットの高速システムコールの仕組みが分かりました。ここまで、システムコールの数種類の方法について、アセンブリを書いて手動でシステムコールを呼び出すやり方を見てきました。通常は、独自のアセンブリを書く必要はありません。様々なアセンブリコードを扱ってくれるラッパ関数がglibcから提供されているためです。しかし、glibcのラッパが存在しないシステムコールもあります。一例としては、高速ユーザ空間ロックのシステムコールfutexが挙げられます。ですが、なぜfutexに対するシステムコールのラッパが存在しないのでしょうか？futexは、アプリケーションコードではなくライブラリだけに呼び出されることが想定されています。このため、futexを呼び出すためには、以下の作業が必要となるのです。ラッパが存在しないシステムコールを呼び出すことが必要になった場合は、断然、2番目の「glibcから提供される関数syscallを使用」を選ぶべきです。ではglibcのsyscallを使って、終了ステータス42でexitを呼び出してみましょう。次に、コンパイルし、実行して、終了ステータスを確認します。成功しました。glibcのsyscallラッパを使って、exitシステムコールを呼び出すことができました。上記の例で使ったsyscallラッパ関数が、glibcでどのような動作をするのか見てみましょう。以下はsysdeps/unix/sysv/linux/x86_64/syscall.Sからの抜粋です。前の方で、x86_64 ABIのドキュメントから、ユーザ空間とカーネルの両方の呼び出し規約を引用してご紹介しました。このアセンブリスタブは、両方の呼び出し規約が示されている点で優れています。この関数に渡される引数はユーザ空間の呼び出し規約に準じますが、それから、syscallでカーネルに入る前に、カーネルの呼び出し規約に従うよう異なるレジスタに移されます。このようにして、glibcのsyscallラッパを使って、デフォルトのラッパが存在しないシステムコールを呼び出すことができます。ここまで、カーネルに入ってシステムコールを行う様々な方法を取り上げ、システムをユーザ空間からカーネルに遷移させるためそれらの呼び出しを手動（または半手動）で行うやり方をご紹介しました。では、カーネルに全く入ることなく、プログラムが特定のシステムコールを呼び出せるとしたら、どうなるでしょうか？Linuxに仮想動的共有オブジェクト（vDSO）が存在する理由は、まさにそこにあります。LinuxのvDSOは、カーネルの一部を構成するコードですが、ユーザ空間で実行されるユーザプログラムのアドレス空間にマップされています。vDSOの目的は、一部のシステムコールをカーネルに入らずに使えるようにすることです。そのような呼び出しの例として、gettimeofdayが挙げられます。gettimeofdayシステムコールを呼び出すプログラムは、実際にはカーネルに入りません。その代わりに、カーネルによって提供されるもののユーザ空間で実行されるというコードに対し、単純な関数呼び出しを行います。ソフトウェア割り込みは発生せず、sysenterやsyscallの情報を管理するという複雑な作業も必要ありません。gettimeofdayは単なる普通の関数呼び出しなのです。lddを使うと、vDSOが最初のエントリとして表示されます。vDSOがカーネルでどのようにセットアップされるか見てみましょう。vDSOのソースはarch/x86/vdso/にあります。アセンブリやCソースファイル、リンカスクリプトで構成されています。このリンカスクリプトは、一見の価値があります。以下は、arch/x86/vdso/vdso.lds.Sからの抜粋です。リンカスクリプトはかなり便利ですが、特によく知られているわけではありません。このリンカスクリプトは、vDSOでエクスポートされるシンボルを配置するものです。上記のvDSOは4つの異なる関数をエクスポートしており、それぞれに2つの名前があることが分かります。これらの関数のソースは、上記ディレクトリのCファイルにあります。例えば、gettimeofdayのソースはarch/x86/vdso/vclock_gettime.cにあります。上記は、__vdso_gettimeofdayへのweak aliasとしてgettimeofdayを定義しています。同じファイルにある__vdso_gettimeofday関数は、ユーザプログラムがgettimeofdayシステムコールを呼び出した時にユーザ空間で実行される、実際のソースを含んでいます。アドレス空間配置のランダム化のため、vDSOはプログラム開始時にランダムなアドレスにロードされます。ランダムなアドレスにロードされるのであれば、ユーザプログラムはどうやってvDSOを見つけるのでしょうか？前にsysenterシステムコールの方法を見た時は、sysenterアセンブリコードを自分で書く代わりに、ユーザプログラムが__kernel_vsyscallを呼び出す必要がありましたね。この関数もまた、vDSOの一部です。前掲のサンプルコードは、__kernel_vsyscallのアドレスを含んだタイプAT_SYSINFOを持つヘッダを見つけるため、ELF補助ヘッダを調べて__kernel_vsyscallの位置を特定しました。同様に、vDSOの位置を特定するため、ユーザプログラムはタイプAT_SYSINFO_EHDRのELF補助ヘッダを調べることができます。このタイプは、リンカスクリプトから生成されたvDSOのELFヘッダの開始アドレスを含みます。どちらのケースも、プログラムがロードされる際、カーネルがそのアドレスをELFヘッダに書き出します。こうして、正しいアドレスがAT_SYSINFO_EHDRとAT_SYSINFOに必ず格納されるのです。そのヘッダの位置が特定されれば、ユーザプログラムはELFオブジェクトをパースして（おそらくlibelfを使用）、必要に応じてELFオブジェクト内の関数を呼び出すことができます。vDSOはシンボルバージョニングのようなELFの有用な機能を活用できるということですので、これは便利です。vDSO内の関数をパースして呼び出す例は、Documentation/vDSO/のカーネルドキュメントに掲載されています。多くの場合、私たちは知らない間にvDSOにアクセスしています。前述したように、glibcで使われるインターフェースによって、そのことが見えなくなっているからです。プログラムがロードされる際、動的リンカ/ローダは、そのプログラムが依存するDSOをロードします。これにはvDSOも含まれます。glibcは、ロードされているプログラムのELFヘッダをパースする際、vDSOの位置に関するデータを格納します。また、実際のシステムコールを行う前に、vDSOを調べてシンボル名を探す、単純なスタブ関数をインクルードします。例えば下記は、sysdeps/unix/sysv/linux/x86_64/gettimeofday.cから抜粋したglibcのgettimeofday関数です。glibc内のこのコードは、vDSOを調べてgettimeofdayを探し、そのアドレスを返します。最後にindirect functionがうまく使われます。このようにして、gettimeofdayを呼び出すプログラムは、カーネルモードに切り替えたり、特権レベル変更を招いたり、ソフトウェア割り込みを発生させたりすることなく、glibcを通じてvDSOを使えるのです。以上で、32ビットか64ビットのIntelかAMDのCPU向けLinuxで利用できるシステムコールの方法を全てご紹介したことになります。この記事ではシステムコールについて説明していますので、glibcがシステムコールをどのように扱うかにも簡単に触れておきたいと思います。多くのシステムコールについて、glibcが必要とするのは、引数を適切なレジスタへ移してからsyscallまたはint $0x80命令を実行するか__kernel_vsyscallを呼び出すというラッパ関数だけです。この際には、テキストファイルで定義された一連のテーブルが使われますが、そのテキストファイルはスクリプトで処理され、Cコードが出力されます。例えば下記は、sysdeps/unix/syscalls.listファイルに記述された一般的なシステムコールです。各列についての詳しい情報は、このファイルを処理するスクリプトsysdeps/unix/make-syscalls.shのコメントを参照してください。ハンドラを呼び出すexitのように、より複雑なシステムコールは、Cやアセンブリコードによる実際の実装があり、上記のようなテンプレート化されたテキストファイルには含まれていません。今後のブログ記事では、興味深いシステムコールに対するglibcやLinuxカーネルでの実装について探ってみたいと思います。この機会に、Linuxのシステムコールに関する2つの重大なバグに言及しないわけにはいきません。以下で見ていきましょう。このセキュリティエクスプロイトでは、ローカルユーザがroot権限を取得することが可能となります。原因となっているのは、ユーザプログラムがx86-64システム上でレガシーなシステムコールを行えるようにするアセンブリコードの、小さなバグです。このエクスプロイトコードはかなり巧妙です。mmapで特定のアドレスにメモリ領域を確保し、整数オーバーフローを用いて、下記のコードが任意のアドレスに実行を渡すようにします。（レガシーな割り込みのセクションで登場したこのコードを覚えていますか？）これがカーネルコードとして動作し、実行プロセスをルート権限に昇格させることができるのです。前の方で、sysenter ABIをアプリケーションコードにハードコーディングしないようにとお伝えしたことを覚えていますか？残念ながら、android-x86の開発者はそのミスを犯しました。カーネルABIが変わって突然、android-x86が機能しなくなったのです。カーネルの開発者は、出回っているAndroidデバイスが、古くなったハードコードのsysenterシーケンスによって動かなくなることを避けるため、以前のsysenter ABIをリストアする羽目になりました。Linuxカーネルに施された修正はこちらです。コミットメッセージには、androidソースで元凶となったコミットへのリンクがあります。注意：決して独自のsysenterアセンブリコードを書いてはいけません。何らかの理由でそのようなコードを直接実装しなければならない場合は、前述の例のようなコードを使い、せめて__kernel_vsyscallは呼び出すようにしてください。Linuxカーネルにおけるシステムコールのインフラは、非常に複雑です。各システムコールについて様々なやり方があり、利点や欠点もそれぞれ異なります。独自のアセンブリを書いてシステムコールを呼び出すことは、背後のABIが動かなくなる可能性があるので、通常はいい方法とは言えません。カーネルとlibc実装こそが、そのシステム上でシステムコールを行うのに最も速い方法を（おそらく）選んでくれるでしょう。glibcから提供されるラッパが使えない（または存在しない）場合は、せめてsyscallラッパ関数を使うか、vDSOから提供される__kernel_vsyscallを呼び出すようにすべきです。今後のブログ記事では、個々のシステムコールとその実装について詳しく取り上げる予定ですので、ご期待ください。この記事を読んでみて面白いと感じた方には、低水準技術に関する以下の記事も参考になるかもしれません。
