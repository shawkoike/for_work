AnthonyCalandra/modern-cpp-features by Anthony Calandra(注：2017/02/07、タグが誤っていたので修正いたしました。)C++11/14/17に関する記述や例の多くは、様々なリソース（詳しくは謝辞の項目をご覧ください）を参考にしており、それらを自分の言葉でまとめてみました。C++17には、以下の新しい言語機能が導入されています。C++17には、以下の新しいライブラリ機能が導入されています。C++14には、以下の新しい言語機能が導入されています。C++14には、以下の新しいライブラリ機能が導入されています。C++11には、以下の新しい言語機能が導入されています。C++11には、以下の新しいライブラリ機能が導入されています。これは、テンプレート引数の推論を自動的に行うもので、関数に対して実行される方法に似ています。今回、これにクラスのコンストラクタが導入されました。許可された型[*]の非型テンプレートパラメータリストを順守しながらautoの推論規則に従うと、テンプレート引数をその引数の型から推測することができます。

フォールド式は、二項演算子に対してテンプレートパラメータパックの折りたたみを行います。

統一的な初期化構文と共に使用された場合、auto推論に変更します。以前は、auto x{ 3 };がstd::initializer_list&lt;int&gt;を推論していましたが、今回からintを推論するようになります。

constexprを使用したコンパイル時ラムダです。

インラインの指定子は変数や関数に適用することができます。インライン宣言された関数は、インライン宣言された関数と同じセマンティクスを持ちます。

入れ子になった名前空間の定義を作成するために、名前空間のスコープ解決演算子を使用します。

非構造化の初期化に対する提案をします。これによって、exprがタプルライクなオブジェクトで、その要素が変数x、y、z（これらがコンストラクトを宣言します）にバインドされたauto {x, y, z} = expr;の書き込みを許可します。タプルライクなオブジェクトには、std::tuple、std::pair、std::array、アグリゲート構造が含まれます。

共通コードパターンを簡素化させ、ユーザがスコープを固定した状態に保つことを助ける、新しいバージョンのifとswitchです。

コンパイル時条件次第でインスタンスが作成されるコードを書きます。

クラステンプレートstd::variantは、タイプセーフなunionを表しています。いつでもstd::variantのインスタンスは、それに取って代わる型の1つの値を保持します（それを無価値にすることも可能です）。

クラステンプレートstd::optionalは、値を含んだoptionalを管理します。言い換えれば、値は存在するかもしれませんし、存在しないかもしれません。optionalの一般的な使用事例として、機能しない可能性のある関数の戻り値があります。

あらゆる型の単一値におけるタイプセーフコンテナです。

ストリングへの非所有リファレンスです。ストリング上に抽象化を提供するのに便利です（例えば、パーシングに対してなど）。

パラメータと共にCallableオブジェクトを呼び出します。Callableオブジェクトの例として、オブジェクトが通常の関数と同様に呼び出されるstd::functionまたはstd::bindが挙げられます。

引数のタプルと共にCallableオブジェクトを呼び出します。

コストのかかるコピーや移動、ヒープの割り当てまたは割り当て解除などのオーバーヘッドなしで、ノードを移動したり、コンテナを統合したりします。1つのmapから他のmapへと要素を移動するには以下のようにします。全てのsetを挿入するには以下のようにします。コンテナをより長生きさせる要素を挿入するには、以下のようにします。map要素のキーを変更するには、以下のようにします。

バイナリリテラルは2進法の数を表すための便利な方法を提供します。'を使って桁を区切ることができます。

C++14では、パラメータリストでauto型指定子を使用できるようになり、多相的ラムダが可能になりました。

これにより、任意の式で初期化されたラムダキャプチャを作成することが可能です。キャプチャされた値に与えられる名前は、エンクロージングスコープ内の変数と関連する必要はなく、ラムダ本体の内部で新しい名前が導入されます。初期化の式はラムダが（呼び出された時ではなく）作成された時に評価されます。従来はコピーまたは参照によってしかキャプチャできなかったラムダに、値を移動（または転送）することが可能になったので、値によりラムダ内にmove-only型をキャプチャすることができます。以下の例では、=の左辺、task2のキャプチャリスト内のpは新しいラムダ本体のプライベート変数であり、元のpとは関係がないことにご注意ください。この参照キャプチャを使用すると、参照された変数と異なる名前を付けることができます。

C++14で戻り値の型autoを使うと、コンパイラはその型を推論しようとします。ラムダでは、autoを使って戻り値の型を推論することができ、推論された参照、あるいは右辺値参照を返すことが可能となります。

decltype(auto)型指定子はautoが行うような型も推論します。しかし、その一方でその参照や”定数性”を維持したまま、戻り値の型を推論します。これに対しautoではこの推論はできません。

C++11では、constexpr関数本体には、typedef、using、単一のreturn文のような（でも、それだけに限定されない）非常に限られた構文のセットしか含めることができませんでした。C++14では、許容される構文のセットは拡張され、if文、複数のreturn、loopのような最も一般的な構文を含むことができるようになりました。標準ライブラリ型のユーザ定義リテラルは、chronoとbasic_stringの新しいビルトインのリテラルを含む標準ライブラリ型の新しいユーザ定義リテラルです。これらはconstexprであり、つまりコンパイル時に使用されることになります。このようなリテラルの使い方には、コンパイル時の整数パース、バイナリリテラル、および虚数リテラルが含まれます。クラステンプレートstd::integer_sequenceはコンパイル時整数シーケンスを表します。ここには幾つかのヘルパが構築されています。以下のように、配列をタプルに変換します。

移動セマンティクスは、主にパフォーマンスの最適化に関することであり、コピーのコストのかかるオーバーヘッドなしに移動することをいいます。コピーと移動の違いは、コピーではソースは変更されないのに対し、移動ではソースが変更されない、あるいは完全に異なったものになります。これは、ソースが何であるかに左右されます。POD型では移動とコピーは同じことになります。オブジェクトを移動するということは、そのオブジェクトが管理する幾つかのリソースの所有権を他のオブジェクトに移動することを意味します。移動先のソースオブジェクトによって、ソースオブジェクトが保持しているポインタを移動させる、もしくは新たに保持するように変更することと考えることができます。つまり、リソースはメモリ内のその場所に留まるということです。このようなコストのかからないリソースの移動は、rvalueのソースが移動後に変わってしまうといった副作用が起こる可能性がある場合にとても便利です。というのも、そのソースは一時的なオブジェクトで、後でアクセスすることができないからです。移動により、オブジェクトをあるスコープから別のスコープに移動することも可能になります。例えば、std::unique_ptrsといった、一意のオブジェクトへのポインタを保持するような設計のスマートポインタなどです。以下の右辺値参照、特殊メンバ関数の移動の定義、std::move、std::forwardの各項をご覧ください。

C++11では、右辺値参照と呼ばれる新しい参照が導入されており、Aに対する右辺値参照はA&amp;&amp;という構文で作成されます。これによって有効になる主要な機能は2つです。1つは移動セマンティクス、そしてもう1つは、引数に関する情報を一般的な方法で左辺値/右辺値として維持しながら渡すことができるPerfect Forwardです。左辺値および右辺値によるauto型推論：関連項目：std::move、std::forward

...構文は、パラメータパックを作成または展開します。テンプレートパラメータパックとは、0個以上のテンプレート引数を受け入れるテンプレートパラメータです（非型、型、またはテンプレート）。少なくとも1つのパラメータパックを含むテンプレートのことを可変値引数テンプレートと呼びます。

“波カッコのリスト”構文で作成される配列に類似した軽量の要素のコンテナです。例えば、{ 1, 2, 3 }は、std::initializer_list&lt;int&gt;型を持つ整数のシーケンスを作成します。オブジェクトのvectorを関数に渡す代わりとして便利です。

アサーションが、コンパイル時に評価されます。

auto型の変数が、その初期化子の型に従ってコンパイラにより推論されます。特に複雑な型の場合、可読性が向上し非常に便利です。関数がautoを利用することで、戻り値の型を推論することもできます。C++11では、戻り値の型は明示的に指定するか、あるいは以下のようにdecltypeを使わなければなりません。上の例にある後続の戻り値の型は、x + y式の宣言型（decltypeの項を参照）です。例えば、xが整数でyがdoubleの場合、decltype(x + y)はdoubleとなります。従って上記の関数は、x + y式がどのような型を取るかによって型を推論します。なお、後続の戻り値の型はそのパラメータ、および該当する場合はthisを取得します。

lambdaは、スコープ内の変数を取り込める無名関数オブジェクトで、その機能としてキャプチャリスト、オプションの後続の戻り値の型を持つオプションのパラメータセット、そしてボディなどが挙げられます。キャプチャリストの例は以下の通りです。デフォルトでは、コンパイラ生成メソッドがconstとしてマークされているため、値のキャプチャはラムダ内では変更できません。ただし、mutableキーワードを使用すると、キャプチャされた変数の変更が可能です。キーワードはパラメータリスト（空であっても記述は必要）の後に置きます。

decltypeは、渡された式の宣言型を返す演算子です。decltypeの例は以下の通りです。

typedefを使うのに意味的には似ていますが、usingによるテンプレートエイリアスは可読性が高く、テンプレートと互換性があります。

C++11では、CのNULLマクロを置き換えるために設計された新しいNULLポインタ型が導入されています。nullptr自体はstd::nullptr_t型で、暗黙的にポインタ型に変換できますが、NULLとは違いbool以外の整数型には変換できません。

タイプセーフな列挙型が解決するCスタイル列挙型の様々な問題の中には、暗黙的な変換、基盤となる型を指定できないこと、スコープの汚染が含まれます。

属性は、__attribute__(...)や__declspecなどの汎用構文を提供します。

定数式は、コンパイル時にコンパイラによって評価される式です。定数式では、複雑ではない計算だけが実行できます。constexpr指定子により、変数や関数などが定数式であることを示します。constexpr値は、コンパイラがコンパイル時に評価できます。クラスを持つ定数式は以下の通りです。

コンストラクタは、初期化子リストを利用して同じクラス内の別のコンストラクタを呼び出せるようになりました。

ユーザ定義リテラルにより、言語を拡張し、独自の構文を追加できます。リテラルを作成するには、Xの名前で型Tを返すT operator "" X(...) { ... }関数を定義します。ちなみに、この関数の名前がリテラルの名前を定義することに留意しておいてください。アンダースコアで始まらないリテラル名は保留され、呼び出されません。ユーザ定義のリテラル関数が受け入れるべきパラメータには、リテラルがどの型で呼び出されているかによるルールがあります。摂氏から華氏への変換：文字列から整数への変換：

仮想関数が別の仮想関数をオーバーライドするという明示をします。仮想関数が親の仮想関数をオーバーライドしない場合、コンパイラエラーがスローされます。

コンストラクタなどのような関数の既定化を提供する、より効率的で洗練された方法です。

関数の削除指定を提供する、より効率的で洗練された方法です。オブジェクトへのコピーを回避するのに有効です。

コンテナの要素を反復する糖衣構文です。intを使う際にはint＆との違いに注意してください。

コピーが作成されるとコピーコンストラクタおよびコピー代入演算子が呼び出されますが、C++11では移動セマンティクスの導入により、移動用に移動コンストラクタと移動代入演算子があります。

std::moveは、渡されたオブジェクトが移動されること、言い換えるなら、コピーすることなく、あるオブジェクトから別のオブジェクトに移動されることを示します。渡されたオブジェクトは移動後、特定の状況下では使用してはなりません。std::moveの定義（移動の実行は、右辺値にキャストするといった程度の意味です）：std::unique_ptrを移動：

渡された引数を、左辺値あるいは右辺値のいずれかとしてそのまま返し、cv修飾を含みます。該当する場合、例えばファクトリのように、参照（左辺値または右辺値のいずれか）が必要な汎用コードに便利です。転送はテンプレート引数の推論によって可能になります。std::forwardの定義：単に、他のAオブジェクトを新しいAオブジェクトのコピーまたは移動コンストラクタに転送するwrapper関数の例：

数値の引数をstd::stringに変換します。

型特性は、型のプロパティを照会または変更するための、コンパイル時におけるテンプレートベースのインターフェースを定義します。

C++11では、std::unique_ptr、std::shared_ptr、std::weak_ptrという新しい（改善された）スマートポインタが導入されました。std::auto_ptrは現在では非推奨になっており、最終的にC++17で廃止されています。std::unique_ptrはコピー不可の移動可能なスマートポインタで、配列とSTLコンテナを適切に管理します。

chronoライブラリには、持続時間、時計、タイムポイントを扱うユーティリティ関数と型のセットが含まれています。このライブラリの使用例の１つにベンチマークコードがあります。

タプルは、異なる値の固定サイズコレクションです。std::tieまたはstd::getを使ってアンパックし、td::tupleの要素にアクセスします。

左辺値参照のタプルを作成します。std::pairおよびstd::tupleオブジェクトをアンパックするのに便利です。無視される値に関しては、プレースホルダとしてstd::ignoreを使用します。C++17では、代わりに構造化束縛を使う必要があります。

std::arrayは、Cスタイル配列の上に構築されるコンテナです。並べ替えなどの一般的なコンテナ操作をサポートします。これらのコンテナは検索、挿入、削除操作に関して、平均した一定の時間計算量を維持します。バケツに要素をハッシングすることで速度を犠牲にし、一定の時間計算量を実現しています。unorderedコンテナは以下の4種類です。C++11ではC++のメモリモデルが導入されており、スレッド化とアトミック操作ライブラリをサポートしています。これらの操作の一部（全てではありません）には、アトミックロード/ストア、コンペア・アンド・スワップ、アトミックフラグ、FutureやPromise、ロック、条件変数などが含まれますAnthony Calandra新規コンテンツを追加したユーザが、ここに順不同でリストされています。MIT
