<p><a href="https://erikbern.com/2016/12/05/the-half-life-of-code.html" rel="nofollow" title="" class="ext-link">The half-life of code &amp; the ship of Theseus</a> （2016-12-05） by <a href="https://github.com/erikbern" rel="nofollow" title="" class="ext-link">Erik Bernhardsson</a></p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/trireme.jpg" alt="trireme"></p><p>プロジェクトが発展する際は、単純に新しいコードが古いコードの上に追加されているのでしょうか。もしくは、時間をかけて徐々に古いコードが新しいコードに置き換えられているのでしょうか。これを解明するために、手ごわい<a href="https://gitpython.readthedocs.io/en/stable/" rel="nofollow" title="" class="ext-link">GitPython</a>プロジェクトの助けを借りて、Gitプロジェクトを分析する<a href="https://github.com/erikbern/git-of-theseus" rel="nofollow" title="" class="ext-link">簡単なプログラム</a>を構築してみました。履歴を年ごとに振り返り、<code>git blame</code>を実行してみようと思ったのです（この処理を多少でも速くすることは簡単ではないと分かりました。しかし、ファイルのキャッシングを便宜的に含ませることや、変更された点を履歴から見つけること、<code>git diff</code>を使って変更したファイルを無効にすることなどの詳細を、いつかお伝えします）。</p><p>頭がさえている時に、<em>テセウスの船</em>をダサくもじって、 “テセウスのGit” と名付けました。私は父親になって、ひどいダジャレを作れるようになったのです。テセウスの船は哲学的なパラドックスを示しています。ある船を何百年も使い続け、その間に部品を少しずつ交換した場合、全ての部品が交換されても同じ船といえるのか、という疑問を投げかける言葉です。</p><p><em>テセウスとアテネの若者がクレタ島から帰還した際、乗っていた船には30本の櫂がありました。この船は、デメトリオス・パレレオスの時代にも、アテネの人々によって保存されていたもので、使い物にならなくなった木材は、徐々に新たな木材に置き換えられていました。これは発展する物ごとの論理的な疑問を論じる時の最適な例として、哲学者たちに取り上げられてきました。つまり、ある者は部品が変わっても、それは同じ船だと言い、別の者は同じ船ではないと主張したのです。</em></p><p>コードが、完全に予想通りに発展していかないことは分かっています。 “テセウスの船” の影響が<em>生じるのです。</em>しかし、時間をかけて持続的にコードベースを作っていく場合は、複合作用も発生します（これは、<a href="https://ja.wikipedia.org/wiki/IND2%E7%95%AA%E8%A1%97%E7%B7%9A" rel="nofollow" title="" class="ext-link">1919年から</a>続くニューヨークの建設計画、 “2番街線” の影響と呼ぶのがふさわしいでしょう）。</p><p>まずはGitそのものを分析してみましょう。Gitは、早い段階で<a href="https://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%AB%E3%83%95%E3%83%9B%E3%82%B9%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0" rel="nofollow" title="" class="ext-link">セルフホスティング</a>となりました。これは、最も人気で古いGitプロジェクトです。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-git.png" alt="git"><br>
これは、コードが追加された年によって群分けされた、時間経過におけるコードラインの総数を示したグラフです。私はもっと大きな減衰が見られると思っていたので、2006年に書かれたコードが、いまだにコードベースに数多く残っているのが分かり驚きました。</p><p>個別のコミットに対する減衰を計算することもできます。全てのコミットをX=0に並べた場合、特定のRepo内のコードに対する、減衰の総数が分かります。この分析を実装するのは、いろいろな要素があるため、イメージするよりも多少難しくなります（新しいコミットほど時間の経過が少ないため、右端の曲線が少な目のコミットの総数を示す、ということが最も大きな理由です）。</p><p>Gitでは、このプロットは以下のようになります。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-git-survival.png" alt="git git survival"><br>
10年経っても、まだ40パーセントものコードラインが残っています。もっと幅広いオープンソース・プロジェクトを分析してみましょう（ある程度、ランダムに選んでいます）。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-projects-survival.png" alt="git projects survival"><br>
Gitは、他と少し異なるようです。指数関数的減衰でGitを描き、半減期を求めると、6年くらいまでになります。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-git-survival-exp-fit.png" alt="git git survival exp fit"><br>
う～ん。必ずしも完璧な一致とは言えませんが、「<em>全てのモデルが間違っているが、役に立つモデルもある</em>」という有名な言葉があります。私は、指数関数的減衰の説明力が好きです。コードには予想寿命があり、常に置き換えられるリスクがあるのです。</p><p>少し優れたモデルが<em>指数関数の総和</em>を描けるかは疑問です。これは、あるコードはすぐに変化し、別のコードはゆっくりと変化するようなRepoについては有効です。曲線の一致という本筋から離れたことを行う前に、「<em>パラメータが4つあれば象を描くことができ、パラメータが5つあれば象の鼻を揺らすことができる</em>」というフォン・ノイマンの言葉を自分自身に言い聞かせました。うまく一致させる方法はあるのでしょう。しかし、これは別の時に改めて考えようと思います。</p><p>いろいろなプロジェクトを全体的に見てみましょう（こちらも、ある程度ランダムに選んでいます）。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-projects-survival-exp-fit.png" alt="git projects survival exp fit"><br>
全体的な半減期は3.33年でした。覚えやすい数字でいいですね。しかし、プロジェクトによって、その差は<em>大きい</em>ようです。集合モデルに非常に強力な予言力があるわけではなさそうです。任意のオープンソース・プロジェクトを示し、3.33年後に半分のコードが消えると予想することは難しいです。</p><p>Apache（別名<a href="https://github.com/apache/httpd" rel="nofollow" title="" class="ext-link">HTTPD</a>はまた別の、昔からあるRepoです。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-httpd.png" alt="apache"><br>
<img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-httpd-survival.png" alt="apache"><br>
<a href="https://github.com/rails/rails" rel="nofollow" title="" class="ext-link">Rails</a></p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-rails.png" alt="rails"><br>
<img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-rails-survival.png" alt="rails"><br>
<em>実に見事に</em>指数関数に一致していますね。</p><p><a href="https://github.com/nodejs/node" rel="nofollow" title="" class="ext-link">Node</a></p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-node.png" alt="node"><br>
<img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-node-survival.png" alt="node"><br>
自分のRepoで実行してみたくありませんか？　繰り返しになりますが、コードは<a href="https://github.com/erikbern/git-of-theseus" rel="nofollow" title="" class="ext-link">こちらで入手できます</a>。</p><p>私のスクリプトを使えば、これらのRepoのほとんどは、どんなに長くても数分程度で分析できます。最後にテストしようと決めたのは、<a href="https://github.com/torvalds/linux" rel="nofollow" title="" class="ext-link">Linux kernel</a>です。これは<em>巨大</em>で、現時点でのコミット数は635,229です。これは、2番目に大きなRepoである前出の（<a href="https://github.com/rails/rails" rel="nofollow" title="" class="ext-link">Rails</a>）の16倍の規模で、私のお粗末なコンピュータで分析するには数日を要しました。最終的に、処理速度を上げるために、少なくとも3週間コミットされているものと<code>.c</code>ファイルだけに限定して、全ての<code>git blame</code>を計算することにしました。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-linux.png" alt="linux"><br>
線が曲がりくねっていますが、これはサンプリングのメカニズムが原因だと思われます。それにしても、16Mもの膨大な行数が描き出すこの見事なグラフを見てください。各年のコード群の影響は、この規模にしては非常に滑らかです。この規模になると、個々のコミットはほとんど意味がありません。集積和はかなり正確に予想できます。<a href="https://ja.wikipedia.org/wiki/%E6%B0%97%E4%BD%93%E5%88%86%E5%AD%90%E9%81%8B%E5%8B%95%E8%AB%96" rel="nofollow" title="" class="ext-link">ニュートンの法則から熱力学への進展</a>のようなものです。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-linux-survival.png" alt="linux"><br>
Linuxもまた、はっきりと線形成長の様相を呈しています。これは、その高いモジュール性と関係があると推測できます。<code>drivers</code>ディレクトリには、今までのところ、最多のファイル（22,091）があります。それに次ぐのが、様々なアーキテクチャに対するサポートを含む<code>arch</code>（17,967）です。これは、見事に定義されたインターフェースを持っているので、複雑なスケールをうまく行いたい場合に最適だと言えます。</p><p>余談になりますが、複雑さを保ったまま、プロジェクトをうまくスケールするという概念が気に入っています。線形のスケーラビリティは究極の目標であり、その場合、ささいな機能のそれぞれが、だいたい同量のコードを使用しています。一方、粗悪なプロジェクトでは、プロジェクトのスケールは非常に線形的で、ささいな機能のどれもが大量のコードを使用しています。</p><p>話は戻りますが、LinuxとAngularなどの比較はなかなか興味深いものです。Angularは基本的に、Linuxとはまるで逆の様相を見せます。</p><p><img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-angular.png" alt="linux"><br>
<img src="https://raw.githubusercontent.com/erikbern/git-of-theseus/master/pics/git-angular-survival.png" alt="linux"><br>
Angularからランダムに抽出されたコード行の半減期は0.32年程度です。この事実は、Angularに悪影響を及ぼすのでしょうか。Angularのアーキテクチャは基本的に “線形” の、恒常的なものではないのでしょうか。Angularは新しいのだから、この比較は不公平だと思う方もいるかもしれません。これはもっともです。しかし、もし何らかの問題のある設計に対して悪影響を及ぼすとしても、驚かないでしょう。Angularをけなすつもりはありませんが、面白い対比だと言えます。</p><p>任意のプロジェクトのサンプルと、それぞれの半減期を以下に示します。</p><p><em>注釈：プロジェクト　寿命　最初のコミット</em></p><p><a href="https://github.com/moment/moment" rel="nofollow" title="" class="ext-link">moment</a>の半減期がこれほど長いとは、興味深いことです。しかし、その理由は、コードの多くが文化圏固有だからです。このため、安定したコードの核を備えた状態で、時間をかけて線形的な追加が行われるという、線形のスケーラビリティを促進することになります。<a href="https://github.com/expressjs/express" rel="nofollow" title="" class="ext-link">express</a>はもう一方の方向性において、極端な数値を示しています。expressが発表されて7年になりますが、そのコードは非常に早く変化しています。その理由として、(a)コードの線形スケーラビリティが欠けており、(b)おそらく、Node.ｊｓの波に乗るべく、主流になろうとして人気をねらった、初めてのメジャーなJavascriptオープンソース・プロジェクトの1つである、といったことが考えられます。もしかすると、コードベースもイマイチなのかもしれませんが、よく分かりません。</p><p>プロジェクトが始まった年と半減期の間に、このような強い相関関係が見られる理由として、以下の3つのことが考えられます。</p><p>興味深いことに、1については、明らかなエビデンスのデータは何もありません。古いプロジェクトにおいて初期に書かれたコードの半減期は、後期に書かれたコードと同様に長いのです。3についても疑わしいものです。というのも、なぜ、プロジェクトの存続とコードの構造の間に関係があるのかは分からないからです（でも、たぶんあるのでしょう）。結論として言えるのは、<strong>コードの書き方は、基本的に、過去10年間で変化した</strong>ということです。最近のプロジェクトでは、コードはより速いスピードで変化しているように思われます。</p><p>さて、この議論については<a href="https://news.ycombinator.com/item?id=13112449" rel="nofollow" title="" class="ext-link">Hacker News</a>と<a href="https://www.reddit.com/r/programming/comments/5gqurc/the_halflife_of_code_the_ship_of_theseus/" rel="nofollow" title="" class="ext-link">Reddit</a>に掲載されていますので、どうぞご覧ください。</p>
