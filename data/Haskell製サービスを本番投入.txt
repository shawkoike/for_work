<p><a href="http://robots.thoughtbot.com/ship-you-a-haskell" rel="nofollow" title="" class="ext-link">Ship You a Haskell</a> （2014-08-02）by <a href="http://thoughtbot.com/" rel="nofollow" title="" class="ext-link">Pat Brisbin</a></p><p>数週間前、私たちはGiant Robotブログで新しいコメント機能をひそかにリリースしました。パラグラフやコードブロック上でホバーすると、右側に小さなアイコンが表示され、その記事の該当するセクションにコメントできる機能です。</p><p><img src="https://thoughtbot-images.s3.amazonaws.com/ship-you-a-haskell/comments.png" class="aligncenter"></p><p>この機能を公開して、これまでずっと言いたかったことがようやく言えます。ついにHaskellのサービスを一般出荷しました！　ここでは、リリースの概要および仕組みを説明し、私たちが遭遇したさまざまな問題に対するソリューションをいくつか紹介します。</p><p>コメントを処理するのは、記事ページにJavaScriptのスニペットをインクルードすることによってブログに”インストール”されたサービスです。私たちが<a href="https://github.com/thoughtbot/carnival" rel="nofollow" title="" class="ext-link">GitHub</a>に登録したCarnivalという別のサービスは、コメントの追加、検索、および編集を担うRESTfulなAPIと、ユーザエクスペリエンスに対応するためのJavaScriptのフロントエンドで構成されます。バックエンドの部分は、<a href="http://www.yesodweb.com/" rel="nofollow" title="" class="ext-link">Yesod</a>Webフレームワークを使ってHaskellで記述されています。</p><p>この質問に対する答えは、聞く相手によって変わります。言語としてのHaskellを愛好し、何だかんだと理由をつけてその言語を使いたがる人たちは、Haskellの持つ安全性や抽象化の質、開発の喜び、もしくはその他の多くの長所に魅力を感じているはずです。一方、最近Haskellを知って、盛んに開発が進められているものに採用したいと考えたり、それまで慣れ親しんだ言語とは全く異なるこの言語をもっと知りたいと思ったりする人たちもいるでしょう。</p><p>最終的に、私たちは、Haskellを使ってクライアントのプロジェクト要件に見合うものを構築できるか確かめたいと思っています。Haskellが適合しそうなクライアントが現れたら、私たちはコードの記述だけでなく、本番環境での運用に必要な全てのことをHaskellで担う自信を持つべきです。</p><p>このサービスの開発を通して、正しいコードを短時間で書くという点で型安全性のメリットについての話が真実だと証明されました。型駆動型開発（TyDD）と受け入れテストの組み合わせを使うことで、ほとんどのAPIを1日かそこらで記述し、以降のイテレーションやリファクタリングがスムーズに進んだのです。インタプリタ型言語を使い慣れたプログラマにとっては、長時間のコンパイルはイライラするものであり、<a href="http://www.haskell.org/haskellwiki/Cabal/Survival#What_is_the_difficulty_caused_by_Cabal-install.3F" rel="nofollow" title="" class="ext-link">cabalの問題</a>について小さな論争が起きたことも確かにありました。そんなわけで、Haskellにおける依存関係の管理で私が経験してきたことから見ると、<a href="http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html" rel="nofollow" title="" class="ext-link">sandbox</a>とfreezingの導入は、決定的な改善になっています。</p><p>APIのみのサービスを記述するということは、JSONを多用して作業するということです。<a href="http://hackage.haskell.org/package/aeson" rel="nofollow" title="" class="ext-link">aeson</a>ライブラリを通してこの作業をすることは簡潔で、作業に必要とされた非常に限定的な<a href="https://github.com/thoughtbot/carnival/blob/master/Helper/Comment.hs#L64-67" rel="nofollow" title="" class="ext-link">バリデーション</a>ロジックを利用し、安全な（デ）シリアライゼーションができました。一般的にはRailsのAPIサービスを使って記述するバリデーションの多くは、型システムで扱うことが可能です。</p><p>ライブラリは<a href="http://hackage.haskell.org/package/yesod-markdown" rel="nofollow" title="" class="ext-link">markdown</a>や<a href="http://hackage.haskell.org/package/gravatar" rel="nofollow" title="" class="ext-link">gravatar</a>、そして<a href="http://hackage.haskell.org/package/heroku" rel="nofollow" title="" class="ext-link">heroku</a>のサポートといった私たちが必要とする大部分のパッケージのためにあります。しかし重要な例外が1つあります。それはプロバイダとして自分たちの<a href="https://upcase.com/subscribe" rel="nofollow" title="" class="ext-link">Upcase</a>を使うのに必要な、OAuth 2.0による認証です。一般的にYesodには認証のための多大なるサポートがあり、OAuth 1.0には<a href="https://hackage.haskell.org/package/yesod-auth-oauth" rel="nofollow" title="" class="ext-link">プラグイン</a>があります。しかしOAuth 2.0にあったのは時代後れの骨子でしかなかったのです。幸運なことに、骨子にすぎなかったものを正規のパッケージに移動させ、動作を確認し、自分たちで<a href="https://hackage.haskell.org/package/yesod-auth-oauth2" rel="nofollow" title="" class="ext-link">公開</a>することはそれほど大変ではありませんでした。Yesodはこの機能をリリースしませんでしたが、認証ロジックを扱ったモジュール式の方法により、私たちは別の独立したパッケージを加えることができました。</p><p>この試みには、できるだけ通常のプロセスを使ってHaskellで開発する、つまりHerokuにデプロイする、という目的があります。しかしHaskellアプリケーションのクリーンコンパイル（特にYesodやPandocのようなライブラリの使用時）は時間がかかるので、<a href="https://devcenter.heroku.com/articles/slug-compiler#time-limit" rel="nofollow" title="" class="ext-link">15分以内にビルドするという制限</a>が問題になりました。</p><p>先に言っておくと、この問題はバイナリのデプロイ方法によっては回避することができます。VM（Herokuの構造と同じにします）上で、ローカルでコンパイルし、バイナリをHerokuのインスタンスにコピーするという方法もありました。しかし、これは通常のプロセスではありません。開発者であるならばgit push heroku masterで動作させるべきでしょう。</p><p>理論上は、これで動きます。ビルドの大部分はキャッシュされるので、15分を超えそうなものは最初のビルドだけです。これを緩和するために、最も人気があるHaskellの<a href="https://github.com/begriffs/heroku-buildpack-ghc" rel="nofollow" title="" class="ext-link">buildpack</a>は<a href="https://github.com/ddollar/heroku-anvil" rel="nofollow" title="" class="ext-link">Anvil</a>というサービスをサポートし、最初のビルドを時間制限なしの環境で実行させます。しかし、何度も実行を試みてはよく分からないエラーメッセージが出た結果、私たちはAnvilベースのデプロイメントを諦めざるを得ませんでした。自分たちで何とかするしかありません。</p><p>結局、<a href="https://devcenter.heroku.com/articles/dyno-size" rel="nofollow" title="" class="ext-link">PX</a> dynoをアップグレードしても15分以内に終えることはどうしてもできませんでした。私たちの代替Herokuはアプリケーションの時間制限を30分に増やすことができたので、いまのところはこれでビルド可能です。しかし、私はこれを一般的だとはみなしません。<a href="http://hackage.haskell.org/package/pandoc" rel="nofollow" title="" class="ext-link">Pandoc</a>（とその強調表示エンジン）への依存が、ほとんどのYesodアプリケーションよりもコンパイルに長い時間がかかる原因ではないかと考えています。なので、標準のbuildpackを使うことをお薦めします。あまりに時間がかかって壊してしまいたい衝動に駆られる前に、15分以内で終わらせることができるようにと願っています。</p><p>一度ステージングに成功すると、今度は別の問題に気付きました。ユーザがランダムにログアウトしていたのです。その原因はYesodのデフォルトセッションのバックエンドが、Cookieベースの鍵をファイルに保存することにありました。これはHerokuのデプロイメントにおける若干のデメリットです。第一に、ファイルシステムは一過性のものなので、dynoが再起動しようとすると全てのセッションが無効になります。次に、実行中のdynoが2つになることです。1つのdynoにログインしても、次に続くリクエストは2つ目のdynoにルーティングするのでログアウトさせられます。そのため、私たちは環境変数から鍵を読み込む<a href="https://github.com/thoughtbot/carnival/blob/master/Session.hs#L32-43" rel="nofollow" title="" class="ext-link">代替のバックエンド</a>を定義しました。この環境変数は各インスタンスに同じ値を設定できます。</p><p>この試みは確かに成功したと考えています。デプロイメントに関するいくつかの問題が解決できました。これで次のHaskellプロジェクト（すでに準備中です）が、より円滑に進むでしょう。Haskellは私たちが遭遇したような問題の解決にふさわしい言語だと分かりました。Yesodと、ライブラリのすばらしいエコシステムのおかげです。</p>
