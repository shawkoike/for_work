<p><a href="https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-1.html" rel="nofollow" title="" class="ext-link">Kernel booting process Part 1</a> by <a href="https://github.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a><br>
in <a href="https://www.gitbook.com/book/0xax/linux-insides/details" rel="nofollow" title="" class="ext-link">Linux Inside</a> GitBook</p><p>これまでの私の <a href="http://0xax.blogspot.com/search/label/asm" rel="nofollow" title="" class="ext-link">ブログ投稿</a>を読まれた方はご存じかと思いますが、しばらく前から低水準言語を使うようになりました。Linux用x86_64アセンブリ言語プログラミングについても書いています。また、同時にLinuxのソースコードにも触れるようになりました。下層がどのように機能しているのか、コンピュータでプログラムがどのように実行されるのか、どのようにメモリに配置されるのか、カーネルがどのように処理や記憶をするのか、下層でネットワークスタックがどのように動くのかなどなど、多くのことを理解しようと意欲が湧いています。これをきっかけに、<strong>x86_64</strong>版Linuxカーネルについてシリーズを書いてみようと思いました。</p><p>私はプロのカーネルプログラマではないことと、仕事でもカーネルのコードを書いていないことをご了承ください。個人的な趣味です。私は下層で何が起きているのかとても興味があり、単に好きなのです。読んでいて私が勘違いしている点、ご質問やご意見がありましたら、ツイッター（<a href="https://twitter.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a>）や<a href="mail:kuleshovmail@gmail.com">メール</a>でお知らせいただくか、もしくはGithubで<a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2F0xAX%2Flinux-insides%2Fissues%2Fnew" rel="nofollow" title="" class="ext-link">Issue</a>を作成してください。助かります。全ての投稿は <a href="https://github.com/0xAX/linux-insides" rel="nofollow" title="" class="ext-link">linux-insides</a> からアクセスできますので、ぜひ読んでみて下さい。また、私の英文が間違っていたり内容に問題があったりした場合は、お気軽にご連絡ください。</p><p><em>これは正式なドキュメントではありません。あくまでも学習のためや知識共有のためのものですのでご注意ください。</em></p><p>ツールについて学び始めている人のために、本稿やそれ以降の投稿の中で説明を入れるようにします。簡単な前置きはここまでにして、本題のカーネルと下層のものに入りましょう。</p><p>本稿で紹介するコードはLinuxカーネル3.18のものです。変更が生じた場合は、その都度更新します。</p><p>本連載はLinuxカーネルについてのシリーズなのですが、カーネルコードからは始めません(少なくともこの段落では)。ノートパソコンやデスクトップは魔法の電源ボタンを押すと起動します。マザーボードが<a href="https://ja.wikipedia.org/wiki/%E9%9B%BB%E6%BA%90%E5%9B%9E%E8%B7%AF" rel="nofollow" title="" class="ext-link">電源回路</a>に信号を送り、コンピュータに適量の電力が供給されます。マザーボードが<a href="https://en.wikipedia.org/wiki/Power_good_signal" rel="nofollow" title="" class="ext-link">電気を流して大丈夫という信号</a>を受けると、CPUが起動します。CPUによってレジスタに残されたデータはリセットされ、所定の値が設定されます。</p><p><a href="https://ja.wikipedia.org/wiki/Intel_80386" rel="nofollow" title="" class="ext-link">80386</a> や後継のCPUでは、コンピュータがリセットされると次の所定のデータがCPUレジスタに定義されています。</p><p><a href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89" rel="nofollow" title="" class="ext-link">リアルモード</a>でプロセッサは動作を始めます。少し戻ってこの動作モードのセグメント方式を理解しましょう。リアルモードは、<a href="https://ja.wikipedia.org/wiki/Intel_8086" rel="nofollow" title="" class="ext-link">8086</a>を始め、最新のIntel64ビットCPUまでのx86互換のプロセッサに導入されています。8086プロセッサには20ビットアドレスバスがあります。つまり、0-2^20バイト(1メガバイト)のアドレス空間を利用できます。しかし16ビットのレジスタしかなく、16ビットのレジスタが使用できるアドレスは最大で2^16 , または0xffff(64KB)までです。<a href="https://ja.wikipedia.org/wiki/%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E6%96%B9%E5%BC%8F" rel="nofollow" title="" class="ext-link">セグメント方式</a>は、アドレス空間すべてを利用するために用いられる方法です。全てのメモリは65535バイトまたは64キロバイトの固定長の小さなセグメントに分けられます。16ビットレジスタでは、64キロバイト以上のメモリ位置にアクセスできないので、別の方法でアクセスします。アドレスは、前半のセグメントアドレス部分とオフセットアドレスの2つの部分で構成しています。メモリ内の物理アドレスを割り出すには、セグメントアドレスに16をかけ、オフセットアドレス部分を足します。</p><p>例えば、<code>CS:IP</code>が<code>0x2000:0x0010</code>の場合、物理アドレスは次のようになります。</p><p>しかし、セグメント部分とオフセット部分を両方最大にした場合、つまり<code>0xffff:0xffff</code>の場合は次のようになります。</p><p>つまり、最初の1メガバイトよりも65519バイトオーバーしていることになります。リアルモードでアクセスできるのは最大で1メガバイトのため、<a href="https://en.wikipedia.org/wiki/A20_line" rel="nofollow" title="" class="ext-link">A20ライン</a>が無効になっていると<code>0x10ffef</code>は<code>0x00ffef</code>になります。</p><p>リアルモードとメモリアドレスが分かったところで、リセット後のレジスタの値について説明しましょう。</p><p><code>CS</code>レジスタは、見えるセグメントセレクタと隠れたベースアドレスの2つの部分で構成されています。<code>CS</code>ベースと<code>IP</code>の値は既知なので、論理アドレスは次にようになります。</p><p>ベースアドレスをEIPレジスタの値に足して、アドレスバスの最初の部分が生成されます。</p><p>その結果、<code>0xfffffff0</code>ができ、4GB-16byteになります。このポイントを<a href="http://en.wikipedia.org/wiki/Reset_vector" rel="nofollow" title="" class="ext-link">リセットベクタ</a>と呼びます。このメモリ配置には、リセット後にCPUが最初に実行するプログラムが置かれています。これには、<a href="http://en.wikipedia.org/wiki/JMP_%28x86_instruction%29" rel="nofollow" title="" class="ext-link">JMP命令</a>が含まれ、通常はBIOSのエントリポイントを指しています。例えば、<a href="http://www.coreboot.org/" rel="nofollow" title="" class="ext-link">coreboot</a>のソースコードを見ると、次のように書かれています。</p><p>JMP命令の<a href="http://ref.x86asm.net/coder32.html#xE9" rel="nofollow" title="" class="ext-link">オペコード</a>である0xe9と、その宛先アドレスである<code>_start - ( . + 2)</code>があります。また、<code>reset</code>セクションが16バイトで<code>0xfffffff0</code>から始まることが分かります。</p><p>ここでBIOSが実行されます。ハードウェアの初期化とチェックを行い、ブートできるデバイスを探します。ブート順位はBIOS設定に保存されており、カーネルがどのデバイスを使用して起動するのかを操作します。ハードドライブから起動しようとする場合、BIOSはブートセクタを探そうとします。ハードディスクがMBRのパーティションレイアウトによってパーティション分割されている場合、ブートセクタは最初のセクター（512バイト）の最初の446バイトに置かれています。最初のセクターの最後2バイトは<code>0x55</code>と<code>0xaa</code>で、BIOSにこのデバイスが起動可能であることを知らせます。例えば次のようになります。</p><p>これを実行します。</p><p>上のコードが<a href="http://wiki.qemu.org/Main_Page" rel="nofollow" title="" class="ext-link">QEMU</a>にディスクイメージとして作成した<code>boot</code>バイナリコードを使用するよう命令します。上のアセンブリコードによって生成されるバイナリコードはブートセクタの要件（はじめが<code>0x7c00</code>に設定され、マジックシーケンスで終点を指定）を満たしているので、QEMUはそのバイナリコードをディスクイメージのMBRセクタとして扱います。</p><p>次のとおりです。</p><p><a href="https://camo.githubusercontent.com/0c5598327b189059cac641cc7bb963dfdda96cf2/687474703a2f2f6f6936302e74696e797069632e636f6d2f327162777570302e6a7067" rel="nofollow" title="" class="ext-link"><img src="https://camo.githubusercontent.com/0c5598327b189059cac641cc7bb963dfdda96cf2/687474703a2f2f6f6936302e74696e797069632e636f6d2f327162777570302e6a7067" alt="Simple bootloader which prints only `!`" data-canonical-src="http://oi60.tinypic.com/2qbwup0.jpg" style="max-width:100%;"></a></p><p>この例では、16ビットリアルモードでコードが実行され、メモリの0x7c00から始まります。実行が始まると、<a href="http://www.ctyme.com/intr/rb-0106.htm" rel="nofollow" title="" class="ext-link">0x10</a> が呼び出され、<code>!</code>マークが出力されます。残りの510バイトを0で埋め、2つのマジックバイト<code>0xaa</code>と<code>0x55</code>で終わります。</p><p>上のバイナリダンプは<code>objdump</code> で見ることができます。</p><p>実際のブートセクタの場合、この続きは多くの0や感嘆府ではなく、起動処理とパーティションテーブルになります。これ以降はBIOSではなくブートローダが操作します。</p><p><strong>注</strong>：上でも書いたようにCPUはリアルモードで動作します。リアルモードでは、メモリ内の物理アドレスを次のように計算します。</p><p>前述したように、16ビットの汎用レジスタしかなく、16ビットレジスタの最大値は<code>0xffff</code>のため、最大値を取ると次のようになります。</p><p><code>0x10ffef</code>は、<code>1MB + 64KB - 16b</code>と同じになります。しかし、<a href="https://ja.wikipedia.org/wiki/Intel_8086" rel="nofollow" title="" class="ext-link">8086</a>プロセッサは、リアルモードが搭載された初めてのプロセッサであり、A20ラインが有効です。また、<code>2^20 = 1048576</code>は1MBなので、実際に使用可能なメモリは1メガバイトとなっています。</p><p>一般的なリアルモードでのメモリマップは次のとおりです。</p><p>本稿の最初の部分でも書きましたが、CPUが実行する最初の処理は<code>0xFFFFFFF0</code>アドレスに配置されています。これは、<code>0xFFFFF</code> (1メガバイト)よりはるかに大きい領域です。CPUはどのようにしてこのリアルモードでアクセスするのでしょうか。これは<a href="http://www.coreboot.org/Developer_Manual/Memory_map" rel="nofollow" title="" class="ext-link">coreboot</a>ドキュメントに記載されています。</p><p>実行時、BIOSはRAMではなくROMに置かれています。</p><p><a href="https://www.gnu.org/software/grub/" rel="nofollow" title="" class="ext-link">GRUB 2</a>や<a href="http://www.syslinux.org/wiki/index.php/The_Syslinux_Project" rel="nofollow" title="" class="ext-link">syslinux</a>のような、Linux<br>
を起動させることができるブートローダは数多くあります。Linuxカーネルは、Linuxサポートを実行するためのブートローダに必要な条件を指定する<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt" rel="nofollow" title="" class="ext-link">ブートプロトコル</a>を持っています。ここではGRUB 2について取り上げます。</p><p>BIOSはブートデバイスを選んで、ブートセクタコードに対する制御を伝達し、<a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD" rel="nofollow" title="" class="ext-link">boot.img</a>から実行を開始します。このコードは、利用可能な空間が限られているため非常に単純であり、GRUB 2のコアイメージの位置へジャンプするためのポインタを含んでいます。コアイメージは<a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD" rel="nofollow" title="" class="ext-link">diskboot.img</a>で始まりますが、これは通常、最初のパーティションの前の、使用されていないスペースにある最初のセクタの直後に格納されます。上記のコードは残りのコアイメージをメモリにロードしますが、それにはGRUB 2のカーネルとファイルシステムを取り扱うためのドライバを含んでいます。残りのコアイメージをロードした後に、<a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c" rel="nofollow" title="" class="ext-link">grub_main</a>を実行します。</p><p><code>grub_main</code>は、コンソールの初期化、モジュールのためのベースアドレスの取得、ルートデバイスの設定、GRUB設定ファイルの搭載/パース、モジュールのロードなどを行います。実行の最後には、<code>grub_main</code>がGRUBを通常モードへ移動させます。（<code>grub-core/normal/main.c</code>からの）<code>grub_normal_execute</code>が最後の準備を完了させ、オペレーティングシステムを選択するためのメニューを表示します。GRUBメニューを選択する際に、<code>grub_menu_execute_entry</code>が起動し、GRUB<code>boot</code>コマンドを実行して、選択したオペレーティングシステムが作動します。</p><p>カーネルのブートプロトコルを見て分かるように、ブートローダはカーネルのセットアップヘッダを読み込み、いくつかのフィールドを満たさなければいけません。そしてそれは、カーネルの設定コードのオフセット<code>0x01f1</code>から始まります。カーネルヘッダ<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/header.S</a>は次のようにスタートします。</p><p>ブートローダは、これと、（<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L354" rel="nofollow" title="" class="ext-link">この</a>例のようなLinuxブートプロトコルの<code>write</code>でマークされている）残りのヘッダを、コマンドラインや計算から導き出される値で満たす必要があります。カーネルのセットアップヘッダの全てのフィールドの記述や説明についてはここれは触れません。後で、カーネルが使用する時に説明します。<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L156" rel="nofollow" title="" class="ext-link">ブートプロトコル</a>で全てのフィールドの記述を見つけることができます。</p><p>カーネルのブートプロトコルを見て分かるように、メモリマップはカーネルをロードした後、次のようになるでしょう。</p><p>そこでブートローダがカーネルに対する制御を転送したときに、以下で開始されます。</p><p><code>X</code>がカーネルのブートセクタが搭載されている位置を示します。この場合は、<code>X</code>が<code>0x10000</code>で、メモリダンプに見て取れます。</p><p><img src="https://camo.githubusercontent.com/a450cde6ad2b342ce5d8a312c185f6bf80b065b6/687474703a2f2f6f6935372e74696e797069632e636f6d2f3136626b636f322e6a7067" alt="kernel first address" data-canonical-src="http://oi57.tinypic.com/16bkco2.jpg" style="max-width:100%;"><br>
ブートロードはLinuxカーネルをメモリへロードし、ヘッダのフィールドを満たし、そこへジャンプします。今は、カーネルの設定コードへ直接移動することができます。</p><p>ついにカーネルまでたどり着きました。しかし、このままでは、カーネルは起動しません。まず、カーネルとメモリ管理、プロセス管理などの設定が必要になります。カーネルのセットアップの実行は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L293" rel="nofollow" title="" class="ext-link">_start</a>で<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/header.S</a>から開始します。いくつか命令が前にあって、ひと目見ると、少し違和感を覚えるかもしれません。</p><p>ひと昔前は、Linuxカーネルは自前のブートローダを持っていました。ですが、今は実行すると次のようになります。</p><p>次のような結果が見られるはずです。</p><p><img src="https://camo.githubusercontent.com/cff3757c397b6d4ebf2706a874a729cad5eefaef/687474703a2f2f6f6936302e74696e797069632e636f6d2f723032786b7a2e6a7067" alt="Try vmlinuz in qemu" data-canonical-src="http://oi60.tinypic.com/r02xkz.jpg" style="max-width:100%;"><br>
実際は（画像の上にある）<a href="https://en.wikipedia.org/wiki/DOS_MZ_executable" rel="nofollow" title="" class="ext-link">MZ</a>から<code>header.S</code>が開始され、<a href="https://ja.wikipedia.org/wiki/Portable_Executable" rel="nofollow" title="" class="ext-link">PE</a>ヘッダに続いて、エラーメッセージが表示されます。</p><p>これには<a href="https://ja.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" rel="nofollow" title="" class="ext-link">UEFI</a>モードでOSを起動することが必要です。今すぐにこれが稼働するかどうかを確かめることはしませんが、次の章の中の1つで見ていきましょう。</p><p>実際のカーネルセットアップのエントリポイントはこちらです。</p><p>ブートローダ（grub2など）はこのポイント（<code>MZ</code>からオフセット<code>0x200</code>）を知っています。<code>header.S</code>がエラーメッセージが表示される<code>.bstext</code>セクションから始まっているにも関わらず、このエントリポイントへ直接ジャンプします。</p><p>カーネルセットアップのエントリポイントはこちらです。</p><p>ここでは<code>start_of_setup-1f</code>のポイントに対する<code>jmp</code>命令オペコード<code>0xeb</code>が見て取れます。<code>Nf</code>表記が意味するところは、<code>2f</code>が次のローカル<code>2:</code>ラベルを表しているということです。この場合、ジャンプした直後に行くのがラベル<code>1</code>です。そこには残りのセットアップ<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L156" rel="nofollow" title="" class="ext-link">ヘッダ</a>も含まれます。セットアップヘッダのすぐ後に、<code>start_of_setup</code>ラベルで開始される<code>.entrytext</code>を見られます。</p><p>実際にはこれが（もちろんジャンプ命令を除いて）最初に実行するコードです。カーネルセットアップがブートローダから制御された後に、最初の<code>jmp</code>命令がカーネルのリアルモードの開始からオフセット<code>0x200.</code>（最初は512バイト）に格納されます。これは次のLinuxのカーネルブートプロトコルとgrub2のソースコードを見て分かります。</p><p>カーネルセットアップが始まった後、セグメントレジスタが以下の値を持つことを意味します。</p><p>この場合は、カーネルが<code>0x10000</code>に置かれます。</p><p><code>start_of_setup</code>にジャンプした後は、以下の作業が必要になります。</p><p>それでは実装を見てみましょう。</p><p>まず、セグメントレジスタの<code>ds</code>と<code>es</code>が同じアドレスを指すようにし、<code>cli</code>命令を実行して割り込みに応答しないようにします。</p><p>前述したとおり、GRUB 2はカーネルの設定コードをアドレス<code>0x10000</code>に、<code>cs</code>を<code>0x1020</code>にロードします。なぜなら、実行はファイルの冒頭からではなく、以下のコードから開始されるからです。</p><p><code>jump</code>は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L47" rel="nofollow" title="" class="ext-link">4d 5a</a>から512バイト離れたオフセットにあります。また、他の全てのセグメントレジスタと同じように、<code>cs</code>を<code>0x1020</code>から<code>0x10000</code>までアラインする必要があります。それが終わったらスタックを設定します。</p><p><code>ds</code>の値をスタックにプッシュし、続けてラベル<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L494" rel="nofollow" title="" class="ext-link">6</a>のアドレスもスタックにプッシュすると、<code>lretw</code>命令が実行されます。<code>lretw</code>を呼び出すと、ラベル<code>6</code>のアドレスが<a href="https://en.wikipedia.org/wiki/Program_counter" rel="nofollow" title="" class="ext-link">IP（instruction pointer）</a>レジスタの中にロードされ、<code>ds</code>の値を備えた<code>cs</code>もロードされます。それが完了すると、<code>ds</code>と<code>cs</code>は同じ値を持つようになります。</p><p>実際、ほぼ全ての設定コードが、リアルモードでC言語の開発環境を作る準備となります。次の<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L467" rel="nofollow" title="" class="ext-link">ステップ</a>では<code>ss</code>レジスタの値をチェックし、もし<code>ss</code>が間違っている場合は正しいスタックを設定します。</p><p>これは、異なる3つのシナリオを導くことが可能です。</p><p>それでは、これら3つのシナリオを全て見てみましょう。</p><p>1. <code>ss</code>は正しいアドレス（0x10000）を持つ。この場合は、ラベル<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L481" rel="nofollow" title="" class="ext-link">2</a>へと進みます。</p><p>ここで、<code>dx</code>（ブートローダによって与えられる<code>sp</code>を含みます）が4バイトにアラインされ、ゼロになっているかどうか確認できます。ゼロの場合は<code>0xfffc</code>（最大セグメントサイズの64KBより前で4バイトにアラインされたアドレス）を<code>dx</code>内に置きます。ゼロでない場合は、引き続きブートローダに与えられた<code>sp</code>（私の例では0xf7f4）を使います。正しいセグメントアドレス<code>0x10000</code>を格納している<code>ss</code>に<code>ax</code>の値を置いた後で、正しい<code>sp</code>の値を設定します。これで正しいスタックが設定できました。</p><p><img src="https://camo.githubusercontent.com/fd6508ced7cf2bc23a5401388f47c4bf75ffa53b/687474703a2f2f6f6935382e74696e797069632e636f6d2f313669776369732e6a7067" alt="stack" data-canonical-src="http://oi58.tinypic.com/16iwcis.jpg" style="max-width:100%;"><br>
2. 2つ目のシナリオでは（<code>ss</code>!=<code>ds</code>）となります。まず、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/setup.ld#L52" rel="nofollow" title="" class="ext-link">_end</a>(設定コードの最後のアドレス)の値を<code>dx</code>に置き、<code>loadflags</code>のヘッダフィールドを<code>testb</code>命令を使ってチェックし、ヒープ領域を使えるかどうかを確認します。<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L321" rel="nofollow" title="" class="ext-link">loadflags</a>は、以下のように定義されるビットマスクヘッダです。</p><p>また、ブートプロトコルを読むと、以下のように書かれています。</p><p><em>(訳: heap_end_ptrに入力された値が有効であることを示すために、このビットを1にしてください。もしこのフィールドがからの場合、いくつかのセットアップコードの機能は無効になります。)</em></p><p><code>CAN_USE_HEAP</code>のビットが設定された場合は、<code>_end</code>を指す<code>dx</code>に<code>heap_end_ptr</code>を置き、そこに<code>STACK_SIZE</code>（最小スタックのサイズは512バイト）を加えます。これ以降、<code>dx</code>がキャリーでない場合（キャリーでなければ、dx = _end + 512となる）、これの前のケースと同じようにラベル<code>2</code>にジャンプし、正しいスタックを作ります。</p><p><img src="https://camo.githubusercontent.com/49e2c3b70d081f745bc6e53f72df96b806e27cb6/687474703a2f2f6f6936322e74696e797069632e636f6d2f6472376235772e6a7067" alt="stack" data-canonical-src="http://oi62.tinypic.com/dr7b5w.jpg" style="max-width:100%;"><br>
3. <code>CAN_USE_HEAP</code>が設定されていない場合は、<code>_end</code>から<code>_end + STACK_SIZE</code>まで、最小スタックを使うだけです。</p><p><img src="https://camo.githubusercontent.com/33f54e2576edfb855cc90f4669fd49c5556a1aa6/687474703a2f2f6f6936302e74696e797069632e636f6d2f323877303531792e6a7067" alt="minimal stack" data-canonical-src="http://oi60.tinypic.com/28w051y.jpg" style="max-width:100%;"></p><p>メインのCコードにジャンプする前に、あと2つステップが残っています。それは<a href="https://ja.wikipedia.org/wiki/.bss" rel="nofollow" title="" class="ext-link">BSS</a>領域の設定と”マジック”シグネチャの確認です。それでは、まずシグネチャの確認から始めましょう。</p><p>これは単純に、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/setup.ld#L39" rel="nofollow" title="" class="ext-link">setup_sig</a>をマジックナンバー<code>0x5a5aaa55</code>と比べているだけです。この2つが等しくなければ、Fatal errorが表示されます。</p><p>マジックナンバーと等しくなれば、正しいセグメントレジスタとスタックを設定できたことが分かり、あとはBSSセクションさえ設定すればCコードにジャンプすることができます。</p><p>BSSセクションは、静的にアロケートされた初期化されていないデータを保存するために使われます。Linuxでは以下のコードを使い、このメモリ領域が必ず最初は空になるように設定します。</p><p>最初に<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/setup.ld#L47" rel="nofollow" title="" class="ext-link">__bss_start</a>のアドレスが<code>di</code>に移動し、次に<code>_end + 3</code>（+3は4バイトにアラインされている）のアドレスが<code>cx</code>に移動します。<code>eax</code>レジスタは消去され（<code>xor</code>命令を使います）、BSSセクションのサイズ（<code>cx-di</code>）が計算されて<code>cx</code>の中に置かれます。それから、<code>cx</code>は4（=語長）で除算され、<code>stosl</code>命令を繰り返し<code>di</code>が指すアドレスに<code>eax</code>の値（ゼロ）を格納して、<code>di</code>は自動的に4ずつ増加します（これは<code>cx</code>がゼロになるまで続きます）。このコードの実際の効果は、<code>__bss_start to _end</code>から始まり、メモリ内にある全ての語を介してゼロが書き出されるということです。</p><p><img src="https://camo.githubusercontent.com/76b4eece266aae9a5e435c07744abdc2fb7fd6fa/687474703a2f2f6f6935392e74696e797069632e636f6d2f32396d326579722e6a7067" alt="bss" data-canonical-src="http://oi59.tinypic.com/29m2eyr.jpg" style="max-width:100%;"></p><p>これで準備完了です。スタックもBSSもそろったので、C言語の関数<code>main()</code>にジャンプできます。</p><p><code>main()</code>関数は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/main.c.</a>にあります。この働きについては、パート2で説明しましょう。</p><p>これでLinux kernel internalsについて書いた本稿のパート1が終わります。ご質問やご意見がありましたら、ツイッター（<a href="https://twitter.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a>）や<a href="mail:kuleshovmail@gmail.com">メール</a>でお知らせいただくか、もしくはGithubで<a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2F0xAX%2Flinux-insides%2Fissues%2Fnew" rel="nofollow" title="" class="ext-link">Issue</a>を作成してください。本稿のパート2では、Linuxカーネルの設定で実行する最初のCコード、<code>memset</code>、<code>memcpy</code>、<code>earlyprintk</code>の実装といったメモリルーチンの実装、そし初期のコンソールの初期化など、他にも多くを説明していく予定です。</p>
