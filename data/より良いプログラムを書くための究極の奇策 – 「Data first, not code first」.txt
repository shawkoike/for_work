<p><a href="http://etodd.io/2015/09/28/one-weird-trick-better-code/" rel="nofollow" title="" class="ext-link">One Weird Trick to Write Better Code</a> (2015-09-28) by <a href="https://twitter.com/etodd_" rel="nofollow" title="" class="ext-link">Evan Todd</a></p><p><small>(訳注：2015/10/31、いただいた翻訳フィードバックを元に記事を修正いたしました。)</small></p><p>開発者は嫌うでしょう。</p><p>ここでは、標準的なコツや策略について書きますが、本当に興味があるのは、別のことです。究極の奇策を見つけたいと思います。策略をひとつずつ試して、プログラミングの聖域に少しでも近づければ良いのですが。</p><p>私が初めて書いたビデオゲームは、<em>Ninja Wars</em>（忍者戦争）でした。</p><p><img src="http://etodd.io/assets/ninjawars.png"><br>
そう、これは、画像で埋めたHTMLのtableです。<code>src</code>属性を変えることで、動きを実現しています。JavaScriptファイルの冒頭は下記のようになっています。</p><p>見たことのあるコードだと思います。このようなコードでプログラムを書き始めているのは私だけではありません。しかしながら、(プログラミングの定石のように見える) この部分が実は大間違いです。従って、この部分に対する私の提案が、策略その1となります。</p><p>この時点では、グローバル変数がなぜ悪なのか説明することはできません。直観的に違うと感じているのです。</p><p><em>追記：今はグローバル変数に対して否定的ではないことをはっきりと言っておきます。でも、先走ってしまうことになるので、ここでは否定的な観点から話をします。</em></p><p>オブジェクトについてはこの後触れますが、変数は次のようにまとめることができます。</p><p>さらにここで継承を使えば、コピー＆ペーストの手間を省くことができます。</p><p>継承は便利です。次の策略にも使えます。</p><p>オブジェクト指向プログラミングは最高で、昔ながらのビデオゲームの多くのコア部分となっています。Doom 3のコア部分もそうであり、偶然にも<a href="https://github.com/id-Software/DOOM-3-BFG" rel="nofollow" title="" class="ext-link">オープンソース</a>となっています。</p><p>Doom 3には継承が多用されています。信じられない？　このゲームのクラス階層のサブセットの一部は以下の通りです。</p><p>仮に、あなたがid Softwareの社員だったとします。この継承階層は最初の数カ月は順調に機能するでしょう。そして、ある運命的な月曜日、大惨事が起こります。ボスに呼ばれ、「計画変更だ。プレーヤーを車にする。」と言われます。</p><p>階層の<code>idPlayer</code>と<code>idAFEntitiy_VehicleFourWheels</code>を見て下さい。大問題その1です。<em>多く</em>のコードをいじる必要があります。</p><p>大問題その2です。ボスが正気に戻り、「プレーヤーを車にする」案を取り消します。その代わりに、全てに砲塔を装備すると言い出しました。車はHalo Warthog（車体後部に機関銃を装備した四輪駆動車）となり、プレーヤーは大型の砲塔を背負います。</p><p>ずぼらなプログラマなので、コピー＆ペーストの作業を省くために、また継承を使います。しかし、階層を見てください。砲塔のコードはどこに書き込めばよいのでしょうか。<code>idPlayer</code>と<code>idAFEntity_VehicleFourWheels</code>の共通の親は<code>idAFEntity_Base</code>のみです。</p><p>そのため、恐らく<code>idAFEntity_Base</code>にコードを書き込み、<code>calledturret_is_active</code>のブーリアンフラグを追加します。この時、車とプレーヤーのみをTRUEに設定します。これで確かに機能しますが、その結果、あまりにも多くのものがベース階層に書き込まれすぎてしまっています。<code>idEntity</code>のソースコードは次のとおりです。</p><p>スクロールして見てください。全部見る必要はありません。</p><p>つまり、言いたいのは、コードが長いということです。Physics debrisに至るまでの全てのエンティティにチームという概念があり、殺されてしまうと概念があります。あきらかに理想的とは言えません。</p><p>もし、Unityのゲーム開発者なら解決策はお分かりでしょう。コンポーネントです。次のようになります。</p><p><img src="http://etodd.io/assets/unity.jpg"><br>
Unityのオブジェクトは、機能の継承ではなくコンポーネントのまとまりなのです。これで、先ほどの砲塔の問題を簡単に解決できます。砲塔のコンポーネントをプレーヤーと車のオブジェクトに追加すれば良いのです。</p><p>Doom 3にコンポーネントを使用した場合、次のようなコードになります。</p><p>ここまででわかることとは何でしょうか。</p><p>ここまでの策略を振り返ってみると、グローバル変数はダメ、オブジェクトはいい、コンポーネントはさらにいいとの結果がでました。次に説明することは信じ難いかもしれません。</p><p>ちょっとだけ脱線して、どの関数がより速いのかというとても簡単な質問を手掛かりに下層階のパフォーマンスの世界をのぞいてみましょう。</p><p>多くの複雑性はひとまず忘れて、これら2つの関数がいずれ、それぞれ1つのx86命令にコンパイルされると仮定します。恐らく、関数<code>a</code>は<code>sqrtps</code>にコンパイルされ、関数<code>b</code>は<code>lea</code>(「load effective address」命令)のようなものにコンパイルされるでしょう。</p><p><a href="http://www.intel.co.jp/content/dam/www/public/ijkk/jp/ja/documents/developer/248966-024JA.pdf" rel="nofollow" title="" class="ext-link">インテルマニュアル</a>によると、<code>sqrtps</code>命令には、最新のインテルプロセッサでおよそ14CPUサイクルが浪費されます。では、<code>lea</code>命令はどうでしょうか。</p><p>答えは、「それは複雑な問題」ということになります。データの書き込みがどこから実行されるかによって変わってくるのです。</p><p>最後の数字が重要なのです。メインメモリにアクセスするのに100-300サイクル浪費するのです。つまり、どのような時でも、障害となるのは、メモリへのアクセスになるということでしょう。見て分かるように、L1やL2、L3のキャッシュの使用を増やせばこの状況を改善することができます。でもどのようにすれば良いのでしょうか。</p><p>では、Doom 3に戻って現実的な例を挙げてみましょう。次は、Doom 3のアップデートループです。</p><p>オブジェクト指向の観点からすると、このコードはきれいで汎用性があります。多分<code>RunEntityThink</code>が仮想の<code>Think()</code>メソッドを呼び出すことで、ほとんどのことができるのだろうと思います。とても応用がきくと思います。</p><p>おっと、ボスがまた戻ってきました。質問があるようです。</p><p>簡単に言うと次のとおりです。</p><p><img src="http://etodd.io/assets/shrug.gif"><br>
しかし、これだけではありません。よく見てみると、オブジェクトはリンクされたリストに格納されています。メモリ内では、次のようになっています。</p><p><img src="http://etodd.io/assets/linked-list.png"><br>
これではL1やL2、L3のキャッシュが残念なことになっています。リストの最初のアイテムにアクセスするとキャッシュは、「次に欲しいのは近くのアイテムだ」と思います。そして、最初のアクセスが終わると、次の64バイトを引っ張ってきます。しかしその直後、全く別のメモリ領域へと飛ぶため、キャッシュは使おうとした64バイトをクリアし、RAMにある新データにアクセスします。</p><p>こんな感じです。</p><p>オブジェクト指向のプログラマは、このコードに怒りを覚えるかもしれません。汎用性が全然足りないからです。ご覧の通り、隣接している配列に対して同じ処理を繰り返し実行しています（ポインタの配列ではありません、念のため）。従って、メモリの中身はこのようになります。</p><p><img src="http://etodd.io/assets/components.png"><br>
全てが順番に並んでいます。キャッシュは大満足です。おまけに、このバージョンを使えば、ボスから投げかけられた煩わしい質問に、全部答えることができます。今なら私たちは、実行とはどういうことか、どの順番で実行しているかが分かっていますし、並行処理に書き換えるのもずっとやりやすくなったように見えます。</p><p><em>追記：キャッシュの最適化に熱中しすぎないように気を付けてください。最適化は、全てを配列に配置すれば終わりというわけではありません。本稿でこの処理を取り上げたのは、要点の裏付けとするためですが、私の力では、初歩の導入部分を説明することぐらいしかできません。詳細は本稿の最後に示すリンク先を参照してください。</em></p><p>ではそろそろまとめに入ります。究極の奇策とは何でしょう。策略その1からその4（本当はまだまだ続きがあります）の共通点とは何でしょう。</p><p>グローバル変数を悪だと考える根拠は何でしょう（策略その1）？　ずぼらなデータ設計でもどうにかごまかせるからです。</p><p>オブジェクトはなぜ便利なのでしょう（策略その2）？　データの整理がやりやすくなるからです。</p><p>コンポーネントがさらに便利なのはなぜでしょう（策略その3）？　コンポーネントはデータをうまくモデル化していて、現実のデータ構造と調和しやすくなっているからです。</p><p>また、データをきちんと整理すればCPUにも喜んでもらえます（策略その4）。</p><p>では実例を示しながら説明します。Unityでよく見られる、コンポーネントベースのゲームデザインの例を示します。</p><p><img src="http://etodd.io/assets/uml.png"></p><p>1つのコンポーネントが1つのオブジェクトになっています。オブジェクトの中では、上の方にステート変数が列挙されていて、その下に、その変数を使うメソッドが挙げられています。</p><p>これはよく練られたデザインの、オブジェクト指向のシステムなので、変数はプライベート変数です。変数にアクセスできるコードは、そのオブジェクト内のメソッドだけです。これを「カプセル化」と言います。<br>
<img src="http://etodd.io/assets/uml-encapsulation.png"></p><p>オブジェクトにはそれぞれ、ある程度の複雑性が含まれます。でも恐れることはありません。OOP（オブジェクト指向プログラミング）の世界では、変数のステートをプライベートにしておく限り、複雑性はオブジェクト内にカプセル化されたままで、他のオブジェクトに拡散することはないというのがお約束です。</p><p>しかし残念ながら、これは真実ではありません。</p><p><img src="http://etodd.io/assets/throne-of-lies.jpg"><br>
<em>訳：お前が座っているのは嘘で固められた玉座だ</em></p><p>2～3個のオブジェクトにアクセスする関数が必要になることが、往々にしてあります。こういう場合、現実的な解決策は次の2つのうちのどちらかです。1つは、あくまでオブジェクト内で完結するように、関数の方を分割する方法です。もう1つは「getなんとか」「setなんとか」のような関数を山ほど書いて、必要なデータにアクセスする方法です。ただし、どちらのソリューションもあまり感心しません。</p><p>ここからが真実です。オブジェクトとして表そうとするとあまりうまくいかないものごとが、現実には存在します。そこで私はオブジェクトに代わるパラダイムを提案します。どんなプログラムでも完璧に表現できるパラダイムです。</p><p><img src="http://etodd.io/assets/data-flow.png"><br>
<em>訳注：入力データ→プロセス→出力データ</em></p><p>データをプロセスから切り離せば、がぜん分かりやすくなります。</p><p>オブジェクト指向には、美しいコードを書きやすいという利点があります。複雑性（つまりステート）はカプセル化するという決まりがあるからです。一方、カプセル化には特定の処理方法しか許されない、という性質もあります。以下の図のようなカプセル化が認められてもいいと私は思います。こうすれば問題が起こった現場では、ちゃんと筋が通るのですから。</p><p><img src="http://etodd.io/assets/data-flow-encapsulation.png"></p><p>まとめると、データ構造の設計は、あなたが直面している問題に即した形にすることが大事です。1つのコンセプトを幾つにも分割して、カプセル化したオブジェクトに押し込んではいけません。</p><p>それから、関数を書く時は、使用するデータに残すフットプリントをできるだけ小さくします。可能であれば、純粋にステートレスな関数を書いてください。</p><p>これが策略です。</p><p>本稿に共感できたとすれば、それは私がほとんど以下の文献に頼ってこれを書いたからでしょう。その文献を正直に紹介します。</p><p>最後まで読んでくださってありがとうございました。感想があればぜひコメント欄に書き込んでください。</p>
