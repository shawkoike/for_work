LLVM for Grad Students （2015-08-03） by Adrian Sampsonこの記事は、LLVMコンパイラ基盤を使ってリサーチをする人のための入門書です。これを読めば、コンパイラに全く興味のない大学院生も、楽しみながらLLVMを使って優れた功績をあげられるようになるでしょう。LLVMは非常に優れていて、ハックしやすく、C言語やC++のような”ネイティブ”言語向けの、時代の先端を行くコンパイラです。LLVMの素晴らしさに関しては他にも様々な話を聞くのではないでしょうか（JITコンパイラとしても使えるとか、C言語系列以外の様々な言語を強化できるとか、App Storeからの新しい配信形態であるとか、などなど)。もちろん全部本当のことですが、今回の記事の目的としては、上述の定義が重要です。LLVMが他のコンパイラと差別化される理由には、いくつかの大きな特徴があります。LLVMは素晴らしいコンパイラですが、コンパイラの研究をしていない人にとっては興味がないですよね。コンパイラ基盤とは、プログラムを使って何かをする時に役立つものです。私の経験からすれば、大変大きな役割を果たします。プログラムを分析し、何らかの処理の頻度を調べたり、システムとの整合性を向上させるための変更を行ったりできます。また、新しいアーキテクチャやOSを仮想的に使用するための変更を行えるので、実際に新しいチップを組み入れ、カーネルモジュールを記述する必要もありません。多くの人が支持するツールよりも、大学院生にとってはコンパイラ基盤が適切なツールであると言えます。他に正当な理由がない限り、下記のようなツールをハックするのではなく、最初からLLVMを試してみることをお勧めします。あるコンパイラがあなたのタスクにぴったりだとは思えなくても、例えば、ソースからソースに変換をするよりはるかに簡単に、やりたいことの90%を達成できるでしょう。それほどコンパイル的ではない研究プロジェクトにLLVMを用いた、効果的な事例を以下にいくつか挙げます。もう一度強調します。LLVMは、ただ新しいコンパイラの最適化を実装しただけのものではないのですよ。ここに描いたのは、LLVMのアーキテクチャの主要な構成要素です（モダンなコンパイラのアーキテクチャでもあります）。

各要素の説明は以下の通りです。
* フロントエンドがソースコードを中間表現（またはIR）に変換します。この変換によって、これ以降のコンパイラの作業が単純化され、C++の複雑なソースコードと格闘しなくても済むようになります。果敢な大学院生のあなたは恐らく、この部分をハックしなくてもいいでしょう。修正無しでClangが使えます。
* PassがIRをIRへと変換します。通常の状況では、passはコードを最適化します。つまり、passは入力されたIRと同じことをするIRプログラムを出力するのですが、より速くなるよう最適化するのです。ここがハックのしどころです。あなたの研究ツールはIRがコンパイルのプロセスを通過している間、それを参照し変更しながら作業できるでしょう。
* バックエンドは、実際の機械語を生成します。この箇所についてはほぼノータッチで構いません。このアーキテクチャは、昨今のほとんどのコンパイラに当てはまりますが、LLVMには注目すべき点が1つあります。それは、全プロセスを通じてプログラムが同じIRを使うということです。他のコンパイラでは、pass毎に独自のコードが生成されることがありますが、LLVMはこれとは逆のアプローチをとっています。私たちハッカーにとっては素晴らしいことで、プロセスがフロントエンドとバックエンドの間である限り、どこでコードが実行されるか心配しなくても済むからです。ではハックしてみましょう。まずLLVMをインストールします。通常、Linuxのディストリビューションから、LLVMとClangのパッケージがすぐ使える形で入手可能です。注意しなければいけない点は、ハックするために必要なヘッダを含んだバージョンを入手するということです。例えば、 Xcodeに付属してくるOS Xのビルドは完全版ではありません。幸い、CMakeを使えばソースからLLVMをビルドするのはそう難しくありません。通常はLLVMだけをビルドすればいいのです。バージョンさえ合っていれば、システムに付属してきたClangでも十分使えます（ただし、Clangをビルドするための指示書もありますから確認してくださいね）。特にOS Xに関しては、Brandon Holtによる作業を正しく行うための優れた指示書を公開していますし、Homebrew formulaも提供されています。ドキュメントをよく読み込みましょう。下記に挙げるリンクは繰り返し参照する価値のあるものです。LLVMを使って生産的な研究をするには、カスタムのpassを作成したほうがいいでしょう。この項では、臨機応変にプログラムを変換することのできるシンプルなpassをビルドし、実行するまでを解説します。実用的ではないLLVM passを格納したテンプレート用のリポジトリを作ったので、このテンプレートから着手してみてください。一から作ると、ビルドコンフィギュレーションの設定に手間がかかるかもしれません。GitHubからllvm-pass-skeletonリポジトリをクローンします。実際の作業はskeleton/Skeleton.cpp上で行われるので、ファイルを開きましょう。ここで作業が行われます。LLVMのpassが何種類かありますが、私たちが使うのはfunction passと呼ばれるものです（最初に手を着けるのに適しています）。予想通り、LLVMは、コンパイルをかけているプログラムの中に見つけた全ての関数に対して上記のメソッドを呼び出します。今のところは、名称の出力しかしていません。詳細は以下の通りです。CMakeでpassをビルドします。LLVMがグローバルにインストールされていない場合は、CMakeに対して場所を指示する必要があります。LLVM_DIR環境変数の中にLLVMがあるshare/llvm/cmake/ディレクトリならどこのパスを指定しても大丈夫です。Homebrewのパスの例は下記のようになります。Passをビルドすると共有ライブラリが生成されます。build/skeleton/libSkeletonPass.soまたは、プラットフォームに応じて似たような名称で見つけられます。次は、このライブラリを読み込んで、実際のコード上でこのpassを実行してみます。新しいpassを実行するには、Cのプログラムでclangを呼び出し、今コンパイルした共有ライブラリを指す変なフラグを使います。この-Xclang -load -Xclang path/to/lib.soを使えば、Clang上であなたのpassを読み込み、アクティベートできます。より大きなプロジェクトを処理する必要があるなら、MakefileのCFLAGSか、あなたのビルドシステム上の同等なものに対して、これらの引数を付加すればいいのです。（clangから呼び出すのとは別に、passを一度に実行することもできます。これは、LLVMのoptコマンドを用いるやり方で、公式のドキュメントで記述されている方法ですが、この記事では触れません）。おめでとうございます。コンパイラのハックができました。次は、この演習passを拡張して、プログラムに対して何か面白いことをしてみましょう。
モジュールは、関数で構成され、関数は基本ブロックで、基本ブロックは命令で構成されています。モジュール以外の全ては、値から枝分かれします。LLVMでプログラムを扱うには、多少なりともIRの構造を知っておく必要があります。以下はLLVMプログラムで最も重要な構成要素の概要です。関数や基本ブロック、命令を含むLLVMのほとんどが、値と呼ばれる多岐にわたる基底クラスから継承しているC++のクラスです。値は、数字やコードのアドレスなど、計算に使える値であれば何でも構いません。グローバル変数や定数（リテラル、即値とも呼ばれる。例えば数字の5など）もまた値になります。以下は、人間が理解することができる形式で記述されたLLVM IRの命令の一例です。この命令は、2つの32ビット整数（i32型と表示）を加算することを意味しています。つまり、レジスタ4（%4）の整数とリテラル2（2）を加算し、その結果をレジスタ5に表示させるということです。先程、私がLLVM IRは理想のRISCの機械語に似ていると言ったのは、これが理由です。レジスタといった同様の専門用語を使っていますが、たくさんのレジスタが無限に存在します。同様の命令は、C++クラスの命令のインスタンスとしてコンパイラの内部で表現されています。オブジェクトには命令コードがあり、加算であること、型であること、そして他の値のオブジェクトのポインタであるオペランドのリストであることを示しています。この例の場合、定数のオブジェクトは数字の2であり、他の命令はレジスタ4となります。（LLVM IRは静的単一代入であることから、レジスタと命令は1つずつで、それらは同じものになります。レジスタの数値は、文字表現の中間生成物です。）もし、あなたのプログラムでLLVM IRを出力してみたいのであれば、Clangを使ってみてください。では、LLVM passの話に戻りましょう。全ての重要なIRオブジェクトを調査するには、dump()という、誰もが知っている便利なメソッドを使います。これはIR内にある、人間が理解することができるオブジェクトの表現を出力してくれます。Passは関数に渡されているので、これを各関数の基本ブロック、そして各基本ブロックの命令セットに繰り返し適用するために使いましょう。以下がそのコードです。このコードは、“containers（構成）”ブランチ内にあるllvm-pass-skeletonというgitリポジトリから入手が可能です。C++11のauto型やforeachシンタックスを使えば、LLVM IRの階層間の移動が容易になります。再度passを構築し、それを通してプログラムを起動させると、パーツ間を行き来するたびに、IRの様々なパーツが分散されていくのが分かると思います。プログラムのパターンを探し、それが見つかったら、そのコードを変えてみてください。驚くことが起こります。簡単な例を挙げましょう。例えば、全ての関数の最初の二項演算子(+, - など)を乗算に変換したいとします。なんだか役立ちそうですよね？コードはこんな感じになります。このバージョンは、実際に試せるプログラムの例と併せて、“mutate（変換）”ブランチ内にあるllvm-pass-skeletonというgitリポジトリから入手が可能です。詳細は以下の通りです。では、下記のプログラムをコンパイルすると、どうなるでしょう（コードはリポジトリにあるexample.cです）。通常のコンパイラでコンパイルをするとコードに記述された通りの結果となりますが、私たちのプラグインでは、2を追加するのではなく、値を倍にする結果となります。素晴らしい！重要な作業をするために、コードをインストルメントしなくてはならない時、IRBuilderを使ってLLVMの命令を生成するのは手間がかかるので、C言語にランタイムの振る舞いを記述し、コンパイルしているプログラムにリンクさせたいと思うかもしれません。ここでは、二項演算子の結果をログするランタイムライブラリの記述方法を紹介します。以下は、LLVMのpassコードです。このコードは、“rtlib“ブランチ内のllvm-pass-skeletonリポジトリから入手できます。必要なツールは、Module::getOrInsertFunctioとIRBuilder::CreateCallです。前者は、ランタイム関数logopに対する宣言を定義します。これは、関数本体を持たないC言語のソースのプログラムにあるvoid logop(int i);の宣言と類似しています。インストルメント化されたコードは、logop関数を定義するランタイムライブラリ（リポジトリにあるrtlib.c）と組み合わされます。インストルメント化されたプログラムを起動するには、ランタイムライブラリとリンクさせます。また、機械語にコンパイルする前に、プログラムとランタイムライブラリをまとめることも可能です。llvm-linkユーティリティ（ldと同等レベルの大まかなIRと思われるかもしれませんが）が活用できます。ほとんどのプロジェクトは、最終的にプログラマと連携しなくてはなりません。そして、プログラムからLLVM passに追加情報を渡す方法である、アノテーションの必要性を感じるでしょう。ここで、アノテーションシステムを構築するいくつかの方法をご紹介します。これらのテクニックに関して更なる記事を投稿していきたいと思います。LLVMは膨大な範囲に及びます。今回、触れることができなかったトピックについて、いくつか挙げておきます。あなたが素晴らしい何かを作り出すのに、少しでも助けになることを願っています。研究して、作成して、これが役に立ったか教えてください！ワシントン大学のアーキテクチャグループとシステムグループに感謝します。この記事で取り扱ったトピックに対し活発に議論し、刺激になるいい質問をしてくれました。親切な読者による補遺。コメントや質問があれば、メールしていただくか@samps宛てにツイートしてください。
