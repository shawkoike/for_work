<p><a href="http://robotlolita.me/2016/01/09/no-i-dont-want-to-configure-your-app.html" rel="nofollow" title="" class="ext-link">No, I Don't Want To Configure Your App!</a> （2016-01-09） by <a href="https://twitter.com/robotlolita" rel="nofollow" title="" class="ext-link">Quil</a></p><p>(訳注：2016/3/2、頂いたフィードバックをもとに記事を修正いたしました。)</p><p><strong class="heading">注</strong><br>
このブログ投稿は不満をぶちまけています。かなりのものです。自説は曲げません。長いです。そして、頭に血が上っています。かなり暴言です。</p><p>最近、ソフトウェア開発において復活しつつあるとても<em>興味深い</em>傾向があるようです。おそらくNode.jsの哲学に影響を受けているのでしょう。何かを使うためには、まず大量の「依存パッケージ」をインストールする必要があり、さらにそのコンフィギュレーションに10時間を費やし、あなたが信じている神（もしくは天の存在）のようなもの―たとえ信じていなくても―に祈ります。そして、とても運が良ければ、また夜空に星がきちんと並べば、画面に”Hello, world”という出力を見ることができるのです。</p><p>例えば<a href="https://webpack.github.io/" rel="nofollow" title="" class="ext-link">WebPack</a>や<a href="https://babeljs.io/" rel="nofollow" title="" class="ext-link">Babel.jsのバージョン6</a>といった、新しい人気のツールからも明らかなように、どうやら、より多くのコンフィギュレーションが、常により良いということを意味するようです。このことにより、昔Javaがどうしてそれほどまでに人気のプラットフォームであったかについても説明がつきます。</p><p>なぜプログラミングツールにすっかり嫌気がさすのか（つまり、そうですね、ほとんどのアプリケーションに、間違いなく<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup>）についてかなり科学的に分析を始める前に、いくつかの用語を確認しておきましょう。</p><p>これらの定義があれば、WebPackもBabelも<em>アプリケーション</em>の定義に合わないだけだと結論づけることができます。<em>フレームワーク</em>の定義にもほとんど合わないので、<em>ライブラリ</em>というしかありません。</p><p>このことは、こういったツールが、「コンパイラ」が文献で定義されたのと同様に「トランスパイラ」を定義し、この2つの言葉は同義ではないと発言したコミュニティから生まれたということを考えれば、驚くべきことではないでしょう。</p><p>タイトルがすべてです。ここはこれで終了です。お読みいただきありがとうございます。</p><p>あるいはもう少しお役に立てるかもしれません。ええと…。</p><p>ちょっとコーヒーメーカーの例に戻りましょう。</p><p>コーヒーメーカーは非常に素晴らしいです。「コーヒーを入れる」というボタンが１つだけあります。それを押すと、処理が始まり、コーヒーが注がれます。</p><p><img src="http://robotlolita.me/files/2016/01/gay1.png" alt=""><br>
あなたは幸せで陽気です。<br>
<img src="http://robotlolita.me/files/2016/01/gay2.png" alt=""><br>
しかし・・・違ったコーヒーが欲しければどうしますか？　コーヒーメーカーのボタンがもっと必要になるかもしれません。砂糖を入れるかどうか選ぶボタンや、コーヒーに加えるミルクの量を選ぶボタン、クリームを入れるかどうかを選ぶボタン、さらには、コーヒーではなく<em>紅茶</em>を入れるボタン。もしくは・・・</p><p>飲み物が欲しいだけなのに、ここまでくるとあまりにも多くの選択を迫られ、自分でコーヒーを入れるのと同じくらい面倒に感じます。それに加え、コーヒーメーカーの<em>取扱説明書</em>も必要です。</p><p><img src="http://robotlolita.me/files/2016/01/sad1.png" alt=""><br>
悲しみと欲求不満がなぜか対応できないぐらいあふれます。<br>
<img src="http://robotlolita.me/files/2016/01/sad2.png" alt=""><br>
この2つのコーヒーメーカーの使用体験を比べると、本当に欲しい種類のコーヒーが飲めなかったとしても、<em>前者の方がずっと良いです。</em></p><p>これが常識だったとしても、コンピュータアプリケーションは後者を好みます。Babel v5とBabel v6で使用感を比べてみましょう。</p><p>これがBabel v5です。</p><p><img src="http://robotlolita.me/files/2016/01/babel5.png" alt=""><br>
<em>Babel v5 では何とか動いています。</em></p><p>そして、これがBabel v6です。</p><p><img src="http://robotlolita.me/files/2016/01/babel6.png" alt=""><br>
<em>こ、これはどういうことなのでしょう？</em></p><p>ご覧のとおり、Babel v6はまったく動かないだけでなく、意味不明なエラーが出ていて、問題解決にはどうすべきなのか見当もつきません。</p><p>あなたならどうしますか？　まあ、動くべきものが動かない理由をインターネットで調べるでしょう。それに時間を費やします。ドキュメンテーションの”’—-help”’コマンドの項目には”'”Usage: babel [options] <files ...> “”’とだけ書いてあるでしょう。</files></p><p>ドキュメンテーションを読むと気付きます。”’npm install babel-cli”’を実行してES6からES5へのコンパイラをインストールすれば良かったはずだったのに、コンパイラを動かすためには<strong>実際</strong>にそのコンパイラをインストールしなければならないと書いてあるのです。</p><p><img src="http://robotlolita.me/files/2016/01/babel-w-h-y.png" alt=""><br>
<em>注釈：</em></p><p>以下のコマンドをローカルで実行してBabel CLIをインストールすることができます。</p><p>”’$ npm install –-save-dev babel-cli”’</p><p>”’$ ./node_modules/.bin/babel src –d lib”’</p><p>注<br>
Babel Pre-6.xは、デフォルトで特定の変換が可能です。しかし、Babel 6.xでは変換が標準装備ではありません。明確にどの変換を実行するのか指定する必要があります。その最も簡単な方法は、ES2015 Presetのようなプリセットを使用することです。</p><p><em>言葉がありません。</em></p><p>そのため、上記の注にある2つのリンク先（1つは問題解決法にはまったく触れていません。余計に混乱し欲求不満となるだけです）を読むと、アロー関数や配列展開をコンパイルするだけに200MBものデータ<sup id="fnref:2"><a href="#fn:2" class="footnote-ref">2</a></sup>をインストールし、自分の環境で動くようにするのです。どこに保存するのか、どのフォーマットなのか、どうやって使うのかわからないテキストファイルも作成する必要があります。わからないのは、リンク先のどこにも（ドキュメンテーションのどのページにも）何の説明もないからです。</p><p>「神様がグチをこぼすことを許さないので、これを”そんなものだ”と受け入れなければならない」とうのは言いましたっけ？ そう、良かった。</p><p><img src="http://robotlolita.me/files/2016/01/babel6-take2.png" alt=""><br>
<em>うまくいっているようですが、そんなこと誰がわかるでしょう。</em></p><p>では、良い考えと思われたこれまでのBabelの方法の何が悪かったのでしょうか？　ええ、特に何も悪くありません。選択肢を減らしたければ、プログラムを設定する方法を簡単に追加できたはずです。しかし、そうではなく、<strong>すべてのユーザ</strong>に最初にBabelをインストールするという選択をさせることにしたのです。</p><p>どうやったら、イライラしない、また、ユーザがコン​​ピュータのことを知らなくても済むようなアプリケーションを作成できるのでしょうか。それには、<a href="https://elementary.io/ja/docs/human-interface-guidelines#avoid-configuration" rel="nofollow" title="" class="ext-link">Elementary OSのヒューマンインターフェースガイドライン</a>から始めるといいでしょう。たとえElementary OSアプリケーションを設計しない場合でも、ガイドラインに書かれていることを全てまねすれば、たいてい、<strong>人間にとって本当に使いやすい</strong>アプリケーションが作成できます。</p><p>『ヒューマンコンピュータインターフェース』の<strong>ヒューマン</strong>は強調してもしきれません。設計する際は、使用する人間のことを、ぜひ考えてください。</p><p>理想的なアプリケーションは、インストールすればすぐに使えるものです。コンフィギュレーションは、一切必要ありません。時間を無駄にすることもありません。しかし、たまに、アプリケーションを起動して実行するには、特定のデータが必要になることがあります。では、あなたならどうしますか。</p><p><em>ルール1：コンフィギュレーションが必要なアプリケーションは間違っている</em></p><p>「ユーザに情報を入力させるのですか？」</p><p>それは、<strong>やってはいけないこと</strong>です。その情報は既にあるはずです。</p><p>しかし、時には、コンピュータのどこにもない情報があります。 「そういう場合は、ユーザに尋ねるしかないのでしょうか」——それは、時と場合によります。<strong>アプリケーションを実行するために</strong>、ユーザに情報を入力させることが本当に必要なのでしょうか。もしそうなら、それは、たぶん間違いです。代わりに、アプリケーションを実行するために必要なものをすべてパッケージ化してみてください。</p><p>「それでも、いつか必ずコンフィギュレーション<em>プロファイル</em>が必要になります」——確かに。では、コンフィギュレーションがどうしても必要になった<strong>場合は</strong>、ユーザにコンフィギュレーションツールを提供してください。ユーザのユースケースに最適な設定の仕方も手引きしてください。ただし、コンフィギュレーションファイルは使用しないでください。ユーザに手動でコンフィギュレーションファイルを編集させるようなことはしないでください。</p><p>理想的には、アプリケーションは実行しただけでうまく動作すべきです。しかし、時には、それがどうしても不可能な場合があります。例えば、<code>nvm</code>アプリケーションを考えてみましょう。これは、Node.jsのバージョンを管理するためのツールですが、バージョン情報を与えなければ、どうやって使用するバージョンを認識するのでしょうか。</p><p><em>ルール2：本当にコンフィギュレーションが必要なら、アプリケーションを使いながらユーザを丁寧に導く</em></p><p>コマンドラインから<code>nvm</code>を入力すると、膨大な量の情報が表示されます。</p><p><img src="http://robotlolita.me/files/2016/01/nvm.png" alt=""><br>
<em>情報がとても多すぎます。しかも、1画面に収まりきれていません。</em></p><p>さらに悪いことに、このテキストは、アプリケーションの使い方については、何も説明していません。しかし、この中に<code>nvm use &lt;version&gt;</code>というコマンドがあります。これが、探しているコマンドですね。Node.jsの特定のバージョンを使用したいのなら、このコマンドを試すことになります。</p><p><img src="http://robotlolita.me/files/2016/01/nvm2.png" alt=""><br>
<em>使い方がわかりません。</em></p><p>「バージョン5.0はまだインストールされていません」と表示されました。これでは、不親切で、どうしたらいいのかわかりません。「問題がある」と言われたので、もっと具体的な情報が表示されるのを待ちます。「問題なのはわかったから、どうしたらいいのか教えてくれ」と叫び返しても、何も起きません。では、どうしますか。<em>さらに</em>テキストを読んでみます。</p><p>もう一度、最初のコマンドを見てみると、リスト内に<code>nvm install &lt;version&gt;</code>というのがあるようです。少なくとも、上述した暗号のようなエラーメッセージと合っているように見えます。<strong>おそらく</strong>何か関係があるのでしょう。コマンドからは、どの順番で実行するべきかを知ることはできません（どちらにしても全てを実行する必要があるのに、どうしてステップごとに分ける必要があるのでしょうか）。</p><p>「では早速、試してみましょう」</p><p><img src="http://robotlolita.me/files/2016/01/nvm3.png" alt=""><br>
<em>あとは、<code>install</code>を実行すればいいということでしょうか。</em></p><p>アプリケーションに、同じ動作をする2つのコマンドがあるのはなぜかと考えてしまうでしょう。しかも2つあるうちの1つしか動きません。たとえ、この事実をよしとしていなくても、物事はそうなっています（少なくとも見た目の上では）。</p><p>また、別のアプリケーションを実行するためには新しいシェルを開きます。当然ですが、そのアプリケーションもNode.jsのバージョンに左右されます。</p><p><img src="http://robotlolita.me/files/2016/01/nvm4.png" alt=""><br>
<em>数秒前までうまく動いていたのに…。</em></p><p>何が起きているのか理解できず、ぼうぜんとスクリーンを見つめてしまうでしょう。うまく動いていたNode.jsが動かなくなりました。もしかしたらnvmの不具合で、ランダムに問題が起きるのかもしれません。<code>node --version</code>を別のシェルで試すと、驚くことに期待通りの<code>v5.0.0</code>となりました。「では、シェルを開く時は<em>すべての</em>シェルで、<code>nvm install &lt;version&gt;</code>を実行するべきなのでしょうか」</p><p>もう一度<code>nvm install &lt;version&gt;</code>を実行して、その説を検証してみましょう。</p><p><img src="http://robotlolita.me/files/2016/01/nvm5.png" alt=""><br>
<em>うまくいきました。どうしてでしょう？</em></p><p>あまりの驚きで絶句してしまいます。何かをコンピュータ上で使うために、こんなに苦労するなんて考えたこともないでしょう。先ほどBabelを使ったことが頭によみがえり、深いため息とともに、「<em>おそらく</em>、そういうものなんだろう」と思ってしまいます。</p><p>しかし、他にも方法は<strong>あるはず</strong>ですよね。毎回、<code>nvm install &lt;version&gt;</code>を実行しなくてもいいはずです（知らないでしょうが、実際に<code>nvm run &lt;version&gt;</code>を実行しても<em>皆さんのために</em>働いているようには見えません）。</p><p>もう一度、最初のコマンドラインを見てください。毎回、この処理をしなくて済むようにするヒントを探しましょう。<code>nvm alias default &lt;version&gt;</code>が目に留まります。そして、そこに”default. node. shell”と書かれています。まるでキーワードみたいですね。これを試してみましょう。</p><p><img src="http://robotlolita.me/files/2016/01/nvm6.png" alt=""><br>
<em>どうして、これが全部必要なのでしょう？</em></p><p>「やっと、うまくいった」と怒りとともに叫びたくなります。肩の重荷はほとんどなくなったでしょう。しかし、なかなかここまでたどり着かなかったコンピュータに、相当イライラしているはずです。「ようやく次に進んで、仕事を終わらせることができる」と、不満を漏らしつつ考えるでしょう。</p><p>もっと別のやり方はなかったのでしょうか。もちろんあります。前述したものとは別の、ありえそうな人間とnvmの間のインタラクションを見てみましょう。nvmの目的が、Node.jsのバージョン管理であると仮定します。この目的を念頭に置いて考えてみると、nvmはアプリケーションの新しいユーザ（及びに長期的に利用しているユーザ）にとって、非常に一般的なユースケースを辿っています。</p><p>ユーザが、<code>nvm</code>を実行すると、アプリケーションは自身がまだ何もできないと気づき、いくつかの一般的な対処法を提案します。</p><p><img src="http://robotlolita.me/files/2016/01/nvm7.png" alt=""><br>
<em>何をするべきかをユーザに知らせると、より使いやすくなります。</em></p><p>ユーザは、nvmを動かすにはまだ設定が必要であると気づきます。インタラクティブなスクリーンでは、迅速に設定するために<code>stable</code>バージョンをインストールするよう、アプリケーションが提案します（これは、よいデフォルトのコンフィギュレーションです）。設定する必要があるものの、これは大幅な改良です。少なくとも動かすために必要なことを<em>知らせてくれます。</em></p><p><img src="http://robotlolita.me/files/2016/01/nvm8.png" alt=""><br>
<em>1つのコマンドですべてが間に合います。</em></p><p>おっと、あなたは<code>use</code>を実行する前に、どのバージョンのNode.jsもインストールしていませんでしたね。しかしこのコマンドはそれを認識し、適したバージョンをインストールしてくれます。<strong>賢明なのはこれだけです</strong>。そこで<em>できる</em>ことは他にはありません。</p><p>インストール後、たった今インストールしたバージョンをデフォルトのNode.jsにしたいか尋ねられます。あなたが望めば好きな時に変更することができると、律儀に示します。<code>npm use &lt;version&gt;</code>は一般的に実行されるべきもので、アプリケーションの肝心な部分です。このことを考えると、仕事を減らすための選択肢を与えることは賢明だと言えます。</p><p>「で、でも、全てのプログラムで適用されるわけじゃないですよね？　プログラム言語の実装のためには、どのようにやればいいのでしょうか？」とアプリケーションの開発者は叫びます。では、<a href="http://amber-lang.net/learn.html" rel="nofollow" title="" class="ext-link">AmberのSmalltalk</a>の例を見てみましょう。</p><p><img src="http://robotlolita.me/files/2016/01/amber.png" alt=""><br>
<em>注釈：Stef教授と一緒に、Smalltalkを学びましょう<br>
皆さん、5分お時間をいただけますか？私Stef教授は、皆さんにSmalltalkをお教えしたいのです。約束します。すぐに終わりますよ。</em></p><p><em>プログラミング言語を学ぶための対話方式のチュートリアルは、実にいいアイデアです</em></p><p>あなたのアプリケーションが予想外の動きをした時、一番いい対処方法は、ユーザのために修正し、ユーザが望む方向に進むことです。もしも賢明な方法で問題を解決できるのなら、ですが。しかしこれは、いつでも可能というわけにはいきません。</p><p><em>ルールその3：もしもうまくいかなかったら、できる限りよい方法で、ユーザがその問題を解決するのを助ける必要がある</em></p><p>次の例を考えてみましょう。</p><p><img src="http://robotlolita.me/files/2016/01/v8.png" alt=""><br>
<em>V8には、かつて見た中で最悪とも言えるエラーメッセージがあります。</em></p><p><code> JSON.parse()</code>は言っています。「申し訳ありません。ここに<code>b</code>があるので構文解析はできません」。<code>b</code>が一体どこにあるんですって？　本当は何があるはずなの？　このコードには<code>b</code>が2個あることに気付いてる？　間違っているのはどっち？　それとも両方とも間違ってる？　どうやって直せばいいのよ？</p><p>V8のエラーメッセージを見て分かるように、多少は改善されたにも関わらず、大部分は役に立たないままです。特にこれは、JSONのパーサにもう少し手を加えれば、ユーザに非常に役立つメッセージを与えることができる例なのです。</p><p><img src="http://robotlolita.me/files/2016/01/v82.png" alt=""><br>
<em>パーサに簡単な変更を少し加えれば、このようになります。</em></p><p>このエラーメッセージは、<strong>何が</strong>間違っているかを理解する助けになるだけでなく、直し方まで教えてくれます。何かを直す方法をユーザに教えてくれるのは理想的ですが、いつも可能とは限りません。しかし、少なくともユーザに何が間違っているかを伝える努力をしなくてはいけません。それは「ごめんなさい、デイブ。私にはできません」と叫ぶのではなく、ユーザが理解できるような形で伝えるべきです。</p><p>使えるエラーメッセージなら、少なくとも静的なコンパイラについて言えば、<a href="http://elm-lang.org/blog/compilers-as-assistants" rel="nofollow" title="" class="ext-link">Elm</a>には<a href="http://elm-lang.org/blog/compilers-as-assistants" rel="nofollow" title="" class="ext-link">この話題に関する非常にいいブログ記事</a>があります。</p><p><img src="http://robotlolita.me/files/2016/01/elm.png" alt=""><br>
<em>恥ずかしながら、上の画像はElmのブログ記事から拝借しました。</em></p><p>ドキュメンテーションは、ライブラリやフレームワークにとっては良いものです。しかしアプリケーションにとっては<strong>最悪</strong>です。もしあなたのアプリケーションがドキュメンテーションを本当に必要としていると考えているなら、複雑すぎますし、ユーザにフラストレーションを感じさせるでしょう。</p><p>これは本当です。<a href="https://xkcd.com/1343/" rel="nofollow" title="" class="ext-link">XKCD</a>に出ているからです。</p><p><img src="http://imgs.xkcd.com/comics/manuals.png" alt=""><br>
<em>注釈：<br>
SOLVE PROBLEMS　問題を解決する<br>
CREATE PROBLEM　問題を発生させる<br>
TOOLS THAT DON’T NEED A MANUAL　マニュアルを必要としないツール<br>
TOOLS THAT NEED A MANUAL　マニュアルを必要とするツール<br>
TOOLS THAT NEED A MANUAL BUT DON’T HAVE ONE　マニュアルを必要とするが、そのマニュアルを持っていないツール<br>
TOOLS WHOSE MANUAL STARTS WITH “HOW TO READ THIS MANUAL”　マニュアルが「このマニュアルを読む方法」から始まっているツール</em></p><p><em>私の意見はご覧のとおりです</em></p><p>ドキュメンテーションの代わりに、単に起動することによってアプリケーションに仕事をさせましょう。環境設定もなし、まったく何もなしです。ユーザに仕事を終えさせましょう。</p><p><em>ルール4：製品を使う前にマニュアルを読むよう、ユーザに要求してはいけない</em></p><p>Appleは理解しています。あなたはただ真似すればいいのです。</p><p><iframe width="420" height="315" src="https://www.youtube.com/embed/G2YNqr-V-xM" frameborder="0" allowfullscreen></iframe></p><p>Mac vs PC Commercial – Out of the Box</p><p>コンピュータは最低です。<br>
アプリケーションも最低です。<br>
私たちは、この2つをもっとよくすることができます。<br>
しかし皆さんはやってみようとすら思わないでしょう。<br>
（私もこれに関しては罪悪感があります。）</p><p><a href="https://glyph.twistedmatrix.com/2015/09/software-you-can-use.html" rel="nofollow" title="" class="ext-link">あなたが使えるソフトウェア</a><br>
Glyph</p><p><a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.caqezkuwc" rel="nofollow" title="" class="ext-link">JavaScriptの疲弊</a><br>
Eric Clemmons</p><p><a href="https://vimeo.com/71278954" rel="nofollow" title="" class="ext-link">プログラミングの未来</a><br>
Bret Victor</p><p><a href="https://www.destroyallsoftware.com/talks/a-whole-new-world" rel="nofollow" title="" class="ext-link">全く新しい世界</a><br>
Gary Berhardt</p><p><a href="https://www.youtube.com/watch?v=3ka4KY7TMTU" rel="nofollow" title="" class="ext-link">セルフとセルフ：疑問と理由</a><br>
David Ungar</p>
