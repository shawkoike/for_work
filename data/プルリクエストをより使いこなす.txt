<p><a href="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/" rel="nofollow" title="" class="ext-link">A better pull request</a> （2015-01-25） by Tim Pettersen of <a href="https://developer.atlassian.com/index.html" rel="nofollow" title="" class="ext-link">Atlassian Developers</a><br>
Twitter:<a href="https://twitter.com/kannonboy" rel="nofollow" title="" class="ext-link">@kannonboy</a></p><p>Gitを使用している人であれば、プルリクエストには馴染みがあるでしょう。これは、分散バージョン管理システムが世に出始めてから、何らかの形で使われています。BitbucketやGitHubのように凝ったWebユーザインターフェイスが構築される前は、プルリクエストは単純に電子メールベースで行われており、Aliceのリポジトリから変更をプルするように依頼していました。プルリクエストを受けた側がこの変更を妥当だと判断すれば、いくつかのコマンドを実行しmasterブランチに変更をプルするという流れです。</p><p>もちろん、手あたり次第Aliceの変更をmasterにプルすることは、<em>得策</em>ではありません。masterには、顧客に納品する段階のコードが書かれているべきですから、何がマージされるのかをしっかりと把握しておきたいところです。ですから、masterに直接変更をプルするよりも、いったん異なるブランチにプルし、内容を確認してからマージする方が、間違いがありません。</p><p>git diffの後ろに“トリプルドット”を入力した構文を使うことで、alice/masterの最新のコミットとローカルのmasterブランチにあるマージベース（共通の祖先）との差分を表示することができます。これにより、Aliceがプルして欲しいすべての変更を効率よく表示できます。</p><p><img src="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/branch-diff.png" alt="A simple branch"><br>
git diff master…alice/masterは、git diff A Bと同等のコマンドです。</p><p>プルリクエストを受けた側が、加えられた変更個所を確認する手段として、これは一見妥当な方法に思えます。実際、この記事を書いている時点では、ほとんどのGitホスティングサービスがプルリクエストの差分を表示するアルゴリズムをこのように実装しているようでした。</p><p>しかし、“トリプルドット”を使った差分表示のアプローチでは、プルリクエストの差分を表示させるのにいくつかの問題が生じます。というのも、実際のプロジェクトではmasterブランチは、どのfeatureブランチとも内容が大きく異なります。開発者は、それぞれのブランチで作業を行いmasterにマージしていきます。つまりmasterも更新されていくので、featureブランチの最新のコミットとマージベースを表示するシンプルなgit diffでは、最新のブランチ同士の差が適切に表示されないのです。表示されるのは、ブランチを分岐した時点でのmasterのバージョンとfeatureブランチの最新のコミットとの差になります。</p><p><img src="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/triple-dot-diff-missing.png" alt="Master progresses"><br>
“トリプルドット”を使ったgit diff master…alice/masterでは、masterに加えられた変更が考慮されません。</p><p>では、プルリスクエストでこれらの変更の差分が表示されないことが、なぜ問題になるのでしょう。それには2つの理由があります。</p><p>1つ目は、よくありがちな<strong>マージコンフリクト</strong>です。featureブランチにあるファイルに変更を加え、同時にmasterにも変更が加わっている場合、git diffではfeatureブランチに加わった変更しか表示されません。一方、git mergeでは、エラーがはじき出され、作業しているファイル全体にコンフリクトマーカーが追加されます。これはマージしようとしているブランチとの間でコンフリクトが起きている、またはGitでさえもマージする方法が見つけられないということを表しています。</p><p><img src="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/merge-conflict.png" alt="Merge conflict"><br>
マージコンフリクトの解決は面倒ですが、バージン管理システムではよくあることです。少なくともファイルレベルのロックをサポートしないバージョン管理システムに関しては、それ自体が問題です。</p><p>しかし、 “トリプルドット”を使ったgit diffで生じる2つ目の問題に比べれば、マージコンフリクトの問題はまだマシです。その2つ目の問題とは、<em>論理的な</em>コンフリクトです。これはマージする際にはエラーにならいのですが、コードベースに発見しづらいバグが出てしまいます。</p><p>もし複数の開発者が同じファイルに対して別のブランチを作成し、それぞれに変更を加えたとしたら、多少厄介なことになるかもしれません。それぞれの変更が単独では機能していて、<em>コンフリクトもなく</em>適切にマージされているように見える場合でも、それらが統合された時に論理的なバグが生じることがあります。</p><p>いくつか状況は考えられますが、よくあるシナリオとしては、2人以上の開発者が偶然同じバグに気付き、それぞれのブランチを作成して修正してしまうというケースです。下記のような、航空券の代金を計算するJavascriptを例にとって考えてみましょう。</p><p>このコードには、税関手数料が含まれていないという明白なバグがあります。</p><p>2人の開発者、AliceとBobがこのバグに気付き、それぞれがブランチを作成し修正を行いました。</p><p>AliceはimmigrationFeeの前の行にcustomsFeeを追加しています。</p><p>一方BobはimmigrationFeeの後ろの行に似たような修正を入れます。</p><p>それぞれのブランチで異なる行が追加されたので、これらのブランチは両方とも問題なく順にmasterへとマージされます。しかしそうすると、masterには<em>両方の行</em>が追加されることになり、税関手数料が顧客にダブルでチャージされてしまうという深刻なバグが発生してしまいます。</p><p>（もちろんこれはわざとらしい例かもしれません。しかし重複したコードやロジックは、<a href="https://www.imperialviolet.org/2014/02/22/applebug.html" rel="nofollow" title="" class="ext-link">“go to fail”文の重複</a>のようにかなり深刻な問題を起こし得ます。心当たりはありませんか？）</p><p>先にAliceのプルリクエストをmasterにマージしたと仮定しましょう。“トリプルドット”を使ったgit diffでブランチの最新のコミットと共通の祖先との差分を表示した場合、Bobのプルリクエストはこのようになります。</p><p>これは祖先に対しての差分をレビューしているので、マージボタンをクリックしても差し迫った問題になるような警告は出ません。</p><p>プルリクエストで本当に見たい内容は、Bobのブランチをマージした時masterがどのように変更されるかです。</p><p>この差分にはちゃんと問題が表示されています。これならプルリクエストのレビューワーはおそらく重複した行を発見し、コードを再修正するようBobに知らせることができるでしょう。このようにしてmasterに（ひいては製品版に）深刻なバグが発生するのを防ぐことができます。</p><p>このようなことからBitbucketやStashの中ではプルリクエストの差分を実装することにしました。プルリクエストを表示すると、マージコミット後の結果をプレビューすることができます。これは実際にマージコミットを水面下で作成することで、マージする2つのターゲットの差分を表示させています</p><p><img src="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/merge-result.png" alt="Merge result"><br>
Dを<strong>マージコミット</strong>とした場合“git diff C D”で2つのブランチの全ての差分が表示されます。</p><p>いくつかのホスティングプロバイダに同じリポジトリをプッシュしたので、ご興味があればどうぞ。実際に活用されているいろいろなｄｉｆｆのアルゴリズムを見ることができます。</p><p><a href="https://github.com/kannonboy/abpr/pull/2/files" rel="nofollow" title="" class="ext-link">GitHubを使った“トリプルドット”diff</a>のプルリクエスト<br>
<a href="https://bitbucket.org/tpettersen/abpr/pull-request/2/fixed-a-bug-that-would-charge-2x/diff" rel="nofollow" title="" class="ext-link">Bitbucketを使った“マージコミット”diff</a>のプルリクエスト<br>
<a href="https://gitlab.com/kannonboy/abpr/merge_requests/2/diffs" rel="nofollow" title="" class="ext-link">GitLabを使った“トリプルドット”diff</a>のプルリクエスト</p><p>BitbucketとStashで使われている“マージコミット”のdiffは、マージした時に適用される<em>実際の</em>変更を表示します。問題点としては実装しづらいということと、実行するのにコストがかかるということです。</p><p>1つ目のコストの問題ですが、この時点でマージコミットDが実際はまだ存在しておらず、マージコミットを作成するのは比較的費用のかかるプロセスだということです。2つ目の問題である実装に関しては、Dを作成すればそれで終わりではないということです。このマージコミットの親であるBとCがいつ変更されるか分かりません。この場合、親に対してプルリクエストのスコープ範囲の変更をかけることで、プルリクエストがマージされた時に適用される差分が効率よく更新されます。masterのようにビジーなブランチをターゲットにしたプルリクエストであれば、頻繁にスコープの設定が変更される可能性が高いのです。</p><p><img src="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/rescopes.png" alt="Rescoping"><br>
<em>どちらの</em>ブランチが更新されても、いつでもマージコミットは作成されます。</p><p>実際、誰かがブランチを、masterもしくはfeatureブランチに対してプッシュしたりマージしたりする度に、BitbucketやStashは正確な差分を表示するために新しいマージを計算する必要がでてくる可能性があります。</p><p>プルリクエストの差分を表示させるためのマージの問題では、時としてマージコンフリクトに対処する必要があります。Gitサーバは無人の状態で運用されるため、周りにマージコンフリクトを解決できる人はいないでしょう。そのため、事態は少しばかり複雑になってきますが、実際には好都合なことが分かります。BitbucketやStashでは、コンフリクトマーカーをマージコミットDの一部として<em>コミットします</em>。そしてプルリクエストのコンフリクトの内容を差分の中にマークアップします。</p><p><img src="https://developer.atlassian.com/blog/2015/01/a-better-pull-request/conflicts-bitbucket.png" alt="Conflicts on Bitbucket"><br>
BitbucketとStashの差分では、追加された行が緑、削除された行が赤、コンフリクトしている行がオレンジで表示されます。</p><p>こうすることで、プルリクエストがコンフリクトしていることを事前に検出することができるだけでなく、コンフリクの解決法についてもレビューワーに検討させることができます。コンフリクトには少なくとも2人が関係しているので、これを解決するのは、プルリクエストが適切な場と言えるでしょう。</p><p>さらなる複雑性やかかるコストに関わらず、StashやBitbucketで取ったアプローチが最も正確かつ効果的にプルリクエストの差分を表示できると思います。もし質問やフィードバックがあるようなら、ぜひコメントやTwitterで教えてください。GitやBitbucket、Stashの更新もたまにつぶやいているので、もしよかったら私のアカウント（<a href="https://twitter.com/kannonboy" rel="nofollow" title="" class="ext-link">@kannonboy</a>）もフォローしてください。</p>
