<p><a href="http://blog.kevinalbs.com/base122" rel="nofollow" title="" class="ext-link">Base-122 Encoding</a> （2016-11-26） by <a href="http://kevinalbs.com/" rel="nofollow" title="" class="ext-link">Kevin Albertson</a></p><p>base-64よりもスペース効率の良い方法。<a href="https://github.com/kevinAlbs/Base122" rel="nofollow" title="" class="ext-link">GitHub レポジトリ</a></p><p>バイナリをテキストに変換するエンコード方式としての<a href="https://ja.wikipedia.org/wiki/Base64" rel="nofollow" title="" class="ext-link">base-64</a>は、そのデータ量を33％増大させます。この記事では、UTF-8のテキスト変換方式であり、元のデータから14％増大するbase-122を紹介します。base22はWebを念頭において作られました。<a href="https://github.com/kevinAlbs/Base122" rel="nofollow" title="" class="ext-link">実装</a>には、Javascriptのデコーダを使い、base-122でエンコードしたリソースをWebページに読み込ませる過程が含まれます。</p><p>画像、フォント、オーディオなどの外部のバイナリリソースは、base-64でエンコードする<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" rel="nofollow" title="" class="ext-link">データURI</a>を使ってHTMLに埋め込むことができます。データURIは通常、小さなイメージを埋め込む際に、HTTPリクエストを避け、ロード時間を減らすために使われます。</p><p>このソースでは”example.png”を取得するのに余分なHTTPリクエストを要します。</p><p>base-64変換で同じ画像を埋め込む場合。</p><p>データURIの埋め込みを使えば、サーバから”example.png”を取得するための余分なHTTPリクエストを避けられます。場合によってロード時間の改善につながりますが、データURIは慎重に使用するよう勧められています。小さな画像には役立つとはいえ、逆にパフォーマンスを下げる可能性もあるからです。</p><p>base-122がbase-64よりも改良されている点を論じる前に、base-64とは何かを簡単に説明しましょう。<a href="https://ja.wikipedia.org/wiki/Base64" rel="nofollow" title="" class="ext-link">Wikipedia</a>でより詳しく紹介されていますが、ここでは主な点を見ていきます。</p><p>base-64は<a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding" rel="nofollow" title="" class="ext-link">バイナリのテキスト変換</a>に伴う、一般的な問題を解決するひとつの方法です。例えば、1バイト 01101001をテキストファイルに埋め込みたいとします。テキストファイルは文字のみで成り立つので、このバイトを文字で表す必要があります。このバイトをシンプルに変換する方法は、”A”は0ビット、”B”は1ビット、といった要領で、それぞれのビットを文字に当てはめることです。例えば、次のようなエンコード方式が存在し、1バイト 01101001が1つの（非常に小さな）画像を表すとしましょう。それに対応するHTML上のデータURLは次のように見えます。</p><p>バイナリのテキスト変換のダミー</p><p>容易にデコードできるのは確実ですが、スペースの無駄というコストがかかります。”A”や”B”などそれぞれの文字はHTMLファイル上では1バイトです。つまり、1ビットのバイナリデータを8ビットのテキストデータで変換するので、データは8:1の率で増えます。</p><p>base-64方式は上記のエンコーディング例の改良版です。6ビットの塊（0から63の数字で表す）を64文字のいずれか1つに位置づけます。その結果出てくる文字はそれぞれ1バイトなので、増加率は8:6です。</p><p>同じバイトをbase-64で変換した場合。追加の==は余白です。</p><p>base-64はバイナリのテキスト変換に有用なのは、標準のASCII文字を生成するからです。しかし、base-64を改良するためには、UTF-8文字にどれだけのデータを詰め込めるかを調べる必要があるでしょう。</p><p>大半のWebページはUTF-8でエンコーディングされているので、base-122はUTF-8の文字変換方法のプロパティを利用します。ここで、UTF-8と文字コードに関する用語を明確にしましょう。</p><p><img class="full" src="http://blog.kevinalbs.com/img/base122/encoding.jpg"><br>
<em>注釈：＜左から＞16進数　2進数（バイナリ） 2進数（バイナリ）</em><br>
<em>＜黒帯部分＞Unicodeコードポイント　UTF-8エンコーディング　レンダリングされる文字</em><br>
図1：εの3種類の表し方</p><p><a href="https://ja.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E7%82%B9" rel="nofollow" title="" class="ext-link">コードポイント</a>は、（通常）1つの文字を表す1つの数字です。Unicodeは、標準的な複数言語のアルファベットから、コードポイント0x2615のコーヒーカップの絵文字（U+2615と表記されることが多い）など、より曖昧な文字まで記述可能な範囲を広く受け入れられる基準です。<a href="https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF" rel="nofollow" title="" class="ext-link">このUnicode表</a>でコードポイントを参照できます。</p><p>一方で、<a href="https://ja.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E3%82%B3%E3%83%BC%E3%83%89" rel="nofollow" title="" class="ext-link">文字コード</a>にはバイナリでコードポイントをどのように表示するかを決める役割があります（例：ファイル内など）。UTF-8はWebにおいて<a href="https://w3techs.com/technologies/overview/character_encoding/all" rel="nofollow" title="" class="ext-link">圧倒的によく使われている</a>テキストエンコード方式です。可変長のエンコード方式で、1,112,064種類のコードポイントを表現できます。ASCII文字を表すコードポイントは、UTF-8ではたった1バイトで変換できますが、より高いコードポイントでは最大4バイト必要です。以下の表1は、様々なコードポイントの領域におけるUTF-8エンコード方式のフォーマットをまとめたものです。</p><p>表 1：　UTF-8エンコード方式のまとめ。xは、コードポイントデータのためのビットを表す。</p><p>増加率は、文字のビット数に対するコードポイントのビット数の比率です。比率が1:1であれば効率的に全く無駄がないということです。バイト数が増えるにつれ、コードポイントのためのビットが減るので、増加率は悪化します。</p><p>表1でUTF-8の1バイト文字のエンコーディングを見ると、図2のように、1エンコードバイトで7ビットの入力データを変換できることが分かります。</p><p><img class="full" src="http://blog.kevinalbs.com/img/base122/naive-encoding.jpg"><br>
図2：バイトごとに7ビットを変換する試み</p><p>図2のエンコード方式がうまくいけば、base-64の8:6の増加率は、8:7に改善されることになります。しかし、このバイナリのテキスト変換を、HTMLページのコンテキストで使いたいのです。残念ながら、１バイトのUTF-8文字はHTML上でコンフリクトを起こすため、このエンコード方式は役に立ちません。</p><p>上記のアプローチの問題はHTMLページのコンテキストでは安全に使えない文字があることです。ここでは、コードをデータURIに似たフォーマットで格納します。</p><p>この変換データはダブルクォートを含めることができません。またはブラウザが適切にsrc属性を解析しないことがすぐに分かります。さらに、改行文字、復帰文字は行を分割します。バックスラッシュとアンパサンドは不意にエスケープシーケンスを生成することもあります。また、表示不可のnull文字（<a href="http://unicode-table.com/en/0000/" rel="nofollow" title="" class="ext-link">コードポイント0x00</a>）も、<a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)" rel="nofollow" title="" class="ext-link">エラー文字</a>（0xFFFD）として解析されるのも問題でしょう。よって、null、バックスラッシュ、アンパサンド、改行文字、復帰文字、そしてダブルクォートは１バイトのUTF-8文字の中では不正と判断されるのです。結局、122の正規の1バイトUTF-8文字を使うしかないというわけです。122文字は7ビットの入力データをほぼ変換できます。7ビットのシーケンスが不正文字の原因になるなら、補強をする必要があります。これが最後のエンコード方式に至った理由です。</p><p>エンコード方式　base-122は、一度に7ビットの入力データのチャンクを処理します。チャンクが正規の文字に位置づけられる場合、1バイトのUTF-8文字：<strong>0xxxxxxx</strong>で変換されます。チャンクが不正の文字に当たる場合は、代わりに2バイトのUTF-8文字: <strong>110xxxxx 10xxxxxx</strong>を使います。正規のコードポイントは6つのみのため、たった3ビットで識別できます。これらのビットを<strong>sss</strong>として表すと、フォーマット： <strong>110sssxx 10xxxxxx</strong>になります。残りの8ビットはより多くの入力データを変換できるように見えます。しかし、0x80以下のコードポイントを表す2バイトのUTF-8文字は無効です。ブラウザは無効のUTF-8文字をエラー文字とみなします。コードポイントが常に0x80より大きくなるよう制御するには、0x80のビット単位OR（これはさらに改良できる可能性があります。4を見てください）と同等のフォーマット <strong>110sss1x 10xxxxxx</strong>を使うと簡単です。図3はbase-122のエンコーディングのまとめです。</p><p><img class="full" src="http://blog.kevinalbs.com/img/base122/final-encoding.jpg"><br>
図3：　base122のエンコーディング。nullコードポイントは000に位置づけられる。</p><p>これは14ビットの変換に、1バイト文字変換の7ビットと2バイト文字を使います。よって、1バイトにつき7ビット変換する目標を達成しています。つまり、8：7の増加率です。結果として、base-122で変換した文字列は、base-64で行った場合の86％のサイズです。</p><p>入力データの最後の7ビットチャンクは、必要な場合はゼロビットで埋め込まれます。そのため、最後の1バイト文字は、6個のパディングゼロビットを持つ可能性があります。デコーディングでは概数になるので、これらの6個のパディングビットはデコーディング中に適宜切り捨てられます。しかし、もし2バイト文字で終える場合は、13ものパディングビットを持つことになります。この解決には、最後の2バイト文字が7ビット以上を変換したかどうか区別するのに<a href="https://github.com/kevinAlbs/Base122/issues/3" rel="nofollow" title="" class="ext-link">役立ち</a>ます。</p><p>base-122によるエンコーディングとデコーディング機能の実装は<a href="https://github.com/kevinAlbs/Base122" rel="nofollow" title="" class="ext-link">GitHubで</a>入手できます。これには2つの主な機能があります。</p><p>base-122が変換した文字列にはコピー＆ペーストができないように見える文字が含まれています。ユーザのコピー＆ペーストを禁止するため、NodeJSスクリプトはHTMLファイル内でbase-64のデータURIを再変換します。図4はその一例です。</p><p>図4a：　元ファイル</p><p>図4b：　再変換したファイル</p><p>少しの差分では意味がありません。CSSデータURIではなく、src属性の中のデータURIだけが再変換されます。UTF-8文字セットのメタタグを指定しなければなりません。data-b122属性はデコード中にDOMの簡単なクエリ実行に使われます。デフォルトのMIMEタイプは”image/jpeg”ですが、data-b122m属性は他のMIMEタイプを特定します。</p><p>base-122変換リソースをデコードするには、<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob" rel="nofollow" title="" class="ext-link">atob</a>関数を使い、base-122文字列を元データにデコードする必要があります。さらに、いくつか設定コード（DOMにクエリを実行し、<a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" rel="nofollow" title="" class="ext-link">createObjectURL</a>でデコードしたBLOB URLを生成する、など）をHTMLページ内のスクリプトを含めるとなると、外部スクリプト（別のHTTTPリクエスト）を追加するか、全関数をページ内に書くことになります。しかしそれでは、base-122のエンコーディングの省スペースを損ねてしまいます。よってデコード関数はパフォーマンスを犠牲にせずに、なるべく小さくしなければなりません。縮小したデコードスクリプトは下記で、現状のサイズは487バイトです。</p><p>全ての要素をdata-b122属性でデコードし、BLOB URIを生成する。</p><p>図4cはデコーディング、設定コードを含めた最終ファイルです。</p><p>図4c：　デコーディング、設定コードを含めた最終ファイル</p><p>base-122が、base-64のWebにおけるエンコード方式の実用的な代替手段になるかどうか検討するため、実装をテストし、省スペースであることを確かめ、ランタイムの実績をチェックしました。</p><p>エンコード方式　base-122は、1バイトにつき7ビットの入力データを変換します。base-64は6ビットです。ですから、同等のbase064のデータと比べ、base-122のデータは14％小さくなるはずです。様々なサイズの四角の画像で行なった最初のテストでそれを確認できます。</p><p><em>表の項目の見出し（左から）：画像（JPEG）サイズ　オリジナル（バイト）　base-64（バイト）　base-122（バイト）　％差分</em><br>
図2：　base-64とbase-122の画像サイズを比較</p><p>しかし、<a href="http://davidbcalhoun.com/2011/when-to-base64-encode-images-and-when-not-to/" rel="nofollow" title="" class="ext-link">以前の記事</a>で指摘したように、HTMLページを圧縮したgzipはbase-64のエンコーディングのサイズを劇的に減らします。表3はgzipデフレ―ト圧縮を適用した変換結果です。</p><p>図3：gzipを適用したbase-64とbase-122の画像サイズを比較</p><p>あいにく、base-64のほうがbase-122よりも圧縮の効果が高いようです。おそらく、base-64には冗長なシーケンスのビットが比較的多いために圧縮も簡単なのでしょう。興味深いのは、gzipでbase-64を使うと、元のサイズよりも小さくなることです。</p><p>base-122デコーダを実際に使うにあたっての懸念はパフォーマンスです。ブラウザでbase-122をデコードするとパフォーマンスが大きく落ちてしまうと、ダウンロードサイズの小ささでロード時間を減らせる利点をしのいでしまいます。<a href="https://jsperf.com/base-122-performance" rel="nofollow" title="" class="ext-link">このJSPerfテスト</a>を使って、同等に変換したランダムな10,000バイトのバイナリの文字列で、base-122のデコーディング関数をbase-64のデコーディング関数である<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob" rel="nofollow" title="" class="ext-link">atob</a>と比較しました。</p><p>図4：　デコーディングのランタイム実績を比較</p><p>Chromeでは、約3倍パフォーマンスが落ちます。驚くべきことにFirefoxでは1.5倍から2倍向上しています。</p><p>実用テストとして、様々なサイズの小さな画像が載ったHTMLページのロード時間とサイズを比較しました。<a href="https://unsplash.it/" rel="nofollow" title="" class="ext-link">unsplash.it</a>から取った64×64ピクセルの画像を使い、10点、100点、1,000点の画像を載せたページで比較しました。</p><p><img class="full" src="http://blog.kevinalbs.com/img/base122/casestudy.jpg"><br>
図5：　ケーススタディ用のページ</p><p>まず、各ページのダウンロードサイズが予測どおりであることを確認しました。</p><p><img class="full" src="http://blog.kevinalbs.com/img/base122/transfer-size.jpg"><br>
<em>注釈：転送サイズ率　転送サイズ率（Gzipを有効にした場合）</em><br>
図6：　転送サイズと元サイズの比率</p><p>次にロード時間を5回試し、ChromeとFirefoxの中央値を記録しました。</p><p><img class="full" src="http://blog.kevinalbs.com/img/base122/load-time.jpg"><br>
<em>注釈：ロード時間率（Google Chrome）　ロード時間率（Mozilla Firefox）</em><br>
図7：　元のロード時間（zipなし）との比率<br>
Chromeでは、約3倍パフォーマンスが落ちます。驚いたことにFirefoxでは1.5倍から2倍向上しています。</p><p>Firefoxでは大きな改善が見られますが、残念ながらChromeでは後退しています。様々な理由があると思われますが、base-64の文字列は、解析され次第即座にデコードされるのに対し、base-122ではデコーダスクリプトの解析からロードされるまでの遅延が大きな原因でしょう。また、gzipを有効にした場合、ダウンロードサイズのさらなる向上は望めません。これらのテストが示すのは、base-122はWebのコンテキストでは、少なくともブラウザのサポートなしでは、大して使い物にならないということです。</p><p>base-64、base-122の両方でロード時間が改善されているものの価値はありません。外部からロードされる画像にはなおプログレッシブローディングという利点があり、画像データを埋め込まないことによって、HTMLページのパーツは画像データのダウンロード前からロードできるからです。</p><p>下記を参照すれば、これまでの結果を再現したり、様々な環境でテストしたりすることができます。</p><p>Webのパフォーマンスの向上がbase-122の目的でしたが、それはWebに留まりません。UTF-8が使われている部分、バイナリのテキスト埋め込みのあらゆるコンテキストでbase-122を使える可能性があります。そこには例えば次のような改善の余地がありますが、他にもまだ挙げられるでしょう。</p><p>助言、率直なフィードバック、どちらも歓迎します。<a href="https://github.com/kevinAlbs/Base122/" rel="nofollow" title="" class="ext-link">GitHub</a>ページをチェックしてください。</p>
