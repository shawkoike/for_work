<p><a href="https://eager.io/blog/everything-I-know-about-the-script-tag/" rel="nofollow" title="" class="ext-link">Everything I Know About The Script Tag</a> (2016-06-24) by <a href="https://twitter.com/zackbloom" rel="nofollow" title="" class="ext-link">Zach Bloom</a></p><p>もうすでにご存じだとは思いますが、scriptタグはWebページで実行されるJavaScriptを特定するために使用されます。scriptタグはJavaScriptを直接含むことも、スクリプトがロードされるべきURLを指すこともできます。</p><p>次のコードを読めば、直感的に分かるでしょう。</p><p>外部リソースを操作する時、次のようなコードになりますが、前のコードほど直感的ではありません（だからと言って真実ではないとは限りません）。</p><p>ローカルスクリプトとリモートスクリプトを組み合わせても同様に操作することができます。</p><p>機能的には、Webページの前の部分で重いスクリプトのロードがあると、サイトの表示が明らかに遅くなることを意味します。さらに、ページの最後の方で表示されるスクリプトは、それまでに存在するされたスクリプトの動作に依存することを意味します。</p><p>先行する全てのscriptタグがロードされ実行されるまで、ページ上の要素は表示されません。つまり、パフォーマンスへの悪影響を覚悟する気があれば、ロードする前の微調整する際に自由に突飛なことをすることができるのです。</p><p>しかしながら、<code>document.appendChild</code>などを使用してページをロードした後にscriptタグをDOMに追加した場合は例外となります。この場合、<br>
ブラウザがこれらのタグをロードするタイミングを順不同に決定します。</p><p>HTMLパーサが、遭遇するJavaScriptを実行しながらドキュメントのタグからタグへと移動していると思ってください。つまり、あなたのscriptタグより前にオープンタグがあれば、DOMノードはJavaScriptによって利用可能になります（<code>querySelectorAll</code>や<code>jQuery</code>などを通して）。</p><p>これは必然的に、（Web上で）使用するJavaScript全てで<code>document.head</code>が事実上常時利用可能になるという便利な結果をもたらします。<code>document.body</code>は、あなたのscriptタグ内あるいはオープンタグの<code>body</code>の後に表示された場合のみ利用可能になります。</p><p>HTML5には、スクリプトの実行を制御できるツールがいくつか追加されています。</p><p>これまで（Netscape 2以降）、scriptタグに<code>type="text/javascript"</code>を特定してもしなくても、空白のままにしても問題はありませんでした。もし、<code>type</code>としてJavaScriptの派生以外のMIMEタイプを指定すると、ブラウザは実行しません。独自の言語を定義したい場合は問題ないでしょう。</p><p>そうすると、次の例のように、コードの実行はあなた次第になります。</p><p><code>runEmeraldCode</code>関数の定義については読者への演習問題とします。</p><p>もし、どうしてもページの全てのscriptタグにデフォルト設定された<code>type</code>を無効にしたい場合は、<code>meta</code>タグを使用することができます。</p><p><code>Content-Script-Type</code>ヘッダを使用することもできます。</p><p>どの<code>type</code>が有効だったか、詳細は<a href="https://eager.io/blog/a-brief-history-of-weird-scripting-languages/" rel="nofollow" title="" class="ext-link">A Brief History of Weird Scripting Languages on the Web（Web上の奇妙なスクリプト言語の簡単な歴史）</a>をお読みください。</p><p><code>integrity</code>属性は新しいSubresource Integrity仕様の一部になります。これにより、スクリプトファイルが持つべきコンテンツに対してハッシュを与えることができます。つまり、送信されるscriptタグに極悪なコンテンツを挿入されるのを阻止する目的があるのです。SSLの世界では、<code>code.jquery.com</code>のように制御できない外部ソースからスクリプトをロードする際にとても貴重になります。</p><p>もし、これを使用する場合は、使用するハッシュやハッシュ値をハイフンで分けて含める必要があります。</p><p>まだこれが実際に使用されているところを見たことがありません。もしご存知ならコメントで教えてください。</p><p><code>crossorigin</code>属性は、まだ完全には標準化されていませんが、サポートしているブラウザもあります。概念として、ブラウザは現在開いているページと異なる”オリジン（生成元）”からのリソースを制御します（オリジンとは、プロトコル、ホスト名、ポート番号を組み合わせた通信フォーマットです。例：<code>http://google.com:80</code>）</p><p>これは、例えば「自分のWebサイトにアクセス中のユーザの、競合サイトのアカウントを削除してしまうようなリクエストを送信する」といったこと（最悪ですね）を防ぐために存在する機能です。しかし、scriptタグとのつながりは若干付随的です。ハンドラを<code>window.onerror</code>イベントに適用する場合は、コードを外部サイトからロードする時に得られないページやスクリプトの情報を、ハンドラが持つことになります。セキュリティがしっかりしているブラウザでは、あなたが<code>crossorigin</code>を指定<em>しない限り</em>、この情報は含まれません。</p><p>しかし<code>crossorigin</code>は、魔法のセキュリティ･ハックではありません。何をする機能かと言えば、<code>OPTIONS</code>リクエストを行い<code>Access-Control</code>ヘッダについてチェックするといった、通常のCORSアクセスチェックを行うようブラウザに指示することです。</p><p><code>document.currentScript</code>は、珍しくIEで全くサポートされていませんが、現在実行されているスクリプト要素を返すプロパティです。これは、実行中の埋め込みコードのscriptタグから属性を抜き出したい時に、非常に役立ちます。個人的には、我が社Eagerで埋め込みコードをインストールする作業が少し大変になるので、この属性が完全にはサポートされていないことをうれしく思っています。</p><p>Firefoxでしかサポートされていないこの属性は、全く役に立ちません。<code>onafterscriptexecute</code>と<code>onbeforescriptexecute</code>を使うと、そのページで実行される全てのスクリプトの実行前と実行後のイベントをバインドすることができるので、私はそれがすごいところだと思っています。</p><p>気になっている方もいると思うので補足ですが、イベントオブジェクトは実行するスクリプトを参照先として含み、<code>before</code>イベントは、<code>preventDefault()</code>を呼び出すことで実行をキャンセルできます。</p><p>今までHTML5の仕様ではまず見られなかった、イベントにコードをバインドするメソッドです。以前はIE固有のものでした。以下のコードで、ページのロードが終わるまでscriptタグの実行を止めておくことができるはずです。</p><p>私が試してみたところ、ChromeやFirefoxでは、このコードが動きませんでした。（つまり、標準に準拠している<em>わけではない</em>ということです）。しかし、IEでは動作する可能性が高いでしょう。</p><p>あなたの両親にも若かった時代があるのと同じように、JavaScriptにも若かりし時代があったとは信じ難いことです。しかしながら、ブラウザがJavaScriptをサポートしているかどうかが分からなかった時代がありました。さらに悪いことには、ブラウザが<code>script</code>タグを認識するかどうかさえも分からなかったのです。そしてブラウザがタグを認識しない場合、ブラウザはそのタグの中身を一般的なインライン要素として表示していました。つまり、あなたが書いた秘密のJavaScriptがテキストとしてページに表示されてしまうということです。</p><p>幸運なことに、仕様的には十分な解決策が用意されており、コードをラップすることで、scriptタグをサポートしていないブラウザがHTMLコメントとしてコードを解釈することができます。</p><p>御多分に漏れず、XHTMLは事態をさらに悪くしました。XMLはクロージングタグのようなものを含む可能性のあるコンテンツをエスケープするのに、かなり特別なメソッドを使います。そのためにCDATAが誕生したのです。</p><p>このように記述すれば、有効なXHTMLとなるでしょう。機能には何の影響も与えませんが、Web開発者としては、極めて重要なことです。</p><p>また、JavaScriptを処理できないブラウザを使う人々のために、ブラウザには有効なメソッドがあります。それは<code>noscript</code>タグです。<code>&lt;noscript&gt;</code>を使って、スクリプトの実行をブラウザがサポートしていない場合のみに表示されるコンテンツをラップしておきます。</p><p>観察力が鋭ければ、<code>noscript</code>が<code>type</code>引数を受け付けないことに気づくでしょう。やや曖昧ですが複数の<code>types</code>を使うページでは、ページとのやり取りを行います。実際の動きはブラウザによって異なりますが、<em>ドキュメントの最初の方で</em>サポートしていない<code>type</code>を使用している<code>script</code>タグが使われている場合は、<code>noscript</code>ブロックを参照します。つまり、最初の方で<code>noscript</code>が書かれていなくても、最後の方で書かれている場合があるということです。</p><p>DOMを介して動的に追加されたscriptタグは、ブラウザによって実行されます。</p><p><code>innerHTML</code>を介してページに動的に加えられたscriptタグは実行されません。</p><p>分かりづらいですね。しかし、”Chromeインスペクタで、実行されていないscriptタグを認識するのは可能か？”のようなトリビアに答えるのは楽しいものです。さらに、このようなトリビアは、同僚をひっかけるいい方法にもなります。</p><p>お読みいただき、ありがとうございます。<a href="https://eager.io/blog/the-curious-case-of-document-write/" rel="nofollow" title="" class="ext-link">次の記事</a>は<code>document.write</code>の変わった性質についてです。私たちの新しい記事がリリースされた時にお知らせがほしい方は、以下からお申し込みください。</p>
