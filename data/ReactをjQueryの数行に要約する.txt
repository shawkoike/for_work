<p><a href="http://hackflow.com/blog/2015/03/08/boiling-react-down-to-few-lines-in-jquery/" rel="nofollow" title="" class="ext-link">Boiling React Down to a Few Lines in jQuery</a> （2015-03-08） by <a href="https://twitter.com/hackflow" rel="nofollow" title="" class="ext-link">Alexander Schepanovski</a></p><p>Python、JS、そして時々英語を書きます。<a href="https://twitter.com/CoolSuor" rel="nofollow" title="" class="ext-link">ツイッター</a>と<a href="http://habrahabr.ru/users/suor/topics/" rel="nofollow" title="" class="ext-link">ブログ</a>はロシア語で書いています。</p><p>「Reactが素晴らしい理由は、UIをアプリケーションの状態の純粋関数にできるからだ」いうような話を聞いたことがあるでしょう。しかしそれだけではなく、不変性と仮装DOMを利用して動作するということも聞きますよね。その上、保存、読み込み、取り消し、それにタイムトラベル・デバッグと呼ばれるすごい機能まで自由に手に入れられる。でも知っていますか？　Reactの核となるアイデアを利用し、その恩恵に預かるのにこれらのことは必要ありません。jQueryの数行にしてお見せします。</p><p>これを以下のように書き直します。</p><p>最もシンプルな（そして簡略化された）Reactの概念が提示されていますね。それについてはまた後で書くとして、今は、こっちが優れている点は何かという疑問に答えようと思います。では、図解します。最初のバージョンはこのような仕組みになっています。</p><p><img src="http://hackflow.com/images/boiling-react-down/jquery-small.svg" style="width: 100%"><br>
2つ目はこうです。</p><p><img src="http://hackflow.com/images/boiling-react-down/react-small.svg" style="width: 100%"></p><p>とりたててこちらがいいようにも思えませんが、これをスケーリングすることを考えてみましょう。時間が経てばUI上でより多くのイベントや要素が発生します。イベントは複数の要素を更新し、要素は複数のイベントによって更新されます。それを表すと下記のようになります。</p><p><img src="http://hackflow.com/images/boiling-react-down/jquery-big.svg" style="width: 100%"></p><p>簡略化したReactライクなコードではこうなります。</p><p><img src="http://hackflow.com/images/boiling-react-down/react-big.svg" style="width: 100%"></p><p>最初の図ではN個のイベントとM個の要素、そして最大O(N<em>M)になるリンクがあります。2つ目ではN個のイベントリンクが1つと、M個要素のリンクだけです。全体的に見れば、最大でO(N</em>M)の複雑性をO(N+M)まで下げることができます。単純な仕掛けの割には悪くありません。</p><p>さあ一歩前進です。しかし魔法のようなパワーについてはどうでしょう。それらももうすぐゲットできますよ。</p><p>基本的に上述した全ての魔法のパワーはこのように書くことで得られます。</p><p>2つの事実がこれを支えています。</p><p>これだけでいいのです。シリアライズされたcanned stateをローカルストレージに書き込み、サーバに送信することによりcanned stateの履歴を管理することができます。これにより、ページのリロードの保護や、持続性、取り消しやタイムトラベルがそれぞれ可能になります。</p><p>ややこしいですか？　コードを書いてみましょう。偶発的なページのリロードから守ってくれる方法です。</p><p>こっちはタイムトラベル・デバッグのやり方です。</p><p>状態の変更があるごとに、そのディープコピーを履歴リストに追加します。そうすれば単に履歴からコピーし、それに合わせてUIを更新することにより状態の復元ができます。もう少し詳しく説明するため、<a href="http://jsbin.com/fejija/1/edit?js,output" rel="nofollow" title="" class="ext-link">クリックして試せるデモ</a>を作成しました。</p><p>ここでも同じパターンが使われていますね。<code>time</code>はタイムトラベル・サブアプリケーションの状態を表し、<code>updateTimeUI()</code>はその更新のための関数です。</p><p>さて、これでビルドできます。取り消し(undo)は開発者向けではなくユーザ向けのタイムトラベルの機能です。履歴をローカルストレージに保存することにより、ページのリロードごとに保管することができます。エラーを補足してシリアライズされた履歴とともにバグ管理システムに送信すれば、自動的にユーザが直面するエラーを再現できるのです。</p><p>Reactがこの全ての魔法のパワーを備えているわけではありません。少なくとも設定なしの状態では無理です。なぜならReactはアプリケーションの状態を細かく分断し、コンポーネントの中に隠すからです。</p><p>何故純粋関数や不変データ、そして仮想DOMが必要なのでしょうか。これらは最適化の手法であり、ある意味において簡素化でもありますが、アイデアの核ではありません。そうは言ってももう少し見ていきましょう。</p><p>最初にもう少し複雑な例が必要です。</p><p>いくつかの点に注目してください。</p><p>これをもっとシンプルにやる方法があります。</p><p>ここでは<code>render()</code>はただのアプリケーションの状態からhtmlまでの純粋関数です。これが純粋関数でなくてはならないのは、状態のみがUIを定義するただ1つのものだからです。</p><p>この簡略化されたコードの中でさえ、ある意味UIは状態を表す関数でしたが、それほど明確というわけではありませんでした。なぜなら、毎回UIを計算し白紙の状態から再構築したわけではなく、更新したためです。また、<code>updateUI（）</code>と記述して台無しにする可能性もありました。その場合、UIの状態がそれ自身の前の状態とアプリケーションの状態の両方によって定義されるため、レンダリングは実際には最適化ではなく、単純化やガードとなるのです。</p><p>とりあえず、純粋関数については以上で終わりです。</p><p>ここで、<code>render()</code> / <code>$().html()</code>のペアをご覧ください。イベント毎に、恐らくキーを打つごとに全体の表現を一から構築しています。何だか重そうですね。そこで別の最適化を使ってみましょう。それが仮想DOMです。</p><p>このdiff / patchが複雑に思えるようでも、Reactや<a href="https://github.com/Matt-Esch/virtual-dom" rel="nofollow" title="" class="ext-link">スタンドアロンのvirtual-dom実装</a>がカバーしてくれるでしょうから心配いりません。ただ、実際にはそれほど複雑ではありません。差分（diff）を算出するアルゴリズムが書けるようであれば、ほぼ間違いなく自分でこれを実装できるはずです。</p><p>ちなみに、先ほどやった最適化は不完全ではありますが、現状のシンプルな例は、上記の単純なrender-to-Stringの実装を問題なくこなせています。驚くべき事ですが、世間に出回っているほとんどのSPA（シングルページアプリケーション）でも同様にうまく処理することが可能です。最近はブラウザも高速ですからね。ここでもう一度強調しておきますが、平均的なアプリケーションであれば、初動期にはReactやその他の仮想DOMについてはスルーしても大丈夫です。動作が重くなってから目を向けても遅くはありません（そうでなければ、そのままスルーで大丈夫です）。</p><p>Reactの進行方向にあるもう1つの障害、それは仮想DOMがブロックの中で<a href="http://vdom-benchmark.github.io/vdom-benchmark/" rel="nofollow" title="" class="ext-link">最も遅いものの1つ</a>だということです。</p><p><code>deepcopy()</code>のコールが手つかずのままの状態であることに気付きましたか？一見するとゴミですね（些末な話ですが、もう少しお付き合いください）。不変データ構造の背後にある考え方は、以前の状態をコピーしてからそれを変えるのではなく、以前の状態に基づいて新しい状態を構築するということです。</p><p>少し具体性が足りないので、JSで不変オブジェクトを作成する方法をお見せします。</p><p><code>object.a.x</code>と<code>object.b</code>を再利用していますよね。これによりコピーしなくても、より短い時間で効果的に差分を作成できるようになります。つまり、<code>object.b</code>と<code>object2.b</code>の差分を抽出する前に、それらが同じオブジェクトであるかをまずチェックするのです（参照の等価性）。実行後、差分がemptyであれば最後までやる必要はありません。</p><p>上記に1つ付け加えることがあるとすれば、不変コレクションに対しては、この単純なアプローチは面倒なだけでなく、効果もないということです。多くのキーを持つオブジェクトがあると仮定してみてください。そのうちの1つの値が変わった場合、同じキーを持つ新たなオブジェクトを作らなければならなくなりますよね（値の再利用は可能ですが）。きっとそんなオブジェクトは使わないと思います。ただ、配列についてはどうでしょうか。どうなるか見てみましょう。</p><p>全てをコピーしなければなりませんね。でも、以下のようにすれば不変のシーケンスをもっといい形で実装できるようになります。</p><p>ここでは<code>log N</code>のオブジェクトを新規に作成したのみで、残りは再利用です。コピーの頻度はさらに減っていますし、差分もより高速になっています。また全てのツリーに対しても実際には対処する必要はありません。なお、すぐに使えるすばらしい実装があります。例：以下は<a href="https://github.com/facebook/immutable-js" rel="nofollow" title="" class="ext-link">Immutable.js</a>を使うことで、最初に挙げた例がどう変わるかを示したものです。</p><p>効率的ですばらしいAPI、そして不変コレクションへの誤った書き込みに対する保護が提供されています。次に、ClojureScriptから抽出された不変コレクションのセットである<a href="https://github.com/swannodette/mori" rel="nofollow" title="" class="ext-link">mori</a>も見てみましょう。</p><p>ちなみに実際のところ、Reactは既存のコレクションによる単純な不変を使っています。</p><p>ここまでの私の意見からReactがそんなにいいツールではないと思われるかもしれませんが、そんなことはなく実際とても便利なツールです。魔法のパワーや最高の速さはないかもしれませんが、それに代わるコンポーネントがありますし、速度も比較的速いと言えるでしょう。それにエコシステムやコミュニティもあります。</p><p>さらに別の角度からも見ることが可能です。それは何かというと、Reactがフロントエンド開発を仮想DOMや不変コレクションライブラリなどといった面白い方向に大きく後押ししているということです。</p><p>いずれにしても、ここで紹介した内容を通じて、どんなツールでどのようにコードを構築するかを判断する際のお力になれれば幸いです。</p>
