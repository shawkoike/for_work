<p><a href="http://mrale.ph/blog/2016/11/23/making-less-dart-faster.html" rel="nofollow" title="" class="ext-link">Adventures in the land of substrings and RegExps.</a> （2016-11-23） by <a href="http://twitter.com/mraleph" rel="nofollow" title="" class="ext-link">Vyacheslav Egorov</a></p><p>数週間前、Dart SDKに関して、<a href="https://github.com/dart-lang/sdk/issues/27810" rel="nofollow" title="" class="ext-link"><code>String.substring</code>のパフォーマンスが非常に悪い</a>というバグが報告されました。以下は、その問題と一緒に提出されたマイクロベンチマークの中心部分です。</p><p>結果は、Dartバージョンでかなり悪くなっています。</p><p>見る方の経歴によっては、Dartでの実行時間が非線形増加を示していることにも驚くかもしれません。つまり、入力文字列のサイズを2倍（25000から50000）に増やすと、実行時間が4倍（244ミリ秒から949ミリ秒）に増えているのです。</p><p><code>dart --observe</code>でベンチマークを実行して<a href="https://dart-lang.github.io/observatory/cpu-profile.html" rel="nofollow" title="" class="ext-link">CPUプロファイル</a>を<a href="https://dart-lang.github.io/observatory/" rel="nofollow" title="" class="ext-link">Observatory</a>で見てみると、意外ではない結果となりました。</p><p><img src="http://mrale.ph/images/2016-11-23/observatory-cpu-1.png" alt="CPU profile"></p><p>実行時間の大部分が、部分文字列の操作に費やされています。では、なぜDart VMの部分文字列はV8のよりも時間がかかるのでしょうか？実装が全く異なっているのに違いありません。そして、実際そうなっています。</p><p>Dart VMは、<code>String.substring(start, end)</code>を非常に直接的な方法で実装しています。長さ<code>end - start + 1</code>の新しい<code>String</code>オブジェクトを割り当て、この新しい文字列に文字列コンテンツをコピーします。形式的にいえば、これは<span id="MJXc-Node-19" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-20" class="mjx-mrow"><span id="MJXc-Node-21" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.464em; padding-bottom: 0.296em;">O</span></span><span id="MJXc-Node-22" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.464em; padding-bottom: 0.59em;">(</span></span><span id="MJXc-Node-23" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.212em; padding-bottom: 0.296em;">n</span></span><span id="MJXc-Node-24" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.464em; padding-bottom: 0.59em;">)</span></span></span></span>の実装であり、<em>線形時間</em>としても知られています。部分文字列の長さに比例した演算量が必要になるということです。</p><p>ベンチマークの中心部分を見てみると、実行時間が<em>2次</em>成長を示した理由が明らかになるはずです。</p><p>文字列<code>s</code>の初めの長さをNと仮定すると、ループの最初の反復で長さN−1の部分文字列が生成されます。次の反復で長さN−2の部分文字列が生成され、以後同様に続きます。最後の反復で長さ1の部分文字列が生成されます。ループに必要な演算は以下の数式で表されます。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/12/3258d3eb6f3be91c6b62a1c8e2db38a1.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/12/3258d3eb6f3be91c6b62a1c8e2db38a1.jpg" alt="%e6%95%b0%e5%bc%8f2" width="626" height="64" class="alignleft size-full wp-image-8892"></a></p><p>これは、<span id="MJXc-Node-69" class="mjx-msubsup"><span class="mjx-base" style="margin-right: -0.085em;"><span id="MJXc-Node-70" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.464em; padding-bottom: 0.296em; padding-right: 0.085em;">N</span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0.227em; padding-right: 0.071em;"><span id="MJXc-Node-71" class="mjx-mn"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.38em; padding-bottom: 0.338em;">2</span></span></span></span>に比例します。</p><p>[上記の数列を今まで見たことのなかった方は、ちょっと時間を取って、和の公式の導き方について考えてみることをお勧めします。解法がいかに単純で簡潔かが分かると、Webpackの設定との格闘をやめられるようになるかもしれません。数学の<a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%BC%E3%83%AB%E3%83%BB%E3%83%95%E3%83%AA%E3%83%BC%E3%83%89%E3%83%AA%E3%83%92%E3%83%BB%E3%82%AC%E3%82%A6%E3%82%B9" rel="nofollow" title="" class="ext-link">フリードリヒ・ガウス</a>は、これを8歳の時に見事に理解していました。もちろん、ガウスがモダンなJavaScriptのエコシステムを前にした時に何をするかは、想像もつきませんが]</p><p>上記ループの計算量<span id="MJXc-Node-73" class="mjx-mrow"><span id="MJXc-Node-74" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.46em; padding-bottom: 0.294em;">O</span></span><span id="MJXc-Node-75" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.46em; padding-bottom: 0.585em;">(</span></span><span id="MJXc-Node-76" class="mjx-msubsup"><span class="mjx-base" style="margin-right: -0.085em;"><span id="MJXc-Node-77" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.46em; padding-bottom: 0.294em; padding-right: 0.085em;">N</span></span></span><span class="mjx-sup" style="font-size: 70.7%; vertical-align: 0.513em; padding-left: 0.227em; padding-right: 0.071em;"><span id="MJXc-Node-78" class="mjx-mn"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.377em; padding-bottom: 0.335em;">2</span></span></span></span><span id="MJXc-Node-79" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.46em; padding-bottom: 0.585em;">)</span></span></span>こそ、文字列の反復時に処理済みの部分をスライシングする方法が適さない理由を示しています。ただし、ランタイムが内部で”ちょっとした”マジックを使って、この特定のパターンを最適化できるのであれば、もちろん話は別です。V8はその最適化を行います。</p><p>V8のソースを調べてみると、何だか恐ろしくごちゃごちゃとした、様々な文字列表現があることが分かりました。それぞれ、特定のユースケース（索引付け、連結、スライシング）のための最適化です。</p><p><img src="http://mrale.ph/images/2016-11-23/sequential.jpg" alt="Sequential String"></p><p><img src="http://mrale.ph/images/2016-11-23/concat.jpg" alt="Cons String"></p><p><img src="http://mrale.ph/images/2016-11-23/substring.jpg" alt="Sliced String"></p><p><img src="http://mrale.ph/images/2016-11-23/external.jpg" alt="External String"></p><p>JavaScriptコードで文字列値を見る時、実はこれらの表現が背後にあるわけですが、その時はいつでも、ランタイムはこれらの表現を切り替えて操作することができ、操作のパフォーマンスが向上するのであれば、ある表現から別の表現へ動的に移行することさえ可能です。</p><p>［他のJavaScriptランタイムも、ベンチマーク競争から生じた同じく複雑な表現階層を持ち、一般的な使用パターンのための最適化を志向しています。SpiderMonkeyの<a href="http://hg.mozilla.org/mozilla-central/file/b92dcbb89ffc/js/src/vm/String.h#l43" rel="nofollow" title="" class="ext-link">String.h</a>や、JSCの<a href="https://github.com/WebKit/webkit/blob/372ef3674a0d4035237640a8328dad4eb0dd2232/Source/JavaScriptCore/runtime/JSString.h" rel="nofollow" title="" class="ext-link">JSString.h</a>、Chakraの<a href="https://github.com/Microsoft/ChakraCore/tree/247f6b9f3f050cc877d84be265eef4bdd318cb21/lib/Runtime/Library" rel="nofollow" title="" class="ext-link">ソース</a>にある*String.hファイルをご参照ください］</p><p>様々なJavaScriptランタイムで使われている様々な文字列表現の違いを理解することは、通常、自分の書いた文字列操作コードが一定のパフォーマンスを示す理由を理解するための鍵となります。例えば、少し脱線して以下の例で考えてみましょう。</p><p>このコードは、SpiderMonkeyではV8の場合より60倍速く動きます。ただ残念ながら、その詳細について扱うのは本記事の範囲外です。</p><p><code>String.prototype.substring</code>のマイクロベンチマークの話に戻りましょう。C++のレイヤとアセンブリをかき分けていくと、最終的に、<a href="https://github.com/v8/v8/blob/061c2ab23a1d4cd192b935e7912e7dfb1fed845d/src/factory.cc#L668-L729" rel="nofollow" title="" class="ext-link">部分文字列操作を実装しているコード</a>に到達するはずです。</p><p>［V8では、1つの場所<em>だけ</em>に実装されたものはないので、部分文字列の実装探しに迷える人は、さらに<a href="https://github.com/v8/v8/blob/061c2ab23a1d4cd192b935e7912e7dfb1fed845d/src/code-stub-assembler.cc#L3049" rel="nofollow" title="" class="ext-link">CodeStubAssembler::SubString</a>を詳しく調べることになるかもしれません。これは、マシンコードにコンパイルされてSubStringスタブとして役立つTurboFanグラフを作成します。SubStringスタブは基本的に、上記C++ロジックへのファストパスを実装するものです］</p><p>このC++ロジックをDartに変換すると、以下のようになります。</p><p>これがJavaScriptバージョンのおおよその動作であり、マイクロベンチマークで2次の計算量が観察されない理由が示されています。大まかにいえば、部分文字列操作は（入力文字列が単調だと仮定し、メモリ管理のオーバーヘッドを無視すると）一定時間を要します。したがって、</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/12/b66d11c774df0ef96f0bc9805718892f.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/12/b66d11c774df0ef96f0bc9805718892f.jpg" alt="%e6%95%b0%e5%bc%8f1" width="502" height="64" class="aligncenter size-full wp-image-8893"></a></p><p>上記ではなく、下記になります。<br>
<a href="http://postd.cc/wp/wp-content/uploads/2016/12/acfbddc6e522130c237a5dbe580d2a67.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/12/acfbddc6e522130c237a5dbe580d2a67.jpg" alt="%e6%95%b0%e5%bc%8f3" width="415" height="33" class="aligncenter size-full wp-image-8894"></a></p><p>パフォーマンスが劇的に向上するのであれば、なぜDart VMで同様の最適化を実装しないのでしょうか。それは、この部分文字列最適化には危険な落とし穴があるからです。驚くべき<em>メモリリーク</em>を引き起こすのです。</p><p>上記の<code>obj</code>は、わずか20文字のトークンではなく、10GBの入力文字列全体を保持します。なぜなら、このトークンの内部表現は、ソース文字列を指す<code>SlicedString</code>であるからです。わざとらしい例に見えるかもしれませんが、このようなメモリリークは本当に実際の場で起こりがちです。例えば、<code>three.js</code>はこの問題を<a href="https://github.com/mrdoob/three.js/issues/9679" rel="nofollow" title="" class="ext-link">回避しなければなりません</a>。ランタイムが見えないところで巧妙な最適化を行ってコードを速めることには、厄介な側面もあります。<a href="https://bugs.chromium.org/p/v8/issues/detail?id=2869" rel="nofollow" title="" class="ext-link">Issue 2869</a>では、この問題のV8側での修正について経過をたどっていますが、2013年以来、実際的には何も起こっていません。その理由は恐らく、唯一のシンプルかつ確かな解決法は、スライシングされた文字列を完全に除去することだからでしょう。興味深いことに、これはまさにJavaが行っていたことです。Javaはかつて、親の<code>String</code>の<code>char[]</code>ストレージを部分文字列オブジェクトのために再利用することで、<em>O</em>(1)時間での<code>String.substring</code>を実装していました。しかし、これは<a href="http://bugs.java.com/view_bug.do?bug_id=4513622" rel="nofollow" title="" class="ext-link">メモリリーク</a>を引き起こし、<a href="http://marc.info/?l=openjdk-core-libs-dev&amp;m=135796361239057&amp;w=4" rel="nofollow" title="" class="ext-link">結局2012年に廃止されました</a>。V8の文字列スライスに関する経緯は、さらに不思議です。V8には元々、<a href="https://github.com/v8/v8/blob/43d26ecc3563a46f62a0224030667c8f8f3f6ceb/src/objects.h#L2927-L2931" rel="nofollow" title="" class="ext-link">文字列スライスがあり</a>、2009年に<a href="https://codereview.chromium.org/385004" rel="nofollow" title="" class="ext-link">廃止</a>されましたが、その後2011年に<a href="https://codereview.chromium.org/7477045" rel="nofollow" title="" class="ext-link">復活</a>したのです。</p><p>以上のことは、本記事の道のりの<a href="https://github.com/dart-lang/sdk/issues/27810" rel="nofollow" title="" class="ext-link">出発点となったDart SDKのバグ</a>にとっては、少々厄介な問題です。実のところDart VMは、スライシングされた文字列による部分文字列最適化を実装しそうにありません。そこで私は、一体なぜ部分文字列のパフォーマンスが測定されているのかを探ることにしました。</p><p>冒頭のバグは、<code>less_dart</code>が遅いことについての調査で見つかったものだと分かりました。<code>less_dart</code>とは、<code>less.js</code>のJavaScriptからDartへのポートです。</p><p><code>less_dart</code>のベンチマークをObservatoryで見てみると、以下の結果になりました。</p><p><img src="http://mrale.ph/images/2016-11-23/observatory-cpu-2.png" alt="CPU profile"><br>
Lessパーサが、私なら勧めないことをまさに行っています。つまり、部分文字列操作で入力文字列の処理を繰り返しているのです。ソースを調べたところ、以下のコードが浮上し、部分文字列を使っている理由も明らかになりました。</p><p>［コードはJavaScriptから逐語的にポーティングされていますので、<a href="https://github.com/less/less.js/blob/d0fbadba2ec4c92d9871da5a1f282c67c96a995b/lib/less/parser/parser-input.js#L107-L124" rel="nofollow" title="" class="ext-link">まさに同じコード</a>がJavaScriptバージョンに存在します。そちらでは、準最適化が<em>有用な</em>JavaScriptランタイムの存在によって隠れています］</p><p>Lessの作者は、カスタムレクサを書くのではなく正規表現を使って入力をパースすることに決めました。しかし、ES6以前の世界では<code>RegExp</code>で解析することは複雑でした。なぜなら、正規表現を使って<em>指定位置で</em>マッチするかを簡単に調べることができなかったためですが、それこそ、文字列をたどってトークンに分割する際にレクサが行う必要のあることです。</p><p><code>match</code>は、ES6で導入された<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Using_a_regular_expression_with_the_sticky_flag" rel="nofollow" title="" class="ext-link">RegExpの<em>sticky</em>フラグ</a>をサポートするモダンなJavaScriptインタプリタなら、どれにでも容易に実装できます。</p><p>［フラグ<code>y</code>は、<a href="https://ja.wikipedia.org/wiki/Lex" rel="nofollow" title="" class="ext-link">Lex</a>のAPIの一部である<code>yylex</code>にちなんで名付けられたようです（その技術はES7に含まれるも技術よりも高度なものでつくられた宇宙船<a href="https://en.wikipedia.org/wiki/Lexx" rel="nofollow" title="" class="ext-link">Lexx</a>と混同しないように）。恐らく<em>sticky</em>という名前も、*yで終わるという理由で選ばれたのでしょう］</p><p>では、ES6以前のJavaScriptエンジンで<code>match</code>を実装する方法とは？　非常に単純なアプローチを取るとしたら、以下のようになるでしょう。</p><p>ですが、この方法は極めて非効率です。というのも、<code>match(/\d+/g)</code>を呼び出すと基本的に、最初の数字列を探すために<code>this.idx</code>以降を検索して、<code>this.idx</code>で出現したマッチでなければ破棄することになるからです。</p><p><code>RegExp</code>の機能にもう少し詳しい人であれば、以下のような最適化を考えるかもしれません。</p><p>しかし、<code>match</code>を実装するもっと一般的かつ直接的な方法は、<code>substring</code>と<em>アンカーを付けた</em>正規表現を使うものでしょう。</p><p>これはまさしく、<code>less.js</code>と<code>less_dart</code>にあるコードです。<code>less.js</code>にとっては幸いなことに、V8ランタイムは<code>String.prototype.substring</code>を<em>O</em>(1)の演算として実装し、<code>less_dart</code>にとっては不運なことに、Dart VMは<em>O</em>(1)の演算として実装していません。</p><p>Dart VMが実装<em>している</em>のは、<a href="https://api.dartlang.org/stable/1.20.1/dart-core/Pattern/matchAsPrefix.html" rel="nofollow" title="" class="ext-link"><code>RegExp.matchAsPrefix</code></a>のメソッドです。これは基本的に、指定された正規表現についてstickyなマッチを指定位置で実行するものです。バンザイ！☺</p><p>しかし、<code>less_dart</code>コードに必要な変更を施したところ、実際には何倍も遅くなってしまいました。うーん。☹</p><p>結局、VMのRegExp実装の内部に、ちょっとした<code>TODO</code>があったことが分かりました。</p><p>明らかに、この解決法は、V8がstickyフラグを実装しているのと同じやり方で<code>RegExp.matchAsPrefix</code>を実装することでVMを修正する、というものでした。これは、Dart VMが基本的に、V8と同じく<a href="https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html" rel="nofollow" title="" class="ext-link">Irregexp</a>と呼ばれる<a href="http://news.dartlang.org/2015/02/irregexp-dart-vms-new-regexp.html" rel="nofollow" title="" class="ext-link">正規表現エンジン</a>を使っているので、ややシンプルになっています。</p><p>［Dart VMポートをIrIrRegexpと呼ぶべきだったかもしれません。なぜなら、Dart VMは、RegExp特有の中間表現（IR）をマシンコードに変換する代わりに、マシンに依存しないIRにまで変換し、その処理をジェネリックなコンパイラパイプラインに任せるからです。これによって、マシン特有の正規表現関連バックエンドコードをポーティングしなくても、IrregexpをDart VMに組み込むことができたのです］</p><p>そこで私は、オリジナルのIrregexpで<em>sticky</em>フラグの実装を推進していた1人である<a href="https://twitter.com/erikcorry" rel="nofollow" title="" class="ext-link">Erik Corry</a>に直接相談してみました。そして、<a href="https://github.com/dart-lang/sdk/commit/2403444eba54675d8b5d96912fce86f13eff1f1c" rel="nofollow" title="" class="ext-link"><em>sticky</em>フラグをDart VMにポーティング</a>してみました。その際に、V8の<em>sticky</em>の実装における非常に小さなバグを<a href="https://github.com/v8/v8/commit/29745ee927bf1f4cb3e0b0075d0a149575000f18" rel="nofollow" title="" class="ext-link">発見し、修正</a>しました。</p><p><code>RegExp.matchAsPrefix</code>が効率的な形で実装されたので、私がless_dartの<a href="https://github.com/mraleph/less_dart/commit/626137cfee46f6a843f80ecf84c2195c497277c1" rel="nofollow" title="" class="ext-link">修正</a>を行った結果、期待されたパフォーマンス改善が実現して、<code>less_dart</code>と<code>less.js</code>が互角の状態になりました。</p><p>できればこのポジティブな雰囲気で本記事を終えたかったのですが、ソースコードをトークン化するために正規表現を使うという一般的な話に戻りたいと思います。</p><p>その実現に際して非常に重要な点は、確かに正規表現は解析に便利な方法であるとはいえ、決して効率的な方法ではないということです。関係している抽象化レイヤがとにかく多すぎるのです。</p><p>前に試したように、正規表現でのトークン化とそのベンチマークテストを<code>("aaaaa aaaa ".repeat(50) + "10 ").repeat(10000)</code>のような単純な文字列で実行してみると、以下のようなパフォーマンス数値が得られます。</p><p>速度を上げられるでしょうか？　抽象化レイヤを取り払い、完全に手動でやってみましょう。</p><p>別用途の際に私が使ったものと全く同じベンチマークで、このトークナイザのベンチマークテストを実行します。</p><p>すると、以下の結果が出ました。</p><p>このことから分かる重要なポイントは、<em>作業量が減ればプログラムははるかに速くなる</em>ということです。例えば、この手動トークナイザは、部分文字列オブジェクトのトークンへの割り当ては行わず、単純に文字列をたどるものです。しかし、<code>var val = l.val;</code>をベンチマークのループ内に追加してこの無意味な割り当てを強制するようにすると、やはり、RegExpベースのパーサよりはるかにパフォーマンスが良いことが分かります。</p><p>以下にDartにおける同種のレクサベンチマークを挙げておきます。</p><p>Dart VMは、このコードでなかなかのパフォーマンスを見せました。</p><p>まとめると、パフォーマンスに関する総合的なアドバイスは以下のようになります。</p>
