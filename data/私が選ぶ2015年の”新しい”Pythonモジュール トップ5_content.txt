My top 5 ‘new’ Python modules of 2015 （2015-12-23） by Robin Wilsonここ1年、私はPythonに関するブログをたくさん書いてきました。そこで今回は、2015年における、私にとって”新しい”Pythonモジュールの中から、お気に入りものを厳選してご紹介したいと思います。なお、以下に挙げるモジュールは、必ずしも2015年に新規にリリースされたものではありません。ただ、”私にとっては目新しい”ものだったので、恐らく皆さんも新鮮に感じるのではないかと思います。tqdmはとてもシンプルであり、かつ非常に実用的なモジュールです。これを使えば、コード内に含まれるループの進捗バーを、驚くほど簡単に表示できます。例えば以下のようなコードがあったとしましょう。このiterableを単純にtqdm関数でラップします。すると以下のような美しい進捗バーが表示されます。最近、このモジュールを妻に紹介したところ、そのシンプルさと実用性に驚いていました。joblibの存在は以前から知ってはいたものの、実際のところはよく理解しておらず、いろいろな機能を寄せ集めたようなモジュールだと思っていました。まあ、その印象は今もあまり変わりませんが、実は非常に便利なモジュールだったのです。私はFlowminderの同僚から再度joblibを勧められて、このモジュールをデータ分析用のコードに幅広く使用しました。では、その機能について紹介しましょう。joblibは大きく分けて、キャッシング、並列化、永続化（データの保存と読み込み）の3つの機能から成ります。実を言うと、私はまだ並列プログラミングの機能は使ったことがないのですが、あとの2つの機能は頻繁に使ってきました。キャッシング機能とは、シンプルなデコレータを使って、関数を簡単に”メモ化”する機能です。具体的には、関数の計算結果をキャッシュしておき、再度同じパラメータを使ってその関数が呼び出された際に、結果をキャッシュから読み出すことで処理時間を短縮します。なお、キャッシング機能を使う際は、メモ化する関数の引数を慎重に選ぶようにしましょう。joblibでは超高速のハッシュ関数を使用して引数を比較しますが、何ギガバイトもある巨大な配列を処理するとなると、さすがに時間がかかってしまいます。そのような場合は、ファイル名、日付、モデルのパラメータなど、巨大な配列の作成に使用される値を引数に取る関数をメモ化するのが良いでしょう。そうすることで、巨大な配列を読み込んだり、関数が呼び出されるたびにその配列のハッシュ値を計算したりする処理が省けます。上記のメモ化の機能と密接に関連しているのが永続化の機能で、これはキャッシュされた結果をファイルに保存するのに使われます。基本的な機能はビルトインのpickleモジュール（または後述のdillモジュール）と同じですが、NumPy配列を含むオブジェクトに対しては非常に効果的に機能します。インターフェースはpickleと全く同じ（シンプルなload関数とdump関数）なので、切り替えが非常に簡単です。私は途中で気が付いたのですが、compressed=Trueと設定すると、出力ファイルが明らかに小さくなり、出力結果が1ファイルに集約されます（.pklファイルや大量の.npyファイルが生成されるデフォルトの動作とは正反対です）。
私はfoliumを、かろうじてざっとかじっただけですが、このライブラリはPythonからの地理的データを即席で描きだすのに、実に役に立ちます。おまけにJupyter Notebookとでさえうまく動作します。このドキュメンテーションからのコード例の一部を見ても、どれほど簡単に使用できるかが分かります。使用されているバックグラウンドマップ（あらゆるリーフレットのタイルセットも機能します）、ポイントアイコン、カラー、サイズ、その他多くの要素を含めて、上記のマップのほぼ全ての面を、容易に構成することができます。GeoJSONデータを視覚化し、コロプレスマップも作成することができます（さらにPandasのデータフレームともリンクしています）。このモジュールもまた、Flowminderとの仕事で使用しました。後になっていろいろな他のコンテキストでも使ってみました。上記のコードを用い、ループでsimple_markerに呼び出しを行うことで、たくさんのポイントを簡単に視覚化できます。また上の例は、指定されたHTMLファイルへマップを保存する方法を表しています。しかしJupyter Notebookの中での使用は、Mapオブジェクト（上の例で言うとmap_1）がそれ自体でセルの最終ラインにあることを確かめるだけです。Jupyter Notebookは魔力を働かせ、それをインラインに示します。完璧ですね。私にとって”新しい”モジュールのrecipyの最初のバージョン（Collaborations Workshop 2015 (CW15)で発表したもの）では、バックエンドデータの保存用にMongoDBを使用しました。しかし、最初にMongoDBサーバをインストールし、動作させる必要があったので、インストール/セットアップの手順がかなり複雑になりました。私がpure-Python NoSQLデータベースを探している時に、TinyDBに出会いました。これには単純なインターフェースがあって、ここまで投げかけてきたもの全てに対応していました。より長期的にはrecipyのためのバックエンドを可変にすることについて考えています。MongoDBの利点（ネットワークを介して簡単に、より優れたパフォーマンスのデータベースを共有できる）を活用したい、とユーザが思っている場合でも、私たちの生活をもっと楽にしてくれるTinyDBをデフォルトのDBとして使い続けるでしょう。dillは、より優れたpickle（納得できますか？　）です。あなたはディスクにさまざまなPythonオブジェクトを保存するために、おそらくビルトインpickleモジュールを使用してきたでしょう。ですが、時々、このようにエラーが出たかもしれません。こうなってしまうのは、pickleオブジェクトがpickle化できるものの中で比較的、制限されているからです。つまり入れ子関数やlambda、スライスや、その他いろいろなものを処理できません。これらのオブジェクトを直接pickle化したいケースは、それほどはないかもしれませんが、pickle化したい他の物の中に、そういったオブジェクトが出てくることは、かなり一般的です。そのため、pickle化が失敗する原因となるのです。より多くのものをpickle化できるようになることで、dillは、この問題を解決します。実際のところ、フレームやジェネレータやトレースバックとは関係なく、ほとんどあらゆるものをpickle化できます。先にご紹介したjoblibと同様、インターフェースはpickleと全く同じ（loadとdump）なので、切り替えは実に簡単です。また、RDataファイルにセッション全体を保存できるRの性能が気に入っている方にお勧めしたいのは、dillにはdump_sessionおよびload_session関数もあるということです。これは、まさに待ち望んでいたものです。これは”おまけ”であって、実質的にはPythonのモジュールではありません。でも、私は2015年に使い始めて（そうです、私は乗り遅れたのです）、今ではこれが無いと困るほどです。Anacondaにはちょっと分かりにくいところがあります。というのも、Anacondaは複数のパーツから構成されているからです。それらの集合体が”Anaconda”と呼ばれるものです。そのパーツとは、以下のようなものです。さあ、以上が私にとって新しい、2015年のPythonモジュールトップ5です。便利だと感じてもらえると嬉しいです。皆さん、楽しいクリスマスと新年をお過ごしください。（この記事が気に入った方は、Jupyter Notebook extensionsの簡単なインストール方法、Bokeh plotsとデータフレーム基盤のツールチップ、Pytohnにおける直交距離回帰もぜひご覧になってください。)
