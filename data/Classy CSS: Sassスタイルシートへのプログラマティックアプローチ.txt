<p><a href="http://una.im/classy-css/" rel="nofollow" title="" class="ext-link">Classy CSS: a Programmatic Approach to Sass Stylesheets</a> (2015-11-15) by <a href="http://unakravets.com/about.html" rel="nofollow" title="" class="ext-link">Una Kravets</a></p><p>上記で紹介した記事（「Atomic OOBEMITSCSS」）では、コンポーネントをマークアップする方法について（Pinterestを使った例を示しながら）説明し、それぞれのスタイルの関連性について比較しました。私たちのフロントエンドアーキテクチャは大規模なパターンライブラリ上で耐性テストを行っていますが、そのことで何か質問された時には、いまだに私はその記事を手ごろなマニュアルとして使っています。</p><p><img src="http://una.im/images/posts/classy-css/ex.jpg"><br>
<em>注釈：SitePointの記事に載せた例の1つ</em></p><p>その結果、従来のコンピュータサイエンスの経験がある人々に対して、私はいつの間にか、システム（そしてSass自体）を説明する必要が出てきたことに気づきました。そうしていくうちに分かったのは、記事の中で説明したCSSのアーキテクチャシステムがどれほどプログラマティックでクラスに基づく考え方をしているかということです。そこで、少し時間を取って、その考え方をこれからも使っていくのにふさわしい名前をつけてみました。Classy CSSです。では、従来の考え方をするプログラマにとって、もう少し身近に感じられるような方法で、この考え方について説明していきたいと思います。</p><p>この記事の目的は、以下の3つです。<br>
1. <code>@extend</code>について擁護すること<br>
2. <strong>Classy CSS</strong>を紹介すること（Atomic OOBEMITSCSSより言いやすい名前ですね）<br>
3. CSSの、スケーラブルかつモジュラー、そしてクラスに基づいたアプローチについて説明すること</p><p>それでは、例としてボタンを使いながら、どのような仕組みになっているのかについて詳しく見ていきましょう。（ボタンを使う理由は、CSSにおける”Hello World”の役目をボタンが果たしているからです）。</p><p><img src="http://una.im/images/posts/classy-css/buttons.png" alt="buttons" style="max-width: 500px;"><br>
まず、すべてのボタンのベースとなるコードを含む、暗黙のプレースホルダセレクタから見ていきましょう。BEM風の構文を修正したものを使います。命名の最初の部分は、これから参照していくオブジェクト（buttonまたはbtn）です。ダッシュを2つ置いたあとにはモディファイア（今回の場合はbase）を記述します。<strong>注意：</strong> 変数も同じ方法で命名します。変数の型を基にするのです。（以下の例ではcolorがそれに該当します）。</p><p><strong>上記でbaseとして定義したbuttonが、私たちの使うbuttonクラスです。</strong>これをベースにして各ボタンを構築していきます。つまり、<strong>それぞれのボタンはこのクラスのインスタンス</strong>です。各ボタン要素はbutton型で、いくつか共通の特性（solidの輪郭や透明な背景など）を持っています。各ボタンから共通のプロパティを呼び出し、それを<em>ベース</em>にして構築していくのです。プロパティの上書きはしませんが、プロパティを追加することができます。すべてbuttonの上に成り立っているものであり、基となるbuttonを継承します。<em>（この説明で十分でしょうか？）</em></p><p><img src="http://una.im/images/posts/classy-css/ydkjs-fig.png" alt="protoypal inheritance" style="max-width: 500px;"><br>
<em>注釈：<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch5.md" rel="nofollow" title="" class="ext-link">「知られざるJavaScript: thisとオブジェクトプロパティ（You Don’t Know JS: This &amp; Object Prototypes）」</a>から引用した原型的な継承の実例</em></p><p>以下のように使います。</p><p>これらの記述をもっと<em>classyな</em>方法で書くとすると、<strong>コンポーネント</strong>（メインビジュアル（hero）、サイドバー、グローバルナビ）ごとに、部分的な.scss fileを持つことになり、ここで、実際に使うクラスのインスタンスが生成されます。具体的には、以下のようになるはずです。</p><p>_hero.scss</p><p>_sidebar.scss</p><p>_global-nav.scss</p><p>なぜ、代わりに<code>@mixin</code>を使わないのか疑問を持つかもしれませんね。クラスを分けているので、<code>@extend</code>を使う方が目的やコンセプトに合っています。システムを構築するために継承したプレースホルダのクラス内にMixinを作成することは可能です。そして、これらのインスタンスをクラス内に生成するために<code>@extend</code>を使います。</p><p><code>@extend</code>を使うことで何が起きているか（＝スタイルの複製を作る代わりに追加する）を理解できていれば、、より小さいアウトプット用CSSファイルと、より簡潔なコードにすることができます。「gzip圧縮してしまえばそんなことは問題にならない」との主張も可能ですが、サーバの環境設定へのアクセスがなければ、確実にgzip圧縮できるかどうかわからない場合もあります。</p><p><code>@extend</code>を理解し、効果的に使うには、正確な<em>“現状”</em>と<code>@mixin</code>と<code>@extend</code>の根本的な違いを位階することが大切です。以下のイメージ図をご覧ください。</p><p>
<style>.half--left {    width: 48%;    margin: 1%;    float: left;}.half--right {    width: 48%;    margin: 1%;    float: right;}.clearfix{clear:both}</style>
</p><p>つまり、実装の度にコードブロックを再作成しないため、より小さいアウトプット用CSSファイルができるということです。<code>@extend</code>を使うと、単純にプロパティを<em>参照</em>できるようになります。ここではExtendの方がぴったりですね。論理的な目的が理解できます。<br>
<a href="https://twitter.com/intent/tweet?via=Una&amp;text=&amp;url=&amp;original_referer=#teamExtend" rel="nofollow" title="" class="ext-link">#teamExtend</a></p><p>これの欠点は、「あるプロパティを持つコードブロックを含む新たなインスタンスを呼び出す」というやり方ではなく、単純に継承するスタイルを参照するだけなので、プロパティのブロックを<em>どこに</em>置くかコントロールできないことです（これがmediaクエリ内で<code>@extend</code>を使えない理由です）。しかし、<em>Classy CSS</em>のルールに従えば関係ありません。静的プレースホルダをインスタンス化するために、実際に使えるクラスへと継承します。また、<code>@mixin</code>はある目的のため、まだ使わずにおきます。それは、「静的プレースホルダ内で使うことで継承されるコードを構築する」という目的です。</p><p>例として、1つ目のボタンと2つ目のボタンを簡単に作れるように、ボタンのMixinを作ってみましょう。</p><p>CSSのアウトプットは次のようになります。</p><p>これが独断的なシステムであることは言うまでもありません。また、初心者にとっては複雑でしょう。しかし使い始めてみると、名前付けや構築的な決断をする際に、非常に役立ちます。</p><p>有益性には以下も含まれます。</p><p>では、これでおしまいです。お見送りはいりませんよ。</p>
