<p><a href="http://philipwalton.com/articles/do-we-actually-need-specificity-in-css/" rel="nofollow" title="" class="ext-link">Do We Actually Need Specificity In CSS?</a> (2015-11-01) by <a href="http://philipwalton.com/" rel="nofollow" title="" class="ext-link">Philip Walton</a></p><p><small>(訳注：2016/01/05、頂いたフィードバックをもとに記事を修正いたしました。)</small></p><p>まず、初めに言っておきたいことがあります。この記事は、私がどれほど詳細度を嫌っているのかを延々と書いたもの<em>ではない</em>ということです。もしそのような内容の記事を読みたいのであれば、インターネットで探してください。たくさんあるはずです。</p><p>この記事の目的はWeb開発コミュニティにただ質問を投げかけることですので、その答えを考えてもらえれば嬉しいです。</p><p>問題の核心を突くために、質問を言い換えてみましょう。「<em>カスケードに詳細度が追加されていない世界の方が良かったのでしょうか、悪かったのでしょうか。</em>」</p><p>もちろん、この質問を見て、<em>どうでも良いでしょうとか、詳細度は存在するのだから我慢するしかない、考える必要はないだろう</em>と思う人がいることでしょう。</p><p>そう思っている人に、このような考えは正しくないということをお知らせできるのを嬉しく思います。:-)</p><p>この記事では、カスケードへの詳細度の影響を防ぐことが<em>可能である</em>ことをお見せします。つまり、上の質問が机上の空論ではないことを説明します。もし、詳細度の及ぼす悪い影響の方が、良い影響よりも大きい場合は、実際に対応することができます。</p><p>カスケードはどういう仕組みか忘れてしまっている人のために、簡単に説明しましょう。通常のCSS規則において、カスケードは「書かれた順番・詳細度・重要度」の3つの優先順位から適応するスタイルを決めています。</p><p>書かれた順番による優先順位は当然だと思います。YルールがXルールよりも後に書かれていて、両方のルールが同じ要素に適応される場合は、Yルールの宣言が”勝利”するのは自然で直感的です。</p><p>重要度による優先順位もつじつまが合います。何かをオーバーライドする必要が出てくる場合は常にあるので、重要度をつけるという選択肢があると便利です。インラインで書かれたスタイルをオーバーライドすることができるのは重要度だけですし、場合によっては必須になります。</p><p>しかし、詳細度に関しては違うと思います。</p><p>詳細度は、直感的なものではありません。特に新人の開発者にとっては。しかも、どちらかというと意図していた結果よりも、<em>やられた</em>と思える結果の方が多い気がします。他のシステムや言語に同等のものがあるか定かではありません。</p><p>例えば、詳細度という指標がJavaScriptにあったとします。次のテストを実行した場合、自分のコードがどれほど予測不可能なものになってしまうか想像してみてください。</p><p>上の<code>window.document.foo = 'bar'</code>設定（1番目）の参照の方が”詳細度が高い”ため、<code>document.foo = 'qux'</code>設定（2番目）を無効にしてしまうようなことが発生すると、収拾がつかない上に全く管理できなくなってしまいます。このようなことは実際にCSSで発生します。</p><p>スタイルの構成を詳細度に頼っているWebサイトが何千、いえ何万も存在すると思います。もし明日にでもブラウザが詳細度を無視するようなことが起きれば、Webサイトは全て破壊されてしまうでしょう。</p><p>詳細度が使用されていないと言っているのではありません。明らかに使用されています。私が言いたいのは、予測不可能であることや混乱を招くことを我慢してまで使用する価値はないということです。</p><p>私は、グローバル変数と同じくらい詳細度は便利だと思います。グローバル変数に頼ることがアンチパターンであると多くの人が考えるように、詳細度にも同じことが言えるのではないでしょうか。</p><p>さらに、CSS規則で別のCSS規則を（詳細度を使用して）オーバーライドしたのに、同時に詳細度の高い規則を後の方に書き込まなかったことは一度もなかったと思います。</p><p>つまり言い換えると、次の例のように、詳細度の高いフッターリンクの定義を詳細度の低いデフォルトリンクの前に書くようなことはないということです。</p><p>XルールをYルールでオーバーライドしたい場合は、私はソースコードの後の方に書きます。以上。つまり、詳細度の矛盾がある場合、それは常に偶然の出来事だということです。</p><p>ここで私は、コードを書く順番において、前の方に書いた規則を後の方に書いた規則でオーバーライドしたい時に規則の詳細度に関係なく実行するにはどうすれば良いのか考えました。</p><p>最終的に、皆で当然と同意したパラダイムから私（やチームメンバー）が誤って離れないようにするにはどうしたら良いのでしょうか。</p><p>CSSに詳細度が存在しない世界を想像してみてください。その世界では、カスケードが記述順や重要度だけで優先順位を決めることになります。そのため、XルールとYルールの両方がある特定の要素に一致し、Xルールの後にYルールが書かれている場合は、Xルールの詳細度に関係なく、常にYルールが勝ちます。Xルールの宣言プロパティがYルールの宣言プロパティをオーバーライドするには重要度を使用するしかありません。</p><p>この方がより良い世界なのでしょうか。予測しやすくて維持しやすい、拡張的なコードにつながるのでしょうか。</p><p>多くの人はCSSで”ステート”や”ユーティリティ”クラスを使用します。この例が、要素を非表示するための<code>is-hidden</code>クラスです。</p><p>一般的に、どの要素にもステートクラスは適用されます。大抵の場合、ステートクラスは単一のクラスセレクタに定義されているため、詳細度は低くなります。しかしながら、概念としてはオーバーライドタイプのクラスになります。つまり、要素を表示したい場合、<code>is-hidden</code>クラスはつけないということです。</p><p>詳細度が存在しない場合は、ステートクラスによって他のクラスをオーバーライドするには、単純にオーバーライドするコードを後の方に入れれば良いのです。しかし、今は<code>!important</code>を使用して問題を解決することができます。</p><p>正しいか分かりませんが、<a href="https://smacss.com/book/type-state#tips" rel="nofollow" title="" class="ext-link">SMACSSステート</a>や<a href="https://github.com/suitcss/utils-display/blob/0.4.2/lib/display.css" rel="nofollow" title="" class="ext-link">SUITユーティリティクラス</a>をこのようなシチュエーションで用いる場合に <code>!important</code>を付けることを勧められています。日常にスタイリングの必要性を核心的オプションに頼ることが、ベストプラクティスでなければ良いと思います。</p><p>ここからが面白いところです。単にブラウザに詳細度を無視するように指示するのは不可能ですが、特定のCSSファイルやCSSファイルのセットについて、カスケードへの詳細度の影響を防ぐことは<em>可能</em>です</p><p>どうやって防ぐのでしょうか？　答えは、詳細度と記述の優先順位を同じにするのです。</p><p>詳細度の最も低い規則から最も高い規則へと実行されるスタイルシートを想像してください。このようなスタイルシートでは、規則の詳細度は記述順序や規則に一致するため、詳細度を効果的に式から外すことができます。</p><p>もちろん、多くの人はCSSをこのように書きませんし、このように書くように期待したり、要求したりするのは理不尽かもしれません。</p><p>しかし、コードを書いた後にトランスパイラでCSSを更新して、全ての詳細度を昇順に並べられるとしたら？　さらに重要なことですが、どのセレクタにどの要素が一致するかに関係なく実現できるとしたら？</p><p>ありがたいことに、CSSセレクタの素晴らしい癖のおかげで実現できるのです。</p><p>次のCSS規則を見てください。現在詳細度は降順（各規則の上に詳細度を<code>[idCount].[classCount].[typeCount]</code>表記で記載）になっています。</p><p>これらのセレクタを、<em>一致する要素に影響を及ぼすことなく</em>詳細度の昇順に書き換えることができます。<!-- 書き加えたコードをハイライトしました。 --></p><p>全てのHTMLドキュメントはルート要素（<code>&lt;html&gt;</code>要素）を含むため、このコードは上手く動きます。<code>:root</code>疑似クラスをセレクタの前に付けることが要素のマッチングを変えることはありません。</p><p>例えば、<code>:root:root:root</code>が<code>&lt;html&gt;</code>要素に一致するように、疑似クラスを多重に付けることができるため、どのセレクタにも任意で詳細度を付けて前のセレクタよりも詳細度を高めることができます。</p><p>IDセレクタは、疑似クラスセレクタよりも詳細度が高いので、セレクタの前に<code>:root</code>を付けた場合の詳細度への影響がIDの詳細度を上回ることはありません。</p><p>しかし、IDセレクタの<code>#content</code>と属性セレクタの<code>[id="content"]</code>は同じ要素と正確に一致するので、全てのIDセレクタを属性セレクタに置き換えると、上記で説明した方法でもまだ動きます。</p><p>例えば、次のような規則を見てみましょう。</p><p>トランスパイルされると、こうなります。</p><p>ほとんどのセレクタは、それらを見ただけで<code>&lt;html&gt;</code>要素と一致するのかどうかを知るのは不可能です。例えば、<a href="https://modernizr.com/" rel="nofollow" title="" class="ext-link">Modernizr</a>を使用しているサイトなら、恐らく次のようなセレクタになるでしょう。</p><p>どちらかのセレクタが<code>&lt;html&gt;</code>要素と一致するかもしれない可能性を説明するためには、両方の可能性を含めて、次のように書き換えなければいけません。</p><p>この他の方法でも問題を完全に回避することができます。どのセレクタも<code>&lt;html&gt;</code>要素と一致することを許可しないように規定し、<code>&lt;body&gt;</code>が最も高くなるようにします。</p><p>この記事で述べてきたようなトランスパイラを私はまだ一切知りません。もしトランスパイラを書くことにに興味がおありなら、<a href="https://github.com/postcss/postcss" rel="nofollow" title="" class="ext-link">PostCSS</a>のプラグインで書くことをお勧めします。多くのビルドステップが<a href="https://github.com/postcss/autoprefixer" rel="nofollow" title="" class="ext-link">Autoprefixer</a>（これはPostCSSのプラグインです）を含んでいるので、これを加えてもビルド時間や複雑さへの影響はほとんどないでしょう。</p><p>次の基本的なアルゴリズムに従ってください。</p><p>ここまで説明してきたアプローチでうまく動作しますが、少し欠点も生じます。まず1つは、CSSのファイルサイズが増加してしまうことです。しかしこれは、詳細度を低く保って主に昇順で規則を記述していれば、大きな問題にはならないでしょう。それに、”root”という単語を何度も加えていくだけなので、うまくgzip圧縮できるはずです。その差は無視できると思います。</p><p>もう1つ注意すべきことは、外部スタイルを参照することの潜在的な問題点です。CDNから<em>bootstrap.css</em>を組み込んで他のスタイルでこの方法を使うと、おかしなことになる可能性があります。セレクタのセットの1つは書き換えられますが、他のセットは書き換えられないからです。</p><p>そして、正常に動作するために詳細度に頼っている場合とそうでない場合があるので、必然的に、ただ<em>bootstrap.css</em>をビルドに組み込むだけではいけなくなるのです。</p><p>記事を締めくくる前に、冒頭で述べたことについて、もう一度触れたいと思います。この記事は質問であって、処方箋ではありません。私自信も完全に考えがまとまっていないので、ここで挙げた方法を実際に試してはいません。</p><p>この方法が物事を大いに単純化するかどうかは疑わしいですが、私たちが詳細度にどれほど頼ってきたのかを明確にしてくれるのではないでしょうか。</p><p>詳細度に戦いを挑み続けている大規模なチームがあるなら、このような助言が彼らの役に立てれば面白いと思います。試してみた方がいらっしゃれば、どうぞお気軽に結果を<a href="http://philipwalton.com/about/#contact" rel="nofollow" title="" class="ext-link">お知らせください</a>。または、フォローアップ記事を書いていただければ、リンクを張ります。</p><p><strong>更新：</strong> <em>(2015年11月３日)</em></p><p><a href="https://twitter.com/LeaVerou" rel="nofollow" title="" class="ext-link">Lea Verou</a>が<a href="https://twitter.com/LeaVerou/status/661617150243672064" rel="nofollow" title="" class="ext-link">Twitter</a>で指摘してくれました。セレクタの詳細度が任意で増えてしまうので、<code>:root</code>の代わりに疑似クラスの<code>:not()</code>を使用するというものです。</p><p><code>:root</code>を使用する利点は、(<code>&lt;html&gt;</code>を含む)どの要素にも適応できるので、セレクタを分ける必要がないことです。これを使えば、例えば<code>not(z)</code>や<code>not(#z)</code>というような、型やIDレベルの詳細度も追加できるので、常にクラスを増やす必要はなくなります。</p><p><code>:root</code>を使用する欠点は、要素と一致しないように設定されているセレクタを選択しないように注意しなければいけないことです。そうしなければ、動作しなくなってしまいます。</p><p><strong>更新</strong> <em>(2015年11月14日)</em></p><p><a href="https://twitter.com/davidkpiano/" rel="nofollow" title="" class="ext-link">David Khourshid</a>が、”<a href="http://codepen.io/davidkpiano/post/the-simplicity-of-specificity" rel="nofollow" title="" class="ext-link">詳細度の単純さ</a>“というタイトルの返信記事を書いてくれました。CSSは命令型言語と比較するべきではなく、優先順位に関係なく規則を記述すれば、よりうまくいくと論じています。私はこの考えに同意できませんが、ここで述べたものとは違う方法を望むなら、一読されることをお勧めします。</p>
