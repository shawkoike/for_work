<p><a href="http://robotlolita.me/2015/11/15/how-do-promises-work.html" rel="nofollow" title="" class="ext-link">How do Promises Work?</a> （2015-11-15） by <a href="https://twitter.com/robotlolita" rel="nofollow" title="" class="ext-link">Quil</a></p><p><strong>目次</strong></p><p>JavaScriptの多くの実装は、シングルスレッドで動作するようになっています。そしてその言語の意味ゆえ、並行処理の命令に<em>コールバック</em>を使いがちです。JavaScriptで継続渡しスタイル（CPS）を使うのは特に間違いではありませんが、読みづらいコードになりやすく、必要以上に手順が増えるのも事実です。</p><p>これに関して多くの解決法が提案されており、Promiseを利用してこれらの並行処理を同期するという方法もそのひとつです。この投稿では、Promiseとは何か、どのように動作するのか、使うべき状況、使うべきでない状況とあわせて見ていきます。</p><p>最初に、重要な問いに答えましょう。「ところで、Promiseって何？」</p><p>この問いの答えを得るため、現実の世界で、非常に一般的なシナリオを考えてみます。</p><p><img src="http://robotlolita.me/files/2015/09/promises-01.png" alt=""><br>
<em>とても人気のあるレストランで食事をしようしている女の子たち</em></p><p>Alissa P. Hackerとその女友達は、とても人気のあるレストランで食事をすることにしました。あいにく、予想されたとおり、レストランに到着するとテーブルは全ていっぱいでした。他の店であれば、彼女たちはあきらめるか、別の場所で食事をするか、テーブルが開くまで長い列に並ぶかを選ぶことになったでしょう。しかしAlissaは行列が嫌いでした。そしてこのレストランには彼女にとって完璧な解決法があったのです。</p><p>「心配しないで、お客様。この装置があなたのために全て手配します」と、小さな箱を持ったレストランの女性が言いました。</p><p>「これは何？」Alissaの友人、Rue Baeが尋ねます。</p><p>「これは、レストラン内のあなたの未来のテーブルを表す魔法の装置です…」。女性が答え、Baeを手招きしました。「本当は魔法ではないのですが、これはテーブルの準備が整い、あなた方が食事ができるようになったら教えてくれるのです」。</p><p><img src="http://robotlolita.me/files/2015/09/promises-02.png" alt=""><br>
<em>レストラン内にある未来のテーブルを表す魔法の装置</em></p><p>あなたの未来のテーブルのために代わりに並んでくれる”魔法の”装置のように、Promiseは将来使えるようになる<em>何か</em>を表すために存在します。プログラミング言語では、それは値です。</p><p><img src="http://robotlolita.me/files/2015/09/promises-03.png" alt=""><br>
<em>リンゴをまるごと入れると、スライスが出てくる。</em></p><p>同期処理の世界では、関数の計算は非常にシンプルに理解できます。何かを関数に入れると、関数は何かを返します。</p><p>この<em>入力すると出力される</em>モデルはとても分かりやすく、多くのプログラマにとって最も身近なものです。JavaScriptの全ての構文構造と組み込み関数は、あなたの書く関数がこのモデルに沿うことを仮定しています。</p><p>しかし、このモデルには1つ大きな問題があります。何かを関数に入れることで美味しい何かを得るためには、そこに座って関数が仕事を終えるのを待つ必要があるのです。しかし理想としては、座って待つよりも、自分の時間でできるだけたくさんのことをしたいと誰もが思うでしょう。</p><p>この問題を解決するべく、Promiseは、欲しい値を待つ代わりに、その値の代替となるものを即座に得る方法を提案します。そうすれば私たちは自分たちの生活を続け、後のどこかの時点で、欲しい値を取りに戻って来るということができます。</p><p><img src="http://robotlolita.me/files/2015/09/promises-04.png" alt=""><br>
<em>リンゴをまるごと入れると、美味しいリンゴのスライスを後で入手するためのチケットが出てくる。</em></p><p>では、Promiseとは何かを理解したところで、Promiseによって並行処理プログラムをより簡単に書く方法を見ていきます。その前に、1歩戻って、より根本的な問題、プログラムの実行順序について考えましょう。</p><p>JavaScriptのプログラマとして、プログラムが極めて独特な順序で実行されることに気づいた人もいるかもしれません。それはプログラムのソースコード内に書かれた命令の順序なのです。</p><p>このプログラムを実行すると、JavaScript仮想マシンは<code>circleArea</code>の計算を行い、それが済むと、<code>squareArea</code>の計算を行います。言い換えれば、プログラムはマシンに「これをやりなさい。そしてあれをやりなさい。それからあれをやりなさい。それから…」と説明しているのです。</p><p>結局、全てを順番に実行すると非常にハイコストなのです。もし、<code>circleArea</code>の実行に長い時間がかかるなら、それが終わるまで<code>squareArea</code>は全く実行されません。実際、この例でも、どのような順序にするかは問題ではありません。結果は常に同じなのです。プログラムに表現されている順序は非常に恣意的です。</p><p>私たちのコンピュータには、より多くのことを<em>より速く</em>行わせたいのです。そのためにまず、実行順序を完全に省きましょう。つまり、プログラムの中で、全ての式がきっかり同時に実行されるようにするのです。</p><p>このアイデアは先の例ではうまく動作します。しかし少しでも異なることを試すと破綻します。</p><p>順序を全く持たない場合、他の式から得られる値を利用するにはどうすればいいのでしょう。まあ、それは不可能です。なぜなら、値が必要な時間までに計算されるという保証はないからです。</p><p>別の方法を試しましょう。プログラム内の唯一の順序は式の構成要素の間にある従属性によって定義されます。それは原則として、式は、他のことが既に実行されていたとしても、その全ての要素の準備ができ次第、実行されるということです。</p><p><img src="http://robotlolita.me/files/2015/09/promises-05.png" alt=""><br>
<em>単純な例の従属性グラフ</em></p><p>実行の際にプログラムがどのような順序で実行されるべきかを宣言する代わりに、各計算が互いにどのように関わり合っているかだけを定義しました。そのデータをもとに、コンピュータは上記の従属性グラフを作成し、最も効率的なプログラム実行方法を自ら把握します。</p><p>
</p>
<p>前の章で説明した、順序を式の間の従属性で明快に定義する実行モデルは力強く効率的ですが、JavaScriptに適用するにはどうしたらよいのでしょうか。</p><p>このモデルを直接JavaScriptに適用することはできません。言語の意味が本質的に同期式であり、かつ先頭から順に動くものだからです。しかし、別のメカニズムを作って式の間の従属性を記述し、これらの従属性を解決して、独自のルールに沿ってプログラムを実行させることはできます。1つの方法は、この従属性の概念をPromiseの中核に導入することです。</p><p>そこでPromiseの意味を改めて考えると、2つの大きな要素で成り立つことになります。1つは「値の代理品を作り、その代理品の中に値を入れることができる」ということ。それから、「1つの式と1つの値の間に従属性を作り、その式の結果を出すための新しいPromiseを作る」ということです。</p><p><img src="http://robotlolita.me/files/2015/09/promises-06.png" alt=""><br>
<em>未来の値の代理品を作成</em><br>
<img src="http://robotlolita.me/files/2015/09/promises-07.png" alt=""><br>
<em>値と式の間の従属性を作成</em></p><p>ここにおけるPromiseは、まだ計算していない値を表します。この代理品は不明瞭で、値は見えず、値と直接対話することもできません。さらに、JavaScriptのPromiseでは代理品から値を抜き出すこともできません。一度JavaScriptのPromiseに何かを入れると、Promiseから取り出すことは<strong>できない</strong>のです<a name="tofootnote-1" href="#footnote-1"><sub>1</sub></a>。</p><p>このことはさほど有用ではありません。なぜなら何とかしてこれらの値を使う必要があるからです。そして代理品から値を抜き出せないとすると、それらを使うために別の方法を理解しなければなりません。結局、”抜き出しの問題”を解決する最も単純な方法は、プログラムにどう動作させたいのかを記述し、明示的に従属性を与え、実行のためにその従属性グラフを解決することです。</p><p>そのためには、実際の値を式の中に差し込み、この式の実行を確かに必要な時まで延期させる術が求められます。幸いJavaScriptには、第一級関数がまさにこの目的のために存在しています。</p><p>
</p>
<p><code>a + 1</code>の形の式がある場合、この式で、一度準備ができれば<code>a</code>が差し込まれ得る値になる、といった抽象化を行うことが可能です。こうして、次の式が、</p><p>下のようなラムダ抽象化になります<a name="tofootnote-2" href="#footnote-2"><sub>2</sub></a>。</p><p>第一級関数は非常に強力な概念です（それらが匿名のラムダ抽象化であってもなくても）。第一級関数を持つJavaScriptは、後で値を差し込めるようPromiseの値を使った式を第一級関数に変換することによって、これらの従属性をとても自然に書くことができます。</p><p>
</p>
<p>
</p>
<p>Promiseの概念の性質を見直したので、次はマシンの内部でどのように動くかを理解しましょう。これからPromiseを生成するのに使う演算を記述し、値を置き、式と値の間の従属性を書きます。サンプルのため、偶然、既存のPromise実行には使われない、次のような非常に説明的な演算を使います。</p><p>circlesとsquaresの例に戻りましょう。ここでは、より単純な式で始めます。Promiseを使い、同期の<code>squareArea</code>をプログラムの並行記述に変えます。<code>squareArea</code>は、<code>side</code>値にのみ依存しているので、よりシンプルなのです。</p><p>コードの同期処理バージョンと比較すると、非常にノイズが多いのですが、この新バージョンはJavaScriptの実行順序と結びついていません。代わりに、その実行に働く唯一の制約は、私たちが記述した従属性です。</p><p>
</p>
<p>もう1つ、未解決の問題があります。記述した従属性から得た順序に沿うように実際にコードを走らせるにはどうすればよいのでしょうか。JavaScriptの実行順序に従わないのであれば、何か別のものが望みどおりの実行順序を提供しなければなりません。</p><p>幸運にも、これまで使ってきた関数で簡単に定義できます。最初に値の表現方法と従属性を決めます。最も一般的なやり方は、このデータを<code>createPromise</code>から返される値に追加することです。</p><p>まず、<em>何か</em>のPromiseはその値を代理できるものですが、必ずしも常に値が確定しているわけではありません。値は、<code>fulfil</code>を呼び出して初めてPromiseに配置されます。最小限の表現は次の通りです。</p><p><code>Promise of something</code>は、値<code>null</code>を持った状態で生成されます。後の時点で、誰かがそのPromiseのために<code>fulfil</code>関数を呼び出すと、その時点からPromiseはfulfilされた値を持つでしょう。Promiseがfulfilされるのは一度だけなので、その値は残りのプログラムの間、Promiseが持ち続ける値になります。</p><p><code>value</code>（<code>null</code>は有効な値です）を見るだけでは、Promiseが既にfulfilされたかどうかの把握が不可能な場合があります。それを2度fulfilしてしまうリスクを避けるため、Promiseの値が入っているか否かの状態を追跡する必要があります。そのためには前の表現を若干変えます。</p><p>また、<code>depend</code>関数によって作られた従属性も制御する必要があります。従属性が最終的に満たされることで、Promise内の値が満たされ、評価ができるようになりあます。1つのPromiseはその値に依存する多くの関数を持つことができるので、このための最小限の表現は次のようになります。</p><p>Promiseのための表現を決定したので、新たなPromiseを作る関数の定義から始めましょう。</p><p>シンプルな表現に決めたので、その表現のための新規オブジェクトの構築はかなり単純です。もう少し複雑な手順、Promiseへの従属性付与に進みましょう。</p><p>この問題の解決法の1つは、Promiseの<code>dependencies</code>フィールドの中に作られた全ての従属性を引き出し、Promiseを、必要に応じて計算を行うインタープリタに送り込むやり方です。これを実行すると、インタープリタが開始しない限り従属は動作しません。今回はこの方法によるPromiseの実装は行いません。なぜなら多くの人がとるJavaScriptプログラムの一般的な記述方法に合わないからです<a name="tofootnote-3" href="#footnote-3"><sub>3</sub></a>。</p><p>もう1つの解決法は、「Promiseが<code>pending</code>状態にある間、本当に必要なのはPromiseの従属性を追跡することだけだ」という認識があれば分かります。なぜなら、Promiseがいったん完了すれば、関数を即座に実行できるからです。</p><p><code>depend</code>関数は、値が出るまで待機してから、従属の表現の実行を扱います。しかし、従属性を付与するのが早過ぎると、その関数はPromiseオブジェクトの配列で終了してしまい、仕事は終わらないということになります。実行の2番目の要素では、値を取得した時点で従属性を実行させる必要があります。幸運にも、<code>fulfil</code>関数が使えます。</p><p>Promiseに入れたい値と共に<code>fulfil</code>関数を呼ぶことによって、<code>pending</code>状態にあるPromiseをfulfilできます。これはPromiseの値が使えるようになる前に作られた全ての従属性を呼び出し、その他の実行を手配する好機です。</p><p>
</p>
<p>
</p>
<p>全ての計算がいつも有効な値を生成するとは限りません。<code>a / b</code>や、<code>a[0]</code>といったいくつかの関数は部分的関数であり、従って<code>a</code>や<code>b</code>の値が、それぞれある範囲にあるときのみ定義可能になります。部分的な関数を含むプログラムを書いて、関数で扱えない状況に当たった時は、プログラムの実行を続けられません。言い換えれば、プログラム全体がクラッシュするということです。</p><p>プログラムに部分的な関数を組み込むより良い方法は、全域関数にすることです。つまり、先に定義されていなかった関数の部分を定義する方法です。一般的にこれは、関数が”成功”の形を扱える状況と、”失敗”の形を扱えない場合を考慮するということを意味します。この施策だけで、たとえ正しい値を生成できない計算に直面しても実行し続けるプログラムにすることができます。</p><p><img src="http://robotlolita.me/files/2015/09/promises-08.png" alt=""><br>
部分関数の分岐</p><p>失敗の可能性のある部分それぞれで分岐させるのは合理的な処理方法ですが、必ずしも実用的ではありません。例えば、失敗し得る3つの計算を合成した場合、そのシンプルな合成に対して、少なくとも6種類の分岐を定義しなければならないのです。</p><p><img src="http://robotlolita.me/files/2015/09/promises-09.png" alt=""><br>
各部分関数において分岐</p><p>理想としては、各部分式でエラーに対応するよりも、合成全体に対してただ<code>y / (x / (a / b))</code>とだけ書いて、可能性のあるエラーを一度で処理したいものです。プログラミング言語はそのために様々な方法を備えています。C言語やGoのように、完全にエラーを無視、あるいは少なくとも可能な限り触れるのを延期する言語もあれば、Erlangのように、プログラムをクラッシュさせつつ、復旧させるツールを供給する言語もあります。しかし最もよく見られるアプローチは、”エラー処理ハンドラ”を割り当て、失敗が起こりそうなコードを中断する方法です。JavaScriptは<code>try/catch</code>文を通じてそのアプローチを可能にします。下記が一例です。</p><p><img src="http://robotlolita.me/files/2015/09/promises-10.png" alt=""><br>
手際良く失敗を処理するアプローチの例</p><p>
</p>
<p>ここまでのPromiseの形は、失敗を認めません。そのため、Promiseで起こる全ての計算は常に有効な値の結果を生成しなければなりません。このことは、Promiseの中で<code>a / b</code>などの計算を実行する時に問題になります。なぜなら、<code>2 / 0</code>の場合のように、<code>b</code>が0なら、その計算は正しい値を出せないからです。</p><p><img src="http://robotlolita.me/files/2015/09/promises-11.png" alt=""><br>
新たなPromise構文の可能性</p><p>失敗の表現を極めて簡単に考慮するため、Promiseを修正します。現状、ここでのPromiseは<code>pending</code>状態から始まっており、可能なのはfulfilだけです。新しい状態、<code>rejected</code>を追加すれば、Promise内に部分関数を作ることができます。成功する計算はペンディングの状態で始まり、最終的に<code>fulfilled</code>になります。失敗する計算はペンディングの状態で始まり、最終的に<code>rejected</code>になります。</p><p>今や失敗の可能性があり、Promiseの値に依存する計算もそのことに気をつけなければなりません。とり急ぎ、<code>depend</code>は、Promiseがfulfilledになった時に実行される式と、Promiseがrejectedになった時に実行される式を持つことになります。</p><p>よって、新しいPromiseの表現は次のようになります。</p><p>Promiseは適切な値あるいはエラーを含み、それがfulfilledかrejectedかが確定するまで<code>null</code>を含みます。この処理のため、従属性は適切な値とエラーの値に対して何を行うか知っていることも必要です。そこで従属性の配列を少しだけ変えます。</p><p>表現の変更の他、<code>depend</code>関数も変えます。次の通りです。</p><p>最後に、エラーをPromiseに置く手段が要ります。<code>reject</code>関数を使いましょう。</p><p>また、<code>dependencies</code>フィールドを変更したため、<code>fulfil</code>関数をレビューしなければなりません。</p><p>これらの新規追加を行ったところで、Promise上に失敗し得る計算を配置できるようになりました。</p><p>
</p>
<p>最後のコード例は決して<code>zPromise</code>を実行しません。<code>c</code>が0なので、計算<code>div(x, c)</code>は失敗するからです。これはまさに予測していたことですが、今はPromiseの中に計算を定義するたびに失敗の分岐を渡す必要があります。理想としては、同期処理の<code>try/catch</code>で行ったのと同様に、必要な箇所にのみ失敗の分岐を定義したいところです。</p><p>Promiseにとってこの機能性のサポートはたやすいのです。制御フローにおいてよく起こることですが、抽象化不可の場合のたびに、成功と失敗の分岐を定義するだけです。例えば、JavaScriptでは、<code>if</code>文や<code>for</code>文を抽象化することはできません。それらは第二級制御フローメカニズムであり、編集、送り出し、変数への格納ができないためです。このPromiseは第一級オブジェクトなので、失敗と成功の具体的な表現を持っています。それらは作成された時点だけでなく、いつでも必要なときに検査、対話ができます。</p><p><img src="http://robotlolita.me/files/2015/09/promises-12.png" alt=""></p><p><code>try/catch</code>と似たものを手に入れるため、成功と失敗の表現を使って2つのことを行わねばなりません。</p><p>幸運にも、<code>depend</code>関数がこの仕事のほとんどを既に行っています。<code>depend</code>はその表現がPromise全体を返し、値だけでなく、Promiseが存在する状態の伝播も要求するからです。<code>successful</code>分岐だけを定義してPromiseが失敗した場合、値だけでなく失敗の状態も伝播させたいので、これは重要です。</p><p>これらのメカニズムが既に適切だとして、シンプルな失敗の伝播のサポート、エラー処理と、失敗の時の短絡演算を行うには、2つの演算子の追加が必須です。<code>chain</code>、これは、失敗の際の短絡演算子ではなく、Promiseの成功した値に関して従属性を生成します。そして<code>recover</code>は、Promiseの失敗した値に関して従属性を生成し、そのエラーから復旧させます。</p><p>こうして、2つの関数を使って、先述の部分サンプルを単純化できます。</p><p>
</p>
<p>Promiseの演算子の配列が一連の従属性を要求する一方、Promiseの並行的な結合はただ、Promiseが相互に従属性を持たないことだけを求めます。</p><p>Circleの例における計算は、本来的に並行でした。<code>radius</code>式と<code>Math.PI</code>式は相互に依存しておらず、別々に計算されますが、<code>circleArea</code>は両方に依存します。コードで表したのが下記です。</p><p>同じものをPromiseで表すと、次のようになります。</p><p>ここで小さな問題があります。<code>circleAreaAbstraction</code>は<strong>2つ</strong>の値に依存しますが、<code>depend</code>にできるのは1つの値に依存する式の従属性を定義することだけなのです。</p><p>この制限の中で作業を進める方法はいくつかありますが、シンプルなものから始めます。もし<code>depend</code>が1つの式に対して1つの値を提供できるなら、クロージャの中で値を取得し、Promiseから1つずつ値を引き出すことができるはずです。これはいくつか暗示的な順序を生成しますが、並行処理への影響はそれほど大きくありません。</p><p>これによって、<code>circleAreaPromise</code>を下記のように定義できます。</p><p>3つの値に依存する式に<code>wait3</code>を、4つの値に依存する式に<code>wait4</code>などを定義できました。しかし<code>wait*</code>は暗示的な順序を生成し（Promiseは特定の順序で実行されます）、差し込もうとしている値の数を事前に知っていることが条件です。そのため、例えばPromiseの配列全体を待ちたい場合には使えません（ただ、<code>wait2</code>と<code>Array.prototype.reduce</code>をそのために結合することはできます）。</p><p>別の解決法は、Promiseの配列を受け取り、それぞれを可能な限り早く実行し、元のPromiseが持っている値の配列のためにPromiseを返すことです。このアプローチは、シンプルな有限状態機械（FSM）を実行する必要があるために少々複雑ですが、暗示的な順序はありません（JavaScript独自の実行を除きます）。</p><p><code>waitAll</code>を<code>circleAreaAbstraction</code>のために使う場合、次のようになります。</p><p>
</p>
<p>Promiseの結合の仕方を見てきましたが、ここまでは確定的に結合するしかありませんでした。例えばもし、2つの計算から速いほうを選びたい場合には役立ちません。2つのサーバ上で何かを探し、どちらか答えを返した方をとってもよいかもしれませんが、ここではとにかく最速の方法を使います。</p><p>この作業のサポートとして、いくつか非確定性を導入します。特に2つのPromiseがある場合、最速で解決する方のpromiseの値と状態を取る演算が必要です。演算の背景にあるアイデアはシンプルです。2つのPromiseを並行に走らせ、最初の解決を待ち、それを結果としてのPromiseに伝播するのです。状態を維持するため、実装はいくらか複雑になります。</p><p>これによって、それらを非確定的に選んで演算の結合を開始できます。先のサンプルで見てみましょう。</p><p>2つ以上のPromiseからの選択が可能です。なぜなら<code>race(a, b)</code>は、基本的に速く解決する方に従って<code>a</code>または<code>b</code>に<em>なる</em>からです。<code>race(c, race(a, b))</code>を持ち、<code>b</code>が先に解決した場合、<code>race(c, b)</code>と同様になるのです。もちろん、<code>race(a, race(b, race(c, …)))</code>と入力するのは最善ではないので、シンプルなコンビネータを書きましょう。</p><p>そして実際に使ってみます。</p><p>2つのPromiseから非確定的に選ぶ別の方法は、1番目の<em>fulfilが成功する</em>のを待つことです。例えば、ミラーのリストから正しいダウンロードリンクを見つける時、初めの失敗だけのために失敗するよりは、一番に得られるミラーからダウンロードし、全てが失敗の場合に失敗としたいはずです。これを取得するため、<code>attempt</code>演算子を書きましょう。</p><p>用法は<code>race</code>と同じなので、<code>attempt(searchA(), searchB())</code>は、ただ最初のPromiseではなく、成功した最初のPromiseを返します。しかし、<code>race</code>とは異なり、<code>attempt</code>はエラーを集めるので、自然には集約できません。いくつかのPromiseをattemptしたい場合は更なる記述が必要です。。</p><p>
</p>
<p><a href="http://www.ecma-international.org/ecma-262/6.0/" rel="nofollow" title="" class="ext-link">ECMAScript 2015</a>はPromiseの概念をJavaScript用に定義しますが、これまで非常にシンプルな、しかし略式のPromiseの実装を見てきました。理由はECMAScript標準のPromiseは複雑過ぎ、基礎から概念を説明するのが難しいだろうと考えたからです。今はPromiseが何であるか、各アスペクトがどのように実装されるかを知っていますから、標準のPromiseに進むのは容易でしょう。</p><p>
</p>
<p>ECMAScript言語の新バージョンでは<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor" rel="nofollow" title="" class="ext-link">標準のPromise</a>をJavaScriptで定義します。この基準はいくつかの方法で導入してきた最小限のPromiseの実装とは異なり、より複雑ですが、より実用的で簡単に使えます。以下のテーブルは各実装の相違点をリストアップしています。</p><p>標準Promiseの主なメソッドは、Promiseオブジェクトを導入する<code>new Promise(…)</code>、それを変形させる<code>.then(…)</code>です。その動作には、ここまでで書いた演算子と比較していくつかの違いがあります。</p><p><code>new Promise(f)</code>は新規Promiseオブジェクトを導入し、特定の値で成功か失敗をする計算を行います。成功か失敗の動作は、想定どおり、関数<code>f</code>に渡された2つの関数引数によって取得されます。</p><p><code>promise.then(f, g)</code>は値のための穴を持つ式とPromise内の値の間に従属性を作る演算で、<code>depend</code>演算に似ています。<code>f</code>と<code>g</code>共に、オプションの引数で、Promiseを供給されない場合、その状態で値を伝播します。</p><p><code>depend</code>とは異なり、<code>.then</code>は複雑な演算で、Promiseの利用を簡単にしようとします。<code>.then</code>に渡された関数実引数はPromiseか、一般の値を返します。その場合、これらは自動的にPromiseに置かれます。</p><p>これらは、先の記述と比べ、Promiseを使ったコードを簡潔に読みやすくします。</p><p>複数の値に並行に従属させるのは、<code>Promise.all</code>演算です。先に見た<code>waitAll</code>演算に似ています。</p><p>エラーと成功の伝播は<code>.itself</code>演算そのものが扱います。そして<code>.catch</code>演算は、成功の分岐を定義することなく<code>.then</code>を呼び出す簡潔な方法です。</p><p>
</p>
<p><code>.then</code>メソッドはいくつかの点で先に書いた<code>depend</code>関数とは違っています。<code>.then</code>は結果値と複数の計算の従属関係を定義する1つのメソッドですが、同時にメソッドの使用を大多数のケースで容易にしようとします。このことが<code>.then</code>を複雑なメソッドにしていますが<a name="tofootnote-5" href="#footnote-5"><sub>5</sub></a>、先に見たからくりとこの新しいメソッドを関連付ければ分かりやすいでしょう。</p><p>
</p>
<p>先に作った<code>depend</code>関数はPromiseの領域で作動しました。従属の計算がPromiseそのものを返すために、Promiseを返すように作られています。<code>.then</code>にはこの条件がありません。もし従属の計算が<code>42</code>といったただの値を返した場合、<code>.then</code>はそれを、値を含むPromiseに変換します。本来、<code>.then</code>は、必要に応じてただの値をPromiseの領域に引き上げるものです。</p><p>単純化したタイプの<code>depend</code>関数と比較します。</p><p>単純化したタイプの<code>.then</code>メソッドです。</p><p>唯一<code>depend</code>関数でできることは、何かのPromiseを返すこと（それから、同じ何かを結果のPromiseに持たせること）ですが、<code>.then</code>関数は簡便性のため、ただの値を(promiseでラップすることなく)返すことを許容しています。</p><p>
</p>
<p>ECMAScript 2015 Promiseが一般的なユースケースでの用法を簡素化しようとしているもう1つの方法は、Promiseのネストの禁止です。<code>.then</code>メソッドを持つすべてを同化することによるもので、同化させたくない場合は問題になり得ます<a name="tofootnote-6" href="#footnote-6"><sub>6</sub></a>。しかし、そうでなければ戻り値のタイプのマッチングを考えずに済むので便利です。</p><p>この特徴ゆえ、<code>.then</code>メソッドに、非従属タイプに認識可能なタイプを与えることは不可能です。しかし、それは大まかに説明すると以下のような形になります。</p><p>は、下記と等価です。</p><p>これは、<code>Promise.resolve</code>でも強制されますが、<code>Promise.reject</code>では実行されません。</p><p>
</p>
<p><code>.then</code>メソッドを通して付加した従属の計算を評価する間、同期的に例外が起こった場合、その例外はrejectされたPromiseとして見つけられ、具象化されます。これが本質的に意味するのは、「<code>.then</code>メソッドを通してPromiseの値に付加した全ての計算は、暗示的に<code>try/catch</code>ブロックにラップされたかのように扱わねばならない」ということです。例えば下記のように。</p><p>上記は、次と等価です。</p><p>Promiseのネイティブの実装はこれらを追跡し、処理がされていないものを報告します。Promiseにおいて”取得されたエラー”の構成に関する仕様はないので、エラーリポートのされかたは開発ツールごとに異なります。例えば、Chromeの開発ツールは、rejectされたPromiseのインスタンスの全てをコンソールに出力するため、誤検知を表示することがあります。</p><p>
</p>
<p>先のPromiseの実装は従属する計算を同期的に呼び出しましたが、標準のECMAScript Promiseは非同期的にそれを行います。適切な手段、<code>.then</code>メソッドを使わなければ、Promiseの値への依存は難しいということです。</p><p>従って、次のコードは動きません。</p><p>これによって従属計算は常に空のスタックで確実に実行されますが、そういった保証はECMAScript 2015では重視されていません。全ての実装が適切な末尾再帰をサポートすることが条件になっているからです<a name="tofootnote-7" href="#footnote-7"><sub>7</sub></a>。</p><p>
</p>
<p>Promiseは並行処理の基本形として良く機能しますが、継続渡しスタイルほど一般的ではなく、全てのケースにおいて最善の基本形でもありません。Promiseは最終的には計算される値のプレースホルダなので、これらの値そのものを使うコンテキストでのみ意味をなします。</p><p><img src="http://robotlolita.me/files/2015/09/promises-13.png" alt=""><br>
promiseは値のコンテキストにおいてのみ意味をなす</p><p>Promiseをそれ以外の何にでも使おうとすると、メンテナンスが困難で、読みにくく、拡張もししづらい、非常に複雑なコードベースになってしまいます。以下はPromiseを使うべきでない例の一部です。</p><p>
</p>
<p>Promiseは結果の値を扱う優れた方法です。非同期で計算される値に依存するプロセスの合成と同期ができるようになります。ECMAScript 2015標準のPromiseには、プロセスをクラッシュさせるエラーを自動的に具象化するなど、特有の課題がありますが、前述の問題を十分適切に扱えるツールです。実際に使うかどうかは別として、それらの特徴と動作を理解するのが大切です。今後は全てのECMAScriptプロジェクトにさらに普及していくと考えられるからです。</p><p>
</p>
<p><a href="http://www.ecma-international.org/ecma-262/6.0/" rel="nofollow" title="" class="ext-link">ECMAScript® 2015 言語仕様</a><br>
<em>Allen Wirfs</em>がJavaScriptのPromiseの標準を定義。</p><p><a href="http://www.ps.uni-saarland.de/Papers/abstracts/alice-looking-glass.html" rel="nofollow" title="" class="ext-link">鏡の国のAlice</a><br>
<em>Andreas Rossberg、Didier Le Botlan、Guido Tack、Thorsten Brunklaus、Gert Smolka</em>がプログラミング言語Aliceを紹介。FutureとPromiseで並行処理をサポート。</p><p><a href="https://www.haskell.org/definition/haskell98-report.pdf" rel="nofollow" title="" class="ext-link">Haskell 98 言語とライブラリ</a><br>
<em>Simon Peyton Jones</em>が、プログラミング言語Haskellの意味論を分かりやすく説明。</p><p><a href="http://www.usingcsp.com/cspbook.pdf" rel="nofollow" title="" class="ext-link">Communicating Sequential Processes</a><br>
<em>C. A. R. Hoare</em>が、確定的・非確定的の選択などのプロセスの並行コンビネーションを説明。</p><p><a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf" rel="nofollow" title="" class="ext-link">関数型言語のためのモナド</a><br>
<em>Philip Wadler</em>が、関数型言語においてモナドがどのようにエラーを扱うかなどを説明。Promiseのシーケンス処理とエラーの扱いはモナドの形式に非常に似ている。ただし、ECMAScript 2015標準ではPromiseはモナドインターフェースを実装しない。</p><p>
</p>
<p><a href="https://github.com/robotlolita/robotlolita.github.io/tree/master/examples/promises" rel="nofollow" title="" class="ext-link">ブログポストのソースコード</a><br>
このブログポストのコメント付きソースコード全て。最低限ECMAScript 2015 の仕様に準拠するPromiseの実装も含む。</p><p><a href="http://robotlolita.me/2013/06/28/promises-considered-harmful.html" rel="nofollow" title="" class="ext-link">有害なPromises/A+</a><br>
<em>Quildreen Motta</em>がPromises/A+とECMAScript 2015 Promise標準が持つ問題を、複雑さ、エラーの扱い、パフォーマンスの面から議論する。</p><p><a href="https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details" rel="nofollow" title="" class="ext-link">Frisby教授のこれだけで十分な関数型言語ガイド</a><br>
<em>Brian Lonsdorf</em>による、JavaScript関数型言語の導入本。</p><p><a href="https://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/" rel="nofollow" title="" class="ext-link">コールバックは命令型、Promiseは関数型：見逃されがちなノードの大きなチャンス</a><br>
<em>James Coglan</em>が、プログラムの実行順序を記述するための継続渡しスタイルとPromiseを比較。</p><p><a href="http://www.infoq.com/presentations/Simple-Made-Easy" rel="nofollow" title="" class="ext-link">シンプルは簡単だ</a><br>
直接Promiseに関係ないが、<em>Rich Hickey</em>が語るデザインのコンテキストにおける「シンプル」「簡単」は、常にプログラミングにもあてはまる。</p><p><a href="https://blog.mozilla.org/dherman/2011/01/30/proper-tail-calls-in-harmony/" rel="nofollow" title="" class="ext-link">適切な末尾再帰のハーモニー</a><br>
<em>Dave Herman</em>によるECMAScriptでProper Tail Callsを使うメリットの説明。</p><p><a href="http://queue.acm.org/detail.cfm?id=2169076" rel="nofollow" title="" class="ext-link">あなたのマウスはデータベース</a><br>
<em>Erik Meijer</em>が、Observableの概念を用いてRxのEventベース、非同期の計算のコーディネートと管理について議論する。</p><p><a href="https://github.com/substack/stream-handbook" rel="nofollow" title="" class="ext-link">ストリームハンドブック</a><br>
<em>James Halliday</em>による、Streamを用いてNode.jsプログラムを書く基本。</p><p><a href="http://matt.might.net/articles/by-example-continuation-passing-style/" rel="nofollow" title="" class="ext-link">ケーススタディ：JavaScriptの継続渡しスタイル</a><br>
<em>Matt Might</em>が、継続渡しスタイルを使い、JavaScriptのスレッドが中断されない計算を扱う方法を説明。</p><p><a href="http://www.haskellforall.com/2012/12/the-continuation-monad.html" rel="nofollow" title="" class="ext-link">継続モナド</a><br>
<em>Gabriel Gonzalez</em>が、モナドとしての継続の概念をHaskell プログラミング言語のコンテキストで議論する。</p><p><a href="https://www.cl.cam.ac.uk/teaching/1213/R204/asynclecture.pdf" rel="nofollow" title="" class="ext-link">停止とプレイ：非同期のC#</a><br>
<em>Claudio Russo</em>が、Task comonadを使ったC#の非同期計算、その解決法と他のメソッドとの関わりを説明。</p><p>
</p>
<p><a href="https://www.npmjs.com/package/es6-promise" rel="nofollow" title="" class="ext-link">ES6-PROMISE</a><br>
ECMAScript 2015標準のPromise、ES2015を実装していないプラットフォームのためのポリフィル。</p><p><a href="https://www.npmjs.com/package/bluebird" rel="nofollow" title="" class="ext-link">BLUEBIRD</a></p><p><a name="footnote-1" href="#tofootnote-1">1</a>: Promises/A、Promises/A+とその他の一般的なPromise式では、Promiseの値を抜き出すことはできません。<br>
Rhinoや Nashornなど一部のJavaScript環境では、値の抜き出しをサポートするPromiseの実装へのアクセスを持ち得る可能性はあります。JavaのFutureが一例です。<br>
Promiseから未計算の値を抜き出すには、値が計算されるまでスレッドを中断しなければなりません。ほとんどのJS環境はシングルスレッドのため、それは機能しません。</p><p><a name="footnote-2" href="#tofootnote-2">2</a>: 「ラムダ抽象化」はある式の中で抽象化を行う匿名の関数にラムダ計算が与える名称です。JavaScriptの匿名関数はLCのラムダ抽象化と同等ですが、JavaScriptではさらに自らの関数に名前をつけることもできます。</p><p><a name="footnote-3" href="#tofootnote-3">3</a>: “計算の定義”と”計算の実行”の分離には、Heskellプログラミング言語が役立ちます。Haskellプログラムは、<code>IO</code>データ構造体まで評価する巨大な式に過ぎません。この構造体はいくらかこの記事で定義した<code>Promise</code>構造体に似ています。そこではプログラム内の計算間の従属性が定義されるだけです。<br>
Haskellではプログラムはタイプ<code>IO</code>の値を必ず返し、分離されたインタープリタに渡されます。インタープリタは<code>IO</code>計算を行い、それが定義した従属性を尊重することしか知りません。JSのために似たものを定義することは可能かもしれません。それを行うと、全てのJSプログラムは結果としてPromiseに至るただ1つの式になるでしょう。そのPromiseは、Promiseとその従属性の実行の仕方を認識している別の要素に渡されるはずです。<br>
この形のPromsieの実行については、<a href="https://github.com/robotlolita/robotlolita.github.io/tree/master/examples/promises/pure/" rel="nofollow" title="" class="ext-link">Pure Promises</a>のサンプルディレクトリを見てください。</p><p><a name="footnote-4" href="#tofootnote-4">4</a>: モナドは、シーケンス処理に頻繁に使われるインターフェースです。次のような演算の構造体として書かれます。</p><p>この形では、JavaScriptの「カンマ演算子」（<code>print(1); print(2)</code>が一例）のようなものを、モナド<code>chain</code>演算子<code>print(1).chain(_ =&gt; print(2))</code>の使用として考えることが可能です。</p><p><a name="footnote-5" href="#tofootnote-5">5</a>: これはRich Hickeyが言うところの”複雑”と”容易”です。<code>.then</code>は確かに簡単なメソッドです。シンプルな概念で、一般的なユースケースに使えます。要は、<code>.then</code>は多くの作業を行い、そこには大量の重複があるということです。<br>
一方で、シンプルなAPIはこれらの分離した概念を、<code>.then</code>メソッドと一緒に使える別の関数に移動させます。</p><p><a name="footnote-6" href="#tofootnote-6">6</a>: <code>.then</code>メソッドはPromiseに見える全てのものの状態と値をどうかします。歴史上、これはインターフェースチェックを通して行われます。オブジェクトが‘“.then<code>メソッドを供給したかどうかをチェックするだけで、それには、内包する</code>.then<code>メソッドがPromiseの</code>.then“`メソッドに準拠していない全てのオブジェクトが含まれます。<br>
標準のPromiseが、既存のPromise実装との下位互換に制限されていなければ、より信頼のおけるテストができるでしょう。その際はインターフェースのSymbolや、それに類するものを使います。</p><p><a name="footnote-7" href="#tofootnote-7">7</a>: Proper Tail Callsは末尾の呼び出しが一定のスタックで起こることを保証します。プログラムや計算が末尾再帰で占められており、スタックが膨らまない限り保証されるので、そのようなコードではスタックオーバーフローエラーが起こり得ません。ところで、Proper Tail Callsにより、言語は通常の関数呼び出しの負荷を処理する必要がないため、上のようなコードの速度は上がります。</p>
