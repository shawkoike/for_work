<p><a href="https://github.com/mhinz/vim-galore" rel="nofollow" title="" class="ext-link">Everything you need to know about Vim</a> by <a href="https://github.com/mhinz" rel="nofollow" title="" class="ext-link">Marco Hinz</a></p><p>(訳注: 2016/2/26、記事タイトルを変更いたしました。)</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/02/vim-galore.png"><img src="http://postd.cc/wp/wp-content/uploads/2016/02/vim-galore.png" alt="vim-galore" width="1500" height="278" class="alignnone size-full wp-image-6066"></a></p><p>特定のトピックについての記述をご希望ですか？ <a href="https://github.com/mhinz/vim-galore/issues" rel="nofollow" title="" class="ext-link">Issue</a>を立てるか、<a href="https://twitter.com/_mhinz_" rel="nofollow" title="" class="ext-link">Twitter</a>で私までお知らせください！ありがとう！</p><p><a href="http://www.vim.org/" rel="nofollow" title="" class="ext-link">Vim</a>は1991年に<a href="https://en.wikipedia.org/wiki/Bram_Moolenaar" rel="nofollow" title="" class="ext-link">ブラム・ムーリナー</a>がリリースしたテキストエディタで、その祖先は<a href="https://ja.wikipedia.org/wiki/QED_(%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF)" rel="nofollow" title="" class="ext-link">QED</a>までさかのぼります。</p><p><a href="http://www.vim.org/index.php" rel="nofollow" title="" class="ext-link">vim.org</a>で、オンラインでホストされています。</p><p>Vimを入手するには、お好みのパッケージマネージャを利用するか、vim.orgの<a href="http://www.vim.org/download.php" rel="nofollow" title="" class="ext-link">ダウンロードページ</a>を訪問してください。</p><p>ディスカッションやユーザの質問は<a href="https://groups.google.com/forum/#!forum/vim_use" rel="nofollow" title="" class="ext-link">vim_use</a>というメーリングリスト、または<code>#vim</code>チャネルのIRC（<a href="https://freenode.net/" rel="nofollow" title="" class="ext-link">Freenode</a>）で行うのが一番いいでしょう。</p><p><a href="https://github.com/vim/vim" rel="nofollow" title="" class="ext-link">Github</a>上で開発されていて、ディスカッションは<a href="https://groups.google.com/forum/#!forum/vim_dev" rel="nofollow" title="" class="ext-link">vim_dev</a>メーリングリストで行われています。</p><p><a href="http://www.viemu.com/a-why-vi-vim.html" rel="nofollow" title="" class="ext-link">なぜ頭のおかしい人はviを使うのか</a>を読めば、Vimに対する一般的な勘違いについてお分かりいただけると思います。</p><p>
</p>
<p>Vimはモーダルエディタの原則を順守しています。つまり、複数のモードが提供されていて、モードによってキーの意味が変化します。<em>ノーマルモード</em>でファイル操作を行い、<em>入力モード</em>でテキスト入力し、<em>ビジュアルモード</em>で行を選択し、<em>コマンドラインモード</em>でコマンドにアクセスする、といった具合です。最初は複雑に感じるかもしれませんが、これには非常に大きなメリットがあり、一度に何個ものキーを押さえて指を痛める必要がありません。ほとんどの場合1つずつ押せばいいのです。一般的なタスクになるほど、少ないキーで対応できます。</p><p>他にモーダルエディタで便利なのは、似たようなコンセプトですが、オペレータとモーションです。<em>オペレータ</em>は特定のアクションを起動します。例えば変更、削除、またはテキストの選択などです。その後<em>モーション</em>を使って、アクティブにしたいテキストの領域を特定します。括弧に囲まれた部分を変更するには<code>ci(</code>（<em>チェンジ・インナー・パーレン</em>と読む）を使います。テキストの全パラグラフを削除するには<code>dap</code>（<em>デリート・アラウンド・パラグラフ</em>と読む）を使います。</p><p>ベテランのVimユーザを見れば、まるでピアニストがピアノを自在に弾くかのように、Vim言語を操っているのに気付くでしょう。</p><p>複雑な処理でも数個のキーの組み合わせだけで実行できます。これらの動作はすでに<a href="https://en.wikipedia.org/wiki/Muscle_memory" rel="nofollow" title="" class="ext-link">マッスルメモリ</a>化しているため、考える必要もありません。<a href="https://en.wikipedia.org/wiki/Cognitive_load" rel="nofollow" title="" class="ext-link">認知的負荷</a>を減らし、実際のタスクに集中できます。</p><p>
</p>
<p>Vimには対話式のチュートリアルが付属していて、知っておくべき基本的なことについてはほぼ全て学ぶことができます。これはシェルから起動します。</p><p>退屈に思えても、先延ばしにせずに演習をしてみてください。IDEはほとんど全てがモーダルでないはずなので、最初はモードを切り替えながら作業するのを面倒に感じるかもしれません。しかしVimを使うにつれ、どんどん<a href="https://en.wikipedia.org/wiki/Muscle_memory" rel="nofollow" title="" class="ext-link">マッスルメモリ</a>化していきます。</p><p>Vimは、<a href="https://ja.wikipedia.org/wiki/Vi" rel="nofollow" title="" class="ext-link">vi</a>のクローンである<a href="https://en.wikipedia.org/wiki/Stevie_(text_editor)" rel="nofollow" title="" class="ext-link">Stevie</a>をベースにしていて、2つの処理モード、「互換」と「非互換」をサポートしています。互換モードでVimを使うと、全てのオプションがviのデフォルトの状態で使われることになり、Vimのデフォルトで使うのとは異なります。vimrcをまだ作成していない場合や、Vimを<code>vim -N</code>で起動した場合は、互換モードと見なされます。決して互換モードでVimを使わないようにしましょう。</p><p>次のステップは以下の通りです。</p><p>最後のアドバイスとしては、様々な過剰な<a href="https://github.com/mhinz/vim-galore/blob/master/README.md#managing-plugins" rel="nofollow" title="" class="ext-link">プラグイン</a>を追加する前にVimの適切な使い方をまず学ぶことです。Vimがネイティブにサポートしている機能を追加するだけだった、ということにならないように。</p><p>
</p>
<p>ユーザのvimrcは<code>~/.vimrc</code>に設定するか、よりきちんと分けるためには、<code>~/.vim/vimrc</code>に設定します。後者のほうがバージョン管理をしながら全コンフィギュレーションを設定することが簡単ですし、例えばGithubにアップロードするのも楽です。ネット上のあちこちで「ミニマルなvimrc」を見つけられるはずです。私のバージョンはそこまでミニマルではありませんが、かなり良い一揃いの設定を提供しているので、最初に使うのには便利だと思います。</p><p>最終的には全ての設定を読んで、自分自身にとってベストなものを決定しなくてはなりません。</p><p>ここに<a href="https://github.com/mhinz/vim-galore/blob/master/content/minimal-vimrc.vim" rel="nofollow" title="" class="ext-link">ミニマルvimrc</a>があります。</p><p>もし興味があれば、<a href="https://github.com/mhinz/dotfiles/blob/master/vim/vimrc" rel="nofollow" title="" class="ext-link">私のvimrc</a>はここにあります。</p><p><strong>ヒント</strong>：多くのプラグインの著者はいくつかのプラグインを保守していますし、よくvimrcもGithub上で公開しています（”vim-config”や”dotfiles”と呼ばれるレポジトリによくあります）。気に入ったプラグインを見つけたら、管理者のGithubページに行き、レポジトリを探してみてください。</p><p>
</p>
<p><code>:version</code>を見れば、現在実行されているVimのバイナリがどのようにコンパイルされたか情報を知ることができます。</p><p>最初の行ではそのバイナリがいつコンパイルされたか、そして例えば7.4など、バージョンを知ることができます。次の数行のうちの1行は<code>Included patches: 1-1051</code>、つまりパッチレベルを宣言しています。すなわちこの場合のVimのバージョンは7.4.1051です。</p><p>他の行には<code>Tiny version without GUI</code>や、<code>Huge version with GUI</code>などと宣言されています。ここから明確になる情報は、あなたのVimがGUIをサポートしているかどうかです。つまり、シェルから<code>gvim</code>で起動しているのか、ターミナルエミュレータ内でVimから<code>:gui</code>を実行しているのかということです。他の重要な情報は、<code>Tiny</code>と<code>Huge</code>です。Vimは<code>tiny</code>、<code>small</code>、<code>normal</code>、<code>big</code>そして<code>huge</code>という機能セットを区別していて、それぞれに違う機能のサブセットを有効にするのです。</p><p><code>:version</code>のアウトプットの大半は機能リストそのものに費されます。<code>+clipboard</code>は、クリップボード機能がコンパイル時に組み込まれているということを、<code>-clipboard</code>ではコンパイル時に組み込まれていないということを意味します。</p><p>Vimのいくつかの機能を正しく機能させるためにはコンパイル時に組み込む必要があります。例えば、<code>:prof</code>を機能させるためには、<code>+profile</code>機能を有効にするhuge版の機能セットのVimが必要になります。</p><p>もしそうなっておらず、あなたがパッケージマネージャでVimをインストールした場合は、<code>vim-x</code>、<code>vim-x11</code>、<code>vim-gtk</code>、<code>vim-gnome</code>や類似のパッケージをインストールするようにしてください。なぜなら、これらのパッケージは通常huge版の機能セットについてくるからです。</p><p>バージョンや機能をプログラム的にテストすることも可能です。</p><p>関連するヘルプ：</p><p>
</p>
<p>著作権の問題を回避するため、外部URLだけにリンクすることにします。</p><p>
</p>
<p>
</p>
<p>Vimはテキストエディタです。表示されているテキストは全て、<strong>バッファ</strong>の一部です。各ファイルはそれぞれのバッファ内でオープンされます。プラグインの内容は、それぞれのバッファなどで表示されます。</p><p>バッファは多くの属性を持ちます。属性の例としては、バッファに含まれているテキストは書き換え可能か、そのバッファは特定のファイルと連係しているかどうか、従ってディスクに書き込んで保存する際に同期する必要があるかどうか、などがあります。</p><p><strong>ウィンドウ</strong>はバッファの中身を見るための<em>のぞき窓</em>のようなものです。複数のファイルの内容を同時に表示したい場合や、1つのファイルの複数箇所を参照したい場合は、ウィンドウを使います。</p><p>注意が必要なのは、ウィンドウを<em>スプリット</em>と混同してはならない点です。ウィンドウを2つに分割することはできますが、分割後の各部分は<em>スプリット</em>ではありません。</p><p>ウィンドウは垂直方向にも水平方向にも分割することができます。分割した場合、既存ウィンドウのサイズも変更することができます。従って、好みに合わせて、レイアウトを柔軟に変更することができます。</p><p><strong>タブページ</strong>（単に「タブ」と呼ばれることもある）は、ウィンドウのコレクションです。従って、複数のウィンドウを並べて表示したい場合は、タブを使います。</p><p>要点をまとめると、引数を指定してVimを起動した場合、タブページが1枚表示され、そこには1つのバッファを表示するウィンドウが1個含まれます。</p><p>一方、バッファリストはグローバルで、どのタブからでも任意のバッファにアクセスすることができます。</p><p>
</p>
<p>Vimを起動するには、例えば<code>vim file1</code>のように入力します。ファイルの内容はバッファに読み込まれます。この状態のバッファを<strong>読み込み済みバッファ</strong>といいます。バッファの内容はVim上で保存された場合にのみ、ディスクと同期されます（ファイルに書き戻されます）。</p><p>バッファはウィンドウにも表示されますが、この場合は<strong>アクティブバッファ</strong>と呼びます。ここで、仮に<code>:e file2</code>を実行して別のファイルを読み込んだとすると、先に読み込んだ<code>file1</code>は<strong>隠しバッファ</strong>となり、<code>file2</code>がアクティブになります。</p><p>バッファは両方とも<strong>一覧表示される</strong>ので、<code>:ls</code>を実行した時の出力にも表示されます。プラグインバッファ、またはヘルプバッファは一覧には非表示としてマークされます。これはテキストエディタで日頃編集している、通常のファイルではないからです。一覧に表示されるバッファも表示されないバッファも、<code>:ls!</code>を実行すると表示されます。</p><p><strong>無名バッファ</strong>は、プラグインが時折利用するもので、連係するファイル名を特に持たないバッファです。例えば<code>:enew</code>を実行すると、空の無名バッファが新たに作成されます。何かテキストを入力し、<code>:w /tmp/foo</code>を実行してそのテキストをディスクに書き込むと、そのバッファは名前付きバッファとなります。</p><p>
</p>
<p><a href="https://github.com/mhinz/vim-galore#buffers-windows-tabs" rel="nofollow" title="" class="ext-link">グローバルのバッファリスト</a>はVimの特徴的な機能です。Vimの前身であるviでは、引数リストしか使えませんでした。なお引数リストはVimでも使えます。</p><p>Vimでは、ファイル名は全てシェルのコマンドライン上で割り当てますが、これが引数リストの中で記憶されます。引数リストは複数保持することができます。デフォルトでは、全ての引数がグローバルの引数リストに置かれます。ただし<code>:arglocal</code>を使えば、そのウィンドウだけで有効な、新しい引数リストを作成することができます。</p><p>現在の引数リストを表示させるには<code>:args</code>を使います。引数リストの表示からファイルの表示に切り替えるには、<code>:next</code>、<code>:previous</code>、<code>:first</code>、<code>:last</code>などを使います。これらを<code>:argadd</code>、<code>:argdelete</code>、<code>:args</code>のいずれかで置き換えて、ファイル名も追加してください。</p><p>ファイルとのやりとりに使う際に、バッファリストと引数リストのどちらが適しているかは、好みの問題です。個人的には、バッファリスト派が多い印象があります。</p><p>しかしながら引数リストのユースケースも膨大な数に上ります。例えば<code>:argdo!</code>を経由したバッチ処理があります。ここでは単純なリファクタリングの例を挙げます。</p><p>この例では、現在のディレクトリ以下に含まれている全てのC言語のソースファイルとヘッダファイルについて、文字列「foo」を「bar」で置き換えています。</p><p>関連するヘルプ： <code>:h argument-list</code></p><p>
</p>
<p><code>:map</code>ファミリーのコマンドで、ユーザはそれぞれ独自のマッピングを設定することができます。ファミリー内の各コマンドは、特定のモードのマッピングを定義する際に使います。厳密に言えば、Vimには12種ものモードがあり、そのうち6種に対してマッピングを設定できます。さらに、コマンドの中には同時に複数のモードで動作するものもあります。</p><p>
</p>
<p>例： ここではマッピングをノーマルモードのみとすることを定義しています。</p><p>　<code>:nunmap &lt;space&gt;</code>を使うと、再びマッピングを取り消せます。</p><p>上記以外に、ごくたまにしか使われないモードがあと数種類ありますが、それらの詳細は<code>:h map-modes</code>を実行して確認してください。</p><p>ここまではまずまず順調ですね。しかし1つだけ、初心者がかなりつまずきやすい問題があります。<code>:nmap</code>は<em>再帰的</em>です。つまり、右側は別のマッピングを実行していることを考慮しなければなりません。</p><p>そこで、単純に「Foo」をマッピングする操作を定義するには、次のように入力します。</p><p>では、<code>b</code>（1ワード戻る）のデフォルトの処理を別のキーに割り当てたい時にはどうすればいいのでしょうか。</p><p>「a」のキーを打って、カーソルが1ワード分後戻りするだろうと思っているところで、コマンドラインに「Foo」と表示されてしまうのです。なぜなら右側の文字<code>b</code>は、既に別のアクション、具体的に言えば<code>:echo "Foo"&lt;cr&gt;</code>にマッピングされているからです。</p><p>この問題の適切な解決法は、再帰的ではなく<em>非再帰の</em>マッピングを使うことです。</p><p>大原則として、どうしても再帰的なマッピングが必要な場合を除き、常に非再帰のマッピングを使うことです。</p><p>マッピングを確認する時は、右側を指定するのを避けましょう。例えば、<code>:nmap</code>と入力するとノーマルのマッピングが全て表示され、<code>:nmap &lt;leader&gt;</code>と入力すると、マップリーダーで起動されるノーマルのマッピングが全て表示されます。</p><p>通常のマッピングを無効にしたい場合は、マッピングを全て特殊な文字、<code>&lt;nop&gt;</code>に設定します。例えば次のコマンドを実行します：<code>noremap &lt;left&gt; &lt;nop&gt;</code></p><p>関連するヘルプ：</p><p>
</p>
<p>マップリーダーとは、カスタムマッピングに使う、単純なプレースホルダで、デフォルトでは<code>\</code>に設定されています。</p><p>このマッピングは<code>\h</code>によってトリガされます。<code>&lt;space&gt;h</code>を使いたい場合、代わりに以下のように記述します。</p><p>さらに、ローカルで<code>&lt;leader&gt;</code>と同様の役割を果たす存在として<code>&lt;localleader&gt;</code>があります。これは例えばあるファイル型固有のプラグインなど、ローカルからバッファへのマッピングに利用できます。これもデフォルトでは<code>\</code>に割り当てられています。</p><p><strong>注：</strong> マップリーダーはマッピングを実行する前に設定しましょう。既に利用しているマップリーダーのマッピング設定が全て有効になる点は、マップリーダーが変更されても、変わりません。<code>:nmap &lt;leader&gt;</code>を実行すると、ノーマルモードでマップリーダーが既に解決済みのマッピングが全て表示されるので、念のためあなた自身のマッピングと突き合わせて確認してください。</p><p>詳細は<code>:h mapleader</code>、または<code>:h maplocalleader</code>と入力して、表示されるテキストを参照してください。</p><p>
</p>
<p>レジスタとは、テキストを保存するスロットです。Vimではレジスタからテキストをコピーする処理を「<strong>ヤンク</strong>」、レジスタからテキストを抽出する処理を「<strong>ペースト</strong>」といいます。</p><p>vimで提供しているレジスタは以下の通りです。</p><p>
</p>
<p>読み取り専用ではないレジスタは、ユーザが値を設定してもかまいません。</p><p>これを実行しておくと、後で「n」と打てば次の「レジスタ」の内容にジャンプすることができます。</p><p>いつの間にかレジスタが一杯になってしまうと、たくさんの例外が出てきますので、文字列<code>:h registers</code>を必ず確認するようにしてください。</p><p><code>y</code>でヤンク、<code>p</code>または<code>P</code>でペーストするのですが、Vimではビジュアルモードでの文字単位（characterwise）選択と行単位（linewise）選択を区別していることに注意してください。<code>:h linewise</code>を参照してください。</p><p><strong>例：行単位</strong></p><p><code>yy</code>（あるいは単に<code>Y</code>）でカレント行をヤンクし、カーソルをどこか他のところに移動します。<code>p</code>でカレント行の下に、<code>P</code>で上にペーストします。</p><p><strong>例：文字単位</strong></p><p><code>0yw</code>で最初の単語をヤンクし、どこか他のところに移動します。<code>p</code>でカレント行におけるカーソルの後ろに、<code>P</code>で前にペーストします。</p><p><strong>例：レジスタの明確な呼称</strong></p><p><code>"aY</code>はレジスタ<code>a</code>にカレント行をヤンクします。そして別の行に移動します。<code>"AY</code>はレジスタ<code>a</code>にカレント行を追加します。</p><p>試しに、こうしたレジスタを一通り使って、<code>:reg</code>を常にチェックしてみることをお勧めします。そうすれば、実際に起こっている動きを確認することができるはずです。</p><p><strong>面白い事実：</strong> Emacsでは、「ヤンク」はコピーではなくペースト（または、その前にkillした文字列の再挿入）を指しています。</p><p>
</p>
<p>範囲はとても理解しやすいものですが、その実力を存分に活用しているVimユーザは多くないようです。</p><p>範囲の使い方はかなり直感的なものなので、ここにいくつか例を挙げてみます（<code>:delete</code>の略で<code>:d</code>を使っています）。</p><p>
</p>
<p><code>,</code>の代わりに、<code>;</code>がセパレータとして使えることに注目してください。違いは、<code>from,to</code>の場合、<em>to</em>はカレント行に関連していますが、<code>from;to</code>を使う場合、<em>to</em>は<em>from</em>のアドレスに関連しているということです。例えば、5行目にいるとしましょう。<code>:1,+1d</code>は1行目から6行目を削除するのですが、対して<code>:1;+1d</code>は1行目と2行目を削除するということになります。</p><p><code>/</code>アドレスは別のアドレスに先行することができます。これにより、パターンを<em>スタック</em>することができます。例えば次のようになります。</p><p>これは、カレント行の後で、”foo”にマッチする最初の行の後、さらに”bar”にマッチする最初の行の後、そして”quux”にマッチする最初の行を削除します。</p><p>時にVimは自動的に先頭に範囲を含むコマンドラインを追加します。例えば、<code>V</code>でビジュアルモードに移行し、いくつかの行を選択した後、<code>:</code>をタイプします。するとコマンドラインに範囲の<code>'&lt;,'&gt;</code>が入力されます。これは、次のコマンドがその既に選択されている行に作用するということを意味しています。（これは、あなたが時々<code>:vnoremap foo :&lt;c-u&gt;command</code>といったマッピングを目にする理由でもあります。ここで<code>&lt;c-u&gt;</code>は範囲を取り除くために使われています。Vimは範囲がサポートしていないコマンドに与えられるとエラーを発するからです。）</p><p>また別の例としては、ノーマルモードで<code>!!</code>を使っていることです。これが<code>:.!</code>を含むコマンドラインに入力します。外部プログラムが続く場合は、そのプログラムのアウトプットがカレント行に置き換わることになります。そのため、カレントパラグラフを、<code>:?^$?+1,/^$/-1!ls</code>を使うことによりlsのアウトプットと置き換えることができるのです。素敵ですよね。</p><p>関連するヘルプ：</p>
