Comprehensions in Python the Jedi way （2015-03-27） by Bjørn Friese私はよく、ドロイドやジェダイ、惑星、ライトセーバー、スターファイターなどのコレクショングッズを題材にしてプログラムを書きます。Pythonでプログラミングをする際は大抵、これらをリストやセット、辞書として表現するわけです。私は日頃からコレクショングッズをさまざまな形に変身させたいと思っています。そして、その願望を叶えてくれるのが、内包表記という強力な記法です。内包表記は私がさまざまな場面で使っている手法であり、Pythonを使い続けている理由の1つでもあります。では、いくつか例と共に、内包表記がいかに便利かを説明していきましょう。以下の例に出てくる処理はどれも、種類豊富なPythonの標準ライブラリがあれば実装できます。その中には、より簡潔で効率の良い処理に改善できるものもあるでしょう。とはいえ、私は標準ライブラリに不満があるわけではあません。内包表記は明快で、実に的確で美しいものだと思っています。必要な情報は全て簡潔で読みやすいコードに記載されているので、ドキュメントを読みあさる必要はありません。
私たちは今、R2-D2と意思疎通を図ろうとしています。でもR2-D2は、何やら不規則な電子音を発しているだけです。しばらく頭を抱えた後、私たちは、ピー：0とポー：1の羅列を書き出してみることにしました。面白いですね。もしかすると、これはASCII文字を表すビットのオクテットかもしれません。では、このビットの羅列をオクテット単位で区切ってみましょう。命令型で書くと以下のようになります。最初に新しいリストを初期化します。そして一連のビットを8番目のインデックスごとに区切って、長さが8になったものをオクテット用のリストに追加していきます。これが最善策でしょうか？　もっといい方法がありますよね。では、関数型で書いた以下のコードを見てください。オクテットのインデックスをラムダ関数にmapすると、ラムダ関数はそのインデックスから始まるオクテットを返します。このmap関数はイテレータ引数を返すので、それをlist関数を使ってリストに変換します。こうすると、命令型の処理よりも少し簡潔になりますが、可読性は下がってしまいます。ここでマスターヨーダに意見を仰ぐと、彼は以下の提案をしてくれました。もしやフォース？　いいえ、これは内包表記です。より正確に言うと、リスト内包表記です。このブラケット[]は、新しいリストを作成していることを意味します。ブラケット内には、まずbbs[i:i+8]と表記します。次はfor i in range(0, len(bbs), 8)というfor節です。このfor節では、新しいリストのベースとして使うイテレータを定義しており、初期状態では新しいリスト内の結果要素を定義しています。ここまででリスト内包表記については理解できました。次は再びリスト内包表記を使って、オクテットを文字に変換しましょう。すると以下の結果が得られます。希望が見えてきましたが、まだ断片化しています。ではスペースを削除したらどうなるでしょう？通常は' '（空白）文字を全てfilterして削除します。これでもうまくいきますが、内包表記の真の力を生かせば、以下のようにシンプルにできます。リスト内包表記内でif節を使ってフィルタ作業が行えるとは、素晴らしいですね。最後にメッセージをさらに読みやすくするために、文字を統合して文字列にします。さて、「snoisneherpmoc」とは一体何でしょう？　もしかしたらR2-D2は何かしらの理由で、メッセージを逆に話していたのかもしれません。なんとメッセージは「comprehensions（内包表記）」でした。R2-D2は私たちが何をしているか知っていたんですね。この例では勇敢なドロイドのための出会い系サービスを作成します。ドロイドを組み合わせる方法を次のように一覧にします。itertools.combinationsを使って実現できますが、一旦ここでは、このコードは存在しないことにして、独自のコードを書きましょう。まず組み合わせの可能なドロイドを昔ながらの方法で列挙してみましょう。これをビルドインのenumerate関数と配列スライス機能を使ってリストを少し改善しましょう。これをネストしたリスト内包表記にすれば、1行に集約することができます（そうです、ネストできるのです）。最後に好きなジェダイが共通しているかを基に相性度に点数を付けます。条件式を埋め込めばとても簡単にできます。では、組み合わせと点数をzip関数を使って、読みやすい書式で出力できるようにします。その結果、R2-D2とC-3POは相性抜群と結論付けることができます。Death Star周辺での追跡劇の前、Darth VaderとLuke Skywalkerがそれぞれの宇宙船を見つけることができません。見つけられるようにしましょう。問題ありません。ネストしたリスト内包表記を使って2つのリストを一緒にします。それぞれの宇宙船とパイロットに対して同じことを繰り返すようにします。もしパイロットのship_idが宇宙船のidと同じ場合は一致とし、tupleをリストに追加します。では、正しくできたか見てみましょう。発進の準備完了です。それぞれのエピソードに出てくる惑星名のリスト（網羅しているものではありません）を含むエピソードの辞書が提示されます。どのようにすれば、全エピソードに登場する特徴的な惑星を集約できるのでしょうか。まずネストされたリスト内包表記をと使って平滑化した1つのリストにします。注：ネストされた内包表記では左から右へと順番に評価されるため、惑星ループの前にエピソードループが必要になります。ここからは、重複したものを除くためにできたリストを次のようなセットにラップすることができます。しかし、ここではしません。実は秘密兵器を使ってこのタスクを単純化して、取り除きます。内包表記の設定完了です。最近になって、友人の書いたコードを見てcollections.Counterクラスに遭遇しました。友人はこれを辞書に出てくる特定の値の頻度を表す辞書の作成に用いていました。次のようになります。とてもカッコいい解決方法だと思いました。リストが不要だったので、リスト内包表記ではなく、ジェネレータ式を使っていることに注意してください（ジェネレータ式を使うため、Counterはイテレータ引数を取ります）。しかし、本当にこれを実現するためには、クラスをインポートしてそのクラスのドキュメントを読み込む必要はあるのでしょうか。いいえ、辞書内包表記がこれをしてくれます。次のとおりです。この方法では、行を追加して色のリストを作ります。しかし、その一方でCounterのドキュメントを読まなくても何が起きているのかを簡単に理解することができます。注：この解決法では内包表記は二次元時間で実行されますが、collections.Counterは線形時間で実行されます。効率良くするためには、collections.Counterを使ってください。内包表記についての概要が理解できたと思っていただけたら幸いです。もし、思えないのであれば、実際に試してみてください。最後まで記事を読んでいただき、ありがとうございました。どのように内包表記を使ったかぜひコメントでお聞かせください。
