An integer formula for Fibonacci numbers （2015-04-27） by Paul Hankin次のコードを用いると、なんとフィボナッチ数列が生成できます。この記事では、その導き方と振る舞いを説明しましょう。具体的な説明に入る前に、背景としてフィボナッチ数列の概要と計算方法を駆け足で紹介します。すでに数学の専門知識がある方は、導入部分はほとんど飛ばして、「母関数」のセクションをざっと読んでから、「整数の公式」に進んでいただいて構いません。フィボナッチ数列とは、言わずと知れた以下の数列です。1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldotsこの数列のn番目の値は、その直前の2つの値の和です。公式で表現すると、以下のような漸化式になります。ここでは数列の添え字を、一般的な1ではなく、0から始めています。この数列には、わりと有名な計算方法が何種類かあります。以下は明示的な再帰的呼び出しを行う方法で、この実装だと処理速度は遅くなります。次の反復実装の場合、計算量はO(n)になります。上記よりも少し知名度が下がるのが、以下の行列のべき乗を使用した実装で、計算量はO(\mathrm{log}\ n)になります。最後の方法は、fib_iter内のaとbを数列として見なす方法で、以下のように表記できます。これから以下の式が得られます。よって、もしなら、b_n = m_{11}になります（Pythonと違って、行列の添え字は通常1が基準になることに注意してください）。NumPy行列のべき乗が繰り返し二乗法のような振る舞いをすると想定すると、計算量はO(\mathrm{log}\ n)になります。さらに、漸化式を解くために、閉じた式を見つける方法もあります。これにより、次の実数値の公式が導かれます：\phi = (1 + \sqrt{5}) / 2&gt;、\psi = (1 - \sqrt{5}) / 2とすると、\mathrm{Fib}(n) = (\phi^{n+1} - \psi^{n+1}) / \sqrt{5})。この手法には、任意精度の実数計算を要するという実用上の欠点がありますが、nの値が小さければ問題はありません。任意の数列a_nの母関数は、\Sigma_n a_nx^nの無限和です。フィボナッチ数列の場合は\Sigma_n \mathrm{Fib}(n)x^nになります。つまり、これは無限に続くべき級数であり、x^nの係数はn番目のフィボナッチ数に相当します。フィボナッチ数には以下の関係があります。\mathrm{Fib}(n+2) = \mathrm{Fib}(n+1) + \mathrm{Fib}(n)この式にx^{n+2}をかけてn全体で和をとると、以下の式が得られます。\Sigma_n\mathrm{Fib}(n+2)x^{n+2} = \Sigma_n\mathrm{Fib}(n+1)x^{n+2} + \Sigma_n\mathrm{Fib}(n)x^{n+2}F(x)をFibの母関数として、それを\Sigma_n\mathrm{Fib}(n)x^nと定義すると、上の式は次のように簡略化できます。
F(x) - x - 1 = x(F(x) - 1) + x^2F(x)これは、さらに整理できます。F(x) = xF(x) + x^2F(x) + 1これをFについて解くと以下の式が得られます。F(x) = \frac{1}{1 - x - x^2}驚くことに、全てのフィボナッチ数列を網羅する簡単でシンプルな公式を、なんとか導くことができました。この式の利用方法については、次のセクションで詳しく説明しましょう。今はひとまず技術的なことは置いておき、いくつかのxの値についてFを評価してみましょう。そのためには、べき級数が収束する必要があります。フィボナッチ数列は\phi^nのように増大して、|a| &lt; 1なら等比級数\Sigma_n a^nは収束します。よって、|x| &lt; 1/\phi \simeq 0.618から、べき級数は収束することが分かります。ここまでで、Pythonのコードを理解するための準備は整いました。まずは、この公式を直感的にとらえるため、10^{-3}で母関数Fを評価してみましょう。興味深いことに、小数展開した部分に1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89と、フィボナッチ数列が現れています。魔法のような結果に驚いてしまいますが、その理由は次の式から分かります。
F(10^{-3}) = \mathrm{Fib}(0) + \mathrm{Fib}(1)/10^3 + \mathrm{Fib}(2)/10^6 + \mathrm{Fib}(3)/10^9 + \ldotsこの例では、フィボナッチ数列が次々と1/1000倍されて並んでいきます。つまり、その値が一旦1000を超えると、隣り合う数に影響を及ぼし始めるということです。この現象は、上記のF(10^{-3})の計算で988から確認できます。正しいフィボナッチ数は987ですが、数列の次の数から1だけオーバーフローが発生しています。その結果Off-by-oneエラーが発生し、以降はパターンが崩れてしまうのです。しかし、いかなるnの値に対しても、10の負の指数を十分大きく取れば、たとえオーバーフローが発生したとしても、n番目のフィボナッチ数に悪影響が出ることはありません。ここでは、あるkという値について10^{-k}が妥当な値になると仮定しましょう。この値は後ほど選定します。さらに整数で計算をしたいので（その方がコーディングしやすいので）、全体を10^{kn}倍してn番目のフィボナッチ数が整数の範囲にくるようにして、式を整理します。10^{kn} F(10^{-k}) = \frac{10^{kn}}{1 - 10^{-k} - 10^{-2k}} = \frac{10^{kn+2k}}{10^{2k} - 10^{k} - 1}この結果を10^kを法として見ると、n番目のフィボナッチ数が得られます（先ほども書きましたが、kには十分大きな値を選んだものと想定しています）。では先に進む前に、底を10から2に変換しましょう。理由は単にプログラミングを楽にするためです。2^{kn} F(2^{-k}) = \frac{2^{k(n+2)}}{2^{2k} - 2^{k} - 1}あとは\mathrm{Fib}(n+1) &lt; 2^kになるように、kを十分大きく取るだけです。フィボナッチ数列は\phi^nのように増大して、\phi &lt; 2なので、k = n+1とすれば安全です。これらを統合すると以下の式が得られます。Pythonでは左シフトの表記法が使えるので、a &lt;&lt; k = a \cdot 2^kの場合は次のように書けます。\mathrm{mod}\ (2 &lt;&lt; n)の部分は、(2 &lt;&lt; n) - 1 とのビット単位の論理和（&amp;）として表せるので、元のPythonプログラムは次のように書き直せます。非反復型で閉じた解が得られたのは興味深いですが、これは全く実用的な手法ではありません。ここではサイズがO(n^2)ビットの整数を用いて、整数演算を実行しています。でも実際には、最終的にビット単位で論理和を取る前に、最初のn個のフィボナッチ数が全て連結した整数値を取得しているのです。
