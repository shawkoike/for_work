gh-ost: GitHub's online schema migration tool for MySQL （2016-08-01） by Shlomi Noach本日、gh-ostのオープンソース・リリースを発表します。GitHubの、トリガーレスなMySQL向けオンライン・スキーマ・マイグレーション・ツールです。gh-ostは、MySQLテーブルの修正が必要な、進行中の継続的なプロダクション変更に伴って私たちが直面する問題に答えるために、ここ数ヶ月で開発されました。gh-ostは、負担が小さく、制御しやすく、監査しやすく、操作が簡単なソリューションを提供することによって、現在のオンライン・テーブル・マイグレーションのパラダイムを様変わりさせます。MySQLテーブルのマイグレーションは、よく知られた問題で、2009年からはオンライン・スキーマ変更ツールによって対処されてきました。ハイペースで成長するプロダクトに伴って、データベース構造の変更が必要になります。列やインデックスなどの追加・変更・削除は、デフォルトのMySQLの動作を妨げる操作です。私たちはそのようなスキーマ変更を1日に何度も行うので、ユーザにかかる負担を最小限に抑えたいと望んでいます。gh-ostについて説明する前に、既存のソリューションについて、そして、新しいツールを手がける理由について考えてみましょう。現在、オンライン・スキーマ変更は、主に次の3つの方法のどれかを使って行われています。その他の方法にGalera Clusterを使うRolling Schema Upgradeがあり、それ以外には、InnoDBではないストレージエンジンがあります。GitHubでは、共通マスター&amp;レプリカ・アーキテクチャを使って、信頼性の高いInnoDBエンジンを利用します。では、なぜ私たちは、上記の方法のどれかではなく、新しいソリューションを手がけようとしたでしょうか。既存のソリューションは、すべて、方法に限界があり、その欠点のいくつかについて、下記に簡単に説明します。特に、トリガベースのオンライン・スキーマ変更ツールの欠点については、後に深く掘り下げて考えます。オンライン・スキーマ変更ツールはすべて、類似した様式で動作します。元のテーブルと類似したghostテーブルを作成し、そのテーブルを空白の状態で移行させ、元のテーブルからghostテーブルにデータをゆっくりと、徐々にコピーします。その間に、進行中ghostテーブルへの変更（テーブルに行われるINSERT、DELETE、UPDATE）を反映させます。テーブルが同期したとの確信が得られると、ツールは元のテーブルをghostテーブルに置き換えます。pt-online-schema-change、LHM、oak-online-alter-tableなどのツールは同期的な手法を使用します。この手法では、テーブルに加えられた変更は毎回、直ちに、同じトランザクション空間を使用して、ghostテーブルに反映された変更へと移行します。Facebookのツールは非同期的な手法を使用して変更を変更ログ・テーブルに書き込んでから、その書き込みとghostテーブルへの変更適用を繰り返します。このようなツールはすべて、現在テーブルに加えられている変更を特定するために、トリガを使用します。トリガとは、行ごとの、テーブルへのINSERT、DELETE、UPDATE操作時に呼び出される、保管されたルーチンです。トリガはクエリのセットを含んでいてもよく、これらのクエリは、テーブルを操作するクエリと同じトランザクション空間で実行します。これにより、テーブルに対する元の操作とトリガで呼び出される操作の両方に不可分性が得られます。一般的にトリガの使用には、具体的にはトリガベースのマイグレーションには、次の問題があります。gh-ostは、 “GitHub’s Online Schema Transmogrifier/Transfigurator/Transformer/Thingy” (GitHubのオンライン・スキーマ変形（変形、変身など）ツール)の頭文字です。gh-ostには次の特徴があります。gh-ostはトリガを使用しません。バイナリログを追うことによってテーブルデータへの変更を捕捉します。したがって、その動作は非同期方式であり、変更がコミットされてから、いくらかの時間の経過後にghostテーブルに変更を適用します。gh-ostでは、バイナリログがRBR（行ベースのレプリケーション）フォーマットであると期待されますが、SBR（ステートメントベースのレプリケーション）で動作するマスターをマイグレーションするためにgh-ostを使えないという意味ではありません。実際、私たちはそれを行っています。gh-ostは、SBRをRBRに変換するレプリカからバイナリログを簡単に読み出せますし、レプリカを簡単に再構成してマイグレーションを行います。トリガを使わないことによって、gh-ostは、マイグレーションの作業負荷を、全体的なマスター作業負荷から切り離します。マイグレーションされたテーブルで実行するクエリの同時性や競合には無関係です。そのようなクエリによって加えられた変更は、バイナリログの中に無駄なく並べられ、gh-ostは、それらを読み込んでgh-ostテーブルに適用します。実際には、gh-ostは、バイナリログ・イベントの書き込みと共に行コピーの書き込みも1列に並べます。よって、マスターは、ただ1つの接続だけに注意すればよく、その接続は連続的にghostテーブルに書き込みを行っています。ETLと似たようなものです。すべての書き込みはgh-ostによって管理され、また、バイナリログの読み込みはそもそも非同期の動作なので、gh-ostは、スロットリングするときマスターへのすべての書き込みを一時停止することができます。スロットリングすると、マスターでの行コピーが一切なく、また、行のアップデートもありません。gh-ostは内部のトラッキングテーブルを生成し、スロットリングしている時でさえ、ハートビートイベントをテーブルに少量、書き込み続けます。gh-ostはスロットリング管理をさらに洗練させ、スロットリングの管理法もいくつも提供します。上記の方法では、マイグレーションが実行されている間でさえも、大幅に変更されてしまう可能性があります。既存のツールではマイグレーションの負荷が大きくなったら、DBAがより小さなchunk-sizeを再設定し、マイグレーションを止め、最初から再開させます。これは無駄な作業だと私たちは考えます。gh-ostはUNIXソケットのファイルと（設定可能な）TCPを介してリクエストをリッスンします。マイグレーションが実行中でもgh-ostに命令することができます。以下が例です。gh-ostに状態情報を要求するにも同じインターフェースが使えます。gh-ostは現在の進行状況や、主なコンフィギュレーションパラメータ、関係するサーバのIDなどさまざまなことを進んで報告してくれます。この情報はネットワークを通してアクセス可能なので、進行中のオペレーションの可視性を高めます。これがなければ、今のところ共有スクリーンを使うか、ログファイルを追っていくしかありません。バイナリログの内容はマスターの作業負荷からは分離されているので、レプリカでマイグレーションを適用することは、真のマスター・マイグレーションにより類似しています（ただし、完全ではなくので、ロードマップ上でもう少し作業が必要です）。gh-ostは--test-on-replicaを使ったテストのビルトインサポートが付いてきます。これによってレプリカでマイグレーションを実行でき、マイグレーションの最後で、gh-ostがレプリカを止め、テーブルをスワップし、そのスワップを戻し、両方のテーブルを同期して所定の場所に置きます。これでレプリケーションが終了します。2つのテーブルを簡単に分析し比べることができます。GitHubで稼働中のgh-ostをテストする方法は次の通りです。テスト用に指定された複数のプロダクションレプリカがあります。そのレプリカは、トラフィックへのサービスは行いませんが、代わりにすべてのテーブル上のマイグレーションテストを継続的に実行します。それぞれのプロダクションテーブルは、それが空っぽでも数百GBでも、ストラクチャを変更しない普通のステートメント（engine=innodb）を使ってマイグレーションさせることができます。どのマイグレーションも、レプリケーションを終了させることで終わります。私たちは、オリジナルのテーブルとghostテーブルの両方からのテーブルデータ全体の完全なチェックサムを使います。それらは同一であることが期待されます。そして、レプリケーションを再開し、次のテーブルへと進んで行きます。どのプロダクションテーブルも、レプリカ上でgh-ostを使っていくつもマイグレーションを成功させてきたということは言うまでもないでしょう。今まで述べてきた特徴、そしてさらに他の機能も、すべてはgh-ostの動作の信頼性を高めるためのものです。今まで何年もの間、同じツールを使い続けていた環境下では、gh-ostは新しいツールなのです。gh-ostは、複数のサーバと接続し、そのサーバの中の1つから直接バイナリログ･イベントをストリームするためにレプリカとして接続することで、動作します。動作モードにはさまざまな種類がありますが、セットアップや、設定、そしてマイグレーションをどこで実行するかによって選択するのがよいでしょう。
注釈：gh-ostのオペレーションモード
a.  レプリカと接続
b.  マスターと接続
c.  レプリカでマイグレーション、もしくはテストするこのモードはgh-ostのデフォルトの設定です。gh-ostはレプリカを調査し、トポロジーのマスターを見つけ、接続します。マイグレーションは以下のようになります。マスターが、SBRで動作しているならば、このモードが最適です。レプリカは実行可能なバイナリログ（log_bin、log_slave_updates）で設定され、binlog_format=ROWを持っているはずです（gh-ostは後者を適用します）。しかしRBRであっても、マスターが関係する動作モードには、このモードをおすすめします。レプリカがないか、使いたくない場合は、マスターで直接動作させることもできます。gh-ostはすべてのオペレーションをマスターで直接実行できます。ただ、レプリケーション遅延のことを考えて依頼することもできます。このモードはレプリカでマイグレーションを実行します。gh-ostはマスターに簡単に接続しますが、その後、マスター上では何の変更をすることなく、レプリカですべてのオペレーションを実行します。オペレーションの中で、gh-ostは、レプリカが最新の状態になるようにスロットリングします。gh-ostはこれで、本番移行ができる準備が整いました。技術的なリクエストが来ると、gh-ostを毎日実行させます。1日に複数回、実行させる日もあるでしょう。監査し、性能を管理して、ChatOpsと統合させます。技術者は、マイグレーションの進行をしっかりと観察し、動作を管理することができます。メトリクスとイベントが集められ、稼働中のマイグレーション動作に対して、しっかりとした見通しを提供してくれます。gh-ostは MITのライセンスのもと、オープンソースコミュティでリリースされました。gh-ostは安定していることは分かったが、まだ改良したい点があります。今回のリリースで、コミュティへの参加と貢献を歓迎します。今後、しばしばコミュニティへの貢献に関しての提案をアップしていくかもしれません。gh-ostは積極的にメンテナンスをしています。ぜひ使って、テストしてみてください。大きな力を注いで作り上げましたので、自信をもってお勧めします。gh-ostは、GitHubのデータベースインフラクチャ・エンジニアリング・チームによって、デザインされ、開発され、レビューされ、テストされました。@jonahberquist、@ggunson、@tomkrouper、@shlomi-noach貴重な情報と助言をくれたGitHubの技術者たちに感謝します。また、このプロジェクトの試作段階でレビューやコメントを残してくれたMySQLのコミュニティの友人たちにも感謝します。
