Animating with React, Redux, and d3 (2016-03-24) by Swizec Tellerこれは小さな粒を生成するものです。あなたがクリックした場所から、小さな円が生まれて飛び出していくのです。マウスを持って、動かしてみましょう。粒はカーソルから生み出され続けます。モバイル機器や、マウスではなく指で動かすタイプのコンピュータだったらどうでしょうか。同じように動きます。私はオタクなので、これが楽しいと思います。皆さんの見解は様々かもしれません。埋め込み画像をクリックして、円が飛ぶのを見てください。クールじゃないですか？これは全てReact、Redux、D3を使って作られています。アニメーションのトリックはありません。少しの賢さが必要なだけです。一般的な方法を、以下で説明してみます。私たちは、ページ、SVGエレメント、内部の粒といった全てをレンダリングするためにReactを使います。この全ては、propを使ってDOMを返す、Reactコンポーネントを使って作られています。これによって私たちは、どのノードを更新すべきか、いつ古いノードから不要なデータを回収するべきかを決定する、Reactのアルゴリズムを利用できます。そして私たちはD3の計算とイベント検出を利用します。D3は優れたランダムジェネレータを持っているので、それを利用することができます。D3のマウスとタッチイベントハンドラがSVGと関係のある座標を計算します。私たちにはこれが必要で、Reactはこれを行えません。ReactのクリックハンドラはDOMのノードに基づいていて、(x, y)座標とは対応していません。D3は画面上の実際のカーソルの位置を見ているのです。全ての粒子の座標は、Reduxのストアにあります。各粒子は動きのベクトルも持っています。ストアには役立つフラグや一般的なパラメータもあります。これによってアニメーションをデータの変換として扱えるのです。少し、ご説明しましょう。私たちは、粒子を作る、アニメーションを始める、マウスの位置を変えるといったユーザのイベントとコミュニケーションをとるために、アクションを使います。各requestAnimationFrameで、“1歩進んだアニメーション”アクションをディスパッチします。それぞれのアクションで、reducerはアプリ全体の新しい状態を計算します。これには、アニメーションの各段階での新しい粒子の位置も含まれます。ストアが更新されると、Reactはpropを経由してそれを反映します。座標は状態ですから、粒子は動くのです。その結果は、スムーズなアニメーションになります。詳細を学ぶために、読み進めてください。コードはGitHubにもあります。この記事は、近々出版される「React＋d3js ES6」という私の著書の1つの章になる予定です。まずはプレゼンテーションのコンポーネントから始めます。これが一番簡単だからです。粒子の一団をレンダリングするためには、次のことが必要になります。このうちのどれも、状態を持っていません。しかしAppはcomponentDidMountを使うための適切なコンポーネントを持っています。これをD3イベントリスナーにくっつける必要があります。Particleコンポーネントは円です。それは次のようになります。これはxとyの座標を取り、SVGの円を返します。Particlesコンポーネントは、それほど賢くありません。次に挙げるように、グループ化のエレメントに覆われた円のリストを返します。key={particle.id}の部分に注目してください。これがないと、Reactは際限なくコンプレインし続けます。おそらく、似ているコンポーネントを区別するためのものだと思います。これですてきなアルゴリズムが機能するようになります。すばらしい。{id, x, y}オブジェクトの配列を与えられれば、SVGの円をレンダリングすることができるのです。そこで出てくるのが、最初の楽しいコンポーネント、Appです。AppはシーンのレンダリングやD3イベントリスナーの結合を担当します。レンダリングの部分は、次のようになります。

まだ続きがありますが、要点としては&lt;div&gt;をHeaderやFooter、&lt;svg&gt;と一緒に返すということです。&lt;svg&gt;の内部で、私たちはたくさんの円をレンダリングするためにParticlesを使います。HeaderやFooterは、心配しなくて大丈夫です。ただのテキストです。注意してほしいのは、レンダリング関数の核は、“全てのParticlesをここに集めてください”と言っているだけだということです。何が動かされるか、何が新しいか、何がもう必要ないかについては何も言っていません。それについては心配しなくていいのです。座標のリストを入手して、単純に円を描きます。後は、Reactがしてくれます。私に言わせれば、それがここでの本当の魔法です。そうそう、ユーザがこの領域をクリックすると、startTicker()が呼び出されます。粒子が現われる前にクロックを動かす必要はありません。ユーザが粒子を生成するには、propTypesで述べた関数を使わなければなりません。それは、このような感じです。いくつか考えなければならないイベントがあります。そして、updateMousePosとupdateTouchPosはD3の魔法を使って、SVGエレメントと関係する新しい(x, y)座標を計算します。粒子生成段階では、このデータを各粒子の最初の位置として使用します。はい、複雑なのです。注意したいのは、Reactが、マウスの位置を描画領域に対して相対的に決定する程賢くはないということです。Reactは、DOMノードがクリックされたことは認識しています。D3が、魔法を使って正確な座標を見つけるのです。タッチイベントについては、最初のタッチの位置だけを考慮します。一度に複数の指で粒子を描くようなことも可能ではありますが、今の最初の位置の考慮だけで十分でしょう。レンダリングとユーザイベントについては以上です。コードは、107行あります。Reduxのアクションは、「おい、何か起こったぜ」の凝った言い方です。これらは、最新情報についての構造化メタデータを得るために呼び出す関数です。6つのアクションがあり、最も複雑なものは、このような感じです。これは、(x, y)座標にN個の粒子を生成するようシステムに命令しています。Reducerを見ると、どのような動きをするかが分かり、コンテナを見ると、そのトリガーが分かります。アクションは、あるtypeを持っていなければなりません。Reducerは、すべきことを決定するためにそのtypeを使用します。その他のアクションは、tickTime、tickerStarted、startParticles、stopParticles、updateMousePosです。どういう意味か分かるでしょう。コンテナは、ちょうどこのプレゼンテーション部分のようなReactコンポーネントです。プレゼンテーションコンポーネントと異なり、コンテナは、Reduxデータストアにアクセスします。この区別が厳密に必要かどうかよく分かりませんが、これによってコードの見栄えが良くなります。その区別とは、プロパティをエレメントに変換する、関数的にきれいなプレゼンテーションコンポーネントと、外部にアクセスする汚い汚いコンテナです。これらをデータストアのモナドと考えても良いでしょう。AppContainerの概要は、このような感じです。必要なものをインポートして、AppContainerを本来のReactComponentとして定義します。ライフサイクルメソッドを使う必要がありますが、これは処理状態を把握しないコンポーネントでは使えません。このコードには、重要な部分が3つあります。コンテクストは、素晴らしいです。なぜなら、暗黙的にプロパティを渡すからです。コンテクストは、何でも良いのですが、Reduxは、ストアであることを好みます。アプリケーションの処理状態の全てを含んでいます。UIもビジネスデータもです。そこからモナド比較が始まるのです。私は、Haskellに手を出したために、壊れてしまったかもしれません。モナドは至る所で見られました。理解できない人のために言っておきますが、その{::this.startTicker}というシンタックスは、ES2016に見られます。{this.startTicker.bind(this)}と同等です。これを使うには、Babelのコンフィギュレーションのstage-0を有効にしてください。素晴らしい。あなたはもう基本が理解できています。では、これらのコールバックを定義して、Appにアクションを始動させるようにしましょう。大体は、決まった指示のようなアクションラッパーです。このような感じです。これがテンプレートです。アクション関数が{type: ..}オブジェクトを提供するので、ストア上にそれをディスパッチします。そのプロセスが起こると、Reduxは、reducerを使ってステートツリーの新規インスタンスを作成します。次の章でもっと詳しく説明しましょう。まず、startTickerコールバックを見る必要があります。これが魔法の始まりです。すぐに”ゲット”できなくても心配しないでください。私も作成に数時間かかりましたから。これがアニメーションループを動かします。ゲームループとも呼ばれます。あらゆるrequestAnimationFrameにtickTimeアクションをディスパッチします。ブラウザがレンダリング可能になるたび、Reduxデータストアを更新する機会が得られます。理論的には、1秒に60回ですが、多くの要因によって異なります。調べてみましょう。startTickerはストアを2段階で更新します。そうです、つまり、reduxアクションを非同期的にディスパッチするということです。問題はありません。「とりあえず動く」のは、不変データの大きな利点です。maybeCreateParticles関数そのものは、大して面白くありません。store.mousePosから(x, y)座標を取得し、generateParticlesフラグをチェックし、createParticlesアクションをディスパッチします。ここまでがコンテナで、83行のコードです。いいですね。発射と描画のアクションができたら、粒子ジェネレータのロジック全体を見てみましょう。たった33行のコードと少しの変更でできてしまいます。いや、正直に言いましょう。多くの変更が必要です。しかし、CREATE_PARTICLESとTIME_TICKの変化を作り上げる33行は最も興味深いところです。全てのロジックはreducerに集約されます。Dan Abramovは、reducerは.reduce()に置く関数として考えるべき、と言っています。状態と一連の変化を指示されたら、新規状態はどのようにして作ればよいでしょうか。最も簡単に書くとすれば、次のようになるでしょう。全ての数字は、その前の合計を取って数字を足します。ここで使う粒子ジェネレータはそれをもう少し複雑にしたものです。現在のアプリケーションの状態を取り、アクションを組み入れ、新規のアプリケーションの状態を返します。なるべくシンプルにするため、全てを同じreducerに置き、大きなswitch宣言を使ってaction.typeを基盤に動きを決めます。より大きなアプリケーションでは複数のreducerに分けることになりますが、基本の原則は変わりません。基礎から始めましょう。これがreducerです。重力定数と2つのランダムジェネレータから始めましょう。それから初期状態を定義します。これだけではreducerは何も変えません。常に最低1つの不変状態を返すことが重要です。以下に示すように、多くのアクションでreducerは単一値を更新します。ここではブーリアンフラグの値と2桁の配列を変えるだけですが、新しい状態を作らなければなりません。常に新規状態を作るのです。Reduxはアプリケーションの状態が不変であることに依存します。そのため、毎回Object.assign({}, …を使います。新しい空のオブジェクトを作り、現在の状態を入力し、特定の値を新規の値で上書きします。それを毎回行うのでなければ、不変データ構造用のライブラリを使ってもいいでしょう。後者はおそらくうまく機能しますが、私はまだテストしていません。2つの重要な状態の更新 –  アニメーションのティックと粒子の作成 – は次のようになります。大量のコードがあるように見えます。確かに、非常に長くなっています。最初の部分 – CREATE_PARTICLES – は、全ての現状の粒子を新規配列にコピーし、action.Nの新規粒子を先頭に追加します。私がテストしたところ、粒子を末尾に追加するよりもそのほうがスムーズに動きました。各粒子は(action.x, action.y)で動き出し、ランダムな動きのベクトルを取得します。Reduxの観点からすると、これは悪い例です。reducerは純粋な関数であるべきところ、ランダムな動きは本来、純粋ではないからです。しかし今回のケースでは問題ありません。他に考えられる方法としては、このロジックをアクションに落とし込むことです。これには幾つか利点がありますが、1箇所で全てのロジックを網羅するのが困難になります。それはよいとして…2つ目の部分 – TIME_TICK-は粒子をコピーしません（そうすべきかもしれませんが）。参照すると配列が渡されるので、既存データを何らかの方法で変異させることになります。これも良くない方法ですが、絶対悪いというわけでもありません。何よりこうすると動きが速いです。可視エリア外に出た粒子は全て取り除きましょう。その他については、動きのベクトルをそれらの位置に追加します。それからGravity定数を使っているベクトルのy部分を変更します。以上が簡単に加速を実装する方法です。これで終わりです。reducerができました。粒子ジェネレータが機能します。アニメーションもスムーズですね。この粒子ジェネレータをReactとReduxでビルドしたことで、3つの重要な発見がありました。
粒子3000個は多過ぎる。どうでしょうか。React、Redux、それからD3を使ったアニメーションができました。新しいスーパーパワー？ そうかもしれません。まとめです。忘れないでください。これらのクールなワザは、今月出る私の著書の新版、React+d3でも紹介しています。

Primoz Cigler、Sigurt Bladt Dinesen、Will Fanguy、この記事のドラフトを読んでくれてありがとう。本記事の著者によるReact+d3jsの著書についてはこちら

