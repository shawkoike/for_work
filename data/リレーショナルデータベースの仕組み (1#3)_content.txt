How does a relational database work （2015-08-19） by Christophe Kalenzagaリレーショナルデータベースが話題に挙がるとき、私は何かが足りないと思わずにはいられません。データベースはあらゆるところで使われており、その種類も、小規模で便利なSQLiteからパワフルなTeradataまで様々です。しかし、それがどういう仕組みで機能しているかを説明したものとなると、その数はごくわずかではないでしょうか。例えば「リレーショナルデータベース 仕組み」などで検索してみてください。ヒット数の少なさを実感できると思います。さらにそれらの記事は短いものがほとんどです。逆に、近年流行している技術（ビッグデータ、NoSQL、JavaScriptなど）を検索した場合、それらの機能を詳しく説明した記事はたくさん見つかると思います。リレーショナルデータベースは、もはや大学の授業や研究論文、専門書などでしか扱われないような古くて退屈な技術なのでしょうか？私は開発者として、理解していないものを使うのは好きではありません。データベースが40年もの間使われ続けてきたのには、それ相応の理由があるはずで、毎日使っているこの不可思議なブラックボックスを本当に理解するために、私は長年にわたって多くの時間を費やしてきました。リレーショナルデータベースは、便利で再利用可能な構想に基づいており、非常に興味深いものです。これをお読みの皆さんが、データベースを理解したいと思いつつも時間がなかったり、どこから手を付けていいか分からずに手をこまねいていたりするような場合には、きっとこの記事に興味を持っていただけると思います。記事のタイトルをご覧いただければ分かるように、この記事の目的はデータベースの使い方を理解することではありません。そのため、記事の内容を理解するには、単純なJoinクエリや基本的なCRUDクエリを書けるくらいの知識は必要です。ただし、それさえ知っていれば、あとは私の方で説明します。最初に触れるのは、時間計算量といったコンピュータ科学に関するものです。こういった概念はちょっと…という人がいるのは分かっていますが、これをやっておかないと、データベースの明晰さは理解できません。なお、テーマが大きいので、不可欠と思われるもの、つまり、データベースによるSQLクエリの処理方法に焦点を絞って進めます。データベースの背後にある基本の概念を紹介するので、記事を最後までお読みいただければ、実際に内部で何が起こっているのか、おおよその見当が付くようになるでしょう。この記事はとても長く、多くのアルゴリズムやデータ構造に関する技術的な内容が含まれているので、最後まで読むにはある程度の時間が必要です。一部の概念については理解するのが難しいかもしれません。その場合、そこはスキップしてください。それでも大枠は理解していただけると思います。内容についてもう少し具体的に説明しますね。大まかに分けて記事には3つのパートがあります。目次

.toc_number{margin-right:10px;}
.block-text-content li{margin-bottom:0;}

ずっと（遙か彼方の）以前には、開発者はコード内の処理数をしっかりと把握する必要がありました。CPUやメモリの無駄遣いでコンピュータの動作を遅くしないよう、アルゴリズムやデータ構造を頭に入れていたのです。このパートでは、アルゴリズムやデータ構造の概念のいくつかについて話していきたいと思います。データベースを理解する上で不可欠な要素ですからね。また、データベースインデックスの考えについても触れるつもりです。今日、多くの開発者は時間計算量なんてものを気にしませんし、それはそれで間違ってはいません。しかし、大量のデータ（数千という話ではありません）を扱う場合やミリ秒を争うような場合、この概念を理解することは非常に重要です。そして、データベースというのは、上記の両方の状況を扱わなくてはなりません。話が長くなると退屈してしまうと思われるので、手短にその要旨をお伝えしますね。これは、後ほど出てくるコストベース最適化の概念を理解するのに役立ちます。時間計算量は、所定のデータに対してどの程度の時間をアルゴリズムが要するかを見るために使われています。この計算量を説明するためにコンピュータ科学者たちが使うのが、数学のO記法です。この表記は、所定の入力データに対してアルゴリズムに必要な処理数を説明する関数と共に使われます。例えば、「このアルゴリズムはO(some_function())」と言う場合、それは所定のデータに対してアルゴリズムが完了するのに、some_function(所定データ量)の回数だけ処理が必要だということを意味します。重要なのはデータの量ではなく、データが増えた時の処理数の増加の仕方です。時間計算量は確実な処理数を出すものではありませんが、大体の見当は与えてくれます。
この図は、異なる時間計算量の漸次的変化を示しています。グラフ表示には対数目盛りを使っているので、データの数は1から10億まで急速に増加しています。ここで分かるのは以下のことです。データ量が少ない場合、O(1)とO(n2)の違いはほんのわずかです。では、仮に2000要素の処理が必要なアルゴリズムがあるとしましょう。O(1)とO(n2)の差は大きい(4000000倍)ですが、最大でも2ミリ秒ほど余分にかかるだけで、瞬き程度の時間差と言えなくはありません。実際のところ、現在のプロセッサは1秒で数百万の命令を処理できます。パフォーマンスや最適化が多くのITプロジェクトでそれほど問題にならないのは、これが理由です。それでもやはり、前述の通り膨大な量のデータがある場合、この概念を知ることは重要です。例えば先のアルゴリズムが、今回は1000000の要素（データベースとしてはさほどの大きさではありません）を処理するとしましょう。私は数学専攻ではありませんが、O(n2)アルゴリズムなら、1杯（ひょっとしたら2杯）のコーヒーブレイクは取れるでしょう。仮にデータ量があと1桁増えたら、長めの昼寝だって可能かもしれません。参考までに。注：次のパートでは、これらのアルゴリズムやデータ構造を見ていきます。時間計算量には複数のタイプがあります。時間計算量は往々にして、最悪の場合のシナリオであることが多いですね。時間計算量についてのみ話していますが、計算量は以下の場合でも有効です。もちろん、例えば次のようにn2よりもひどい計算量もあります。注：ここで提供したのはO記法の実際の定義ではなく、大枠のアイデアのみです。実際の定義についてはWikipediaに詳しいので、そちらをご覧ください。集合をソートする必要がある場合、あなたなら何をしますか。sort()関数を呼び出す？　確かに、それもいいですね。でも、データベースの場合、そのsort()関数がどのように作用するかを理解していなければなりません。優れたソートアルゴリズムはいくつかありますが、中でも特に重要なものを1つ取り上げてみます。それがマージソートです。今の時点ではなぜデータのソートが役に立つのか分からないかもしれませんが、クエリ最適化に関するパートを読めば理解できるようになるはずです。また、マージソートについて理解することは、後ほど出てくるマージ結合と呼ばれるデータベースの一般的な結合処理を理解する上でも助けになるでしょう。多くの便利なアルゴリズムと同様、マージソートもちょっとした仕掛けに基づいています。N/2のサイズのソート済み配列2つをN要素のソート済み配列にマージしても、N回の処理しか行われないのです。これがマージと呼ばれます。どういうことか、簡単な例で確認してみましょう。上の図を見ると、最終的に8要素がソートされた配列を構築するには、4要素の2つの配列を1回反復すればいいことが分かります。4要素の2つの配列が既にソートされているからです。これでうまくいくのは、4要素の2つの配列がソートされているため、これらの配列を「戻る」必要がないからです。この仕掛けが分かったところで、マージソートの疑似コードを以下に示します。マージソートは問題を小さな問題に分解してからその結果を求めることで、最初の問題の結果を得ます（注：このようなアルゴリズムは分割統治法と呼ばれます）。このアルゴリズムが理解できなくても心配いりません。私も最初は理解できませんでしたから。少しでも理解の助けになるように、このアルゴリズムを2段階のアルゴリズムと考えてみましょう。分割段階では、配列が3段階で単一要素の配列に分割されます。何段階になるかはlog(N)で求められます（上の図の場合N=8、log(N)=3）。どうしてそんなことが分かるのでしょうか。私が天才だからです…というのは冗談で、数学のおかげです。各段階で、最初の配列のサイズが2で分割されていきます。つまり、配列を2で割れる回数が段階の数になります。これは対数の定義と完全に一致します（基数は2）。ソート段階は、単一要素の配列から始まります。各段階でマージを複数回適用し、処理はN=8回になります。log(N)段階あるため、全体で必要な処理はN * log(N)回です。このアルゴリズムはなぜそんなに威力があるのでしょうか。理由：注：このようなアルゴリズムはin-placeアルゴリズムと呼ばれます。注：このようなアルゴリズムは外部ソートと呼ばれます。例えば、分散マージソートはHadoop（ビッグデータの代表的なフレームワーク）の重要な構成要素です。このソートアルゴリズムはほとんど全てのデータベースで使用されていますが、唯一のアルゴリズムではありません。より詳しく知りたい方は、データベースの一般的なソートアルゴリズムについて様々な考察が掲載されているこちらの研究論文をご覧ください。時間計算量とソートの背景にある考え方について理解できたところで、3つのデータ構造について説明したいと思います。これらの構造は、モダンなデータベースの根幹となるので、理解しておきましょう。併せて、データベースインデックスの概念についても紹介していきます。2次元配列はシンプルなデータ構造で、テーブルは配列として見ることができます。例えば以下のようなテーブルです。この2次元配列は行と列からなるテーブルです。データを保存し、視覚化できたのは素晴らしいことですが、特定の値を探すには不便です。例えば、UKで働く男性全員を探す場合、UKと記述されている行がないか、全ての行を確認しなければなりません。つまり、Ｎ回の処理（Nは行の数）が必要になるということです。これは悪いことではありませんが、他に速く処理できる方法はないのでしょうか？　そこでツリーの登場です。補足：最近のほとんどのデータベースでは、ヒープ表や索引構成表のように、効率的にテーブルを保存するための高度な配列が提供されています。しかし、列のグループ内にある特定の条件を素早く探し出すという問題については、何も解決していません。バイナリサーチツリーは、特殊なプロパティを持つバイナリツリーで、各ノードのキーは以下の条件でなければいけません。視覚的に見ていきましょう。
注釈：全てのノードには、結びついたテーブル内の行に向かってポインタがある。このツリーには、N＝15個の要素があります。例えば、208を探し出したいとしましょう。では次に、40を探してみましょう。結局、この2つの探索では、ツリー内で数回のレベルを踏むことになりました。
マージソートのパートを注意深く読んでいただければ、ここにlog(N)レベルがあることに気づくはずです。つまり、探索のコストはlog(N)となります。悪くないですね！上記の探索は抽象的すぎるので、本来の問題に戻って考えてみましょう。退屈な整数はやめにして、前のテーブルで国名を表していた文字列を思い浮かべてください。テーブルに”国名”という列が含まれているツリーだと仮定します。配列を直接使えば、この探索はN回の処理ではなく、log(N)回の処理で済むことになります。今、あなたが思い描いたことこそがデータベースインデックスです。キー（例えば列のグループ）を比較する関数があれば、列がどんなグループ（1つの文字列、1つの整数、2つの文字列、整数と文字列、日付など）であろうと、ツリーのインデックスを構築することが可能です。つまり、キー間の順序を決めることができるのです（これは、データベースのどんな基本的な型にも該当します）。特定の値を1つ得るには、バイナリサーチツリーでも問題ありませんが、2つの値の間にある複数の要素を得たい場合は、大きな問題が生じます。この場合、ツリーにある各ノードを見なくてはならず、さらに、それが2つの値の間（例えば、ツリーの間順走査）なのかを確認しなくてはならないので、コストはO(N)となります。その上、ツリー全体を読み込まなければならないので、この処理はディスクI/Oに優しくありません。ですから、レンジクエリを効率的に行う方法を見つける必要があります。この問題を解決してくれるのが、B+ツリーです。最近のデータベースは従来のツリーから、修正版であるB+ツリーを使っており、以下の特徴を持っています。
注釈：ノードには、結びついたテーブル内の行に向かってポインタがある。
また、各ノードはB+ツリー上の次の要素へのリンクも持っている。見てお分かりの通り、さらに多くのノード（2倍）があります。追加されたノードである”ディシジョンノード”は、正しいノード（結びついたテーブル内の行の位置情報を保存する）を見つけてくれます。しかし、探索の時間計算量は依然としてO(log(N))です（階層は1つだけ増えます）。大きな違いは、最下層のノードは、それぞれ次の要素にリンクしているということです。40と100の間の値を探すのであれば、B+ツリーでは以下のようになります。例えば、M個の次要素が見つかり、ツリーにはN個のノードがあるとしましょう。バイナリサーチツリーと同じように、特定のノードを探索するコストは、log(N)です。ですが、このノードが得られれば、次要素の直リンクを使ってM回の処理を行い、M個の要素を得られます。この場合の探索のコストは、M + log(N)回の処理 対 バイナリサーチでのN回の処理となります。また、ツリー全体を読み込む必要はありません（M + log(N)のノードだけでいいです）ので、ディスクの使用量が少なくて済みます。Mの値が小さくて（200行など）Nの値が大きい（100万行）場合、これは大きな違いになってきます。しかし、ここで新たな問題があります（またです！）。データベース（ひいては、B+ツリーのインデックスに紐づいたデータベース）の行を追加したり削除したりする場合、以下のことに注意しなくてはいけません。言い換えると、B+ツリーは、それ自身で順序を保ち、バランスを取らなくてはいけないということです。有り難いことに、これは高性能な削除、または挿入の処理で可能となります。しかし、これにはコストが伴います。B+ツリーの挿入と削除は、O(log(N))です。必要以上に多くのインデックスを使用することは賢明ではない、と聞いたことがある人もいるかもしれませんが、これがその理由です。データベースは、インデックス毎のO(log(N))回の処理と併せて、テーブルのインデックスを更新する必要があるため、テーブル上での行の挿入や更新、削除の速度が低下してしまうのです。それだけでなく、インデックスを追加するということは、トランザクションマネージャ（この記事の最後のパートで説明します）に対する負荷が増すことにもなります。詳細については、Wikipediaの「B+木（ツリー）」を参照してください。データベースへのB+ツリーの実装例は、MySQLのメイン開発者が投稿しているこちらの記事とこちらの記事を読んでみるといいでしょう。どちらもinnoDB（MySQLのデータベースエンジン）がどのようにインデックスを扱うかについて言及しています。補足：読者の方から教えていただいたのですが、低水準の最適化なので、B+ツリーは完全に平衡化されている必要があるそうです。重要なデータ構造の最後は、ハッシュテーブルです。すぐに値を確認したいときなどにとても役立ちます。さらに、ハッシュテーブルを理解すれば、ハッシュ結合と呼ばれる一般的なデータベースの結合を理解するのが楽になります。このデータ構造は、また、内部のものを保存するデータベースとしても使われます（ロックテーブルやバッファプールなど。こちらの概念については、後でご紹介します）。ハッシュテーブルとは、キーを利用して要素を素早く探すデータ構造の1つです。ハッシュテーブルを構築するためには、次に挙げる項目を定義する必要があります。次のような図で例を見てみましょう。
このハッシュテーブルにはバケットが10個あります。面倒なので図には5個しか表しませんでしたが、実際はもう5個加わっている図を思い描いてください。ここで使ったハッシュ関数は、各キーのmodulo10、となります。分かりやすく言うと、各要素が分類されるバケットを決めるために、要素の下1桁の数値だけをキーとして使うことにします。この例では、単純に2つの整数間の等しさを比べる比較関数を使います。では、78という要素を探すとしましょう。次は、59という要素を探してみましょう。お分かりの通り、探索したい値によって処理数が変わります仮にここでハッシュ関数を、キーのmodulo1000000（すなわち、下6桁）に変えてみます。この結果、バケット000059内には要素が何も含まれなくなるので、次の探索にかかる処理数は1回のみとなります。優れたハッシュ関数は、含まれる要素数が最小となるバケットを生成します。こうした関数を見出すことこそが、まさに取り組むべき挑戦です。今まで見てきた例は単純なものなので、簡単に優れたハッシュ関数を見出すことができます。しかし、キーが次に挙げるようなものである場合だと、適切なハッシュ関数を見つけることはより難しくなります。優れたハッシュ関数があれば、ハッシュテーブル内での探索にかかる処理はO(1)で完了します。では、なぜ配列を使わないのでしょうか。大変良い質問です。より詳しい情報については、以前投稿したJava HashMapという記事をご参照ください。効率的なハッシュテーブルの実装について書いています。Javaの知識がなくても記事の概念は理解できると思います。ここまでデータベース内部における基本的な構成要素について確認してきました。次は、一歩下がって全体像を見ていきましょう。データベースとは、容易にアクセスし修正することができる情報の集合体です。ファイルの単純な固まりでも実は同じことができます。実際、SQLiteといったシンプルなデータベースなどは、ファイルの寄せ集め以外の何ものでもありません。とはいえ、SQLiteはよく考えて作り上げられたファイルの一群であり、次に挙げるようなことが可能になります。より一般的に見てみましょう。データベースとは、次のような図で表現できます。
このパートを書くために、書籍や論文をいくつか読んでみましたが、どれもデータベースをきちんと説明するには物足りないものでした。私自身も、この記事を構成するにあたって割り切った部分があります。ですから、データベースの組織付けや手順の名称についてはあまりフォーカスしないでください。重要なのは、ここに様々な構成要素がある、ということです。すなわち全体から見ると、データベースは互いに作用する複数の構成要素に分割できるのです。主要な構成要素：ツール：クエリマネージャデータマネージャこの記事ではこれから、どのようにデータベースがSQLクエリを管理しているのか、次に挙げるプロセスの解説を通じて詳しく見ていきます。
