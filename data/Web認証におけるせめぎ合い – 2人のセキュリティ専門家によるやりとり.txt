<p><a href="http://blog.slaks.net/2015-10-13/web-authentication-arms-race-a-tale-of-two-security-experts/" rel="nofollow" title="" class="ext-link">The Web Authentication Arms Race – A Tale of Two Security Experts</a> （2015-10-13） by <a href="http://slaks.net/" rel="nofollow" title="" class="ext-link">Schabse Laks</a></p><p><small>(訳注：2015/11/1、いただいた翻訳フィードバックを元に記事を修正いたしました。)</small></p><p>成長し続ける様々な脅威に対抗すべく、この10年間でWeb認証システムは進化を遂げてきました。この記事では、架空のWebアプリケーション開発者とアタッカーのせめぎ合いを通じて、最新のセキュリティ技術がどのように様々な脅威に対抗することができるかを提示したいと思います。</p><p>以下のやり取りにおいて、ユーザはアタッカーが出現する前に、すでにディフェンダーでいくつかのトラストアンカー（パスワードやハードウェアトークンなど）を正規に確立していることが前提となっています。暗号は、時間や空間にわたって、既存のトラストや秘密を伝達する場合にのみ<a href="http://blogs.msdn.com/b/ericlippert/archive/2011/09/27/keep-it-secret-keep-it-safe.aspx" rel="nofollow" title="" class="ext-link">使うことができます</a>。もし、トラストやセキュリティが確立される前にアタッカーがディフェンダーになりすましたとしたら、正規のものを見分けるのは極めて難しいでしょう。また、サイトにはアタッカーがコードを走らせたり、データを読み込んだり、サーバからの認証を解読したりすることが可能な脆弱性（XSSやCSRFなど）が存在しないと仮定します。</p><p><em>この段階で、ブラウザに不正にアクセスしないで、アタッカーが中間者攻撃を実行する妥当な方法はありません。</em></p><p><em>U2Fデバイスなどの秘密鍵は、フィッシングされることのない認証です。秘密鍵を認証する物理的な所有権を持たない者がフィッシングすることは不可能ですが、ハードウェアデバイスが信頼されていることが前提です。もしアタッカーが認知している秘密鍵のデバイスに取り換えることができるとしたら、全ては無意味です。また、アタッカーが単純にデバイスを盗むという行為から守るためにも、ハードウェアデバイスと併せてパスワードを使用すべきです（デバイスそのものが作動するためのパスワードを必要とするのであれば、それでも構いません）。</em></p><p><em>アプリケーションレベルの脆弱性（XSSやCSRFなど）はなく、プラットフォーム自体もいかなるアタックに対して完全にセキュアで脆弱性はないもことした想定した場合です。残念ながら、フィッシングできない認証もサポートするようなプラットフォームを知りません。Chrome OSはフィッシングできないの認証をサポートしていますが、拡張機能がローカルにHTTPリクエストを送ってくるのを防ぐ手だてを提供していません。多くの（ルート化されていないデバイス上の）モバイルブラウザは、拡張機能だけでなく、フィッシングできない認証も現在のところサポートしていません。</em></p><p>理論上は、既述の想定においては、この設計は完全にセキュアです。しかし実際には、状況はそれほど単純ではありません。これらの想定の実現を困難にする問題が多々あったり、他の方法でセキュリティが無効になったりするからです。</p><p>このテクニックは、ユーザがハードウェアトークンを物理的に保持していることを完璧に証明しようとするものです。しかし、あなたの考えるとおりにハードウェアトークンがあるユーザに属していると確約する助けにはなりません。アタッカーのハードウェアトークンはユーザに属している、と証明されてしまえば、サーバはアタッカーが本当のユーザであるかどうか判断がつかないため、中間者攻撃の展開は依然として可能です。</p><p>定義上、ハードウェアトークンを設定しようとしているユーザの認証にハードウェアトークンは使えませんから、標準のHTTPSと証明のピンニングに頼るしかなく、クライアント上での悪意あるコード実行に対しては脆弱なままです。銀行口座のような実体のあるオンラインアカウントに連携させようとしているなら（eメールアカウントのように全く新しいアカウントを作成するのとは反対に）、アカウントを作っているユーザは実際に実体に紐づいており、なりすましや中間者攻撃を試みるアタッカーではないことを証明する必要があります。その最善策は、ユーザ本人が自身を証明し、信頼済みでディフェンダーに制御されたハードウェアを使ってトークンに関連づけすることです。</p><p>ユーザのマシン上で勝手なコードを実行できるアタッカーに対抗するのは不可能です（ディフェンダーのサーバは、送信されたリクエストがユーザによる正当なコードからのものか、アタッカーによる不正のコードによるものか区別できないからです）。上述の「完全にセキュア」なシナリオでは、ユーザのプラットフォームはそもそも勝手なコードを受け入れないことになっており、この問題は想定していません。</p><p>モバイルプラットフォームでは、他のアプリケーションがブラウザのクッキーや秘密鍵を読むのを防ぐことで、ユーザを証明しようとしています。しかし、完全にこれを強制するのはより困難です。ブラウザ、OS、またはプラットフォームにおいて、何らかのセキュリティ脆弱性（または実際の悪意あるコード）がこの保証を無効にする可能性があるからです。例えば、AndroidやiOSデバイスをルート化あるいは脱獄（またそれによるブラウザまわりの保護の回避）させられるなら、この保証に意味はありません。</p><p>この点において踏み込むべきは信頼済みのブートです。WindowsとChrome OSで使われているように、BIOSからブートローダ、OS、ハードウェアドライバまでの全ての実行の流れが、それぞれの起動段階において署名、認証されます。しかし、署名されたコードにおけるセキュリティ脆弱性はなお勝手なコードの実行とマシンを危険にさらすことにつながり得ます。</p><p>より大きな問題では（国家レベルのアタックを想定した場合）、ユーザが完全にセキュアなハードウェアを持っていたとしても、アタッカーはそれを、アタッカーが制御するハードウェアに差し替えることもあります。これにはリバースプロキシが含まれており、全てのプロテクトをすり抜けます。ユーザが自身のハードウェアデバイスを承認するシンプルな方法は（四六時中、見張る以外に）ありません。アタッカーは既存のデバイスをこじ開け、全てのデータとプライベートキーをバックドアのデバイスにコピーして、間違いなくユーザ本人の外観、振る舞いに見せかけることができるのです。</p><p>（PCBから削除されると自動的に消滅する改ざん防止ハードウェアにサポートされた秘密鍵を構築することはできますが、その改ざん防止策がアタッカーの改ざん策よりも優れているかは、運次第です。またアタッカーがハードウェアの他のパーツをいじり、何も動かさずにバックドアから侵入しないとも限りません）</p><p>最後に、「パスワードを忘れた場合」は、これらのセキュリティ保証とは完全に正反対の機能です。「パスワードを忘れた場合」機能の趣旨は、ユーザをここまで見たような認証を得ることなくユーザを承認しようということです。つまり、1つ目の課題で述べたようにユーザを最初に関連づける際の問題を再導入することになります。この状況では、アカウント作成とは異なり、常にユーザが何者かを証明する必要があります。なぜなら、ただ新規アカウントを一から作るのではなく、ユーザを既存アカウントと紐づけようとしているからです。</p><p>「パスワードを忘れた場合」機能は元々、（暗黙で信頼された）他のサービス、多くの場合eメールに認証を委任することで実行できるものでした。1度目にアカウント作成するとき、ユーザはeメールアドレスを1つ指定します。ユーザはそのメールアドレスに送られたeメールを読むことができるという事実によって承認を行うわけです（大抵、「秘密の質問」など、グレードの低い2つ目の要素が求められます）。しかし、これは新たなリスクを招きます。アタッカーはユーザのeメールアカウント（そして、ほぼ容易な2つ目の要素）をいつでも乗っ取れるのです。更に、ユーザが正当に「パスワードを忘れた場合」を使用した場合でも、クライアント側で既に走っている悪意あるコードに中間者攻撃を行ってアカウントに接続し、汚染すること（例えば、アタッカーの秘密鍵をユーザのそれに追加するなどして）を防ぐ方法はありません。</p>
