<p><a href="http://lightstep.com/blog/the-end-of-microservices/" rel="nofollow" title="" class="ext-link">The End of Microservices</a> (2016-07-18) by <a href="https://github.com/djspoons" rel="nofollow" title="" class="ext-link">Spoons</a></p><p><img src="https://cloud.githubusercontent.com/assets/2251553/17001778/4680cf60-4e7d-11e6-958f-1a63237d51c0.png" alt="image"></p><p><em>これは未来からの投稿です。現在、信頼のおけるスケーラブルなプロダクションシステムの構築は、言ってみれば、その他のソフトウェアを書くのと同じくらい容易になっています。未来にはどのような風景が広がっているのか、お伝えしましょう。</em></p><p>2016年当時は、誰も彼もが「マイクロサービス」を取り上げていました。例えば、1996年に「情報スーパーハイウェイ構想」の記事ばかりが出回った頃に似ています。「情報スーパーハイウェイ構想」というフレーズがやがて消滅し、人々はインターネットの構築に戻っていったのと同様に、サービスが、スケーラブルなソフトウェアシステム構築の標準になるにつれ、マイクロサービスの「マイクロ」の部分もまた、削り落とされて行きました。私たちが使ってきた（そして捨て去った）名称であるにもかかわらず、どちらの用語も、当時のテクノロジーに対する考え方とその使い方に起こった転換を示しています。サービスベースのアーキテクチャを利用するということは、開発者にとってはサービス間の連携に注力することを意味しました。それによって、より良いソフトウェアをより短期間で開発できるようになったのです。</p><p><img src="https://cloud.githubusercontent.com/assets/865298/16940213/16ef78f0-4d3d-11e6-8b0f-298277b24e07.png" alt="image"><br>
<em>「情報スーパーハイウェイ構想」の盛衰（<a href="https://books.google.com/ngrams/interactive_chart?content=information+superhighway&amp;year_start=1986&amp;year_end=2008&amp;corpus=15&amp;smoothing=1&amp;share=&amp;direct_url=t1%3B%2Cinformation%20superhighway%3B%2Cc0" rel="nofollow" title="" class="ext-link">詳細を見る</a>）</em></p><p>2016年から、開発者は1つ1つのサービスに集中できるようになり、生産性は上がって行きました。「サービス」とは何なのでしょうか。大まかに言うと、定義がシンプルで、個別のデプロイが可能なソフトウェアの最小単位です。通知サービス、ログインサービス、あるいは、キー値の持続的記憶サービスなどの例を見てみましょう。うまく構築されたサービスは1つのことだけを、上手に執り行います。開発者は仮想マシンやその他、下層のインフラを気にかける必要がないので、仕事を速く進めることができます。つまり、サービスは抽象化のレベルを引き上げるのです。（別の流行語ですが、一時期これはサーバレスコンピューティングと呼ばれていました）。そして、サービス間の関係性が明確なため、開発者はアプリケーションを全体として考慮することからも開放され、その分、開発者自身の担当する機能、依拠するサービスだけに集中できます。</p><p>その頃は、多くの組織が、マイクロサービスアーキテクチャへの移行とは「1バイナリを小さく10個に分解する」ことだと考えていました。そして実際にやってみて、昔から続く問題をさらに10回繰り返しただけだと気付いたのです。その過程において、堅固なアプリケーションの構築とは、一枚岩のシステムを細かいピースに分けることではなく、ピース間の関係性を理解することだと知ったのでした。この時、全うな問いかけが始まりました。私のサービスはどのサービスに依存しているのだろうか。従属が反応しない時、何が起こるのか。他のどのサービスが私のサービスを呼び出すか。どれだけのRPCの数を期待するか。これらの疑問に答えるためには、新しいツールとマインドセットが求められました。</p><p><img src="https://cloud.githubusercontent.com/assets/2251553/17001802/6330e51e-4e7d-11e6-8fe3-4a655441b4fe.png" alt="image"></p><p>サービスベースのアーキテクチャを構築するには、それぞれが独立しながらも相互に繋るというサービスの性質を両立させる新しいツールキットがなければ不可能だったでしょう。ある1組のツールセットが、APIの境界線とサービス間の関係を定義しながら、プログラムでサービスを説明します。これは異なるサービス間の相互作用を管理する契約を効率的に定義します。また、ドキュメント作成やテストサービスでも役立ちますし、分散型アプリケーションを構築する際に必要となる数多くのボイラープレートを生成することができます。</p><p>もう1つの重要なツールセットはデプロイやコーディネートサービスで役立ちます。例えば、消費される基礎的なリソースに関する高度なサービスをマッピングするスケジューラや（適切なスケーリングも行います）、リクエストを適切な場所に確実に届けるためのサービスディスカバリやロードバランサなどです。</p><p>一度アプリケーションがデプロイされると、3つ目のツールセットは、開発者がサービスベースのアプリケーションの振る舞い方を理解し、問題が生じた際に対象部分（または原因）を切り分けられるようにするのを助けます。マイクロサービスが始まったばかりの頃、開発者は見なれたモノリシックアプリケーションの可視性を失い、突如としてログファイルをgrepして根本的な原因を特定を行うことができなくなりました。なぜなら、答えが数百個のノード上のログファイルに分けられ、何千もの他のリクエストと相互にはさみこまれていたからです。マルチプロセストレーシングの出現によって、クリティカルパスの分析を集計でき、スマート・フォルト・インジェクションで分散型アプリケーションの振る舞いを完全に理解することができるようになったのです。</p><p>これらのツールの多くは2016年にも存在していましたが、まだエコシステムが確立していませんでした。標準的なものはほとんどなかったため、新しいツールには莫大な投資が必要でしたし、一緒に使用すると既存のツールがに全く動作しなくなってしまいました。</p><p>現在、このツールキットが要因の一部となり、サービスは日々の考え方や開発者の考え方となっています。しかし、本当に革命が起こったのは、ソフトウェアを構築する時に、開発者がサービスを最優先、最重要と考え始めた時です。テスト駆動開発で、コードの1行目を書く前に開発者がテストについて考え始めるのと同じように、サービス駆動開発ではサービスの依存性、パフォーマンス計測、そしてRPCコンテキストが最初の検討事項となります（後に用意された問題、ではありません）。</p><p>総合的にサービス（「マイクロ」、もしくは全く別のもの）はいいものです。（もはや「マイクロサービス」と言う必要はありません。今にして思えば、サービスのサイズが重要だったことはなく、結合性や関係性が問題だったからです）サービスがソフトウェア開発の話題の中心に戻ってきて、開発者はユーザに価値あるものを届けるために本当に重要なことに対して、より素早く、独立した仕事をできるようなりました。</p><p><em>現在に戻ります…。エコシステムサービスの構築には、まだまだやるべき面白い仕事が残っています。LightStepで、この革命の一翼を担い、トレーシングを通して、プロダクションシステムの可視化の向上を支援できることをうれしく思います。サービスや、トレーシング、一般的な可視化について興味がある方は、<a href="mailto:hello@lightstep.com">hello@lightstep.com</a>, <a href="https://twitter.com/lightstephq" rel="nofollow" title="" class="ext-link">@lightstephq</a>宛にメールでご連絡いただくか、下のコメント欄に投稿してください。</em></p>
