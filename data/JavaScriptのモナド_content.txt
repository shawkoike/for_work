Monads in JavaScript （2015-06-07） by Curiosity drivenモナドとは、一連のステップによって実行する計算を記述する際に使用する、1つのデザインパターンです。純粋関数型プログラミング言語 では、モナドは副作用を管理するために広く利用されていますが、マルチパラダイム言語では、モナドで複雑性を制御することもできます。モナドはデータ型をラップして、空の値を自動的に伝播したり（Maybeモナド）、非同期コードを簡略化したり（継続モナド）といった、新たな動作を既存のデータ型に追加します。一連のコードをモナドと見なすためには、その構造には次に挙げる3つの要素が含まれていなければなりません。次に示すTypeScript上のコードは、一般的な関数のシグネチャを表しています。ここでMは、モナド型を表しています。注： このbind関数は、Function.prototype.bind関数と同じものではありません。後者はES5ネイティブの関数です。部分的に適用する関数や、this値に束縛する関数を作成する場合に使います。JavaScriptのようなオブジェクト指向の言語では、unit関数をコンストラクタ、bind関数をインスタンスメソッドとして表現できます。次に示す3つのモナド則には必ず従わなければなりません。 

1. bind(unit(x), f) ≡ f(x)
2. bind(m, unit) ≡ m
3. bind(bind(m, f), g) ≡ bind(m, x ⇒ bind(f(x), g))上の2つの規則は、unitがニュートラルな要素であることを示しています。3番目の規則は、bindは結合型であることを表しています。結合の順序は問いません。これは、次に示す2つの加算の結果が同じになることと共通しています。(8 + 4) + 2と8 + (4 + 2)では、どちらも結果は同じです。以下で示すコーディング例は、アロー関数の構文をサポートしていることを前提としています。Firefox（バージョン31）はアロー関数をネイティブでサポートしていますが、Google Chrome（バージョン36）はこの関数をサポートしていません。

恒等モナドは、最も単純なモナドです。値を単にラップするだけです。Identityコンストラクタが、unit関数の働きをします。恒等モナドを使った加算処理の例を次に示します。



Maybeモナドは恒等モナドと似ていますが、値を格納するだけでなく、値が存在しない状態を表すこともできます。Justコンストラクタは、値をラップする際に使います。また、Nothingは空の値を示します。基本的な使い方は、恒等モナドと同じです。

恒等モナドとの主な違いは、Maybeモナドは空の値を伝播することです。あるステップでNothingを返すと、モナドはそれ以降の演算をスキップして、Nothingを返します。次に示すコーディング例では、alert関数は実行されません。その前のステップで空の値が返されるからです。

この振る舞いは、特殊な値であるNaN（Not-a-Number）が数式の中に含まれている場合に似ています。演算の中間結果にNaNが含まれていると、NaNが演算結果として伝播されます。Maybeモナドは、null 値によって発生するエラーを防ぎたいときに使用します。次のコーディング例は、ログインしたユーザのアバターを返します。メソッド呼び出しの長いチェーンの中に空の値が含まれていないかどうかをチェックしないと、返されたオブジェクトがnullだった場合に、 TypeErrorが発生します。この問題の対策としては、もちろんnull値のチェックを組み込めばいいのですが、そうするとコードが冗長になりがちです。コードは正しくても、1行追加するとそれを何度も実行することになるからです。Maybeモナドはこんな場面の新たな解決策となります。空の値を検出すると、演算処理を中止します。



リストモナドは、非決定計算の値のリストを表します。このモナドのunit関数は値を1つ取り、その値を生成するジェネレータを返します。bind関数は全ての要素に対してtransform関数を適用し、その結果からすべての要素を生成します。配列やジェネレータは、反復可能なオブジェクトのため、bind関数を適用できます。下記の例は、ペアになっている全ての要素の和のLazyListを作成します。下記の記事は、JavaScriptジェネレータの幾つかの異なる適応例について書いています。

継続モナドは非同期のタスクに対して使用されます。幸い、このモナドはPromiseオブジェクトとしてES6に実装されているため、実装する必要はありません。

Promiseは基本的な継続モナドのいくつかの機能を拡張します。もし、thenが(promiseオブジェクトではない)単なる値を返した場合、モナド内で自動的に値をラップして、与えられた値で成功となる promiseオブジェクトを返します。さらに、promiseではエラー伝播も異なります。継続モナドは、計算処理中は1つの引数しか渡せません。しかし、promiseの場合、処理が成功した時に渡す値とエラーが発生した時に渡す値の2つの値を同時に保持しています。この点はEitherモナドと似ています。エラーは、thenメソッドへの2番目のコールバックを使用するか、特別な.catchメソッドを使用してキャプチャします。下記の記事は、promiseの適用例について書いています。

Haskellには、モナドコードを書く時に利用できる do記法という特別なシンタックスシュガーがあります。doをキーワードに始まるコードブロックをbind関数によって呼び出し可能なオブジェクトに変換します。JavaScriptでdo記法を模倣したのが、ES6ジェネレータです。すっきりとした、同期的に見えるコードができます。下記のように、Maybeモナドで使用したコード例では、bind関数を直接呼び出しています。上記と同じコードをジェネレータで表すと下記になります。yieldをそれぞれ呼び出すところで、モナドのラップ処理を取り消して、元の値を取得しています。この小さなルーチンは、ジェネレータをラップした後、yieldに渡される値でbindを呼び出します。このルーチンは、他のモナド、例えば継続モナドと同時に使用することができます。他のモナドとの整合性を保つため、then関数はbindというエイリアスとして記述される場合があります。ジェネレータとpromiseを同時に使用する方法についてさらに詳しく知りたい方は、Easy asynchrony with ES6（ES6で簡単に非同期処理）をお読みください。

モナドコードをさらに単純化するもう1つの方法は、プロキシの使用です。下記の関数は、モナドのインスタンスをラップして、不明なプロパティのアクセスや関数の起動をモナド内の値へ自動的に転送するプロキシオブジェクトを返します。このラッパーは、将来的に空になる可能性のあるオブジェクトの参照に安全にアクセスするために使用することができます。これは、CoffeeScriptの存在演算子 (?.)と同じような動作をします。アバターは存在しませんが、urlの呼び出しは成功し、空の値を作成します。このラッパーは、通常の関数呼び出しを継続モナドに引き上げる際にも使用できます。下記のコードはある特定のアバターを使用している友達の人数を返します。この例はメモリ内のデータを操作しているように見えますが、実際には非同期データを操作しています。プロパティのアクセスや関数の呼び出しは全てモナドに引き上げられたため、このラッパーは常にpromiseを作成し、もはや単純な値は作成しないことに注意してください。ES6プロキシについてさらに詳しく知りたい方はArray slicesをお読みください。
