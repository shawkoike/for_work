<p><a href="http://blog.fanout.io/2014/06/24/you-might-not-need-a-websocket/" rel="nofollow" title="" class="ext-link">You might not need a WebSocket</a>（2014-06-24）by <a href="http://fanout.io" rel="nofollow" title="" class="ext-link">Justin</a></p><p><small>(訳注：2015/8/4、いただいた翻訳フィードバックを元に記事を修正いたしました。)</small></p><p>本題に入る前に強調しておきます。WebSocketは優れた通信プロトコルです。実際私はこの<a href="http://tools.ietf.org/html/rfc6455" rel="nofollow" title="" class="ext-link">RFC6455</a>を、<a href="https://fanout.io/" rel="nofollow" title="" class="ext-link">Fanout</a>のサービスで使っている(<a href="https://github.com/fanout/zurl" rel="nofollow" title="" class="ext-link">Zurl</a>や<a href="https://github.com/fanout/pushpin" rel="nofollow" title="" class="ext-link">Pushpin</a>といったパーツで採用しています。Fanoutではまた、 <a href="https://github.com/primus/primus" rel="nofollow" title="" class="ext-link">Primus</a>（異なるリアルタイムフレームワーク間での通信を可能とするラッパー）を利用し、 <a href="https://fanout.io/docs/devguide.html#xmpp-client-access-from-the-browser" rel="nofollow" title="" class="ext-link">XMPP-FTWインターフェース</a>を介したWebSocket通信をサポートしています。</p><p>しかしながら私はこれまで、多くの広く普及しているアプリケーションにかなりの時間を費やし、おかげでRESTやメッセージングパターンについては多少なりとも理解が深まってきた今、実はWebSocketを実装した典型的なWebアプリケーション（もしくはWebSocketライクな抽象化レイヤ）の大部分は、WebSocket以外の別の手段を使った方がより良い動きをするのでは、と感じているのです。</p><p>ブラウザへのプッシュ送信を効率よく行う方法は、WebSocketだけではありません。XMLHttpRequestや<a href="http://en.wikipedia.org/wiki/Server-sent_events" rel="nofollow" title="" class="ext-link">EventSource/Server-Sent Events（SSE）</a>の仕組みを使って不定長のHTTPレスポンスをコンシュームし続けることでも、<a href="https://github.com/Yaffle/EventSource" rel="nofollow" title="" class="ext-link">最小限のハックで</a>、今普及しているあらゆるブラウザに<a href="http://caniuse.com/eventsource" rel="nofollow" title="" class="ext-link">継続的にデータを送信し続けることが可能</a>です。この方法は確かにサーバからブラウザの方向にのみデータを送信しますが、典型的なアプリケーションにとって解決が必要な課題はそれだけで、そしてこの課題はそんなに大きな問題ではありません。ブラウザ側からサーバにデータを送る時に問題が生じることはほとんどないからです。</p><p>アルノート・カゼミア―(<a href="https://github.com/primus/primus" rel="nofollow" title="" class="ext-link">Primus</a>作者、講演「<a href="https://speakerdeck.com/3rdeden/websuckets" rel="nofollow" title="" class="ext-link">WebSuckets</a>)は最近、EventSourceについて次のような<a href="http://vimeo.com/77289036" rel="nofollow" title="" class="ext-link">考察を投稿</a>しています。「（EventSourceが）あります。まさにクールなツールです。自動的に再接続できる機能があります。プロキシを通じて通信します。（中略）そしてストリーミングもできるのです。なぜ皆さんこんな便利なツールを使わないのですか？」全くその通りです。</p><p>ロングポーリングにはかなり厳しい小言が寄せられています。ロングポーリングにはかなり厳しい小言が寄せられています。リアルタイムWebの世界においてロングポーリングは当初、ストリームをエミュレーションするのに必要なハックとして大抵利用されていました。かつて<a href="http://xmpp.org/extensions/xep-0124.html" rel="nofollow" title="" class="ext-link">BOSH</a>が開発されたころ、私はXMPPのコミュニティで活動していたのですが、もちろん私たちはBOSHも巨大なハックとみなしていました。当時私たちが求めていたものはブラウザで動くストリーミング機能だけだったので、ソリューションはまるでHTTPにマッシュされているようなものでした。もちろん、<a href="http://socket.io/" rel="nofollow" title="" class="ext-link">socket.io</a>や<a href="https://github.com/sockjs/sockjs-client" rel="nofollow" title="" class="ext-link">SockJS</a>のような別のアイデアも同様の状況でした。</p><p>ご存知の通り、ロングポーリングはもちろんハックとしてではなくても使えます。FriendFeedは<a href="http://friendfeed.com/api/documentation#realtim" rel="nofollow" title="" class="ext-link">直感的に使えるロングポーリングAPI</a>を採用していますし、<a href="http://webhookinbox.com/docs/api.html#live-updates" rel="nofollow" title="" class="ext-link">WebhookInbox</a>でも同様です。Livefyreも<a href="https://github.com/Livefyre/livefyre-docs/wiki/StreamHub-API-Reference#streaming-new-content" rel="nofollow" title="" class="ext-link">このAPI</a>を使って、1億人以上のユーザへのサービス提供を実現しています。RealCrowdは最近、彼らの採用する<a href="http://code.realcrowd.com/restful-realtime/" rel="nofollow" title="" class="ext-link">RESTful Realtime</a>アプローチについて公表しました。何が重要かというと、この中でストリームをエミュレートするためにハックを使っているサービスは１つもないということです。クライアントがこれらのAPIにリクエストする際、クライアントは実はデータの同期を試みています。リアルタイムプッシュは結局データの同期を目的としてよく使われるものですから、こういったロングポーリングAPIの方がより正確に、クライアントが実際に達成しようとしていることを実現できる、と言えるでしょう。</p><p>ロングポーリングが批判される最も大きな理由は、クライアントがサーバを繰り返し呼び出さなければならない、という点です。とはいえ例えWebSocketを使っていてもほぼ確実に、ネットワークが落ちていないかどうか確かめるべく、ある程度定期的にピングは打ち続けるでしょう。ロングポーリングを用いて継続的にHTTP接続を提供し続けるということとWebSocketを使うということは、結局同じネットワークトラヒック量になるのです。</p><p>あなたはもしかして、ロングポーリングなんてIEの古くからのユーザをサポートし続けるだけの時代遅れの無意味なものだと思っていませんか？正反対ですよ。昔ながらのブラウザをサポートすることとは全く関係なく、ロングポーリングは<a href="http://blog.fanout.io/2013/03/04/long-polling-doesnt-totally-suck/" rel="nofollow" title="" class="ext-link">その他多くの理由によって優れている</a>と言えるのです。</p><p>かなり長いこと私は<a href="http://zguide.zeromq.org/page:all" rel="nofollow" title="" class="ext-link">ZeroMQをむやみに信奉</a>しすぎていたような気がします。双方向性ストリームを検討するよりもメッセージングパターンから考えた方がネットワークアプリケーションを簡単に設計できる、と感じていたのです。ではメッセージングパターンとは何のことでしょうか？最もよく挙げられる事例は、HTTPの基本的な動きを表すrequest-response型となります。さて、ブラウザからのAjaxリクエストを送る時ですが、あなたはTCPのことを気にする必要がない、ということに気付いていましたか？かつてそこに潜んでいた複雑な要素はどこかに行ってしまいました。実はリクエストに呼応して、新たなTCP接続が張られていたかもしれません。あるいは継続的な接続がまた設定されていたかもしれません。もしかしたら、リクエストないしはレスポンスが複数のIPパケットに入れ替わったのかもしれません。こうした事象をアプリケーションは一切気にすることなく、ただただリクエストを送ってレスポンスを受け取る、という動作だけに集中しています。ブラウザ側のSocketライブラリが、アプリケーションに文字通り”接続”を強いる傾向はありますが、これはもう時代遅れです。たいていの場合、接続はもうあまり重要な要素ではありません。</p><p>極言すれば、Webアプリケーション（もしくは同様のシンクライアント）はまさにrequest-response型／publish-subscribe型のメッセージングパターンさえあれば、必要なタスクを実行できるのです。そういう意味ではどんな双方向性ストリームレイヤでも、こうしたパターンを実装できる場合に限り有益です。request-response型は昔からのHTTP自体に既に実装されているので、publish-subscribe型の代替案のみ考える必要があります。</p><p>一般に連合化されたWebはこれらの2つのパターンが等しく実装されています。サーバ間での相互通信のほとんどは伝統的なrequest-response型HTTPによって発生し、同様にリアルタイムアップデートの際に使われるpublish-subscribe型によって、HTTPコールバック（旧名Webhooks）がしばしば発生するようになります。受信するためには、ブラウザ自体がパブリッシャに働きかける動的なエンティティとなりますが、それでもpublish-subscribe型が適用できるのです。</p><p>私たちが行う全てはHTTPベースでなければならない、ということを意図しているわけではありません。私はXMPPの標準化に長年注力していますから、こういった代替プロトコルを率先して広めてきている人物でもあるのです。ただ、ある特定のメッセージングパターンをHTTPにマッピングすることは、ディベロッパが想定していたより案外機能的だ、と最近気付いてしまったのです。</p><p>私はどちらかと言えば、 <a href="https://www.firebase.com/" rel="nofollow" title="" class="ext-link">Firebase</a>のアナント・ナーラーヤンに賛成です。彼は、ブラウザでリアルタイムメッセージングを使っているほとんどのディベロッパが懸命に <a href="http://vimeo.com/77352415" rel="nofollow" title="" class="ext-link">同期の問題を解決しようとしている</a>と言っています。WebSocketは、ほとんどのアプリケーションで直接使う必要のないプリミティブであり、ディベロッパは、WebSocket を利用する可能性があるデータ同期関連のAPIを活用する方がずっといいというのが彼の主張です。</p><p>この点を考慮して、（コミュニティとしての）私たちは、なぜ躍起になってWebSocketをサポートしていないブラウザでストリームをエミュレートしようとするのでしょうか？大変な思いをしてHTTP上で何かをハックするくらいなら、手間を省いてpublish-subscribeやデータ同期などの実際に必要なインターフェースをエミュレートすればよいのです。その方が必然的に何か他のレイヤを作ってストリームをエミュレートするよりいいはずです。</p><p>私はこの考えを基に、<a href="https://fanout.io/docs/protocols.html#fanout-pubsub-protocol-fpp" rel="nofollow" title="" class="ext-link">Fanout PubSub Protocol</a>を作成しました。これは、シンプルなpublish-subscribeプロトコルで、コネクション型双方向中間ストリーミングレイヤのないロングポーリングをベースにしています。よって、このプロトコルは、ストリームエミュレーションで動作する類似のpublish-subscribeプロトコル（例えばロングポーリング方式においてSockJS上で動作する<a href="https://github.com/meteor/meteor/blob/devel/packages/livedata/DDP.md" rel="nofollow" title="" class="ext-link">Meteor DDP</a>）に比べ、より軽く、より単純な構造になっています。また、ほとんど例外なく、ネイティブなWebSocket上で動作するどのプロトコルとも同じくらい高性能です。</p><p>確かに、アナントの説明したシステムでは、publish-subscribe型のメッセージングは依然としてプリミティブと捉えられていますが、それは構いません。このパターンをベースにデータ同期を行えば、エミュレートされたストリームの損失を考慮する必要がなく、効率もよくなります。</p><p>もちろん中には、WebSocketによって現状よりも大きなベネフィットがもたらされる事例もあります。</p><p><b>クライアントがサーバに高速送信しなければならない：</b>理論上は、XMLHttpRequestを使って無限のデータストリームをアップロードすることもできます。しかし、ブラウザやサーバでこれに対する充実したサポートがあったら、私はきっと驚くでしょう。ここで留意すべきなのは、サーバからクライアントに高速送信されるデータが大量にある場合、WebSocketが絶対に必要とは言えないということです。なぜなら、高速送信はEventSourceでも可能だからです。</p><p><b>ステートフルなコネクションプロトコル：</b>インバウンドデータとアウトバウンドデータを異なる伝送路で処理するのは、時に厄介です。何らかのスティッキーセッションがあって、クライアントからのデータ送信とクライアントへのデータ送信を常に同じサーバを介して行うための方法が必要なこともあるでしょう。この手法に頼ることなくWebがこれだけ長い間うまく続いているとしても、私はこの方法によって得られる効率性があると思います。</p><p><b>通信が自然に流れている：</b>ある特別なプロトコルをブラウザに実装しようとしていて、そのプロトコルは双方向ストリームで動作するようになっているとしましょう。この一例としてはWebSocket上でXMPPを使うケースが挙げられます。この場合、WebSocketの代わりにSockJSのようなエミュレートされたストリームを使うのは妥当だと言えます。というのも、ストリームはXMPPにとって最も自然な伝送だからです。でも、XMPPへのRESTバインディングもいいアイデアだと思います。</p><p>選択肢を知り、技術を理解しましょう。多くの人にとって、”リアルタイム”はWebSocketと同義で、他のものは全て時代遅れのレッテルを貼られています。私の見解では、WebSocketが絶対に必要なアプリケーションはほとんどないため、その使用に伴う複雑さも必要ありません。自分が解決しようとしている問題をメッセージングパターンの観点から考え、データ同期についても考慮してください。そうすれば、シンプルで、より適切なHTTPベースの手法が見つかるでしょう。</p><p><strong>訳注: 記事修正</strong></p><p>一部翻訳が適切ではな箇所がありましたので、下記の点を変更いたしました。<br>
ご迷惑をお掛けし申し訳ございません。ご指摘いただいた皆様、ありがとうございました！</p>
