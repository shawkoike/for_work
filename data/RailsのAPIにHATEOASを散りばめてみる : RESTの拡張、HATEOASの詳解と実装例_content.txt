Sprinkle some HATEOAS on your Rails APIs (2016-06-26) By Ilija Eftimov概念としてとしてのRESTは、Roy Fieldingが博士論文「Architectural Styles and the Design of Network-based Software Architectures」で導入したものです。その16年後、アーキテクチャとしてのRESTは、APIを設計・構築するための最も広く受け入れられた方法となっています。RESTについては私たちはみんな聞いたことがありますし、自分たちが実際にRESTfulなAPIを構築しているとほぼ皆が思っています。しかし、それは本当でしょうか？「RESTとは何か？」ということを自分たちにもう一度思い出させたうえで、さらにRESTを補う別の方法、「HATEOAS」と呼ばれるものの話に続けていきましょう。私はこれを説明するための良い方法について考えていたのですが、Ryan Tomakoによる「How I Explained REST to My Wife(私がどのようにしてRESTを妻に説明したか：和訳あり)」という珠玉の記事があり、これは私が過去に見た中で最高のRESTの説明でした。ざっくり言えば、REST(REpresentational State Transferの頭字語)とは、インターネットをその上に構築するためのアーキテクチャです。私の意見では、RESTを最も簡単に説明する方法はRichardson Maturityモデル(RMM)です。ここでは詳細には立ち入りませんが、もしRMMについてより詳しく知りたければ、Martin Fowlerによる「Richardson Maturity Model, steps toward the glory of REST」の記事を読むことをお勧めします。RMMはRESTを4つのレベルに分けて説明します。これらのレベル全てを、簡単に分析していきましょう。レベル1は、「どこか離れた場所、つまりリモートな場所(サーバ)でプロシージャコールを実行するためのプロトコル(HTTP)を使う必要がある」ということを示します。また、「そのプロトコルが提供するメカニズム自体は一切使わないが、あくまでリクエストやレスポンスを送るためのトンネルとして利用する」ということも意味しています。レベル2は私たち皆にとって大変なじみ深いものではないでしょうか。それはリソースです。過去に遡って、おそらく私が高校生だったころ、RPCはサーバの単一のエンドポイント上でのコミュニケーションで動作していました。これは「サービス・エンドポイント」と呼ばれます。APIにリソースを実装することで、リソースを表現する複数のエンドポイントを提供することができます。これは、「複数の目的を持つ単一エンドポイントを持つのではなく、APIが提供する各リソースについてエンドポイントを持つ」ということを意味します。レベル1とレベル2では、プロトコルのメカニズムは省略していました。何故かというと、ここではプロトコルを完全に活用する代わりに、呼び出しをトンネルすることだけを考えているからです。レベル3はこれを次のレベルに押し上げるもので(ダジャレのつもりです)、「あらゆるRESTfulなサービスは、クライアントがリソースとやりとりできるよう、HTTPの動詞を使う必要がある」ということを示しています。もしあなたがRailsの世界から来たのであれば、これについて既に知っているのではないかと思います。GET、POST、PUT、PATCH、DELETEの間には大きな違いがある、といった事ですね。もちろん、これらをバックエンドで違ったやり方で処理することができますし、これこそがRailsの輝く領域です。RailsはRESTに従うことをあなたに強く求めるのです。もしRMMのレベル3に従わない場合、API側でアクションごとに異なるエンドポイントを持つことになります。例えば、Petリソースがあるとして、新しいエントリを作成するには/pets/createを、更新するには/pets/updateを持つ、といった具合です。レベル3を使い、HTTP動詞を作用させ始めると、Railsによってとても簡易化された物を使うことができます。Petを得るためにGET /pets/:idを、新しく生成するためにPOST /petsを、更新するためにPATCH /petsを使う、といったものです。さて、RailsはRESTfulなAPIを書けるようになるための大きな助力をしてくれましたが、レベル4はあなたに降りかかってくる、実装すべきものとなります。これは、実はほとんど皆が従っておらず、またコミュニティとしても未だにその最善の達成手段が見つかっていないものです。ハイパーメディア・コントロールは、RESTの「聖杯」であり、「RESTfulであること」の究極のレベルです。「APIがレベル4に達しているとき、クライアントは特定のデータフォーマットでリソースを要求でき、ハイパーメディア・コントロールを用いてAPIじゅうをナビゲートできる」と述べられています。これが分かりにくければ、1歩戻ってブラウザとWebサイトで考えてみましょう。私たちがWebサイトを使うとき、普通はdomainname.tldという形、(ieftimov.comやgoogle.comなど)のエントリーポイントのみを知っています。そこから、ブラウザを通じてWebサイトとインタラクションすることにより、サイト内の異なるページへのナビゲーションができるようになります。ナビゲーションはリンクのクリックにより行われますね？「リンクがなく、サイト上のあらゆるURLを暗記して手動でタイピングしなければならない」というWebサイトを想像してみれば、こんなひどいサイトは他にない、と思うでしょう。これを念頭に置くと、ハイパーメディア・コントロールのアイデアは「リソースがリンクを提供することにより、リソースを利用するクライアントが、エントリポイント以外のエンドポイントの知識なしに自在にナビゲーション/インタラクションできるようにする」というものになります。通常のWebサイトにおいてはページが提供するリンクを通じてやり取りができますが、それと同様のものです。HATEOASなAPIが返すJSONレスポンスのフォーマットに少し話を進めていきますが、まずはHATEOASの重要なメカニズムである「コンテントネゴシエーション」について見ていきます。コンテントネゴシエーションはHTTPに埋め込まれたメカニズムであり、これによりWebサービスは異なるバージョン(あるいはフォーマット)の文書を提供することができます。RESTの用語でいえば、文書とはつまりリソースです。これはHTTPヘッダのAcceptグループによって得られます。例えば、Webページをリクエストする際、ユーザエージェント(ブラウザ)は以下の(あるいは似たような)ヘッダを送信します。内容はブラウザによって変わります。これは、サーバに対して「ユーザエージェントは文書をtext/htmlで受け取ることができ、また文書は指定された圧縮スキームで圧縮されていてもよい。フォーマットはen-US(イギリス英語)」ということを伝えます。APIに戻ると、Railsはコンテントネゴシエーションについても大変よい働きをしてくれます。現在アプリを構築する場合、リソースはふつうHTMLかJSON、あるいはXMLのいずれかを持つものと思われます。以下のようなコードを見たことがあるのではないでしょうか。あるいは、古いバージョンだとこうなります。これにより、indexアクションに対し、コンテントネゴシエーションを通じて3タイプのフォーマットでのリクエストを許容するよう命令することができます。HTML、JSONとXMLは実際のメディア(またはMIME)タイプです。例示したヘッダを見て、qというパラメータに気付いたかもしれません。これはQuality Valueと呼ばれ、あるコンテントタイプを他のコンテントタイプよりも重要にする、というものです。言い換えれば、qパラメータは、紐付られたコンテントタイプについて、その「望ましさ」に相対的な重み付けを与えます。例えば、以下のようなAcceptヘッダがあるとします。このヘッダは、サーバに対して「クライアントは、XMLよりも断然JSONを望んでいる」ということを伝えます。qの値が指定されていなければ、その値はデフォルトで1となります。コンテントネゴシエーションについては、RFC 7231でより詳しい説明を読むことができます。それでは、HATEOASとは何でしょう？これはRESTと同様に頭字語であり、「Hypermedia As The Engine Of Application State」に由来しています。うーん、なんと長く発音しにくいことでしょう？ここまで言及してきたように、RMMのレベル4は「APIはナビゲーション/インタラクションのためのハイパーメディア・コントロールを提供すべきである」ということを述べています。しかし、HATEOASはこれとどう関係するのでしょう？RESTは「表現可能な状態の転送(Representational State Transfer)」を意味するのに対し、HATEOASは「アプリケーション状態のエンジンとしてのハイパーメディア(Hypermedia As The Engine Of Application State)」を意味する、ということについて考えてみましょう。名前だけに着目すると、HATEOASはRESTのメカニズムの一つだと考えられます。アプリケーションの状態と状態遷移に関するすべてを解決してくれるものです。複雑すぎるでしょうか？リソースの普通のJSON表現を例として見てみましょう。どこかのサーバでの、私のユーザ情報を例にしてみます。実にシンプルですね。それでは、このリソースの表現にHATEOASを適用すると、このようになります。linksを提供することで、アプリケーション状態(API側でのデータ変更)のエンジン(利用可能なアクションのリスト)としてのハイパーメディア(この場合JSON)をクライアントが使うことができます。ここでのアイデアは、「一つのAPIまたはリソースに対してはエントリポイントは単一であるべきで、リソースの表現はそのリソース上で実行できるすべてのアクションを含むべきである」というものです。これは、「APIを利用するクライアントはUserリソースのself属性を使うことができ、この属性をアクションを実行できるエンドポイントとして考えることができる」ということを意味します。APIがRESTfulであることを知ることで、クライアントはそのリソースを更新する方法がわかるのです。また、削除する方法もわかります。さらに、このユーザのロール全てを見たい場合、ユーザにとってrolesという関係にあるリソースに対してGETリクエストを実行することもできます。見てわかるとおり、HATEOASを組み合わせることで、クライアントは「リソースからURIを得る」「APIがレベル3のRESTfulであることを仮定する(=HTTP動詞を利用する)」だけでリソースとやりとりできます。自分のRailsのAPIをRMMのレベル4実装にするにはどうすればよいでしょう？例を見てみましょう。ここでのAPIはブログCMSの一部とします。Authorモデルがあり、このモデルはArticleモデルに対して1対多の関係があります。つまり、Authorが複数のArticleを持つことができます。Authorモデルは以下のようになり、Articleモデルは以下のようになります。ルーティングは次のようになります。最後に、ArticleとAuthorの両モデルについてシリアライザがあります。この例では、Active Model Serializersを使います。Authorオブジェクトは全てAuthorSerializerによってシリアライズされます。まずはシリアライザに必要な属性を加え、その拡張について後程解説していきましょう。AuthorSerializerクラスは以下のようになります。とてもシンプルですね！この短い例でも、データのコンテキストを見えたままにしておくために、アノテーションをそのまま残しておきます。私の普段の仕事では、データの構造を忘れてしまった場合、アノテーションの追加ではなくスキーマファイルの確認によってそれを調べています。GET /authorsリクエストを送って、データがどのようになるか見てみましょう。リファレンスのため、AuthorsControllerのindexアクションの実装にしておきます。このリクエストは、以下のようなJSONを返します。データベースにAuthorインスタンスが1つしかないため、その1つのみが帰ってきています。また、このAuthorは関連する2つのArticleインスタンスを持つため、シリアライザはこれをレスポンスに含めています。さて、シリアライザが動くようになりました。次のステップは、これをlinksで拡張することです。これはActive Model Serializersを使えばとても些細なことです。links属性をシリアライザに加え、属性の実装(実際はこれはメソッドになります)をクラス内に提供することが必要になります。見ての通り、実装は極めてシンプルです。linksという新しい属性を追加し、メソッドがただハッシュの配列を返します。初心者向けに、ここではselfリンクだけを持たせました。このselfリンクは、いまその表現を見ているリソースを指しています。しかし、ここでcurlリクエストを再び行うと、以下のようなエラーが返ってきます。Railsのルーティングのヘルパーがシリアライザのスコープに含まれていないために起こっています。シリアライザにこれを含めることで容易に解決できます。ここで再びcurlのリクエストを実行すると、以下のように、JSONの中にlinkを見つけられます。素晴らしい！リソースに少しばかりHATEOASを加えることができました。さらに多くのハイパーメディアをリソースに加え続ける前に、いくらかの考察を加える必要があります。見てわかるとおり、何も考えずにlinks属性をシリアライザに実装しましたね。「私はAPIの製作者で、APIのレスポンスは私が思うままに構築する」とおっしゃることでしょう。ええ、確かにあなたはAPIの作者ですが、その宣言は正しくありません。「我々がみんな、ハイパーメディアの実装方法を個別に考えたらどうなるか」と想像してみるとどうでしょう？全てのAPIがそれぞれハイパーメディア・コントロールに関して異なってしまい、進むべき道を探しても地獄のようになってしまうでしょう。そうです、悲しいことに、私たちはまだHATEOASをどう行うかを知らないのです。より良い言い方をするならば、私たちはまだHATEOASを行うための最善の方法を知らないのです。それゆえに、人々は仕様を策定しようとしてきましたし、そのうちいくらかは採用されてきました。HALのドキュメントには、以下のように書かれています。見てわかるとおり、HALの背後にあるモチベーションは、ハイパーメディア・コントロールを追加するための簡単かつ一貫した方法を作ることです。他の仕様と同様に、HALはJSONとXMLの両方についてハイパーリンクの表現のための規約を提供しています。以下はHALを適用したJSONの例です。JSON APIもHALと同様のものです。2013年にYehuda Katzによって初めて草案が作られました。この最初の草案はEmber DataのRESTアダプタによって暗黙的に定義されたJSON転送からとられています。そこから、JSON APIは多少の指示を得たものの、API仕様のデファクトスタンダードだと確信を持って言うことはできません。JSON API仕様を適用したJSONの例が以下になります。ご想像の通り、人々がよいJSONの標準を作ろうとしてきた試みは実に多いです。より有名な仕様にはJSON for Linking Data(JSON-LDとも)、Collection+JSON、SIRENがあります。JSON APIが勢いをつけてきており、Active Model Serializersがそのとても良いインテグレーションであるため、これに照準を定めて実装を続けていきます。高水準でのActive Model Serializersの動作は、シリアライザとアダプタの2つのパートに分かれます。ドキュメンテーションには以下のように書かれています。私たちのJSONをJSON APIフォーマットにシリアライズするため、異なるアダプタを使う必要があります。信じるかどうかはお任せしますが、これは:json_apiと呼ばれます。個人的には、このタイプのコンフィギュレーションはinitializerファイル内でするのが好きです。アダプタを:json_apiに設定することで、APIがJSON API仕様でフォーマットされたJSONを生成/利用するようになります。先ほど行ったAPIの呼び出しと同じものを実行すると、新たなフォーマットのJSONを得ることができます。お気づきの通り、ここで返ってきたJSONは先ほど得られたJSONと比較すると全く異なる構造になっています。この理由は、使っているJSON APIアダプタがJSONをJSON API仕様にフォーマットしているからです。JSON APIアダプタに関してもう一つ素晴らしい点は、素晴らしいDSLを使ってリンクをとても明示的に書けることです。また、linksを属性として指定する必要がなく、先ほど書いたシリアライザでRailsのurlヘルパーをミックスインしていたincludeの行を消すことができました。/authorsエンドポイントをGETリクエストで再び呼んでみると、拡張されたJSONを見ることができ、これもまたJSON APIの仕様に従っています。AMSはとても素晴らしく、controllerに追加のリソースを含めることでJSONにもそのリソースを加えることができます。Articleの関係性をAuthorモデルに含めることで、JSONの結果を各ユーザの関連記事で拡張することができます。これはとても素晴らしいですが、これを行うとフェッチするすべてのリソースについてN+1クエリが増えることに用心してください。「showアクションは追加のリソースを含む傾向があるのに対し、indexアクションはふつう要求されたリソースしか返さない」ということの理由はこれです。これにより、リクエストしたauthorに関連するarticle全てが追加されます。お気づきの通り、has_manyアソシエーションをシリアライザに追加したため、AMSは含まれる各リソースに使うべき正しいシリアライザをわかっています。これにより、含められるリソースとリクエストされるリソースの間の構造を同じにすることができ、結果に一貫性が生まれるとともにJSONのパースが容易になっています。ここで、リソース間のナビゲーションがどれほど容易かを実際に見てみるため、ArticlesController#showも実装してみましょう。とてもシンプルです。Articleをauthor_idとidのパラメータによって見つけ、JSONにレンダリングします。GET /authors/1/articles/2を呼ぶことで、ArticleオブジェクトのJSON API表現を得ることができます。もしPostman(私はこれを使うのをとても楽しんでいます)やその他のAPIブラウザをエンドポイントのテストに使っているのであれば、リソースのナビゲーションがどれほど容易かを見ることができるでしょう。Webブラウザと同じように、分かっているのはエントリポイントのlocalhost:3000/authorsです。ここから、Authorのlinksプロパティをクリックして単一のAuthorリソースを入手します。このリソースを全ての関連リソースと共に見ることで、Articleリソースに含まれるリンクのどれかをクリックすることができ、その属性をJSONフォーマットで得ることができます。これこそが、HATEOASが基本的に意味するところです。リソースのJSON表現内で提供されるエンドポイントを通じてリソースとのナビゲーション/インタラクションを行うのです。ここまで見てきたとおり、HATEOASとは何かを理解・学習するためには、頭に入れておくべき文脈が少しばかりありました。しかし、その全ては時に極めて複雑に見えますが、RailsのおかげでHATEOASなAPIの実装は極めて簡単になっています。その簡単さは例で見てきたとおりです。もちろん、ハイパーメディア・コントロールについてはもっと学ぶべきことが色々ありますが、ここで示した例は「ちょっと体験してみる」というのには十分すぎるほどだったでしょう。また、HATEOASの概念は一見大変複雑に見えますが、いざ分析してみるととてもシンプルなものです。なぜなら、私たちは同じ挙動をWebブラウザで既に見ているからです。「なぜとても複雑に見えるのか？」という問題ですが、これは「私たちが普通のWebサイトをRESTfulなAPIのように見たことがないから(逆もまた然り)」という理由です。この記事で使ってきたエンドポイントの実際の実装を見たければ、GitHubのこのリポジトリをチェックしてみてください。Fotos Georgiadisは、この投稿の草稿に多くのコメントをしてくれました。また、彼は私をRESTやHATEOASに関する議論に引き込んでくれて、その議論をどのようにしたらより濃厚にできるのかについて多くの有用な情報と共に提案してくれました。
