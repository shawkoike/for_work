Typelevel quicksort in Scala (2015-05-22) by Julien TournayScalaの型システムが先進的であることは、皆さんもご存じのことかと思います。この投稿では、Scalaの型システムのみを使ったクイックソートアルゴリズムの実装方法をご紹介したいと思います。なお、ここで紹介するデモの完全なコードはこちらをご覧ください。まずは準備から。ソートアルゴリズムを実装するには、ソートする対象が必要ですよね。ここでは自然数を用います。もちろん、Scalaの型システムには利用可能な自然数はありません。そんなわけで、全ての自然数の型を作る必要があります。型を無限に作るというのは、恐らく時間の浪費になるでしょうから、ここはもう少し賢い手を考えます。そう、数学を使いましょう。ペアノの公理とは、自然数を形式的に定義するためのシンプルな方法のことです。ペアノの計算法についてより詳しく知りたい方はWikipediaをご覧ください。これらの公理を頭に入れておくと、Scalaの型システムで自然数を表現するのが簡単になります。まずはNatトレイトを作成してみましょう。これらのクラスを定義すれば、どんな自然数も表現できるようになります。早速1から5までの自然数を定義してみましょう。簡単ですよね。これらの数字が実際に利用可能かを証明するため、足し算の実装をします。ここで再び、ペアノを参照することにしましょう（画像はWikipediaより）。分かりにくいかもしれませんが、これで十分です。幸い、ほとんどこのまま型に変換します。ここで示したScalaでの変換は、私が臆面もなくshapelessから取ってきたものです。以降、説明に必要なものがshapelessに存在している場合は、そこから取ってくることにします。「偉大な芸術家は盗む」って言いますよね（それに私は怠け者ですし）。もちろん、参考したところについては逐一言及します。それから、より明快にするため、関係ないと思われる一部のコードを削除する場合はあります。それでは、以下がshapelessのSumです。この素晴らしさに少し圧倒されているのでないでしょうか。まずはゆっくりと深呼吸し、1つずつ見ていきましょう。Sumは2つの自然数AとBを受け取り、別の自然数Outを返します。この型レベル関数の作成に使われているのが依存型です。Out型はAとBに依存しています。つまり、ScalaにAとBを与えれば、何がOutかを魔法のように算出するというわけです。これで足し算の表現方法が分かりましたね。A + B = Outです。表現まではできたので、次は実際に2つの自然数を足した結果を算出してみましょう。任意の自然数bに対し、0 + b = bというのが、私たちの定義する足し算の基本ケースです。applyメソッドを用いて、このケースをテストしてみましょう。その他のケースは帰納法により定義されます。これの示すところは、2つのNatがAとBとするなら、S(A) + B = A + S(B)であるということです。これはWikipediaで定義されている公理とは異なりますが、以下の理由から同等と言えます。そこで、暗黙の解決によって3 + 1の足し算を評価しようとすると、Scalaのコンパイラは次のステップを踏むことになります。ScalaのREPLでテストしてみましょう。型システムで基本的な計算ができますね。クイックソートを実装するには、自然数を比較できるようになる必要があります。ここで再び、shapelessが役に立ちました。先ほどのように、基本となるケースである、0だけをカバーし、帰納的に他の全ケースに当てはめます。ゼロは最小の自然数なので、∀x∈N. 0 &lt; S(x)となります。すぐにテストしてみます。ご存知のように、型は命題であり、プログラムは証明です。型LT[_0, _1]という値があるので、コンパイラは0 &lt; 1であることを証明しただけです（Curry-Howard対応をご覧ください）。他の場合は全て、∀ x,y ∈ N. S(x) &lt; S(y) ⇔ x &lt; yのように、先行する数字を単に比較するだけです。再度、コンパイラは基本となるケースへのステップをたどります。では、テストしてみましょう。クイックソートを実装するには、≥も使用します。Shapelessには≥はありませんが、≤を提供しているので、代わりにこちらを使用します。以下のコードがどのように機能するかお分かりになると思います。さて、ここまで、自然数の扱い方を見てきましたが、ソートするには、自然数のリストも必要になりますね。しかし、リストはどのように機能するのでしょうか。以下は、Scalaのリストを簡素化したものです。リストは再帰的に定義され、次の2つの状態になり得ます。リストの型を表すために、HListを使います。HListは、型システムに反復が生じない限り、全く同じように定義されます。繰り返しになりますが、HListはshapeless内で既に定義されています。従来のリストのように、HListも空であるか、もしくはheadとtailがあるかのいずれかです。どちらのリストも定義が非常によく似ているのが分かりますね。本来は、HListも値を格納するリストです。今は、型システムの話をしているので、はっきりと分かるように不要なコードを削除しました。それでは、自然数の型レベルリストを作成してみましょう。必要なものはほとんど準備できました。まずはパーティションを作成し、HListを3つの要素に分割しなければなりません。今回は、shapelessからはビルトインは提供されていないので、自力で対処します。小さい要素を見つけ出すことから始めましょう。与えられたリストHと、自然数Aがあります。ここから、新しいHlistを作成したいと思います。では、解決策の実装を始めましょう。先ほどのように、基本となるケース、つまり空のリストから始めます。ここで”他にはどんなケースがあるのか”と、考えてみる必要があります。リストを使った関数の機能を決める際に、通常、最初の要素（head）でパターンマッチを行い、それをtailまで、再帰的に呼び出します。やることは、それだけです。その場合、2つのケースが考えられます。最初の要素がピボットより小さいかピボットと等しい場合は、維持します。上記以外の場合は、無視します。コードをテストしてみます。ピボットより大きい型のサブリストも、同様の方法で取得できます。再度テストしてみます。ゴールはもうすぐです。クイックソードのアルゴリズムでは、リストの連結が必要です。Hlistの先頭に、別のHlistを追加する方法を実装しなければなりません。ここまでの過程で、自分で方法を見つけられるくらいに十分に内容を理解されていると思います。テストしてみます。ついに最終段階です。クイックソートの実装に必要なものはすべてそろいました。あとは、それらを統合するだけです。ソートのアルゴリズムは、リストを与えると、リストを返します。先ほどと同じように、最初は基本となるケースを扱います。空のリストをソートすると、空のリストが返されます。次に、帰納的なケースです。おっと、今回はかなりたくさんの型がありますね。ありがたいことに、それほど難しくはありません。

3. サブリストをソートします。4. 小さい型のソートしたリストとピボット、そして大きい型のソートしたリストを連結します。これで終了です。結果は、preps.Outです。最後のテストをしてみましょう。
