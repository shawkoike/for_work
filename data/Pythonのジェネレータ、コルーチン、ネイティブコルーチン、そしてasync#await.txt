<p><a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html" rel="nofollow" title="" class="ext-link">PYTHON GENERATORS, COROUTINES, NATIVE COROUTINES AND ASYNCAWAIT</a> (2015-11-13) by <a href="http://masnun.com/author/masnun" rel="nofollow" title="" class="ext-link">Abu Ashraf Masnun</a></p><p>ドラマ『Doctor Who』のファン。Unix系オペレーティングシステム、オープンソースが大好きでソフトウェアの製作に情熱を注いでいる。趣味は音楽、プログラミング、ゲーム『Urban Terror』で遊ぶことである。</p><p>(訳注:2016/3/9、いただいたフィードバックを元に記事を修正いたしました。)</p><p>注意： この記事で書かれている機能は、大部分がPython 3.4で導入されたものです。ネイティブコルーチンとasync/await構文はPython 3.5でサポートされました。そのため、本記事に記載されているコードを試す場合はPython 3.5の利用をお勧めします。</p><p>ジェネレータは値を<strong>生成する</strong>関数です。普通、関数は<code>return</code>で値を返したあと、その下層のスコープは破棄します。関数を再度呼び出す場合、その関数はゼロから起動されることになります。つまり1回限りの実行となります。しかしジェネレータ関数は値を<code>yield</code>で返し、関数の実行を一時停止します。その後、関数を呼び出したスコープにコントロールが移ります。関数を再び呼び出して次の値を(存在すれば)得たい時は、実行を再開することができます。では、以下の例をご覧ください。</p><p>注意していただきたいのは、ジェネレータ関数が値を直接返すことはないということです。ジェネレータ関数を呼び出すと、反復処理が可能な<strong>ジェネレータオブジェクト</strong>が返されます。そのため、ジェネレータオブジェクトで<code>next()</code>を呼び出し、値を繰り返し生成することが可能です。または、<code>for</code>ループを実行することもできます。</p><p>では、どうすればジェネレータを便利に使えるのでしょうか？　例として、上司から100までの連続した数字を生成する関数を書くように言われたとしましょう。（<code>range()</code>をものすごくシンプルにしたバージョンのようなものです）。あなたが書いてみたコードは、空のリストを用意し、そこに数字を順に入れ、数字とともにそのリストを返すというものでした。しかしそこで要求事項が変更され、1000万までの連続した数字を生成する必要が出てきたとしましょう。もし1000万個の数字をリストに格納しようとすれば、すぐにメモリ不足に陥ってしまいますね。そのような状況で役立つのがジェネレータ関数です。リストに数字を格納しなくても、数字を生成できます。コードは以下のようになります。</p><p>ここでは、あえて数字が9に達したら終了するように作っていますが、コンソールで試してみれば、どのように次から次へと数字が生成されるのかを見られるでしょう。関数のコンテキストを行ったり来たりすることで、一時停止とレジュームを繰り返しているのです。</p><p><strong>まとめ:</strong> ジェネレータ関数は一時停止が可能で、1つの値だけを返すのではなく複数の値を生成することができる関数です。呼び出されると、反復処理が可能なジェネレータオブジェクトを返します。この反復処理で（繰り返しで）、値を1つずつ得ることが可能です。</p><p>前のセクションで、ジェネレータを使うと関数のコンテキストからデータをプルできる、つまり引き出せること（また、実行を一時停止できること）を説明しました。では、データをプッシュしたい場合はどうでしょうか。コルーチンが利用できます。値をプルするために使った<code>yield</code>というキーワードは、関数内部の表現（”=”の右側）としても使うことができます。また、関数に値を返すために、ジェネレータオブジェクト上で<code>send()</code>メソッドを使うこともできます。これは”ジェネレータベースのコルーチン”と呼ばれています。例をご紹介しましょう。</p><p>ここでは何が起こっているのでしょうか。まずはいつも通り、<code>next()</code>関数を使って値を得ようとします。すると、<code>yield "Hello"</code>へ来て、”Hello”を得ることができます。次に<code>send()</code>メソッドを使って値を送ります。これで関数が再開されます。<code>hello</code>に送った値を指定し、次の行まで進んで命令を実行します。そうして、<code>send()</code>メソッドの戻り値として”World”が得られます。</p><p>ジェネレータベースのコルーチンを使う際、”ジェネレータ”と”コルーチン”は同じものとして扱う場合が多いです。完全に同じものではないのですが、交換可能な場合が非常に多いのです。しかし、Python 3.5では、ネイティブコルーチンと共に<code>async/await</code>というキーワードがあります。これについては、この投稿内で後ほど説明しましょう。</p><p>Python 3.4から新たに<a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow" title="" class="ext-link">asyncio</a>モジュールが加わりました。これは、一般的な非同期プログラミングで役立つ、素晴らしいAPIを提供しています。コルーチンをasyncioモジュールと一緒に使うことで非同期入出力を容易に行えるようになります。公式ドキュメントから例をご紹介しましょう。</p><p>とても分かりやすいコードになっています。コルーチン<code>display_date(num, loop)</code>を作ります。これは識別子（数字）とイベントループを使い、現在時刻を表示し続けます。そして、<code>yield from</code>キーワードを使って、<code>asyncio.sleep()</code>関数の呼び出し結果を待ちます。この関数は、与えられた秒数が経過した後に完了するコルーチンです。そのため、ランダムな秒数を与えます。そして、デフォルトのイベントループ内にあるコルーチンの実行スケジュールを決めるために、<code>asyncio.ensure_future()</code>を使います。それからループし続けるよう設定します。</p><p>出力を見ると2つのコルーチンが実行されているのが分かります。<code>yield from</code>を使うと、しばらく忙しくなると分かるので、イベントループはコルーチンの実行を一時停止し、別のコルーチンを実行させます。そのため2つのコルーチンが実行されるのです（イベントループは単一のスレッドなので並行して実行はされません）。</p><p><code>yield from</code>は、<code>for x in asyncio.sleep(random.randint(0, 5)): yield x</code>の素晴らしい糖衣構文であり、非同期のコードをより明瞭にしてくれます。</p><p>ところで、これはまだジェネレータベースのコルーチンを使っています。Python 3.5では、新たにasync/await構文を使うネイティブコルーチンが加わりました。以前の関数は以下のように書くことができます。</p><p>6行目と12行目をご覧ください。ネイティブコルーチンは、<code>def</code>キーワードの前の<code>async</code>キーワードで定義しなければいけません。ネイティブコルーチン内部では、<code>yield from</code>の代わりに<code>await</code>キーワードを使います。</p><p>ネイティブコルーチンとジェネレータベースのコルーチンの間で機能的な違いはありませんが、構文だけ異なります。そのため構文を混ぜて使うことはできません。つまり<code>await</code>をジェネレータベースのコルーチンの内部で使ったり、<code>yield</code>や<code>yield from</code>をネイティブコルーチンの内部で使ったりすることはできないのです。</p><p>このような違いがあるにも関わらず、この両者を相互運用することができます。従来のジェネレータベースのコルーチンに<code>@types.coroutine</code>というデコレータを加えるだけでいいのです。これで、どちらかのコルーチンを、別のコルーチンの内部で使えるようになります。つまり、<code>await</code>をネイティブコルーチンの内部にあるジェネレータベースのコルーチンから使ったり、<code>yield from</code>をジェネレータベースのコルーチン内部のネイティブコルーチンで使ったりすることができます。例をお見せしましょう。</p>
