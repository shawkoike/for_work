<p><a href="https://matt.sh/howto-c" rel="nofollow" title="" class="ext-link">How to C in 2016</a> （2016-01-07） by <a href="https://twitter.com/mattsta" rel="nofollow" title="" class="ext-link">Matt Stancliff</a></p><p>(訳注：2016/3/2、いただいた翻訳フィードバックをもとに記事を修正いたしました。)</p><p>(訳注：著者のMattより、「本文中で明言はしていないが、この記事の内容はx86-64 Unix/Linux/POSIXでアプリケーションをプログラミングする場合にフォーカスしている。他のプログラミング領域では、対象とするシステムに応じた(例： 8-bitの組み込みシステム、10年前のコンパイラ、多くの異なるCPUアーキテクチャで動く必要のあるアプリケーション、Win/Linuxでのビルド互換性など)特有のアドバイスが必要」との補足を頂いております。)</p><p><em>以下の文章は2015年の始めに書いたドラフトで、今まで公開していませんでした。私のドラフト用フォルダの中で誰の目も引かなかったため、大部分が書いた時のままです。公開するにあたり、単純に2015年を2016年に変更しました。</em></p><p>必要な修正、改善、苦情がありましたら、いつでも<a href="mailto:matt@matt.sh">Matt</a>までご連絡ください。</p><p><a href="https://github.com/AdrianArroyoCalle" rel="nofollow" title="" class="ext-link">Adrián Arroyo Calle</a>が、<a href="https://adrianarroyocalle.github.io/blog/2016/01/10/como-programar-en-c-en-2016/" rel="nofollow" title="" class="ext-link">¿Cómo programar en C (en 2016)?</a>で、スペイン語版を公開しています。</p><p><a href="https://github.com/Keith-S-Thompson" rel="nofollow" title="" class="ext-link">Keith Thompson</a>が、<a href="https://github.com/Keith-S-Thompson/how-to-c-response/blob/master/README.md" rel="nofollow" title="" class="ext-link">howto-c-response</a>で、一連の修正と代替案を出しています。</p><p><a href="https://twitter.com/erratarob" rel="nofollow" title="" class="ext-link">Rob Graham</a>が、<a href="http://blog.erratasec.com/2016/01/some-notes-c-in-2016.html#.Vr1bSfmLSHs" rel="nofollow" title="" class="ext-link">Some notes C in 2016</a>で、ここのスコープの外側で他の方法を載せた感想を投稿しています。</p><p>さあ、ここから本編が始まります。</p><p>C言語の第1のルールは、「もし避けられるならC言語を使うな」ということです。</p><p>もしC言語を使わざるをえないなら、最新のルールに従ってください。</p><p>C言語は<a href="https://www.bell-labs.com/usr/dmr/www/chist.html" rel="nofollow" title="" class="ext-link">1970年代の始め</a>に登場しました。C言語が進化する過程の中で、人々はその時その時の「C言語を習得」しました。しかし、習得したあと知識がそこで留まり、学び始めた時期のC言語が全てだと考え、人によって異なる一連の知識を持ってしまいました。</p><p>C言語の開発では「80年代90年代に学んだ事柄」に留まろうという気持ちを捨てなくはなりません。</p><p>ここでは、最新の基準に適合した最新のプラットフォームのもとで、過去のプログラムに対して過大な互換性を求めないことを前提としています。ある種の会社が20年前のシステムのアップグレードを拒否するというだけで、何もかもがいにしえの基準に縛られるべきではありません。</p><p>新しいコードに、<code>char</code>、<code>int</code>、<code>short</code>、<code>long</code>、<code>unsigned</code>などの型を使おうとしているなら、それは誤りです。</p><p>最新のプログラミングでは<code>#include &lt;stdint.h&gt;</code>と記述し、<em>標準</em>データ型を使用するべきです。</p><p>さらなる詳細は<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html" rel="nofollow" title="" class="ext-link">stdint.h仕様書</a>で確認してください。</p><p>一般的な標準データ型は以下のとおりです。</p><p><code>char</code>はもう使わないので注意してください。実際、C言語では<code>char</code>は誤った名称で誤った使い方をされています。</p><p>開発者は、符号なしバイトを操作する時でさえ<code>char</code>を”バイト”として、常習的に乱用しています。<code>uint8_t</code>を単一の符号なしのバイトや1バイト（8ビット）の値として使い、<code>uint8_t *</code>を符号なしのバイトのシーケンスや複数のバイトの値として使う方がずっと単純明快です。</p><p><code>uint16_t</code>や<code>int32_t</code>のように固定された標準の幅に加え、<strong>fast</strong>型と<strong>least</strong>型も<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html" rel="nofollow" title="" class="ext-link">stdint.h仕様書</a>に定義されています。</p><p><strong>fast</strong>型は以下のようになっています。</p><p>fast型は最低限でも<code>X</code>ビットを提供しますが、実際の記憶領域が要求通りのサイズになっているとは限りません。ターゲットとするプラットフォームでは大きい型の方がサポートが充実している場合、<em>fast</em>型は自動的にサポートの手厚い、大きな型を使います。</p><p>最もいい例を挙げましょう。64ビットのシステムで<code>uint_fast16_t</code>を要求すると<code>uint64_t</code>を得ます。ワードサイズの整数で操作する方が、16ビットの整数で操作するよりも速いためです。</p><p><em>fast</em>型のガイドラインは全てのシステムに対応しているわけではありませんが、対応している代表的なシステムはOS Xです。OS Xでは<em>fast</em>型は<a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/stdint.h" rel="nofollow" title="" class="ext-link">対応部分の固定幅にぴったりと一致すると定義されています</a>。</p><p>fast型は、コードの自己説明性という点でも便利です。例えば、16ビットしか計算に必要ないのに、プラットフォームで速く処理するために64ビットの整数を使いたいとします。この場合は<code>uint_fast16_t</code>が役に立ちます。<code>uint_fast16_t</code>は、文書内のコードレベルでは「16ビットしか必要ない」としながらも、64ビット以下のLinuxプラットフォームで処理の速い64ビットで計算をしてくれます。</p><p>fast型で知っておくべきことは、一部のテストケースに影響を与えることがあるということです。記憶領域幅のエッジケースをテストする必要がある場合、一部のプラットフォーム（OS X）上では<code>uint_fast16_t</code>を16ビットとし、他のプラットフォーム（Linux）上では64ビットとします。そのため、テストを合格させなければならないプラットフォームの最低限の数が増えてしまうのです。</p><p><em>fast</em>型は、プラットフォームによってサイズが変わる<code>int</code>型と同じような不確かさがあります。しかし<em>fast</em>型であれば、コード内の安全だと分かっている範囲に不確かさを制限できます（カウンタや、確認済みのバインド付きの一時的な値など）。</p><p><strong>least</strong>型は以下のようになっています。</p><p>least型は、リクエストした型に対して、最も<em>コンパクトな</em>ビット数を提供します。</p><p>実際のところ、<em>least</em>型のガイドラインは標準的な固定幅の型に対してleast型を定義したに過ぎません。なぜなら、標準的な固定幅の型は要求された最小のビット数の正確な値をすでに提供しているからです</p><p><code>int</code>が大好きな方もいるでしょう。絶対に手放さないという方もいるはずです。しかし、型のサイズが想定しているサイズから変わってしまったら、正確にプログラミングすることは技術的に不可能です。</p><p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html" rel="nofollow" title="" class="ext-link">inttypes.h</a>に書かれた<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html#tag_13_19_06" rel="nofollow" title="" class="ext-link">RATIONALE（理論的根拠）</a>の項も読んでみてください。幅の固定されていない型を使うと危険だという理由が分かります。あなたがとても頭がよく、「<code>int</code>を使ったあらゆる場所で全ての16ビットと32ビットのエッジケースをテストする一方で、あるプラットフォーム上では<code>int</code>が16ビットであり、別のプラットフォーム上では32ビットであると理解しながら開発できる」というのであれば、心置きなく<code>int</code>を使ってください。</p><p>それ以外の人、私たちのような、頭の中でマルチレベルの決定木プラットフォームの詳細なヒエラルキー全体を把握できない人は、固定幅の型を使って、正確性の高いコードが自動的に手に入るようにしましょう。概念的に難しい問題が大幅に減り、テストによる間接費もずっと削減できます。</p><p>仕様書では、｢ISOが定めたC言語の標準整数拡張ルールは、予告なく変更する場合があります｣と、さらに簡潔に説明しています。</p><p>うまくこれと付き合いましょう。</p><p>2016年の現在、<code>char</code>の使用を<em>唯一</em>許されるのは、以前から存在するAPIが<code>char</code>を要求した場合（例えば<code>strncat</code>や、printfで用いる”%s”など）、または読み取り専用文字列を初期化した場合（例えば<code>const char *hello = "hello";</code>など）だけです。後者が許されるのは、C言語の文字列リラテル（<code>"hello"</code>）が、<code>char []</code>となるためです。</p><p>追記：C11ではネイティブでユニコードのサポートがあります。UTF-8の文字列リラテルは、<code>const char *abcgrr = u8"abc😬";</code>のようなマルチバイトのシーケンスであったとしても、依然として<code>char []</code>のままです。</p><p>ネイティブな戻り値の型やネイティブなパラメータと共に関数を使う場合、関数のプロトタイプやAPIの仕様書によって説明できるとして、これらの型を使います。</p><p><code>unsigned</code>という型をコード内で使うことはありません。読みやすさや使いやすさを阻害するマルチワード型という悪しきC言語の慣習に従わなくともプログラミングはできます。<code>uint64_t</code>が使えるのに、<code>unsigned long long int</code>を使いたがる人なんているでしょうか。<code>stdint.h</code>の型はより<em>明快</em>で、意味が<em>正確</em>で、<em>意図</em>を伝えるのに優れています。文字の<em>使用上</em>も<em>小さくまとまっていて読みやすく</em>なっています。</p><p>しかし、｢煩雑なポインタの計算のために、ポインタを<code>long</code>型にキャストしなければ｣と思うかもしれません。</p><p>しかし、それは間違った考え方です。</p><p>ポインタの計算に使う正しい型は、<code>&lt;stdint.h&gt;</code>で定義された<code>uintptr_t</code>です。また、同じように<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/stddef.h.html" rel="nofollow" title="" class="ext-link">stddef.h</a>で定義された<code>ptrdiff_t</code>も便利です。</p><p>の代わりに</p><p>または</p><p>を使います。</p><p><a href="http://postd.cc/how-to-c-in-2016-2/">後編</a>に続きます。</p>
