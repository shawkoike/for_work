<p><a href="https://plus.google.com/+BeauCronin/posts/KpeRdJKR6Z1" rel="nofollow" title="" class="ext-link">Why Probabilistic Programming Matters</a> (2013-03-24) by <a href="http://npbay.es/" rel="nofollow" title="" class="ext-link">Beau Cronin</a></p><p>先週、DARPAが確率的プログラミング言語に関する研究に資金を提供するための新たなプログラムを発表しました。関連記事では、このニュースが重要な理由について明らかな見解が示されていましたが、確率的プログラミング言語は新たな研究領域であり、人工知能に興味を寄せる大多数の人々にとっても未知の分野です。</p><p>では、確率的プログラミングはどういうもので、なぜ重要なのでしょうか。以下に私の考えを記しましたので読んでください。</p><p>確率的プログラミング言語は第一級プリミティブとして無作為事象を含む言語です。本質的なプログラミング言語の表現が無作為事象に影響する場合、洗練された<b>体系的な確率論的プロセス</b>、すなわちデータまたは観測結果の収集を行うために、開発者はその環境で発生した可能性のある事象の確率的モデルを、容易にエンコードできます。</p><p>しかし確率的モデルをコンピュータプログラムとして記述することは、単なる構文の問題にすぎないので、特別ワクワクするようなことでもありません。確率的プログラミング言語の真の力は、コンパイラやランタイム上で現れます（他の言語のように、確率的プログラミング言語も、コンパイルしたり解釈実行したりすることができます）。コンパイラやランタイムは、通常の作業に加え、どうやって<b>推論</b>を行うかを考えなければなりません。推論によって質問に対する結論が導き出されます。つまり無作為の選択肢として存在するあらゆる方法の中で、どの実行経路が最適なデータ解釈をもたらすかということに対する結論です。</p><p>別の方法もあります。順方向に実行されるだけの従来のプログラムとは違い、確率的プログラムは順方向と逆方向の両方向に実行されるのです。プログラムが含む、世界についての仮定から導かれる結論（つまり、プログラムが表現するモデル空間）を計算する時は順方向に実行され、モデルの考えられる説明を制約していく時はデータから逆方向に実行されます。実際のところ、多くの確率的プログラミングシステムでは、最適なデータ解釈に効果的に狙いを定めるため、順方向と逆方向の演算が巧妙にインタリーブされているのです。</p><p>かいつまんで言えば、今述べたようなことが確率的プログラミングです。疑いようもなくクールですが、それではなぜこれが重要なのでしょうか。</p><p><b>確率的プログラミングはデータの物語論的説明を明らかにします。</b>データの物語論的説明を明らかにすることは、ビジネス分析論で渇望されていることであり、科学的信念における縁の下の力持ちでもあります。人々は物語の観点から物事を考えます。例えば、事実に基づいているか否かにかかわらず、意思決定を進めるために理屈に合わない逸話をも利用するということです。しかし、既存のアナリティクスでは、この種の物語を扱うことができません。それよりも、選択肢を比較する時にそれを選択する理由となるようなコンテクストがほとんど含まれていないので、数字がどこからともなく現れるように見えるのです。</p><p>しかし、私たちは確率的プログラムを明確に“生成的な”流儀で書くことができます。つまり、観測されたデータを環境がどのように生成したかということを説明する仮説によって構成された仮説空間を、直接エンコードするプログラムなのです。仮説空間から選択される具体的な解は、データに対して具体的に原因と結果があり物語論的説明を構成しています。</p><p>ここには、逸話的で統計的な推論、つまり物語を話すことによる説得力と、予測力、および大きなデータを一般化する能力の最適な側面を組み合わせるという理想があります。</p><p><b>確率的プログラミング言語はモデリングと推論を切り離します。</b>現代のデータベースでインデックスとストレージからクエリが切り離され、また高水準言語とコンパイラでハードウェアの実行からアルゴリズムの問題が切り離されたように、確率的プログラミング言語では、既存の学習システムにはない決定的な抽象化の境界が提供されています。</p><p>長い間、モデリングと推論や学習は概念的に別の活動であると見られてきましたが、実際のところそれらはしっかりとリンクされてきました。これが意味しているのは、与えられた問題に適用されるモデルは、効果的な推論スキームから導かれなければいけないという要求によって、しっかりと制約されていることです。これらの推論スキームは、特別な専門的技能や専門知識を必要とするため、関数を導いて実行するのに信じられないぐらいの時間がかかります。また、モデルにごくわずかな変更を加えるだけで、推論の手順を全面的に見直す必要が出てきます。これではどうしようもありません。</p><p>確率的プログラミングがその本領を発揮すれば、モデリングと推論は、ソリッドな抽象の壁によって、ついに切り離されることになります。そうなれば、プログラマは自分が望むプログラムを書くだけで済み、推論処理をコンパイラやランタイムに任せておくことができるのです（ただし、後述するように課題も残っています）。プログラマは自分のドメイン知識をより活用することができるようになるので、結果的に、はるかにパワフルな推論処理と、より優れたデータ駆動型の意思決定が可能になります。</p><p><b>確率的プログラミングは、より一般化・抽象化された推論を可能にします。</b>なぜなら、確率的プログラミングに基づくプログラムは、推論の様々なレベルを直接エンコードし、それら全てのレベルにわたって同時に推論を行わせることができるからです。一方、既存の学習システムは主に、最適なデータ解釈をもたらすパラメータを学習するだけで、モデルクラス自体が妥当であるかどうかを推論することまではできません。</p><p>しかし確率的プログラムであれば、全てのレベルにおいて同時に推論することができます。モデルのパラメータを学習すると同時に、1つのクラスから最適なモデルを選択し、さらに、全く異なるモデルクラスを比較してそのどちらかを選ぶこともできます。モデリングにおけるバイアスや不適当なモデルの採用といった問題に対する特効薬はありませんが、確率的プログラミングが持つこの性質はそれでも、量的にも質的にも最適なデータ解釈をもたらす上で大きな役割を果たすのです。</p><p>最後に、確率的プログラミングの効果を最大限に引き出すために今後研究者が解決しなければならない重要な課題をいくつか紹介しましょう。</p><p><b>偶然による確率的プログラムに適した推論を自動的に生成するコンパイラとランタイムを作るのは非常に困難です。</b>上述した議論は話がうますぎるように聞こえますが、それは仕方がないのかもしれません。確率的プログラミングを実用化するには、研究者はいくつもの課題を解決しなければなりません。現在のところ最も効果を上げているシステム（BUGS、Infer、Factor）では、プログラミング言語の表現力を制限することで、推論過程で生じる問題の複雑さを緩和しています。</p><p><b>全ての抽象化には漏れがあり、モデリング（つまり確率的プログラムを書くこと）と推論の境界線を抽象化することもその例外ではありません。</b>確率的プログラムの一部は、プログラマが簡単には理解できない理由によって、他のプログラムに比べ極めて高速な推論を行うことがあります。従来の高水準プログラミング言語であれば、こうした問題は通常、プロファイリングと最適化によって解決されますが、確率的プログラミング言語においては、まずそれらと同等なツールを開発しなければなりません。そうしたツールがなければ、プログラマがパフォーマンス障害を調査し解決することは不可能です。</p><p>最後になりましたが、<b>確率的プログラミングを行うには、様々なスキルが必要です。</b>従来のシステム開発から、機械学習、統計的推論まで、様々な手法を組み合わせる必要があるのです。確率的プログラミングを用いたシステムが開発されたとしても、それを利用できる人が、LispやHaskellといった言語を使う一部のプログラマに限られるとしたら、それは残念なことだと思います。</p><p>こうした課題は非常に大きなものですが、今後数年間で確率的プログラミングが飛躍することを私は強く期待しています。このプロジェクトには、私が知る中でも特に優秀な人たちが参加しています。そのうちの何人かは私が一緒に仕事をしたことのある人たちです。彼らなら大きな進展をもたらしてくれるでしょう。</p><p>注記：私は、現在行われている確率的プログラミングの研究やDARPAのプロジェクトに一切関与していません。現時点では、私はただ研究の動向を興味深く観察しているにすぎません。</p><p><a href="http://www.wired.com/2013/03/darpa-machine-learning-2/all/1" rel="nofollow" title="" class="ext-link">ついに始まった：DARPAが自己学習するコンピュータの開発に着手｜Danger Room｜Wired.com</a></p>
