Node.js Flow (part 1) – Callback Hell vs. Async vs. Highland （2015-01-04） by Eirik VullumEirik Vullum美しいものが好きです。コード。ビジュアル。自然。音楽。このブログには技術と生活についての発見や、とりとめのない事を書いています。（このシリーズのPart 2はこちら: Node.jsフロー制御 Part 2 – FiberとGenerator）今回は、JavaScript/node.jsアプリケーションのフロー制御に対するアプローチを、いくつか取り上げて比較してみたいと思います。Expressフレームワークを使った以下のルート処理（お粗末ですが）を例に見てみましょう。たったこれだけの（比較的）単純なステップで、すでに読みづらく、かつ論理的に考察しづらくなっています（少なくとも私は）。このルート処理が何をしているのかすぐに把握できません。実行ステップ数が増えれば増えるほど、ひどいコードになり、アプリケーションの理解や保守、拡張がとても困難になっていくでしょう。その上、各ステップのエラー処理で同じコードを使いまわすのはDRY原則から外れています。この例はpmuellr（@pmuellr）が提供してくれました。少なくともこのアプローチでは、継続が深くネストされることはありません。しかし、フローの各ステップでエラー処理がDRYの原則に反することで生じる問題があります。また、ステップが増えるほど、フローを追うのが大変になる可能性もあります。以下は、asyncライブラリとwaterfallメソッドを使用した同じルート処理です。このアプローチだと、処理の手順として何をしているかが分かりやすくなり、少なくともエラー処理での重複を防ぐことができます。また、フロー中で処理関数を直接使用することもでき（これは引数がフロー関数のものと同じためです）、最終処理のための名前付きコールバックを作成することもできます。“コールバック地獄”に比べれば、格段に良くなりました。でも、まだ十分とは言えません。最近は、@caolanのhighlandライブラリを活用しています。これはネイティブのnode.jsのstreamとの完全な互換性を目指した、高度なstreamのライブラリです。今回はこのライブラリについて触れませんが、以下はhighland streamを使用した同じルート処理です。このアプローチは読みやすく拡張性があると思います。これは関数的アプローチで、アプリケーションはさらに保守しやすく考察しやすいものになります。あと50ステップ追加しても、アプリケーションのフローを簡単に素早く把握できるでしょう。JavaScriptのアプリケーションを作るなら、このライブラリを、また一般に、node.js streamを一読されることを強くお勧めします。Esailija – @PetkaAntonov（bluebirdの作者）の、promiseを使用した例に賛同し、感謝します。この例から分かるように、promiseはstreamとよく似ていますが、単一の値だけを出すという点で異なります。promiseの.then()メソッドはnode streamの.pipe()と同等と考えられます。その結果、私は先週、勉強のためにpromises(A+)を一から実装することに時間を費やしましたが、これがとても面白くて役に立ちました。Lewis Ellis – @LewisJEllis（highlandのcontributorの1人）の巧みな例に感謝します。この記事のパート2(Node.jsフロー制御 Part 2 – FiberとGenerator)には、さらに、generatorとfiberを使った非同期フローの例があります。
