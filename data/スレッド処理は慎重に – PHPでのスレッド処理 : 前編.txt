<p><a href="http://blog.madewithlove.be/post/thread-carefully/" rel="nofollow" title="" class="ext-link">Thread carefully</a> （2015-11-13） by <a href="https://twitter.com/anahkiasen" rel="nofollow" title="" class="ext-link">Maxime Fabre</a></p><p><img src="http://i.imgur.com/jFDknKy.png" alt=""></p><p>私が覚えている限り、非常に重い（または非同期の）タスク処理に関して、PHPは常に厳しい評価をされていました。これまではずっと、長いタスクを並列化したければ<code>pcntl_fork</code>を通してフォークするという方法を取らなければいけなかったので、タスクの結果を適切に処理することができませんでした。</p><p>そこで私たちは、キューイング（どちらかと言えばタスクを遅くするだけ）やReactPHP、または他の言語を一緒に使うといった、より複雑なソリューションへと向かっていきましたが、PHPでもスレッド処理は可能なのです。そしてより重要なのは、<em>その方法はあなたが思っているよりもはるかに簡単だということです。</em></p><p>この記事では、<strong>pthreads</strong>拡張（POSIX Threadsの略）について説明します。2012年ごろから広く使われていますが、多くの人がその存在を忘れているか、使うのが苦痛だと考えると思います。その主な理由は、公式ドキュメントの内容が少ないからです。</p><p>スレッドに詳しくない方のために、pthreadsを作成した人物による素晴らしい要約をご紹介します。</p><p>スレッド処理はあらゆるケースに適しているわけではなく、PHPでもそれ以外でも、ただ全てを並列化するだけで速度を上げることはできません。特殊なケースに備えて用意されているものです。その特殊な状況に立たされた時に、既存のドメインロジックでPHPを活用できるようになるでしょう。</p><p>まず必要なのは、拡張機能をインストールすることです。PHPのHomebrewバージョンを使用しているなら、非常に簡単です。他の拡張機能と同じ要領でインストールしてください。</p><p><code>brew install php56-pthreads</code></p><p>メモ：pthreadsはPHPでコンパイルされ、<code>--with-thread-safety</code>フラグを要求します。インストールが完了したら、<strong>ZTS（Zend Thread Safety）</strong>と呼ばれるPHPの<em>別</em>バージョンを実行します。<code>php --version</code>を実行した際に下記のような警告が出た場合、ほとんどの拡張機能では気にすることはありません。</p><p><code>brew reinstall php56-mcrypt</code>のように、拡張機能を再インストールすれば、うまく先に進めるでしょう。もしBlackfire拡張を有効にしているなら、それを無効にすることをお勧めします。ZTSサポートはいまだ実験的なので、何か問題が発生するかもしれないからです。</p><p><strong>pthreads</strong>拡張には様々な概念が含まれていますが、それらが詳しく説明されているとは限らないので、最初は混乱するでしょう。拡張機能から提供される次の3つのクラスを理解しておけば十分です。</p><p>これだけです。この拡張には少しのクラスしかありませんが、<em>単純に次の図のように派生しています。</em></p><p><img src="http://i.imgur.com/x2gowir.png" alt=""></p><p>この図を見て分かるように、根本的に全てのクラスは<code>Threaded</code>の子クラスです。<code>Threaded</code>は継承の基本クラスとなりますが、これ自体はめったに使いません。子クラスがより便利なメソッドを提供し、通常はそちらの処理の方が簡単だからです。</p><p>では簡単に、単純なWebクローリングの例から始めましょう。まずジョブを作成します。これは<code>Threaded</code>を継承している<code>Thread</code>をさらに継承したクラスになります。<code>Threaded</code>を継承する全てのクラスには、スレッド対象のタスクを定義する<strong>run</strong>メソッドがなくてはいけません。今回は単にGoogle検索の<code>file_get_contents</code>にします。</p><p>“cats”と検索するインスタンスを作成してみましょう。ジョブを開始するために、<code>start</code>メソッドを呼び出します。これは何も返してきませんが、ジョブは別のスレッドで開始されます。</p><p>ジョブが開始されると、<code>$job-&gt;isRunning()</code>のようなメソッドを呼び出してジョブをチェックすることができますが、必要なのは<code>join</code>メソッドです。それを使って親メソッドに処理対象のタスクを待機させ、メインスレッドに”再び結合”します。基本的に次のようなことが起こっています。</p><p><img src="http://i.imgur.com/GjTkzpN.png" alt=""><br>
<em>注釈（左上から）：メインスレッド、メインスレッド、メインスレッド、子スレッド</em></p><p><code>join</code>を呼び出せば、クラスが結果を保持していることを確認できます。</p><p>これを踏まえ、例ごとに複数の検索を同時に開始して結果を取得することができます。</p><p>jobクラス内でタイムスタンプを出力する場合は以下のようになります。</p><p>ファイルを実行すれば、3つのジョブ全てが確かに同時に開始していることを確認できるでしょう。</p><p>ここまでは比較的簡単でしたが、ジョブを自分で管理せずに済むのが理想でしょう。ジョブをそれぞれ個別に開始し、1つずつ結合するようなことはしたくないと思います。ジョブをどこかへ投げさえすれば、勝手に処理され、処理が全て完了した時に結果を取得できたらいいと思っていることでしょう。そこでワーカーの出番です。</p><p>Workerは、その上にジョブをスタックすることができるクラスで、全ジョブを一度に開始し、結合します。</p><p>この出力結果は次のようになります。</p><p>これで、ワーカーにメソッドを追加するだけでジョブからそのメソッドを呼び出して、各ジョブの結果を追跡できるようになりました。ジョブをワーカーにスタックすると、ジョブがそのワーカーを認識し、<code>$this-&gt;worker</code>を通してワーカーにアクセスできるようになります。それを行い、ジョブによってフェッチされたHTMLを収集してみましょう。</p><p>これを実行すれば、以下のような適切な結果を取得できます。</p><p>ここで、<code>$worker-&gt;stack(new SearchGoogle($search))</code>を行っていないことに気づくでしょう。これは、ワーカーにそのジョブの参照を追跡させる必要があるためです。つまり、ワーカーを開始すると、ワーカーにスタックされたジョブは全てメインスレッドで何かを参照しなければなりません。これはかなり面倒なので、このためにPoolクラスと呼ばれるクラスが作成されました。見てみましょう。</p><p><strong>Pool</strong>はクラスで、その目的は、ジョブを1つ以上のワーカーにディスパッチして、それらのジョブを管理することです。ドキュメントでは次のように説明されています。</p><p>前の例を、プーリングで書き換えてみましょう。プールを作成する際、以下の3つの引数を渡す必要があります。</p><p>ネイティブのpoolとworkerクラスを使う今回の例では、新しいインスタンスは以下のようになります。</p><p>それから<code>$pool-&gt;submit(&lt;Threaded&gt;)</code>を呼び出せば、ジョブをプールにサブミットできます。ワーカーとの主な違いは、ジョブをプールにサブミットするとすぐにジョブが開始するということです。もう参照に対処する必要はありません。</p><p>前と同じように行えば、全てのジョブが同時に開始するのが見られるでしょう。全てが正常に機能します。それでは、結果を収集してみましょう。ワーカーなどを通してループしなくてもプール内のジョブとやり取りできるようにするため、プールには便利な<code>collect</code>メソッドがあり、一種のフィルタとして機能します。それをクロージャに渡し、ジョブがプールにあるかどうかを返すことになります。通常はジョブが完了したかどうかを返します。</p><p>このために、pthreadsは<code>Collectable</code>クラスを提供します。そのクラスは<code>Threaded</code>を拡張するもので、2つの追加メソッドを持っています。<code>setGarbage</code>と<code>isGarbage</code>によって、ジョブは完了したものとして記録され、ガベージコレクタに収集される準備ができます。Poolクラスを書いて、ジョブから結果を収集し、それらを廃棄してみましょう。</p><p>また、これはつまり、<code>SearchGoogle</code>ジョブを編集して<code>Collectable</code>を拡張し、<code>setGarbage</code>を実行されたメソッドの最後で呼び出す必要があるということです。</p><p>これで次のようなことが行えます。</p><p>これを実行すれば、5つのジョブが同時に実行されたことだけでなく、それらのジョブが同時に完了し、簡単にジョブの結果が得られたことも分かります。</p>
