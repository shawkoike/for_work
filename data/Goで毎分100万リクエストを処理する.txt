<p><a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/" rel="nofollow" title="" class="ext-link">Handling 1 Million Requests per Minute with Go</a> （2015-07-06） by <a href="https://twitter.com/mcastilho" rel="nofollow" title="" class="ext-link">Marcio Castilho</a></p><p><a href="https://www.malwarebytes.org/" rel="nofollow" title="" class="ext-link">Malwarebytes</a>は、驚くべき成長を見せています。1年以上前にこのシリコンバレーの会社に入社して以来、私の主な仕事は急成長するセキュリティ企業の力となるシステムの設計と開発です。日々数百万人が利用する製品をサポートするために必要な、全ての基盤をつくります。私は12年以上、アンチウイルスとアンチマルウェアに関わるいくつかの会社で働いてきました。毎日処理する膨大なデータのせいで、これらのシステムがどれだけ複雑なものになるかを理解しています。</p><p>面白いことに、ここ9年ほどで私が携わったWebのバックエンド開発のほとんどは、Ruby on Railsが使われていました。誤解されないように言っておきますが、私はRuby on Railsが大好きですし、すばらしい環境だと思っています。しかし、Rubyでシステムを設計し始めると忘れてしまうのは、マルチスレッド化や並列化、高速化、メモリオーバーヘッドの低減に力を入れられれば、ソフトウェアのアーキテクチャが効率的で単純なものになるということです。長年、私はC/C++とDelphi、そしてC#のデベロッパをやっていますが、適切なツールを使えばジョブの複雑さを減らせることに最近気づきました。</p><p>私は設計者の代表として、インターネットで常に行われているプログラミング言語・フレームワーク戦争があまり好きではありません。効率性や生産性、そしてコードの保守性は、どれだけシンプルにソリューションを設計できるかにかかっていると信じています。</p><p>匿名のテレメトリと分析システムを使って仕事をしていたときの目標は、多数のエンドポイントからの大量のPOSTリクエストを処理できるようにすることでした。Webハンドラは、多くのペイロードのコレクションを含むJSONドキュメントを受け取ります。これは後々MapReduceをこのデータ上で操作できるように、Amazon S3に書き込む必要があります。</p><p>私たちはWorker-Tierのアーキテクチャの作成について調査しており、次のようなものを利用しています。</p><p>2つの異なるクラスタをセットアップするのですが、1つはwebのフロントエンドのためのクラスタ、もう1つはWorkerのためのクラスタです。これで操作可能なバックグラウンドの仕事を拡張することができます。</p><p>しかし当初より、私たちのチームはGoを使用するべきだと思っていました。話し合いの段階で、このシステムのトラフィックは膨大になりそうだったからです。私は2年ほどGoを使っています。仕事でいくつかのシステムを開発しましたが、これだけの量のロードが可能なものは1つもありませんでした。</p><p>私たちはいくつかの構造体を作成し、POSTの呼び出しを通して受け取るWebリクエストのペイロードと、S3のバケットにアップロードするためのメソッドを定義することから始めました。</p><p>初めに非常に素朴な方法で、POST ハンドラの実装を行いました。ジョブプロセスをシンプルなgoroutineで並行処理します。</p><p>中程度のロードであれば、ほとんどの人にとっては問題ないはずですが、大きなスケールになると、うまくいかないことは即座に明らかになりました。最初のバージョンをデプロイした際、多くのリクエストが来るとは思っていましたが、それが桁違いの量になるとは想定していませんでした。トラフィック量の見積もりを完全に誤ったのです。<br>
上記のアプローチには、いくつか問題点が挙げられます。Goルーチンをどのくらい生成するかコントロールできないのがひとつ、また、毎分100万のPOSTリクエストを取得すると、このコードはすぐにクラッシュし、炎上してしまいました。</p><p>というわけで、別の方法が必要です。私たちはリクエストハンドラの寿命をごく短くすることと、同時にバックグラウンドでプロセスを生成することの重要性を議論し始めました。もちろん、これはRuby on Rails界においては当然なされるべきことですが、さもなければpuma、unicornあるいはpassengerを用いて、全てのWorker webプロセッサをブロックしているでしょう（JRubyの議論はここでは忘れてください）。そこで、Resque、Sidekiq、SQSといったありふれた解決法にレバレッジを効かせれば良かったのでは、という話になりました。そのやり方であればいくらでも案が出てきます。<br>
2番目のイテレーションは、複数のジョブを待機させ、S3にアップロードさせるバッファチャネルを作ることでした。私たちはジョブの待機列のアイテム最大数をコントロールできた上、全てのジョブをメモリに並べられるだけの十分なRAMを保持していたので、ただジョブをチャネル列にバッファすれば良いだろうと考えました。</p><p>そして、ジョブをデキューしプロセスするのに、下記のような方法を使いました。</p><p>正直なところ、何も考えていなかったということです。きっと何本ものレッドブルを共にした深夜だったのでしょう。このアプローチには何も利点がありませんでした。欠陥だらけの同時実行と引き換えに、問題を先延ばしするだけのバッファされたキューを得ました。私たちの同期プロセッサは一度に1ペイロードだけをS3にアップロードするという代物であり、受信リクエストのレートは1プロセッサがS3にアップロードする能力を大幅に超えていたので、バッファチャネルはすぐに限界に達し、リクエストハンドラが次のアイテムを並べようとする動作をブロックしてしまいました。<br>
単純に問題を避けようとしたところ、かえってシステム滅亡のカウントダウンを始めてしまいました。この欠陥バージョンをデプロイして以来、レイテンシレートはコンスタントに上がり続けてしまっていました。<br>
<img src="http://marcio.io/img/cloudwatch-latency.png" alt="cloudwatch-latency"></p><p>私たちは、Goチャネルを使う際、ある一般的なパターンを活用することに決めました。ジョブを待機させ、JobQueueにおいて同時に動作するWorkerの数をコントロールする2-Tierのチャネルシステムを作るためです。</p><p>このアイデアは、マシンを故障させず、S3から接続エラーを引き起こさない、ある程度の持続可能なレートまでS3のアップロードを並列化処理することでした。そこでジョブWorkerパターンを作ることを選択しました。JavaやC#などをよく知っている人たちは、Worker threadのスレッドプールをチャネルで代用して実装するというGoでのやり方だと考えてください。</p><p>Webリクエストハンドラをモディファイし、ペイロードでJob structのインスタンスを作って、WorkerがピックアップできるようJobQueueチャネルに送ります。</p><p>Webサーバを初期化する間にDispatcherを作り、Workerのプールの作成とJobQueueに現れるジョブをリスニングし始めるため、Run()を呼び出します。</p><p>以下はディスパッチャを実行するためのコードです。</p><p>インスタンスが生成され、Workerのプールに付け加えられる最大のWorkerの数を与えることに注意してください。このプロジェクトのために、Docker化されたGo環境を用いてAmazon Elasticbeanstalkを利用してきたので、常に成果物の中でシステムのコンフィギュレーションを行うために<a href="http://12factor.net/" rel="nofollow" title="" class="ext-link">12-factor</a>の方法論に従うようにしてきました。そして環境変数からこれらの値を読み込みます。Workerの数とジョブキューの最大数をコントロールすることができたので、これらの値に手を加えるのにクラスタの再デプロイする必要がありません。</p><p>デプロイをした直後に、レイテンシレートがわずかな数値にまで下がり、ハンドラリクエストをコントロールする能力が激しく高まっているのが見られました。</p><p><img src="http://marcio.io/img/cloudwatch-console.png" alt="cloudwatch-console"><br>
Elastic Load Balancersの準備ができた後に、ElasticBeanstalk アプリケーションサーバが毎分100万リクエストにまで近づいていることが分かりました。毎分100万よりもトラフィックが急上昇する深夜帯の時間があります。</p><p>新しいコードをデプロイすると、たちまちサーバの数は100から約20まで著しく下降しました。</p><p><img src="http://marcio.io/img/elasticbeanstalk-healthy-hosts.png" alt="elasticbeanstalk-healthy-hosts"><br>
クラスタとauto-scalingセッティングに適切なコンフィギュレーションを行った後は、4つのEC2 c4.Largeにまで下げることができるようになりました。CPUが5分間絶えずに90%を上回った際には新しいインスタンスを生成するようElastic Auto-Scalingを設定しました。</p><p><img src="http://marcio.io/img/elasticbeanstalk-production-dashboard.png" alt="elasticbeanstalk-production-dashboard"></p><p>私は、シンプルさこそが常に正解だと考えています。多くのキュー、バックグラウンドのWorker、複雑なデプロイを用いて複雑なシステムを構築することができますが、代わりにElasticbeanstalk auto-scalingの力と、Golangがもたらす即使用可能な並行処理に対する効率かつシンプルなアプローチを利用することに決めました。</p><p>私が現在使っているMacBook Proよりもよほど貧弱なマシンたった4台が、毎分100万回Amazon S3バケットに書き込んでいるPOSTリクエストを処理するなんて、そうそうあることではありません。</p><p>ジョブのための正しいツールは常に存在します。時折Ruby on Railシステムがとても強力なWebハンドラを必要とする時は、単純だけれど強力な代替可能なソリューションのためにrubyのエコシステムから少し離れて考えてみてください。</p>
