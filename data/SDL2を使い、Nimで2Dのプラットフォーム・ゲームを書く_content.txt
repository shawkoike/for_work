Writing a 2D Platform Game in Nim with SDL2 （2016-06-14） by Dennis Felsingこの記事ではシンプルな2Dのプラットフォーム・ゲームを書きます。SDLを使ったNimによるゲーム開発のチュートリアルとしてもよいでしょう。ここでは、ユーザ入力を読み込み、グラフィックスとタイルマップを表示させ、衝突判定と処理を伴うシンプルな2Dの物理をシミュレーションします。その後、シンプルなカメラの動作とゲームロジックを実装します。また、適宜情報を表示するため、テキストをレンダリングし、そのためのキャッシュの仕組みを構築していきます。最終的な成果物は、SDL2のみで動いて簡単に配信できる、ゲームに最適なバイナリファイルです。Linux環境の場合、NimをWindows用にクロスコンパイルする簡単な方法も提示しますので参照してください。簡潔に説明するため、DDNetとTeeworldsのなじみ深いグラフィックスを使います。このチュートリアルの成果は下の動画のようになります。この記事では、画像とビデオによる解説で開発手順を追っていきますが、最善の学習方法は、この記事を見ながらご自身で各ステップを実装してみることです。コードは、各自でいじったりあらゆる変更を試したりすることによって直感的に理解できるよう、意図的にシンプルかつ簡易にしてあります。フルソースコードのリンクは、各セクションの末尾に用意しました。ここで紹介するコードの各イテレーションと最終的な成果物はGitHubのレポジトリで入手可能です。出来上がったバイナリは以下からダウンロードできます。Win64、Win32、Linux x86_64、Linux x86このプロジェクトに必要なものは下記のとおりです。LinuxやMac OS X等のUnix系のシステムの場合は、インストールは下記のようになります。C言語コンパイラも必要になりますので注意してください。望ましいのはGCCやClangです。ソースコードからNimとNimbleをコンパイルする代わりに、パッケージマネージャを使って最新バージョンのNimとNimbleをインストールしてもよいでしょう。SDL2を他のプラットフォームで設定したい人には、より幅広いガイドがあります。Nimとnimbleの設定に関しても同様です。C言語やC++で書かれたSDL2を知っているなら、これからNimで行うことはそれに非常に似ていると気付くでしょう。実際、NimのSDL2ラッパーは、C言語による本来のSDL2インターフェースを包括する薄いレイヤーに過ぎません。SDL2のチュートリアルで学んだことを何でも適用できる利点がありますが、ハイレベルのNimライブラリを使った場合と比べると若干ボイラープレート的になってしまうのが欠点です。まさにこのボイラープレートで画面を初期化するところから始めましょう。条件を確認するsdlFailIfテンプレートを導入し、条件が真ならSDLの追加エラー情報と共にSDLExceptionを発生させるようにします。mainprocで、SDL2を初期化し、通常の画面と加速した2Dレンダラを作成します。エラー処理は先ほど導入したsdlFailIfprocで行います。いまのところ、ゲームのループは画面の消去と描画を毎フレーム行っているだけです。VSyncが有効で、スクリーンの設定が60 Hzの場合、そのループは1秒に60回実行されます。nim -r c platformerを実行すれば、同様のステップでコンパイルと実行ができます。ファイル名はplatformer.nimになるでしょうか。最適化しながらコンパイルする場合は、nim -d:release -r c platformerを使います。結果はシンプルな単色の画面です。
この小さなプログラムを終了するには、ターミナル画面の中でCtrl-Cを入力してください。残念ながら、まだゲームの画面そのものから終了することはできないので、その修正を行いましょう。セクション1のフルコード初めに、Input型を追加し、サポートしたいすべての入力と、ゲームの状態オブジェクトにおける入力の配列を格納できるようにしましょう。Game状態の型にref型を選ぶことで、誤ってそのコピーが作られてしまうのを簡単に防げます。初期設定では、Gameオブジェクトに対してスマートポインタだけが渡されます。inputsフィールドはInputからboolにマッピングされる配列で、現在どの入力が押されているか(true)/押されていないか(false)を示します。新規ゲーム状態オブジェクトの作成は大したことではないので、今は新規ヒープオブジェクトを作成し、あとで必要になるSDL2 rendererを割り当てます。inputsを何らかの方法で初期化する必要はありません。全てデフォルトでバイナリnullに初期化されているため、「スタート時には全てオフになっている」という要求事項に完全に合致するからです。rendererフィールドを初期化しなかった場合、それはnullポインタになり、誤ってそこを参照してしまうと問題が起こります。次に必要なのは、キーボードのスキャンコードを解釈可能な入力にマッピングする関数です。toInputは、未定義のケースに対しては常にInput.noneを返すことに注意してください。この挙動を使って、コード内に分岐を設けることなく、未使用のキーボード入力を無視します。1つの入力にマッピングするための複数のスキャンコードを知るのは難しいことではありません。次に、ゲームループを修正し、新しいhandleInputprocを呼び出してキーボード入力に反応するようにします。また、mainprocの中で関心の分離をせずにすむよう、レンダリングそのものを分割しました。これで、qの入力、あるいは画面の閉じるボタンでゲームを終了できるようになりました。今は、その他のユーザ入力はinputs配列に格納しておき、あとで使いましょう。できる限り効率よくアクセスできるよう、inputs配列はわざと簡潔な配列にしています。ハッシュテーブルやその他のデータ構造を使うとなると、簡単にそのような約束ができません。多くの場合、シンプルさは有利であり、開発中のシステムにおいて何が起こっているのかを理解しやすいものです。セクション2のフルコードこれらのユーザ入力が何かの役に立つようにしたければ、青空以外のものを表示しなければなりません。プレイヤーのテクスチャと現在の位置・速度も格納するようにゲーム状態オブジェクトを拡張しましょう。ここではbasic2dモジュールを使います。プレイヤー用に、Teeworldの初期設定のキャラクター、teeのグラフィックを使います。
このファイルをplayer.pngとして保存すると便利です。しっくりこないようであれば、DDNet Skin Databaseの数百のスキンの中から選んでもよいでしょう。例えば次のようなグラフィックです。

別のイメージを使いたい場合は、忘れずにプレイヤーグラフィックの名称をplayer.pngにしてください。まず使うと決めたプレイヤーグラフィックをnewGameの定義で読み込み、GameとPlayerのデータ構造体を初期化する必要があります。次のとおりです。restartPlayerを使って、プレイヤーをスタート地点にリセットします。loadTexture関数で、PNGイメージをSDL2テクスチャとしてメモリに読み込み、Gameオブジェクトに格納できるようにします。さらに、SDL2の初期化と同じように、mainprocの中で、SDL2イメージモジュールも忘れずに初期化しましょう。PNGファイルだけサポートできればよいのですが、const imgFlags: cint = IMG_INIT_PNG or IMG_INIT_JPGを追記して、JPEGファイルも加えてもよいかもしれません。次のタスクはこれを適切に配置することです。もちろん、柔軟なプレイヤーイメージを使う意図は、ボディを部分ごとに個別に動かすことにあるのですが、簡潔にするため、固定位置に置きましょう。簡単な追加で、プレイヤーの水平位置によって足を回転させることができるようになります。もう1つの追加で、目がマウスカーソルを追うようにもできます。数字がいくつかというのはさほど重要ではなく、ただプレイヤーがどう配置されるべきかを表しています。renderTeeによって、どのボディパーツをどの場所にどの順序で描くかを定義します。最後にこれらの各ボディパーツはcopyExを使ったSDL2レンダラで描画されます。ここで、ゲームループにteeキャラクターを描くには、renderTeeを呼び出すだけです。ついにまた、ビジュアルが進展を見せました。プレイヤーが空に浮いたのを見てください。
セクション3のフルコードこれで、プレイヤー用のレンダリングシステムが動くようになったので、プレイの場、マップが必要です。タイルのリストだけでなくテクスチャも格納しなければなりません。それぞれのタイルはuint8になるよう定義されます。これは包括的に0から255の間の値を表すということです。都合の良いことに、Teeworldsタイルセットのグラフィックは16 × 16 = 256タイルです。芝のタイルセットを使ってみましょう。
ダウンロードし、このイメージをgrass.pngとして保存します。Mapデータ構造体を初期化するため、以下のフォーマットのマップを解析するちょっとしたパーサを書いてみます。このセクションの目標は、芝のタイルセットのマップで、次のようなレンダリング結果を得ることです。
各数字は芝のタイルセットから選んだタイルを表します。今後この記事内では、このdefault.mapを使います。私たちのパーサは、次のようにnewMapに実装されます。ファイルを句と行の両方で分割します。各数字を符号なしの整数にパースし、正しく0..255の範囲内にあるかをチェックします。最終的な幅と高さは、行の長さと行数から計算されます。マップデータにエラーがあると、例外が投げられ、ゲームが終了してしまいます。ここで、newGameを拡張し、マップを初期化しなければなりません。この時点でテクスチャとマップのタイルが用意できています。やり残したのは、このすべてをレンダリングすることだけです。これはrenderTeeに似ていますが、固定サイズのテクスチャのパーツを使います。テクスチャは64 × 64ピクセルサイズに切り分けられ、1行に16タイルあります。マップ内で各タイルを反復し、マップテクスチャからタイルtileNrをレンダリングしていきます。タイル0はエアタイルであり常に空なので、レンダリングする必要はありません。典型的なマップは大部分が空なので、これによりパフォーマンスが向上します。最後に、プレイヤーをレンダリングした後は、マップがプレイヤーの上に配置されるよう、mainprocの中でレンダリングしなければなりません。今のところ動かせるカメラがありませんので、静的なgame.cameraで、固定のレンダリング位置を取得します。しかしまだ動くことさえできませんから、あとでユーザ入力に関連づけたシンプルな物理モデルを実装することにします。このセクションの成果は美しいマップのレンダリングです。
セクション4のフルコードこのゲームの物理は、1秒50ティックに決めました。新規のティックが届いた時には、次のゲームのイテレーションだけを計算し、ゲームがが60 fpsで動こうが240 fpsで動こうが関係ないようにします。それでは、mainprocにティックを追加しましょう。これがこのゲームの物理フレームワークですが、まだ一切動きません。重力を追加するところから始めます。
プレイヤーが動きましたね。この素晴らしいアニメーションを、rを押すだけで繰り返し見ることができるよう、ここでプレイヤーを再起動できたほうがよさそうです。まるで繰り返し再生する先のGIFそのものです。想像がつくかもしれませんし、playを何度かクリックしてみてもいいでしょう。aとdで左右に動かし、spaceでジャンプするように実装するのは訳もないことでしょう。固有の値は試行錯誤で見つけるしかありません。他に優先したいことがあれば、いろいろな変更も可能です。ただ、プレイヤー位置は直接設定せず、速度ベクターを調整して位置に加算するようにしてください。これは衝突判定の際に重要です。壁と地面にエフェクトがあるかのように動かしてみましたが、読者は気付いてしまったかもしれません。実は衝突判定と処理の準備がまだ何もできていないことに。このコードの大部分はTeeworldsから適用しています。渡した速度ベクターに基づきプレイヤーの位置を計算するmoveBox内で、タイルとの水平/垂直の衝突をチェックすることにより動作します。衝突が起こると、プレイヤーはタイルから外れるよう正しい方向に動きます。isSolidをシンプルに保つため、air, start, finish以外のあらゆるタイルは硬い(=Solid)ブロックとみなします。浮動小数点のプレイヤー位置はタイルマップの中のインデックスに変換されるのです。getTileはマップ内の指定された位置からタイルを読み込み、オーバーフローやアンダーフローが起こらないようにします。isSolidはプレイヤーがタイルと衝突できるかどうかを決めます。先述したように、air、start、finish以外のすべてのタイルは衝突が可能です。どちらかの足の下にブロックがある時、プレイヤーは地上にいます。一方、testBoxはプレイヤーを座標軸に平行な境界ボックスとみなし、プレイヤーが硬い壁の中に挟まっているかどうかを示します。そしてmoveBoxは、速度ベクターvelをプレイヤー位置posに適用しようとします。これで衝突が起こる場合、コードはプレイヤーをx軸上のみ、そのあとでy軸上のみで動かし、タイルのどの側面にプレイヤーが衝突したかを探っていきます。プレイヤーがどの側面にも衝突していなかった場合はコーナーにぶつかります（これが本当のコーナーケースです）。moveBoxprocはさらに衝突のセットを返し、このイテレーションにおいてどのような種類の衝突が起こったのかを伝えてくれます。その情報は使いませんが、ただプレイヤーを衝突した壁から押し出すのでなく、特別な方法で衝突を処理したい場合には役立つかもしれません。やっとonGround とmoveBoxが使えるようになりました。ジャンプは地上に立っている時のみ可能です。空中における水平の動作は地上とは別の方法で計算し、空中における摩擦と地上の摩擦を異なるものとしてシミュレーションします。
セクション5のフルコードキャラクターが画面右へ消えていったのが分かりましたか？　イケてるでしょ？　でも、このままでは残りのコースをプレイするのは難しすぎますよね。キャラクターはうまく動くようになりましたが、カメラが静止したままです。このセクションでは、カメラを水平方向に動かしていきましょう。この説明をすれば、垂直方向への動かし方もすぐに分かるはずです。カメラ位置はプレイヤーが動いている時だけ調整する必要があります。つまり、game.physics()の呼び出し後です。
これでカメラは常に、プレイヤーの動きに合わせて水平方向に移動するようになりました。他にも、プレイヤーがスクリーンの中央から外れた時のみカメラを追わせるという方法もあります。今回の場合は200ピクセルです。
もう1つ、カメラを滑らかに動かす方法もあります。プレイヤーが中心エリアから遠くへ離れた時ほど、カメラを素早く動かすのです。プレイヤーにくっついている輪ゴムでカメラが引っ張られていると考えてみてください。プレイヤーとカメラの距離が離れれば離れるほど、カメラはプレイヤーに強く引っ張られますよね？
どれを採用するか決め難いので、とりあえず3つの方法とも実装します。コンパイルする時に-d:fluidCameraか-d:innerCameraを使って選択をしてください。セクション#6のフルコードこれで、どこの場所に行ってもカメラがきちんとついて来てくれるようになりました。では、ゲームの目標を作りましょう。コースの始まりと終わりに、濃いグレーの明かりのような縦の線があることに気付いたでしょうか？　それぞれstartとfinishとして言及されているのではと予想していた人もいたんじゃないでしょうか？　　もうお分かりですね。これらはスタートラインとゴールラインです。スタートしてからゴールにたどり着くまでのプレイヤーのタイムを記録する役割もあります。これで、PlayerにTimeオブジェクトが格納されている状態です。プレイヤーが今回スタートを切ったタイムと、前回のタイム、プレイヤーのベストタイム、という3つの情報を教えてくれます。デフォルトでは、これらの値は、無効値を示す-1に初期化されていて、それ以外ではティックを格納します。ディスプレイに表示する時間をフォーマットするのに、使い勝手のいいstrfmtライブラリの文字列補間を使います。このゲームのロジックは以下のようになっています。コースのmainprocでlogicを呼び出す必要があります。これで、コースをプレイすることができ、端末に以下のようなアウトプットがやっと得られるようになりました。セクション#7のフルコードレースの結果のテキストが端末上ではなく、実際のゲーム画面に表示されたほうがいいですよね。では、SDL_ttfを使ってみましょう。FontPtrでSDL2のサーフェス（RAMに保存されている）にテキストをレンダリングし、テクスチャ（GPUのVRAMに保存されている）にしました。そしてテクスチャは、スクリーン上の指定した場所にレンダリングされます。TTFのサブシステムを初期化し、renderに現在のティックを渡す必要があります。ゴール後に画面に表示されるテキストのレンダリングが以下です。
なんかカッコ悪いですね。文字のふちがギザギザして見えます。これは、renderUtf8Solidがアルファブレンドを使用してないからです。アルファブレンドは高価なので、代わりに全ピクセルをすべて白にするか、完全に透明にし、半透明など中途半端にはしないようにしましょう。テキストに対して背景の色が決まっているのなら、背景の色を決めるrenderUtf8Shadedを使うこともできますが、ダイナミックな背景にカッコいいアウトプットを載せたいなら、renderUtf8Blendedを使いましょう。
よくなりました。しかし、背景が明くなると見にくいですね。この問題を解決するために、テキストを2回描いて、テキストのアウトラインを作ります。1回目は半透明の黒にして、2回目は背景と同じ色を上に載せます。
セクション#8のフルコードこのチュートリアルの間にCPUの使用率を見た人は気付いたかもしれませんが、このゲームでCPUはほとんど必要ありません。私のシステムでは、今のところ60 fpsで3％ほどです。しかし、テキストをレンダリングすると20％にまで上がります。これは、現状ではテキストが前のフレームと全く同じものだとしても、毎フレームごとにテキストのテクスチャを再生成しているからです。テキストが決まっていれば、再計算をするのではなく、単純にテクスチャを保存すればいいのです。しかし、よりフレキシブルにしたければ、グリフかテクスチャ･キャッシングシステムを使ってください。例えば、SDL_FontCacheなどのシステムです。代わりに、Nimでアプリケーションに特化したちょっとしたキャッシング･スキームを書くこともできます。ここでのヒューリスティクスは、コードベースの一行が、同じ文字列を少なくとも何回かは生成し続ける、というものです。ですから、画面に何かを表示させる行それぞれについて、1つのテキストのレンダリングのみをキャッシュに格納すればいいのです。ということで、キャッシュデータ構造で検索する必要は一切なくなり、キャッシングには確実で不変のメモリの量しか使わないことになります。CacheLineが保存するもので、テクスチャへのポインタと、テクスチャの幅と高さの情報が含まれます。アウトラインの効果を出すためにテキストを2回レンダリングするので、このオブジェクトは2つ必要にあります。また、textはTextCacheにも保存され、正しくテクスチャがキャッシュされたかを確認できます。renderTextを実行して、使用できるCacheLineを返します。テキストがキャッシュから直接格納されたら、2つのpassesでテキストがレンダリングされます。直接ではない場合は、古いキャッシュエントリは削除され、新しいテクスチャに替えられます。Nimのメタプログラミングは、小規模なテンプレートで使い続けることができます。数日前に『Metaprogramming in Nim（Nimのメタプログラミング）』という記事を書きましたので、Nimの強みをさらに勉強したい人はお読みください。3つのrenderTextCached呼び出しはそれぞれのTextCacheを割り当てられました。これは残りのプログラムの実行で使われます。注意しなければいけないのは、このキャッシングスキームは、「renderTextCachedを呼び出す別々のコード行が比較的少なく、また頻繁に同じテキストを複数回連続してレンダリングする」という仮定のもとにのみ実力を発揮します。今回のケースにはぴったりです。また、現在時間のタイム・フォーマットは毎フレームごとに再計算されていたので、精度を下げました。これで、CPUの使用率は4％に戻りました。そして、ゲームの最終形は以下のようになりました。
セクション#9のフルコードplatformer.nimbleファイルを生成して、NimのパッケージマネージャであるNimbelにどのようにパッケージをビルドするかを命令します。この記事のすべての中間コードのステータスはnimble testsでコンパイルできます。nimble buildを実行することで、ビルトをテストできます。これで、バイナリplatformerを生成できるようになります。nimble installは同じバイナリをインストールし、~/.nimble/binで使用できるようになります。しかし、インストールされたplatformerバイナリを実行すると、以下のようなエラーが出てしまいます。考えればこれは当然のことです。現在のディレクトリから実行時のファイルをロードしているからです。今となってはどこのディレクトリでもあり得ます。これを解決するには2つの方法があります。ファイル名の代わりにStreamを受け入るために、newMapを変更する必要があります。コンパイルの時、-d:embedDataを以下のようにセットできます。リポジトリの中に、最終的なプラットフォーム･ゲームのコードを見つけることができます。そして、プルリクエストとしてNimble packagesにリポジトリをサブミットできるようになり、すぐにNim開発者はnimble install platformerで端末からパッケージをインストールでき、platformerを実行するだけでプレイができるようになりました。circle.ymlファイルは、リポジトリをどのように実行してコンパイルするかを定義し、変更に応じて最新ビルドを保つのに使用できます。しかし、このゲームのメインターゲットはおそらくNim開発者ではありませんので、Linux x86、x86-64とWindows x86、x86-64のような一般的なプラットフォーム向けにバイナリをビルドできるようにもしたいものです。Mac OS X向けにのビルドするのは、少し複雑です。DDNetがどのようにそれをするのかチェックしてみてください。もちろん、ビルドしたい各システム用に単にVMをセットアップし、この記事の冒頭のインストラクションを使うこともできます。でもそれは面倒なので、簡単に1つのマシンでビルドできるようにしたいですよね。私はArch Linuxを使っています。Arch Linuxは、他のLinuxディストリビューションと似たような方法で実行することが可能なはずです。Linux向けのポータブルなバイナリをビルドするのは、glibcのせいで大変です。より新しいバージョンのglibcを使ってシステム上でコンパイルすると、古いバージョンのシステムでは実行されない可能性があります。一般的な解決法は、古いLinuxをインストールしたビルドシステムを使うことです。他にも、debootstrapで古いDebianのchrootを生成するという方法もあります。また、この問題を解決するためのLinux Standard Baseというのもありますが、私はまだ使ったことがありません。もう少し過激な解決法としては、新しいシステム上にバイナリを生成し、glibcのより新しいバージョンに対して何のシンボルとリンクしているのかを確認する方法があります。今回のケースでは、すべてにおいてGLIBC_2.2.5を使用させたいので、別のことを確認します。memcpyだけが問題ですね。古いバージョンのmemcpyともう1つの問題realpathをリンカに無理やり使わせることもできます。例えば、インラインアセブラを使ったCコードだと以下のようになります。しかし、これでは生成したすべてのCファイルにこれをインサートしなければならなくなります。もしくは、nimbase.hファイルを乱用して、インサートし、以下のようにコンパイルします。これで、glibc 2.2.5以上のLinuxバージョンでバイナリが使えるようになりました。注意したいのは、ユーザはSDL2やSDL_image2、SDL_ttf2のインストールが必要であるということです。もし動的にリンクしていて、バイナリと一緒に共有のライブラリを配布したい場合は、nim --passC:-Wl,-rpath,. c platformerでコンパイルして、共有ライブラリをバイナリと同じディレクトリに置くこともできます。x86-64を使用し、gcc-multilibがインストールされていれば、少なくとも、Linux上でx86向けにビルドするのは簡単です。Windows向けのポータブルなバイナリをビルドするのは驚くほど簡単です。Linuxからだとしてもです。Windows向けのSDLライブラリはSDL2 website（image, ttf）からダウンロードできます。もし、スペースを節約したくて、バイナリをデバッグすることに抵抗がなければ、シンボルのバイナリをstrip -s platformerで削除するのは有効な方法です。今までの情報を元にすると、完全に自動化されたビルドスクリプトもNimで書くことができます。Lunuxのユーザはパッケージマネジャを使ってsdl2やsdl2_image、sdl2_ttfをインストールしなければなりません。Windowsユーザにとってはこれらはバンドルされています。ビルドスクリプトは、nim -r c releaseで実行される時に、このディレクトリ構造を生成します。結果はここからダウンロードしてください：Win64、Win32、Linux x86_64、Linux x86書いているうちに、どんどん長くなってしまいました。単純なプラットフォーム･ゲームを書くために出発したこの旅路は思った以上に壮大でした。皆さんにとってこの記事が長くすぎてつまらないものになっていないこと、そして、プラットフォーム･ゲームをSDL2を使ってNimで書く方法のいい手引きとして役に立つことを願います。今回の記事で紹介したマテリアルはすべてGitHubのリポジトリにあります。最後まで内容をいじくりまわしたので、もしかしたら、間違えや抜けがあるかもしません。もし、バグを発見したり、コメントがあったりする場合は私にメールをお願いします：dennis@felsin9.der/programmingとHacker Newsで議論もされています。
