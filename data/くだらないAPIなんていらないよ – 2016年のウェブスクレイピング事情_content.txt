I Don't Need No Stinking API ? Web Scraping in 2016 and Beyond by Francis KimソーシャルメディアのAPIとそのレート制限は、あまり気分のよいものではありません。特にInstagram。あんな制限つきAPIを欲しがる人がいったいどこにいるんでしょうね？最近のサイトは、スクレイピングやデータマイニングの試みを阻止するのがうまくなってきました。AngelListはPhantomJSすら検出してしまいます（今のところ、他のサイトでそこまでの例は見ていません）。でも、ブラウザ経由での正確なアクションを自動化できたとしたら、サイト側はそれをブロックできるでしょうか？並行性を考えたり、さんざん苦労して用意した結果として得られるものを考えたりすると、Seleniumなんて最悪です。あれは、私たちが「スクレイピング」と聞いて思い浮かべるようなことをするためには作られていません。しかし、賢く作り込まれた今どきのサイトを相手にして、インターネットからデータを掘り当てるための信頼できる方法はといえば、ブラウザの自動化だけなのですよねえ。私の持ちネタは全部JavaScriptです。あまり読者を稼げないかもしれませんね😑😆。WebdriverIO、Node.js、そしてantigate（参考：Troy Hunt – Breaking CAPTCHA with automated humans）などの大量のNPMパッケージ。全部JavaScriptですが、今回紹介するテクニックの大半は、どんなSelenium 2ドライバにも適用できます。たまたま私は、ブラウザの自動化にはJavaScriptが向いていると感じただけのことです。Seleniumを使った自動化／スクレイピング／クローリングについて、これまで学んできたすべてのことをみなさんと共有しようと思います。この投稿の目的は、私が編み出したテクニックの中でまだ公開していないものについて説明することです。さまざまな範囲に適用できるアイデアであり、ウェブ開発コミュニティ全体で共有して議論できるものだと思います。あと、コービー・ブライアントに出資してもらいたいという気持ちもあります。Hacker Newsでコメントした内容を引用します。倫理的に考えて、私は大量のデータをスクレイピングしたりはしません。仕事としてスクレイピングをしたことはないし、そんな仕事でお金を稼ぐつもりはありません。私にとってのスクレイピングは単に個人的な用途のためだけのものであって、ちょっとしたサイドプロジェクトでしか使いません。そもそも「スクレイピング」という言いかたが気に入らないんですよね。なんだかネガティブな意味にとられがちだし（このコメントのスレッドを見ても明らかですよね）、これってマーケティングの視点からの言葉じゃないですか。お手軽なものを求める人たちはスパムに走ります。テクノロジーの使い方が間違っているんです。私はどちらかというと「自動化」とか「ボットを作る」という言いかたのほうが好みですね。私は単に、日々の生活を自動化しているだけだし、日々の作業（そう、たとえばFacebookを巡回して気に入ったgifや動画を自分のサイトで紹介したりとか）を肩代わりしてくれるボットを作っているだけです。毎日一時間もかけてそれを手動でやりたいと思いますか？私はそんなにマメじゃありませんね。自分の生活のどこを自動化できてどこは自動化できないのか、教えてくれる人なんていないでしょう？なら、やるだけのことですよ。こんなふうにところどころでランダムな待ち時間を入れておくと、人間らしくなって安全です。次のコードは、Facebookページから動画を取得する関数の一部です。これとよく似たこんなメソッドと正規表現を組み合わせれば、コマンドラインのcURLライクなスクリプトでは読めないようなRSSフィードもパースできます。これはほんとうにうまく動いてくれます。いくつかのソースで試したけどまったく問題はありませんでした。私くらいのクラスになると、クライアントサイドのJavaScriptを送り込むのもどうってことありませんね。ところで、うすうす感づいてらっしゃるでしょうけど、このサンプルはまったくもって現実的じゃありません。次、行ってみましょう。GIFLY.coが48時間以上も更新されなかったことがありました。FacebookページからアニメーションGIFを取ってくる私のスクリプトが、CAPTCHA画面でストップしていたのです😮。FacebookのCAPTCHAを破るのはきわめて簡単で、15分もあれば突破できました。内部的になんとかしてしまう手もきっとあるのでしょうが、NPMのAntigateパッケージを使えば低コストで実現できるし、何も考えることはありませんでした。JavaScriptを差し込むのも朝飯前ですね。画像をキャンバスに変換してから、.toDataURL()を実行してBase64エンコードさらたPNG画像を取得します。そしてそれをAntigateのエンドポイントに送ります。この関数は、あるサイトから拝借しました。これ以外にもいろんなネタをいただいています。ありがとう、David Walsh。このコードはFacebookのCAPTCHAを解読し、その値を入力してボタンをクリックします。なぜクライアントサイドのAJAXのエラーを捕まえる必要があるのでしょう？それにはちゃんと理由があります。私はかつて、Instagramでフォローしているアカウントを全部アンフォローする処理を自動化しました。そのときに気づいたのですが、この処理にはレート制限があるようなのです。これは、API経由の場合だけではなく通常のWebインターフェイス経由でも同じでした。フォロー／アンフォローはAJAXコールを伴い、レート制限を越えてしまうとAJAXのエラーが発生します。そこで私は、AJAXのエラーを横取りする関数を作ってグローバル変数に保存するようにしました。アンフォロー処理後の値を毎回収集して、エラーが3回発生したらスクリプトを終了させます。Instagramのスクレイピング（というかクローリングというかスパイダリングというか……）を行っているときに、問題が発生しました。タグのページのDOMに、投稿日が含まれていないのです。IQta.gsで使いたいのでこのデータは必須だったのですが、毎回200枚の写真を処理しているので、すべての投稿にアクセスする余裕はありませんでした。でもよく見ると、ブラウザが受け取るpostオブジェクトにはdateという変数が含まれていました。私はこの変数を使わずに、こんなふうに対応しました。まあこれは、私の住むメルボルンではもはやちょっと時代遅れですね。私はこれらをすべて、AWS上のDockerコンテナで動かしています。ちょっとしたbashスクリプトを書いて、Instagramクローラーの耐障害性を高めました（いまちゃんと動いているか確認してみましょう）。うん。6つのIQta.gsクローラーがきちんと動いているようですね 🙂 。Dockerを使っているときにちょっとした問題も発生しました。イメージが使えなくなったのです。理由はわかりません。根本原因を突き止めるのはあきらめましたが、私の書いたbashスクリプトはイメージがアクティブではなくなったことを検出できるようにしました。検出したら、イメージを削除したうえで、まっさらなイメージからSeleniumグリッドを再起動するように仕込んであります。この記事を書き始める前からこの見出しだけは書いていたのですが、今となっては何を書くつもりだったのかを思い出せません。まあ明日になれば思い出すでしょう。ああ、Hartley Brodyの記事は紹介しておかないといけませんね。Hacker Newsで2012年から2013年にかけて人気だった記事で、私が今回の記事を書くきっかけにもなりました。「ていうかbrowserって何なのさ」と思った人向けに、その正体を書いておきましょう。argvはyargsから取得しています。長年の友人であるGoogleのIn-Hoにこの記事をレビューしてもらいました。ありがとう！彼の曲もぜひ聴いてみてくださいね。
