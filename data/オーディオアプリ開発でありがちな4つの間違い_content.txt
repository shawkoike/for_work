Four common mistakes in audio development （2016-6-28）by Michael Tysonここで論じているのは、オーディオアプリの開発者が陥りがちな4つの間違い、より良く開発する方法、問題個所の発見方法です。主に開発者向けの内容ですが、開発者以外の方にも知っておいてもらいたいと思います。ここでは、開発者向けの診断ツールであるRealtime Watchdogを紹介し、人気のあるオーディオライブラリの調査結果を提示します。オーディオアプリの開発はとてつもなく楽しいです。やりがいを感じるし、創造力を発揮できる範囲が大きく広がり、ひとたび開発が終われば、誰かがクリエイティブなツールとして使ってくれるのです！　こんな分野は多くないし、この領域で働けるなんて非常に幸運だと自分でも思っています。しかし、仕事でオーディオアプリを扱う時には深く考えなければならない部分もあります。オーディオアプリの開発者としてユーザに対する責任があるのです。大前提として、ユーザを公共の場で困らせてはなりません。ミキサーから耳をつんざくような中域の音が出てきたら、DJはありがたがらないでしょう（でも、これはクラブ次第かも。喜ばれたりして？）。あるいは、伴奏に使うドラムマシンが常軌を逸した音を出せば奏者は演奏を投げ出すでしょう。同じことはプライベートな場合でも起こります。ただ収録しただけのはずなのに、録音した音の途中に巨大なクリック音が出てきたりすると、ユーザは開発者を呪うでしょう。今や世の中はAudiobus/IAA以降の世界です。ユーザのセットアップは多岐のアプリにわたり、1つ悪さをするのがあると全てが台無しになる上に、問題がどこから生じたのかも分かりません。もしLoopy HDが途中で不具合を起こしたらと、想像してみてください。「The Tonight Show」のオーディオ担当のエンジニアが私に話してくれたところでは、上記のコーナーでLoopyを選んだ主な理由は「エンジニア自身が長年Loopyのユーザで、Loopyがいつも安定して信頼できるものだから」ということでした。典型的なセッション中にアプリが不具合を起こす確率がたった1万分の1だとしても、もしアプリが1日に1万セッションを行えば1日に1回の不具合が出ます。これは珍しいことではありません。1日に2万セッションなら不具合が2回です。間違いなく、ほとんどの音楽アプリはこれよりも高い確率で不具合を起こしています。たった1回の不具合でライブ演奏中のミュージシャンは自分の全セットアップを完全に信じられなくなります。トラブルシューティングできないセットアップの1つがアプリです。その理由は、それが不透明なシステムだからです。それゆえ、使っている個々のアプリ全部がトラブルシューティングの対象になってしまいます。全アプリの使用を止めなければなりません。全ミュージシャン仲間に向けて、Facebookで怒りの投稿となってもおかしくなく、この記事を読んでいる人々の望みとは正反対のことが起きてしまうのです。つまり、私がこの記事でフォーカスしたいのは、私たちオーディオアプリの開発者が負っているこの種の注意義務のことです。なぜなら、音楽アプリは安定して信頼できるものでなければならないからです。いつ、いかなる時でも。先にお伝えしておきます。私は完璧なソフトウェア開発者ではありません。全くそんなことはありません。間違いもあるし、できる限りのことをしてなくそうとしても、バグがひそかに入り込んでしまいます。ですから、この記事に傲慢なところがあっても、上に座って見下しているというよりも、脇に立ったまま指摘しているのだと考えてください。

AudiobusとThe Amazing Audio Engineの仕事を通じて、数多くの開発者たちのコードを詳しく知りました。それは、この分野に来た新人のコード、有名企業で働く開発者のコード、双方が含まれています。残念なことですが、私が思っていた以上に、私が見た両方のグループのコードのどちらもがオーディオを扱う際の基本的なルールを1つ以上破っています。実のところ、常に見かけるのです。私は頭がおかしくなりそうです。さらに驚いたことに、そこから生まれた注目のライブラリの多数もルールを破っていました。この記事の末尾に、人気のあるオーディオエンジンのライブラリに対する簡単な調査結果を載せましたので見てください。最近Loopyの不具合を大急ぎで修正しなければなりませんでした。結局のところ、Loopyにサードパーティのライブラリ（オーディオエンジンではない何ものか）が余計なことをやって不具合が引き起こされていました。
.ruleslist{margin-top:20px;margin-bottom:40px;font-size:24px;font-weight:200;}.ruleslist li{margin-top:20px;}.ruleslist span{display:block;font-size:14px;color:#bbb;}
これらは横暴なルールに見えるかもしれません。しかし、この4つのどれかを破ると、苦労して作ったオーディオのコードが、予想だにしない時にバチバチと音を立てたりクリックを発生してしまうような、めちゃくちゃな状態になります。アプリの中にサードパーティのライブラリがあり、それがルールを破っていても同じことが起き、さらに悪い状態になります。アプリのオーディオエンジンが不具合を起こしうる原因は他にもたくさんあることに留意してください。例えば、ロジックのエラー、適切ではないルーチン、あるいは、単にデバイスの能力を超えた要求などです。しかし、上記4つは見つけて対応するのが簡単です。私は常にこの4つを見ています。これらのルールを破ると、耳をつんざくような破壊音がとどろいたり、わずかなクリック音が出たりしてしまいます。気付かないかもしれませんが、ぜひ避けてください。基本的には、実行時のタイムアウトです。以下、どのようにして起きるかの説明です。あらゆるオーディオアプリの実行時には最低2つのスレッドが実行されます。メインのスレッドとオーディオのスレッドです。しばしば他のものも動きます。たとえば、ネットワークのスレッドやユーザインターフェースをレンダリングするスレッドです。限られたリソースであるCPUは、これらのスレッドと現在動作中の他のアプリ全てとの間で共有されます。オーディオのリアルタイムのレンダリングはかなり過酷です。システムはn秒ごとにn秒のオーディオデータをオーディオハードウェアに送り出さなければなりません。そうしなければ、バッファが枯渇し、ユーザは不快な雑音や異常音を聞くことになります。再生中の音から無音への移行は難しいのです。
オーディオスレッドは一定の間隔で処理され、たった数ミリ秒以下という非常に厳しい時間制約の中でタスクを完了させなければなりません。リアルタイムスレッドなので、特定の権限が与えられます。UI（上記では青色のスレッド）で何かが起こったり、ネットワーク操作（オレンジ色のスレッド）が実行されていたりしても、オーディオのレンダリングが優先されます。CPUはオーディオスレッドを処理するために全てを中断します。最優先されるのは、それが必要だからです。現在使用されている一般的なオペレーティングシステムはどれも本当の”リアルタイム”OSではありません。”最善の努力”をするアプローチを取っているので、リアルタイムに近づけるよう努力はしているのでしょうが、確かな保証はされていません。つまり、全くどうすることも出来ない何かが起こり、オーディオスレッドが中断され、タイムアウトしてしまう可能性があるということです。ですから、私たちが目指すのは、うまくいかない場合のリスクを最小限に抑えることです。オーディオスレッド上で実行中のコード内で前述のルールの1つを破ると、厄介なことが起こります。メインスレッドと共有のデータ構造を使用しているコードがあるとしましょう。それは再生する音符のリストかもしれません。そして恐らく、ユーザのキー操作に応じて、そのリストに対し、音符の追加や削除が必要になるでしょう。これで、リストを取得し、リスト内の音符に基づいた音を生成するオーディオレンダリングのコードが出来ました。しかし、私たちはメインスレッドとオーディオスレッドが共有するリソースを使って作業しています。いつでも中断されたり、同時に実行されることすらあったりするので、オーディオスレッドがデータを読み込んでいる最中にメインスレッドによって編集され、クラッシュやデータの破損が生じてしまうといった状況に陥る可能性があります。こういった並行性の問題に対処するため、通常はロック（別名mutex、Mutual Exclusionオブジェクト）を使用します。これにより、一度に1つだけスレッドが処理されます。共有されたデータ構造とやり取りする際は、既にロックされているかどうかを確認します。ロックされている場合、ロックが解除されるまで待ちます。解除されたら、自スレッドのためにロックし、処理が終わったら、ロックを解除します。そうすれば、同時にアクセスするのを避けられます。先ほどの例に続けて、こことリストを操作する関数の両方で、mutexを使って自スレッドを保護していきましょう。出来ましたね。さあ、ここからです。メインスレッドによってリストが更新されている最中に、オーディオスレッドでpthread_mutex_lockに達すると、どうなるでしょうか。CPUはオーディオスレッドをブロックし、そのオーディオスレッドを放置して、ブロックされていない別のスレッドを優先します。メインスレッドでリストの更新を完了するのに時間がかかりすぎると…
そうです。タイムアウトしてしまい、オーディオシステムに不具合が発生しました。以下のように聞こえます。
document.createElement('audio');
http://atastypixel.com/blog/wp-content/uploads/2016/06/Glitch.oggそれでは、リストを更新するコードを超高速で実行する何かと入れ替えてみたらどうでしょうか。短時間ロックを維持するだけであれば、大丈夫ですよね？いいえ。とんでもありません。長時間ロックを維持することさえなければ大丈夫だと考える開発者もいますが、間違っています。理由は以下の通りです。上記の図にあった黄色のスレッドを覚えていますか？　それがメインスレッドより少し優先度が高いとしましょう。恐らくアプリはMIDI作業を行い、タイムクリティカルなオフライン処理やネットワーク通信を行っているでしょう。これら全てがより高い優先度を必要とするかもしれません。マルチスレッドに関する問題は、手に負えないレベルです。スケジューラ　―CPUの注意をそらす不可解なケダモノ― が、どこででもスレッドを中断させ、CPU時間をより多くの時間が必要な他のスレッドに渡してしまいます。そして、それがたった1つのプロセス内で起こるのです。さらに、スケジューラは、動作中の他のアプリのスレッドをCPUに処理させる必要もあります。スケジューラは、忙しいやつなのです。そのため、こんなことが起こります。
メインではないスレッド（黄）がメインのスレッド（青）よりも優先度が高いため、スケジューラはCPU時間をメインスレッドから奪います。そのメインスレッドを、さらにオーディオスレッドが待っています。これが優先順位逆転と言われる現象です。メインスレッドをロックしている時間を最小限にすることによって、この発生確率をいくらか下げていますが、完全に除去しているわけではありません。そして、それは、単に十分ではないと言うべきでしょう。そう、これは、私たちや小さなテスタグループにとっては今のところ適度に動くかもしれません。しかし、アプリは、ユーザベースで1日に数千セッションを行っている可能性があります。AudiobusやIAAのマルチアプリケーション環境と組み合わせれば、リスクは増えます。処理数が増加するためです。もし、典型的なセッション中に不具合が発生する確率がたった1万分の1だとしても、アプリが1日に1万セッションを行なえば、毎日ユーザの誰かのアプリに不具合が起こるでしょう。Objective-CやSwiftを使ってオーディオをレンダリングすると非常に便利かもしれません。オブジェクトを渡して、継承、多相性などが可能になるからです。サードパーティのオーディオライブラリの多くがそうしています。しかし、何が問題なのだと思いますか？Objective-CとSwiftには、通常の処理の一部にロックがあるのです。Objective-Cのメッセージ送信システム、つまり、Objective-Cメソッドの呼び出しの裏には、ロックの保持を含む多くの処理を行うコードがあります。信じていませんね？　ご自分でよく見てください。ソースコードは、opensource.apple.comにあります。objc_msgSendが__class_lookupMethodAndLoadCache3を呼び出し、これがlookUpImpOrForwardを、これが、そう、lock(runtimeLock)を呼び出し、これはグローバルなrwlock_tで、あと、lock(cacheUpdateLock)ともう1つを呼び出します。ところで、ドットシンタックスを使ってプロパティにアクセスすると(myInstance.property)、Objective-Cメソッドコールとみなされます。従って、この方法も使ってはいけません。実際、ARCがObjective-CやSwiftのオブジェクトを保持するようにはできません。ご想像の通りでしょうが、保持メカニズムもロックするからです。これを確認してください。sidetable_retainがtable.trylock()を呼び出し、もしこの呼び出しに失敗すると、table.lock()を呼び出すsidetable_retain_slowを呼び出します。mallocの類についてです。これは、作業のためのメモリブロックを割り当てる関数ですが、実行時間が無制限という点に問題があります。ということは、あまり時間がかからないと予想していると、予想よりもずっと時間がかかる可能性があり、優先順位逆転と同じような問題となります。面倒ですが、この内容の言及の他に、ここに直接参照があるのではと必死に探しました。ソースコードまで調べるのはやめにしました。何をどこに探しに行けば良いのか分からなかったし、iOSやOS Xは閉鎖的なシステムなので、見つかるかどうかの確証がなかったからです。だから、少なくとも現時点では、この件についてよく知っている人の言葉を参考にしましょう。無制限の実行時間に加え、mallocはロックも使います。入出力関数の全て、つまり、read、fread、fgets、write、send、sendto、recv、recvfromなどは、mallocのように実行時間が無制限です。メインではないスレッドである必要があります。残念ながら、これらも使うべきではありません。ブロックを保持したり、保持を解除したりしない限り、オーディオスレッドでブロックを安全に呼び出すことが出来ますが、オーディオスレッドでブロックを生成すると、オブジェクトの保持やメモリ割り当てを行うことになり、ひいては、どちらもロックにつながります。しかし、この件に関して、良い知らせがあります。すぐに知りたければ、AEMessageQueueについての説明に行ってください。既に説明した通り、広く使われているオペレーティングシステムは、どれも本当のリアルタイムOSではありません。ということは、保証がないということです。ですから、トラブルが起こる可能性を最小限にするしかありません。そして、良い知らせは、これに対応しているツールがたくさんあり、非常に簡単に使えるものもあるということです。まず、Objective-CはCに基づいて構築されていて、Objective-Cのインスタンスは、実質的にC構造体のように@implementation block内のCの関数からアクセスできます。これは、シンプルで古いポインタ逆参照で、Objective-Cが不正にロックなどする余地はありません。リアルタイムスレッドで使うのに確実に安全です。従って、オブジェクトを渡すことも使用することもできます。しかし、先ほど言ったように、いかなる保持も避けなければなりません。もう一度言っておきます。Objective-Cインスタンスの変数を宣言する際、__unsafe_unretained属性を使ってARC関係の処理を回避する必要があります。簡単でしょう？注意：公開前のこの記事へのフィードバックで、Tempo Rubato (NLog, Nave, iSEM)のRolf Wöhrmann氏から、Objective-CやSwiftのオブジェクトにオーディオコード内からいかなる参照もすべきではないとの指摘がありました。__unsafe_unretained属性付きでもダメです。代わりにCかC++変数で渡すだけにすべきとのことです。この2つを完全に分離させる方が良いそうです。これが確実に最も安全な方法で、効果的な防衛戦略です。もし疑うなら、やってみてください。これについては、色々な方法があります。Appleはlibkern/OSAtomic.hのヘッダ内で、OSAtomicEnqueueとOSAtomicDequeue、OSAtomicAdd32BarrierとOSMemoryBarrierなど、とても便利な機能を数多く提供しています。また、ロックがない場合に備えてまともな対処法を用意している限り、tryLock（pthread_mutex_trylockなど）が利用できると考えられます。知っていると便利ですが、最新のプロセッサなら、int、double、float、bool、BOOL、ポインタなどのスレッド上の変数に安全に値を割り当てることができます。また、読み取る際には一部の値だけが割り当てられているため、別のスレッド上で読み取ってもバラバラになる心配はありません。これは、変数が自然にアライメントされる限り（例として、Objective-Cのインスタンス変数やアンパックの構造体であれば自然にアライメントされます）、バイト、半語、語長などの割り当てが、不可分だからです（ARM アーキテクチャ リファレンス マニュアル ARMv7-A および ARMv7-R エディション）。他のタイプの変数には必ずしも当てはまらないので注意してください。例えば、32ビットのプロセッサでuint64_tという変数を割り当てると、うまくいきません。なぜなら、処理の途中で他のスレッドから値を読み込めるようにするために、プロセッサは値の格納に2つに分かれた命令を必要とするからです。しかし、もし面倒が嫌なら、便利な支援ツールはたくさんあります。皆さんがこれらのツールを使ったとしても、私は皆さんを責めたりしません。同時に起こるプリエンプティブな操作をとことん考えようとすると、私も頭が痛くなってきます。私が使っているものをご紹介します。TPCircularBufferは、数年前に自分で書き、今でも日常的に使用している循環バッファライブラリです。この循環バッファライブラリは、広く利用されています。これを使うと、1つのスレッドの一端にデータを置き、そのデータを他のスレッドから引き出すことができます。その際、ロックは不要で、循環バッファをラップポイントと共に使っているということを完全に無視させてくれる仮想メモリのトリックを使います。これはインターリーブなAudioBufferListsとインターリーブではないAudioBufferListsの両方で、読み取りや書き込みを可能にしてくれます。また、AudioTimestampの値も含んでいます。これらはどれも、Core Audioの利用を簡単にしてくれます。また、The Amazing Audio Engine 2にAECircularBufferとして.組み込まれています。The Amazing Audio Engine 2のAEManagedValueはポインタ変数を提供します。このポインタ変数は、慎重に管理されているため割り当てが不可分で、オーディオスレッドが値を使い終えた直後にのみリリースされます。これは、どんなデータ構造やObjective-Cクラスを指す場合にも使うことができます。値を変える時は、オーディオスレッドに干渉しない古い値だけがリリースされます。前述したNoteリストの例を先に進めるために、AEManagedValueを使ってNoteListポインタへの参照を維持し、変更があった場合は単純に割り当てをやり直すことができます。もう少し簡単にするために、ここでもThe Amazing Audio Engine 2のAEArrayをAEManagedValueに構築し、オーディオスレッド上で安全にアクセスできるNSArrayとC言語の配列の間にマップを実装します。もしくはObjective-CのオブジェクトとC言語の構造体の間にマッピングするブロックを与えます。上の例をもう一度振り返ってみましょう。NSArray内に、MyNote Objective-Cクラスがあるとします。最後に、またしてもThe Amazing Audio Engine 2のAEMessageQueueを使うことで、ブロックをオーディオスレッドで機能させるスケジュールを設定することができます。別の使い方として、メインスレッド上のターゲットやセレクタのスケジュールを安全に決めることもできます。これは、libdispatchに少し似た働きをしますが、オーディオスレッドは完璧に安全です。私は、問題の診断を少し簡単にするツールを開発しました。このアイディアの元になったのは（有名なAudulusの）Taylor Hollidayです。これは、Realtime Watchdogという小さなライブラリで（バージョン1に引き続き、The Amazing Audio Engine 2にも組み込まれています）。これをプロジェクトに加えれば、オーディオスレッド上で安全でない動作が行われていないかを監視し、もし何かを見つけたら警告を出してくれます。全てを検出することはできないでしょうし、Apple自身のシステムコード内で起こることもキャッチできません。ですが、コードと、あなたが使っている静的ライブラリでは、若干のロックとメモリ･アロケーション、Objective-Cが使用しているもの（Swiftではありません）、オブジェクトが保持しているもの、そしてcommon IOが取得しているものなら発見することができるはずです。これを使用するためには、”RealtimeWatchdog”をCocoapods Podfileに追加し(“pod 'RealtimeWatchdog“)、pod installを実行するだけです。これでできました。自動的にデバック構成のための全ての違反が通知されるようになります。またリリース構成においては何も動作しません。デバック構成では、Objective-Cのメッセージ送信が少し遅くなるでしょう。そこでAERealtimeWatchdog.hで定義されたREALTIME_WATCHDOG_ENABLEDをコメントアウトすることで、いつでも割り込みを抑制することができます。もしCocoapodsを使用しない場合、GitHubリポジトリ上のインストラクションをチェックしてみてください。The Amazing Audio Engine 1または2を使っている場合は、動作させるためにAERealtimeWatchdog.hで定義されたREALTIME_WATCHDOG_ENABLEDをアンコメントしてください。携帯性、利便性、手ごろさ、そしてプラットフォームの持つ力のために、ますますミュージシャンはハードウェアを売って、iOS志向になり、すなわち楽器を手放し、アプリで楽曲制作を行うミュージシャンが増えてきています。私は、しばしばユーザからLoopyとAudiobusがどんなに彼らの創造的な可能性の世界を広げているかを聞きます。その声からもとても刺激ややりがいを感じました。しかし同時に、失望と不満という声も聞きます。アプリがバグったり、正しく動作しなかったり、とプログラムの問題回避法を必要とし、不安を引き起こします。開発者たちと一緒にその問題に取り組んでみた場合、しばしばオーディオスレッドのルールに反していることが原因となります。つまりロックを持たない、Objective-C/Swiftを使用しない、メモリを割り当てない、IOを動作させないということです。このアドバイスは「システムレベルで何が起きているか」という推測に基づいている、と言及する（ここではRolf Wöhrmannの知己に富んだ言葉を言い換えます）ことは意味があるでしょう。しかしiOSとMac OS Xは閉じられたシステムです。opensource.apple.com経由で機器の中のピークを得ることだけができます。その成果はとても微々たるものです。こういったルールに従ったとしても、上手く行かなくなることもあります。そこで経験に基づいた推測をしてみます。理論的には、それが難解でテクニカルだとしても、テストをして実験してみます。私のアドバイスですか？　注意して聞いていてくださいね。Core AudioのAPIメーリングリストに参加して、質問してみてください。また、Xcodeを開いてオーディオコードで何が起きているか見てみてください。Realtime Watchdogを試して、あなたのコードとあなたが使っている外部のライブラリをチェックするために使ってください。記事の最後に、人気のあるライブラリとオーディオスレッドの安全性を記したリストがあります。またC++をチェックすることを考慮してみてください。オーディオではObjective-Cより安全で、C単体より多くの機能を与えてくれる傾向があります。もしクラッキングやグリッチが起こっていて、それらをどうにかしなければならないのであれば、コードの最適化を検討したいと思うでしょう。特にAccelerate frameworkなどを使用して、あらゆるスカラ演算をベクトル演算と入れ替えます。コードの書き方にさらに注意を払うことによって、iOSオーディオをユーザにとってよりよい経験に作り上げることができます。すると今度はより真面目なユーザやインフルエンサをプラットフォームへ引きつけることができます。それは全ての人にとって利益となるはずです。楽しいコーディングを！私の仕事をチェックし、意義あるフィードバックをしてくれた開発者の皆さまに、多大なる感謝の意を表します。そしてもちろん、私のパートナー、AudiobusやAudanikaのSebastian Dittmannにも感謝しています。ここでいう“警告”とは、必ずしもライブラリを完全否定するものではないことに注意してください。これは、そのライブラリがトラブルの可能性を上げるということを意味するのではなく、おそらくそのような部分もあるということです。これが価値あるものかどうかを決めるのは、あなたです。私は、それぞれのケースを最大の努力で評価しましたが、間違いがあるかもしれません。どんなコメントも大歓迎です。最終更新は2016年6月28日。注：あなたが使っているライブラリがこのリストにない場合、あるいはリストが間違っているので確認してほしい場合は、コメントを残すか私にメールを送ってください。もしもあなたが、安全ではないとされているライブラリの開発者で、このリスト作成後にアップデートした場合も、同様にしてください。リストを更新します。JUCEにおけるmutexの使い方についての、Julian Storerのコメント
