Understanding Perlin Noise （2014-08-09） by Adrian Biagioliこの記事の目的はKen Perlinの改良パーリンノイズを分かりやすく分析し、お伝えすることです。記事内のコードはC#で書かれており、自由にご利用いただけます。最終形のみを見たい方は、こちらから最終的なソースをご確認ください。パーリンノイズは手続き的なコンテンツ生成によく使われる、非常に強力なアルゴリズムです。ゲームや、映画などの視覚媒体に特に有用です。パーリンノイズの開発者であるKen Perlinは、この最初の実装でアカデミー賞を受賞しました。彼が2002年に発表した改良パーリンノイズについて、私はこの記事で掘り下げていきます。パーリンノイズは、ゲーム開発においては、波形の類や、起伏のある素材、テクスチャなどに有用です。例えば手続き型の地形（Minecraftのような地形はパーリンノイズで生成できます）、炎のエフェクト、水、雲などにも使えます。これらのエフェクトのほとんどが2次元、3次元で使用するパーリンノイズを代表するものですが、このノイズはもちろん4次元にも使用可能です。さらに、パーリンノイズは（テラリアやStarboundなどに使われている）横スクロールの地形や、手書き線のような画像描写にも使用できます。また、パーリンノイズを拡張して、時間という新たな次元も表現できます。例えば、2次元のパーリンノイズは地形生成として機能しますが、同様のノイズが3次元では海のうねる波として解釈されます。以下は次元ごとのノイズと実行結果を表にしたものです。ご覧の通り、パーリンノイズは自然発生する多くの現象に対して適用できます。ではパーリンノイズのアルゴリズムを数学的および論理的に見ていきましょう。注：この章は、Matt Zuckerによって書かれた素晴らしい記事から多くを引用していることを先に述べさせていただきます。しかし、彼の記事は1980年代初めに書かれた最初のパーリンノイズのアルゴリズムを基にして書かれています。私の記事では2002年に書かれた改良パーリンノイズのアルゴリズムを扱います。従って、私のバージョンとZuckerのバージョンにはいくつか大きな違いがあります。ではパーリンノイズの基本的な関数からはじめましょう。入力としてx、y、zの座標を引数に取り、結果は0.0から1.0の間のdouble型で返されます。入力はどのように考えるのでしょうか？　まずx、y、zの座標を単位立方体に分割します。つまり立方体の中の座標の位置を見つけるには、[x,y,z] % 1.0を求めます。以下の図はこの概念を2次元で表現したものです。図１：青い点は入力座標を示し、他の4つの点はそれを囲む整数の単位座標を表す ソース4つ（3Dでは8つ）の単位座標はそれぞれ、擬似乱数勾配ベクトルと呼ばれるものを生成します。勾配ベクトルは正の方向（ベクトルが指し示す方向）と、当然、負の方向（ベクトルが指し示すのと逆の方向）も定義します。擬似乱数とは勾配ベクトルの方程式に入力された任意の整数に対して、常に同じ結果が出ることを意味します。従って、無作為のように見えても実際は違います。さらにこれは、それぞれの整数座標が、グラディエント関数が同じであれば決して変わらない”固有の”勾配を持つことを意味します。図2：上の図を元にした勾配ベクトルの例（ソース）しかしながら、上の図は完全に正確ではありません。この記事で扱っているKen Perlinの改良パーリンノイズでは、これらの勾配は全くの無作為ではありません。立方体の中心点のベクトルから辺に向かって取り出されます。これらの特定の勾配ベクトルの根拠はKen PerlinのSIFFRAPH 2002の論文「Improving Noise」で述べられています。注：パーリンノイズに関する他の記事の多くは、これらのベクトルを使用していない、改良前のパーリンノイズのアルゴリズムを参照しています。例えば、図2は、改良アルゴリズムが発表される前に書かれたソースを参照しているため、初期のアルゴリズムを示しています。しかしながら、根本的な考え方は同じです。次に、任意の点から格子線上の8つの周囲点へ向かう4つ（3Dでは8つ）のベクトルを計算する必要があります。2次元の場合の例を以下に示します。図3：距離ベクトルの例（ソース）そして2つのベクトル（勾配ベクトルと距離ベクトル）の間のドット積を求めます。これにより最終的な影響値が分かります。2つのベクトルのドット積は、それらのベクトルがなす角の余弦とその2つのベクトルの大きさを掛けたものに等しいため、これが成り立ちます。言い換えると、もし2つのベクトルが同じ方向を指していれば、ドット積は以下のようになります。また2つのベクトルが逆方向を指している場合のドット積は、以下のとおりです。2つのベクトルが直交していれば、ドット積は0になります。このように勾配の方向と同じであれば、ドット積の結果は正の数となり、逆方向であれば負の数になります。これが勾配ベクトルの正負の定義方法です。この正負の影響を表す図形を以下に表します。図4：2次元ノイズにおけるベクトルの正負の影響例（ソース）次に、4つ（3Dでは8つ）の格子点の間の加重平均を算出するため、4つの値を補間する必要があります。これを行う方法は簡単です。以下のように平均を出せばいいのです（以下に示すのは2次元の例です）。上で述べた加重平均を算出したら、完成まではあと1工程あります。最終結果は線形補間となるため、あまり美しくはなりません。簡単に計算できるものの、不自然に見えます。勾配間はゆるやかな移行が必要です。そこで、フェード関数を使用することにしました。イーズ曲線とも呼ばれるものです。図5：イーズ曲線の例（ソース）上述のコードの例で言うと、このイーズ曲線はuとvの値に適用されます。これにより整数座標に近づくにつれ、ゆるやかに変わります。改良パーリンノイズの実装でのフェード関数は次のようになります。6t^5 – 15t^4 + 10t^3理論的な話は以上です。これでパーリンノイズを生成するのに必要とされるコンポーネントは全てそろいました。次はコードに移りましょう。繰り返しになりますが、コードはC#で書かれています。コードはKen PerlinのJava実装コードに多少変更を加えたバージョンです。ノイズの繰り返し（タイル）を追加しただけではなく、明確さと可読性を上げました。コードはもちろん全て自由にお使いいただけます（私がゼロから書いたわけではありません。Ken Perlinのおかげです）。まず最初にするべきことは、順列テーブル、つまりp[]配列を設定することです。単純に0～255の乱数を包含する長さ256の配列です。後でバッファオーバーフローを起こさないように、この配列を繰り返します（全体サイズは512バイト）。p[]配列は、後でハッシュ関数で使用し、勾配ベクトルを決定します。詳細については後述します。次に、パーリンノイズ関数を書き始めます。上記のコードは見ての通りです。まず、変数repeatよりも入力座標が超過していればオーバーフローが起きるように、モジュロ（剰余）演算子を使用します。次に変数xi, yi, ziを用意します。これらは座標を含む単位立方体を表します。また、座標は[0,255]の包括的範囲に限定し、p[]配列にアクセスするときにオーバーフローエラーにならないようにします。実はこれには残念な副作用があります。パーリンノイズは常に全ての座標を繰り返してしまうのです。しかしパーリンノイズでは小数点座標がありえるため、この繰り返しは問題ではありません。そして最後に単位立方体内部の座標の位置を求めます。基本的にはn = n % 1.0となり、nは座標を表します。今度は上記（図5）に書かれているフェード関数を定義する必要があります。先程も書いたとおり、これはパーリンノイズのフェード関数です。
6t5-15t4+10t3
コード内では以下のように定義されます。u、v、wの値は後から補間して使用します。パーリンノイズのハッシュ関数は、入力する全座標の固有値を得るために使用されます。Wikipediaでは、ハッシュ関数は以下のように定義されています。これはパーリンノイズが使用しているハッシュ関数です。前に作成したp[]のテーブルを使っています。上のハッシュ関数は、入力座標を囲む8つの単位立方座標全てをハッシュします。inc()は単に数を増やしてノイズが繰り返しているかを確かめるために使っています。繰り返しできるかどうかの確認が必要なければ、inc(xi)をxi+1に置き換えられます。ハッシュ関数の結果はp[]配列により0から255の間（包括的）の値となります。私はこれまでずっと、Ken Perlinの改良前のgrad()関数は不必要に複雑で混乱しやすいものだと思っていました。思い出してください。grad()の目的は、無作為に選択された勾配ベクトルと8つの位置ベクトルのドット積を計算することです。Ken Perlinは、ビットを反転させるコードを使ってこれを計算しました。上のコードをもっと分かりやすい（しかも多くの言語でもっと速く書ける）書き方にすると、以下のようになります。上のコードのソースは、こちらで確認いただけます。どのような場合でも、この2つのコードは同じ働きをします。どちらも以下の12のベクトルから無作為に1つのベクトルを選択します。これはハッシュ関数の値の最後の4ビット（grad()の1番目のパラメータ）によって決まります。他の3つのパラメータは位置ベクトル（ドット積に用いられるもの）を表しています。今度はここまでの全ての関数を使って、周りの8つの単位立方座標を補間し、つなげます。最後に、パーリンノイズをさらに自然に見えるようにする方法について議論したいと思います。パーリンノイズがある程度自然な振る舞いを実現させることは確かですが、自然界で見られるような不規則性を完全に表現できるわけではありません。例えば地形には、山などのように大きく広範囲に広がる特徴や、丘やくぼ地くらいの規模のもの、また石や岩などの細かい特徴、そして非常に小さなものでは小石など、地形の中ではごくわずかな差となるものまであります。これに対しての解決策は非常にシンプルです。周波数や振幅を変えた複数のノイズ関数を使い、これらを合成するのです。もちろん、周波数とはサンプリングされるデータの周期のことで、振幅とは結果が表す範囲のことです。図6：周波数と振幅を変えたノイズの結果6例（ソース）これらの結果を合成すると、以下のようになります。図7：上の結果を合成したもの（ソース）明らかに、この結果の方がはるかに説得力がありますね。上の6つのノイズは、異なるノイズのオクターブを呼び出したものです。連続するそれぞれのオクターブが最終結果に与える影響はどんどん小さくなっていきます。もちろん、オクターブが1つ増えるごとにコード実行時間は線形増加しますので、実行時（例えば60fpsで実行する手続き型の炎のエフェクトなど）には数オクターブ以上使おうとしない方がいいでしょう。しかし、オクターブはデータの前処理（地形の生成など）の時は最高です。では、連続したそれぞれのオクターブはどのくらいの影響力を持つのでしょうか。これを決めるのは、パーシステンスと呼ばれる、また別の値です。Hugo Eliasは、パーシステンスを以下のように定義しています。ここでは、iが問題のオクターブを表しています。コード内の実装はシンプルです。以上で説明は終わりです。これでノイズを作れるようになりました。ここで全てのソースコードを参照できます。もし疑問点があれば、下のコメント欄で質問してください。もし興味があれば、下の参考文献をチェックしてみてください。
* Ken Perlin’s “Official” Improved Perlin Noise―これはKen Perlinが書いた最初のアルゴリズムです。
* “The Perlin Noise Math FAQ”―これはアルゴリズムについての理論的なリファレンスとしてすばらしいものです。しかしこちらは私がこの記事で使用したアルゴリズムではなく、80年代に書かれた最初のパーリンノイズのアルゴリズムを用いていることにご注意ください。
* Hugo Elias’ article―パーリンノイズについての最も有名な記事の1つです。これはオクターブやパーシステンス、現実世界におけるパーリンノイズの使用に関する優れた参考文献です。しかし、これは本当のパーリンノイズではありません。Hugoのアルゴリズムはパーリンノイズのように勾配に基づいたものではないのです。これはバリューノイズと呼ばれるもので、実質的にはホワイトノイズをぼかしたものです。混乱しないでくださいね。
* “How to use Perlin Noise in Your Games” – Devmag―パーリンノイズの潜在的な利用方法についての、なかなか良い記事です。読み物としては非常に面白いですが、こちらも本当のパーリンノイズではありません。この記事の中でDevmagが使っているのはバリューノイズです。
* GPU Gems – “Implementing Improved Perlin Noise”―この記事はパーリンノイズを使ってリアルタイムに美しい海の景色をレンダリングするのに、GPUのものすごいパワーを利用するというものです。シェーダはすごいですね。読んでいただきありがとうございました！2014/9/8―記事を更新しました。ドット積についてより分かりやすい説明を入れ、また記事内の誤字を修正しました。redditのr/programming、r/gamedev、r/Unity3Dでアドバイスをくださった皆さん、本当にありがとうございます。
