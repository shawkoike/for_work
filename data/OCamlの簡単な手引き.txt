<p><a href="http://mads379.github.io/ocaml/2014/11/13/ocaml-briefly.html#sec-1" rel="nofollow" title="" class="ext-link">OCaml Briefly</a> （2014-11-13） by <a href="http://mads379.github.io/" rel="nofollow" title="" class="ext-link">Mads Hartmann</a></p><p>本記事では、<a href="https://ocaml.org/" rel="nofollow" title="" class="ext-link">OCaml</a>について簡単に説明します。ここでは、私が最も優れていると考えるOCamlの機能のみを取上げます。</p><p>本記事では、機能を説明する上で使用例はあまり使わず、どちらかというと構文を使っていきます。すべての機能に関する詳細を知りたい方は、<a href="http://caml.inria.fr/pub/docs/manual-ocaml/" rel="nofollow" title="" class="ext-link">『OCaml Document and User’s Manual』</a>、<a href="https://realworldocaml.org/" rel="nofollow" title="" class="ext-link">『Real World Ocaml』</a>を読むことをお勧めします。</p><p>各機能の説明には、簡単な構文の説明、いくつかの例、そして参考文献のリンクが盛り込まれています。この記事自体は、OCamlの機能を少し味わってみたい方、または特定の機能をもう少し学びたいという方の参考になるでしょう。</p><p>ご意見などありましたら、<a href="mailto:mads379@gmail.com">mads379@gmail.com</a>までご連絡いただくか、<a href="http://www.twitter.com/mads_hartmann" rel="nofollow" title="" class="ext-link">@mads_hartmann</a>のTwitterアカウントにご投稿ください。</p><p>コードを試してみたい方は、<a href="http://ocsigen.org/js_of_ocaml/2.5/files/toplevel/index.html" rel="nofollow" title="" class="ext-link">オンラインのREPL</a>が利用できます。</p><p>注記:　このオンラインREPLは完成版ではありません。パターンマッチング、モジュール、ファンクタ、例外、抽象データ型、一般化代数的データ型など、対応できていないものが多々あります。</p><p>リストは、要素をセミコロンで区切り、角括弧で囲んだ形で書きます。</p><p>配列は、要素をセミコロンで区切り、角括弧と縦線で囲んだ形で書きます。</p><p>タプルは、要素をコロンで区切り、丸括弧で囲んだ形で書きます。</p><p>Let束縛は、識別子を値に関連付けることができ、次の構文を使って表します。let &lt;識別子&gt; = &lt;式&gt; in &lt;式&gt;。</p><p>^ は、2つの文字列を連結する演算子です。^ は上の例のように中置演算子として使いますが、以下のように、前置演算子とすることで簡単に文を呼び出すこともできます。</p><p>Let束縛は、関数を宣言するのにも使われます。次の項目で詳しく説明していきましょう。</p><p>前の章でご紹介したとおり、関数は、ホワイトスペースで区切られた関数名のあとに引数を加えることによって呼び出すことができます。</p><p>他のプログラム言語では、関数をカンマで区切りますが、ここではホワイトスペースと引数で区切るので、この書き方に慣れるのに少し時間がかかるかもしれません。上記の例を他のプログラミング言語で表すと以下のようになります。</p><p>しかしOCamlでは、1つの引数であるタプル(10, 24)を伴うmin関数の<a href="http://en.wikipedia.org/wiki/Partial_application" rel="nofollow" title="" class="ext-link">部分適用</a>となります。部分適用は、OCamlが備えたすばらしい機能の1つです。この機能は、N個の引数をX個の関数に渡すと、X個の関数－引数Nを返すことができます。OCamlでは、すべての関数で<a href="http://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96" rel="nofollow" title="" class="ext-link">カリー化</a>が可能です。</p><p>関数は、関数名のあとにホワイトスペースで区切った関数の引数を置いた構文で定義されます。let &lt;関数名&gt; &lt;引数1&gt; &lt;引数2&gt; = &lt;式&gt; in &lt;式&gt;。<br>
次の関数は、1つの引数x （整数と仮定します）があり、整数の2乗値を返します。</p><p>ラムダ計算をするには、funというキーワードを使って、次の構文で表すことができます。<br>
fun &lt;引数1&gt; &lt;引数2&gt; -&gt; &lt;式&gt;。つまり、上の例は以下で表すことが可能です。</p><p>前章でも触れましたが、いくつかの関数は中置演算子で表されます。 ! $ % &amp; * + – . / : &lt; = &gt; ? @ ^ | ~ のいずれかが中置演算子として使われた場合、これらの記号は関数を表すことになります。中置関数や前置関数に関する詳細については、この記事の冒頭で紹介した『Real World OCaml』の<a href="https://realworldocaml.org/v1/en/html/variables-and-functions.html#prefix-and-infix-operators" rel="nofollow" title="" class="ext-link">こちらの章</a>を読んでみてください。</p><p>引数が1つだけの関数にパターンマッチングを利用したい場合には、functionというキーワードが有効です。（これから紹介する実行文はかなり変な構文になっていますが、どうか許してください。）</p><p>パターンマッチングについては<a href="http://mads379.github.io/ocaml/2014/11/13/ocaml-briefly.html#sec-3-1" rel="nofollow" title="" class="ext-link">後ほど</a>詳しく説明します。なおこの例文から、OCamlで<a href="http://ja.wikipedia.org/wiki/%E5%86%8D%E5%B8%B0" rel="nofollow" title="" class="ext-link">再帰関数</a>を使う場合にはrecというキーワードを利用することも分かります。</p><p>OCamlでは引数の前に ~ を付けることで、ラベル付けをすることができます。ラベルのおかげでコードがより読みやすくなり、引数の順番も気にする必要がなくなります。</p><p>引数の前に ? を付けると、オプショナル引数を作ることができます。オプショナル引数の値は、 <a href="https://realworldocaml.org/v1/en/html/a-guided-tour.html#options" rel="nofollow" title="" class="ext-link">Option型</a>の変数として使うことができます。</p><p>オプショナル引数にはデフォルトの値を付与することもできます。先ほどの例文に当てはめてみると、次のように書き変えることができます。</p><p>レコードは、値の集合体をまとめて1つの値として格納するために使われる機能です。下の例文は、2つのコンポーネントが1つのpersonと名付けられたレコードとして定義されたことを表しています。</p><p>多相型を使えば、レコードにパラメータをつけることができます。</p><p>レコードに関するより詳細は、『Real World OCaml』の[こちらの章] (https://realworldocaml.org/v1/en/html/records.html)と、OCaml Users Guideの<a href="http://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html#sec11" rel="nofollow" title="" class="ext-link">こちらのページ</a>をご確認ください。</p><p>ヴァリアントは、<a href="http://ja.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B" rel="nofollow" title="" class="ext-link">代数的データ型</a>としても知られています。通常は再帰的なデータ構造を決定するために使われています。レコードと同じく、多相型を利用してパラメータをつけることができます。以下の例文では、ヴァリアントはが2分木構造を表すために利用されていることが分かります。</p><p>このtreeという型には、Leaf及びNodeという二つの構成子が含まれています。以下の例文は、このような木構造におけるノード数の最大値を計算する方法の1つを示しています。</p><p>この例文には、以前の章でも紹介したfunctionキーワードが使われています。このキーワードによってパターンマッチングが実行され、引数が1つだけの関数が定義されます。</p><p>ヴァリアントはOCamlの中でも最も使い勝手のよい機能の1つです。この機能については特に時間をかけて勉強するだけの価値があります。『Real World OCaml』の<a href="https://realworldocaml.org/v1/en/html/variants.html" rel="nofollow" title="" class="ext-link">この章</a>を読んで、実際の事例とベストプラクティスについて知識を蓄えておきましょう。</p><p>OCamlには、多相ヴァリアントと呼ばれる別のヴァリアント型があります。多相ヴァリアントを用いれば、事前に構成子を定義しておく必要がなくなります。多相ヴァリアントとは、特定の目的のために派生した通常のヴァリアントの特別版、と言っても差し支えないでしょう。</p><p>多相ヴァリアント機能に関する詳細も、『Real World OCaml』の<a href="https://realworldocaml.org/v1/en/html/variants.html" rel="nofollow" title="" class="ext-link">こちらの章</a>に詳しく書かれています。</p><p>ヴァリアントの拡張とは文字通り、新たな構成子を追加してヴァリアントが拡張できることを指しています。</p><p>これはOCaml 4.02に追加されたばかりの新しい機能なので、実はまだ自分でコードを書いたことがありません。なので、ここでは『OCaml Users Manual』で使われている例文を紹介しておきます。</p><p>詳細については『OCaml Users Manual』の<a href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246" rel="nofollow" title="" class="ext-link">こちらの章</a>をご確認ください。<br>
残念ながらこの機能は『Real World OCaml』が出版された後に追加されたので、この本の中では取り上げられていません。改訂版での解説を待ち望みます。</p>
