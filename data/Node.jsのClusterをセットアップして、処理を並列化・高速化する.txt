<p><a href="http://stackabuse.com/setting-up-a-node-js-cluster/" rel="nofollow" title="" class="ext-link">Setting up a Node.js Cluster</a> （2016-01-11） by <a href="https://twitter.com/ScottWRobinson" rel="nofollow" title="" class="ext-link">Scott Robinson</a></p><p>Node.jsが多数のイベントの非同期な処理に長けていることはよく知られていますが、それが単一のスレッドで行われていることを多くの人は知りません。Node.jsは実際にはマルチスレッドではないので、リクエストは全て単一スレッドのイベントループで処理されているだけなのです。</p><p>そこで、Node.jsクラスタを使って、クワッドコアプロセッサの能力を最大限に引き出しましょう。コードの複数のインスタンスで起動し、さらに多くのリクエストを処理します。少し難しく思えるかも知れませんが、Node.js v0.8で導入された<a href="https://nodejs.org/api/cluster.html" rel="nofollow" title="" class="ext-link">cluster</a>モジュールを使えば、実はとても簡単です。</p><p>もちろん、これは、作業を別々のプロセスに分割することのできるアプリならどんなアプリにでも役立ちますが、webサイトのような多くのIOリクエストを処理するアプリには特に重要です。</p><p>残念ながら、並行処理は複雑なので、サーバ上でのアプリケーションのクラスタリングは必ずしも簡単ではありません。複数のプロセスに同一のポートをリッスンさせる必要があるときはどうすればいいでしょうか？　同時に1つのポートにアクセスできるプロセスはただ1つだということを思い出しましょう。解決策として、各プロセスがそれぞれ異なるポートをリッスンするように設定してから、Nginxをセットアップしてポート間でリクエストの<a href="https://www.nginx.com/resources/glossary/load-balancing/" rel="nofollow" title="" class="ext-link">負荷を分散</a>するという素朴な方法があります。</p><p>この解決策は実行可能ですが、より多くの作業のセットアップと各プロセスの設定、さらに、言うまでもなくNginxの設定が必要になります。この解決策では、管理すべきものが増えるだけです。</p><p>別の方法として、マスタープロセスを複数の子プロセスにforkすることができます（通常、1つのプロセッサに1つの子プロセス）。この場合、子プロセス達は1つのポートを親プロセスと共有することを許可されて<em>いる</em>ので（プロセス間通信、つまり<a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E9%96%93%E9%80%9A%E4%BF%A1" rel="nofollow" title="" class="ext-link">IPC</a>のおかげです）、複数のポートの管理に悩む必要はありません。</p><p>複数ポートの管理こそ、あなたに代わって<code>cluster</code>モジュールがやってくれることなのです。</p><p>アプリケーションのクラスタリングは、特に<a href="http://expressjs.com/" rel="nofollow" title="" class="ext-link">Express</a>プロジェクトのようなwebサーバコードでは、極めて簡単です。下記のとおりに書くだけです。</p><p>このコードの機能は、マスターコードとワーカコードの2つの部分に分けられます。この分岐は、if文（<code>if (cluster.isMaster) {...}</code>）で行われます。ここでのマスターの唯一の目的はワーカを全て作成すること（作成されるワーカの数は、利用可能なCPUの数に基づきます）で、ワーカはExpressサーバの別々のインスタンスを実行する責任を負います。</p><p>ワーカはメインプロセスからforkされると、モジュールの先頭からコードを再実行します。ワーカがif文まで進むと、<code>cluster.isMaster</code>に<code>false</code>が返されるので、Expressアプリ、ルートを作成してから、ポート<code>8080</code>をリッスンします。クワッドコアプロセッサの場合は、4つのワーカが生まれ、同じポートをリッスンしてリクエストが来るのを待ちます。</p><p>でも、リクエストはワーカ間でどのように分けられるのでしょうか。全てのワーカが一つ一つのリクエストをリッスンしてそれに応答することができない（そして、そうしてはならない）ことは明らかです。実は、これに対処するために、別々のワーカ間に分散されたリクエストを処理するロードバランサが<code>cluster</code>モジュール内に組み込まれています。LinuxとOSXでは、ラウンドロビン（<code>cluster.SCHED_RR</code>）ポリシーがデフォルトで有効になっています（ただし、Windowsには該当しません）。スケジューリングに利用可能な他の選択肢はオペレーティングシステムに任せること（<code>cluster.SCHED_NONE</code>）だけで、これはWindowsではデフォルトです。</p><p>スケジューリングポリシーは、<code>cluster.schedulingPolicy</code>内に設定するか、または、環境変数<code>NODE_CLUSTER_SCHED_POLICY</code>に設定（’rr’ または’none’のどちらかの値）することによって設定することができます。</p><p>また、異なる複数のプロセスがどうやって単一のポートを共有するのでしょうか。ネットワークリクエストを処理する多数のプロセスを実行させるために問題になる点は、従来、同時に開くことのできるポートは1つだけだということです。<code>cluster</code>の大きな利点は、あなたに代わってポート共有を処理してくれることであり、webサーバなどのために開いたどのポートにも、全ての子プロセスがアクセス可能です。これはIPCを使って行われるので、マスターは各ワーカにポートハンドルを送るだけです。</p><p>このような機能のおかげで、クラスタリングはとても簡単なのです。</p><p><code>child_process</code>の<code>fork()</code>メソッドの経験がある人なら、それに<code>cluster.fork()</code>が似ているように思えるかもしれません（そして、両者は多くの点で似ています）。そこで、ここでは、この2つのforkの方法の主要な違いについて説明します。</p><p><code>cluster.fork()</code>と<code>child_process.fork()</code>には、いくつかの主な違いがあります。<code>child_process.fork()</code>メソッドはやや低レベルで、引数としてモジュールの位置（ファイルパス）を渡す必要があり、その他のオプションの引数として現在のワーキングディレクトリ、プロセスを所有するユーザ、環境変数なども渡す必要があります。</p><p>もう1つの違いは、<code>cluster</code>が、自身が実行を始めたのと同じモジュールの先頭からワーカの実行コードを起動することです。したがって、アプリケーションのエントリポイントが<code>index.js</code>でありながらワーカが<code>cluster-my-app.js</code>の中で生成された場合でも、ワーカはやはり、<code>index.js</code>の先頭から実行コードを起動します。<code>child_process</code>はそれとは異なり、必ずしも所与のアプリのエントリポイントではなく、渡されたファイルからコードの実行を始めます。</p><p>ここまでで読まれた方は、「<code>cluster</code>モジュールは、子プロセスを生成するために実際には密かに<code>child_process</code>モジュールを使用し、それが<code>child_process</code>自体の<code>fork()</code>メソッドで行わることで子プロセスがIPCを通じて通信することが可能になり、そうやってポートハンドルがワーカ間で共有されるのだろう」と考えているかもしれません。</p><p>明確に言えば、Nodeでのforkは実際には現在のプロセスのクローンを作成するのではなく、新しいV8インスタンスを起動させるという点で、<a href="https://ja.wikipedia.org/wiki/Fork" rel="nofollow" title="" class="ext-link">POISIX fork</a>とは大きく異なります。</p><p>この方法は、最も簡単なマルチスレッドの方法の1つではありますが、注意して使用すべきです。1000のワーカを生成することができても、そうするべきとは限りません。ワーカはそれぞれシステムリソースを消費するので、本当に必要なワーカだけを生成しましょう。Nodeドキュメントによれば、子プロセスはそれぞれ新しいV8インスタンスなので、インスタンスごとにそれぞれ30msの起動時間と、10mb以上のメモリを想定する必要があります。</p><p>ワーカのうちの1つ（または複数）が死んだらどうしますか？　クラッシュの後ワーカを再起動できないのならば、クラスタリングの美点が根本的に失われてしまいます。幸い<code>cluster</code>モジュールは<code> EventEmitter</code>を拡張し、’exit’イベントを提供します。ワーカである子プロセスの１つが死ぬと、’exit’イベントが通知するのです。</p><p>下記のコードを使うと、イベントのログを記録し、プロセスを再起動できます。</p><p>こうすると、たった4行のコードで専用の内部プロセスマネージャが備わったようなものですね！</p><p>次のパートは興味深いですよ。クラスタリングが実際のところどの程度役に立つのか見てみましょう。</p><p>この実験では、先に挙げたコード例に似ているWebアプリをセットアップしました。しかし一番大きな違いは、Expressのルート内で行われている処理のシミュレーションを、<a href="https://www.npmjs.com/package/sleep" rel="nofollow" title="" class="ext-link">sleep</a>モジュールを使い、大量のランダムなデータをユーザに返すことによって行っているという点です。</p><p>下記は同じWebアプリですが、クラスタリングしたものです。</p><p>そして比較用の’control’のコードがこちらです。全く同じもので、ただcluter.fork()がないだけです。</p><p>ユーザ負荷が高い場合のシミュレーションには、<a href="https://github.com/JoeDog/siege" rel="nofollow" title="" class="ext-link">Siege</a> というコマンドラインツールを使うことになります。Siegeを使えば、任意のURLに大量のリクエストを発行することができます。</p><p>Siegeは可用性、スループット、リクエスト処理率等のパフォーマンスメトリクスを追跡するという点で優れています。</p><p>下記はSiegeでのテストに使うコマンドです。</p><p>このコマンドを先に挙げたWebアプリの両方のバージョンで実行したところ、いっそう興味深い結果が出ました。</p><p>ご覧のとおり、このリストに挙げた全てのメトリクスについて、クラスタリングありのアプリケーションがシングルプロセスのものより約3.2倍パフォーマンスが高くなっていますし、平均応答時間ではさらに大幅に上回っています。</p>
