<p><a href="http://paulhankin.github.io/Fibonacci/" rel="nofollow" title="" class="ext-link">An integer formula for Fibonacci numbers</a> （2015-04-27） by <a href="http://paulhankin.github.io/" rel="nofollow" title="" class="ext-link">Paul Hankin</a></p><p>次のコードを用いると、なんとフィボナッチ数列が生成できます。</p><p>この記事では、その導き方と振る舞いを説明しましょう。</p><p>具体的な説明に入る前に、背景としてフィボナッチ数列の概要と計算方法を駆け足で紹介します。すでに数学の専門知識がある方は、導入部分はほとんど飛ばして、「母関数」のセクションをざっと読んでから、「整数の公式」に進んでいただいて構いません。</p><p>フィボナッチ数列とは、言わずと知れた以下の数列です。</p><p><script type="math/tex; mode=display">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots</script></p><p>この数列の<script type="math/tex">n</script>番目の値は、その直前の2つの値の和です。公式で表現すると、以下のような漸化式になります。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/05/d2.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d2.jpg" alt="d2" width="538" height="174" class="wp-image-6786"></a></p><p>ここでは数列の添え字を、一般的な1ではなく、0から始めています。</p><p>この数列には、わりと有名な計算方法が何種類かあります。以下は明示的な再帰的呼び出しを行う方法で、この実装だと処理速度は遅くなります。</p><p>次の反復実装の場合、計算量は<script type="math/tex">O(n)</script>になります。</p><p>上記よりも少し知名度が下がるのが、以下の行列のべき乗を使用した実装で、計算量は<script type="math/tex">O(\mathrm{log}\ n)</script>になります。</p><p>最後の方法は、<code>fib_iter</code>内の<code>a</code>と<code>b</code>を数列として見なす方法で、以下のように表記できます。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/05/d5.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d5.jpg" alt="d5" width="439" height="118" class="wp-image-6789"></a></p><p>これから以下の式が得られます。</p><p><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d6.jpg" alt="d6" width="379" height="103" class="wp-image-6790"></p><p>よって、もし<img src="http://postd.cc/wp/wp-content/uploads/2016/05/d7.jpg" alt="d7" class="wp-image-6791" style="vertical-align: text-bottom;height: 50px;">なら、<script type="math/tex">b_n = m_{11}</script>になります（Pythonと違って、行列の添え字は通常1が基準になることに注意してください）。</p><p>NumPy行列のべき乗が繰り返し二乗法のような振る舞いをすると想定すると、計算量は<script type="math/tex">O(\mathrm{log}\ n)</script>になります。</p><p>さらに、漸化式を解くために、閉じた式を見つける方法もあります。これにより、次の実数値の公式が導かれます：<script type="math/tex">\phi = (1 + \sqrt{5}) / 2</script>&gt;、<script type="math/tex">\psi = (1 - \sqrt{5}) / 2</script>とすると、<script type="math/tex">\mathrm{Fib}(n) = (\phi^{n+1} - \psi^{n+1}) / \sqrt{5})</script>。この手法には、任意精度の実数計算を要するという実用上の欠点がありますが、<script type="math/tex">n</script>の値が小さければ問題はありません。</p><p>任意の数列<script type="math/tex">a_n</script>の母関数は、<script type="math/tex">\Sigma_n a_nx^n</script>の無限和です。フィボナッチ数列の場合は<script type="math/tex">\Sigma_n \mathrm{Fib}(n)x^n</script>になります。つまり、これは無限に続くべき級数であり、<script type="math/tex">x^n</script>の係数は<script type="math/tex">n</script>番目のフィボナッチ数に相当します。</p><p>フィボナッチ数には以下の関係があります。</p><p><script type="math/tex; mode=display">\mathrm{Fib}(n+2) = \mathrm{Fib}(n+1) + \mathrm{Fib}(n)</script></p><p>この式に<script type="math/tex">x^{n+2}</script>をかけて<script type="math/tex">n</script>全体で和をとると、以下の式が得られます。</p><p><script type="math/tex; mode=display">\Sigma_n\mathrm{Fib}(n+2)x^{n+2} = \Sigma_n\mathrm{Fib}(n+1)x^{n+2} + \Sigma_n\mathrm{Fib}(n)x^{n+2}</script></p><p><script type="math/tex">F(x)</script>を<script type="math/tex">Fib</script>の母関数として、それを<script type="math/tex">\Sigma_n\mathrm{Fib}(n)x^n</script>と定義すると、上の式は次のように簡略化できます。<br>
<script type="math/tex; mode=display">F(x) - x - 1 = x(F(x) - 1) + x^2F(x)</script></p><p>これは、さらに整理できます。</p><p><script type="math/tex; mode=display">F(x) = xF(x) + x^2F(x) + 1</script></p><p>これを<script type="math/tex">F</script>について解くと以下の式が得られます。</p><p><script type="math/tex; mode=display">F(x) = \frac{1}{1 - x - x^2}</script></p><p>驚くことに、全てのフィボナッチ数列を網羅する簡単でシンプルな公式を、なんとか導くことができました。この式の利用方法については、次のセクションで詳しく説明しましょう。</p><p>今はひとまず技術的なことは置いておき、いくつかの<script type="math/tex">x</script>の値について<script type="math/tex">F</script>を評価してみましょう。そのためには、べき級数が収束する必要があります。フィボナッチ数列は<script type="math/tex">\phi^n</script>のように増大して、<script type="math/tex">|a|</script> &lt; 1なら等比級数<script type="math/tex">\Sigma_n a^n</script>は収束します。よって、<script type="math/tex">|x|</script> &lt; <script type="math/tex">1/\phi \simeq 0.618</script>から、べき級数は収束することが分かります。</p><p>ここまでで、Pythonのコードを理解するための準備は整いました。</p><p>まずは、この公式を直感的にとらえるため、<script type="math/tex">10^{-3}</script>で母関数<script type="math/tex">F</script>を評価してみましょう。</p><p><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d27.jpg" alt="d27" width="1122" height="205" class="wp-image-6803"></p><p>興味深いことに、小数展開した部分に<script type="math/tex">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</script>と、フィボナッチ数列が現れています。魔法のような結果に驚いてしまいますが、その理由は次の式から分かります。<br>
<script type="math/tex">F(10^{-3}) = \mathrm{Fib}(0) + \mathrm{Fib}(1)/10^3 + \mathrm{Fib}(2)/10^6 + \mathrm{Fib}(3)/10^9 + \ldots</script></p><p>この例では、フィボナッチ数列が次々と<script type="math/tex">1/1000</script>倍されて並んでいきます。つまり、その値が一旦1000を超えると、隣り合う数に影響を及ぼし始めるということです。この現象は、上記の<script type="math/tex">F(10^{-3})</script>の計算で988から確認できます。正しいフィボナッチ数は987ですが、数列の次の数から1だけオーバーフローが発生しています。その結果Off-by-oneエラーが発生し、以降はパターンが崩れてしまうのです。</p><p>しかし、いかなる<script type="math/tex">n</script>の値に対しても、10の負の指数を十分大きく取れば、たとえオーバーフローが発生したとしても、<script type="math/tex">n</script>番目のフィボナッチ数に悪影響が出ることはありません。ここでは、ある<script type="math/tex">k</script>という値について<script type="math/tex">10^{-k}</script>が妥当な値になると仮定しましょう。この値は後ほど選定します。</p><p>さらに整数で計算をしたいので（その方がコーディングしやすいので）、全体を<script type="math/tex">10^{kn}</script>倍して<script type="math/tex">n</script>番目のフィボナッチ数が整数の範囲にくるようにして、式を整理します。</p><p><script type="math/tex; mode=display">10^{kn} F(10^{-k}) = \frac{10^{kn}}{1 - 10^{-k} - 10^{-2k}} = \frac{10^{kn+2k}}{10^{2k} - 10^{k} - 1}</script></p><p>この結果を<script type="math/tex">10^k</script>を法として見ると、<script type="math/tex">n</script>番目のフィボナッチ数が得られます（先ほども書きましたが、<script type="math/tex">k</script>には十分大きな値を選んだものと想定しています）。</p><p>では先に進む前に、底を10から2に変換しましょう。理由は単にプログラミングを楽にするためです。</p><p><script type="math/tex; mode=display">2^{kn} F(2^{-k}) = \frac{2^{k(n+2)}}{2^{2k} - 2^{k} - 1}</script></p><p>あとは<script type="math/tex">\mathrm{Fib}(n+1)</script> &lt; <script type="math/tex">2^k</script>になるように、<script type="math/tex">k</script>を十分大きく取るだけです。フィボナッチ数列は<script type="math/tex">\phi^n</script>のように増大して、<script type="math/tex">\phi</script> &lt; <script type="math/tex">2</script>なので、<script type="math/tex">k = n+1</script>とすれば安全です。</p><p>これらを統合すると以下の式が得られます。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/05/d41.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d41.jpg" alt="d41" width="560" height="246" class="wp-image-6831"></a></p><p>Pythonでは左シフトの表記法が使えるので、<script type="math/tex">a</script> &lt;&lt; <script type="math/tex">k = a \cdot 2^k</script>の場合は次のように書けます。</p><p><a href="http://postd.cc/wp/wp-content/uploads/2016/05/d48.jpg"><img src="http://postd.cc/wp/wp-content/uploads/2016/05/d48.jpg" alt="d48" width="739" height="88" class="wp-image-6843"></a></p><p><script type="math/tex">\mathrm{mod}\ (2</script> &lt;&lt; <script type="math/tex">n)</script>の部分は、<script type="math/tex">(2</script> &lt;&lt; <script type="math/tex">n) - 1</script> とのビット単位の論理和（<code>&amp;</code>）として表せるので、元のPythonプログラムは次のように書き直せます。</p><p>非反復型で閉じた解が得られたのは興味深いですが、これは全く実用的な手法ではありません。ここではサイズが<script type="math/tex">O(n^2)</script>ビットの整数を用いて、整数演算を実行しています。でも実際には、最終的にビット単位で論理和を取る前に、最初の<script type="math/tex">n</script>個のフィボナッチ数が全て連結した整数値を取得しているのです。</p>
