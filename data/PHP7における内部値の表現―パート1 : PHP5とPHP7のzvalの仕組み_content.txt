Internal value representation in PHP 7 – Part 1 （2015-5-5） by Nikita Popov前回の投稿では、PHP7に取り入れられたimprovements to the hashtable implementation（ハッシュテーブル実装の改善）について書きました。それに続く形で、今回はPHPの全般的な値の新しい表現形式に目を向けてみます。取り上げる内容の量から考えて、2つのパートに分ける予定です。このパートでは、PHP5とPHP7の間におけるzval（Zend値）の実装の違い、それから参照の実装について説明し、パート2では、文字列やオブジェクトなど、個別の型の実現について、詳細に検討していこうと思います。PHP5では、zval構造体は次のように定義されます。見ての通り、zvalにはvalue、typeそれから__gc情報（後ほど話します）が含まれています。valueメンバは、zvalに格納できる複数の値の共用体です。C言語の共用体は、1度に1つのメンバのみがアクティブになる構造で、そのサイズは、最も大きなメンバのサイズと同じです。共用体の全てのメンバは、同じメモリ領域に保持され、アクセスされるメンバに応じて異なる解釈がされます。例えば上記の共用体のlvalメンバを読み込めば、その値は符号付き整数として解釈され、dvalメンバを読み込めば、値は代わりに倍精度浮動小数点数として解釈されるというわけです。共用体のどのメンバが使用中であるかを把握するため、zvalのtypeプロパティは整数の型タグを保持します。PHP5のzvalは（少数の例外を除いて）ヒープに割り当てられており、PHPは、どのzvalが使用中で、どのzvalを解放すべきかを把握しなければなりません。この目的のために参照カウントが取り入れられています。ある時点におけるzvalの”参照されている”頻度を、zval構造体のrefcount__gcメンバが保持します。例えば$a = $b = 42では、値42が2つの変数から参照されているため、refcountは2です。もしrefcountが0なら、その値は使われていないということなので、解放することができます。ちなみに、refcountが参照するリファレンス（値が現在、使用されている回数）はPHPの（＆を使う）リファレンスとは何の関係もないのでご注意ください。以降は2つのあいまいさを回避するため、用語を分けて”リファレンス”と”PHPリファレンス”としますが、今のところ、PHPリファレンスのことは無視しておきましょう。参照カウントと密に関係しているコンセプトと言えば”コピーオンライト”です。zvalを複数ユーザで共有している時、そのzvalは変更できません。共有されたzvalを変更するには複製（”分離”）を作らなければならず、その複製においてのみ変更が適用されます。コピーオンライトとzvalの破壊の例を見てみましょう。参照カウントには重大な欠陥が1つあります。循環参照を検出して解除できないということです。これに対応するため、PHPは追加のサイクルコレクタを使っています。zvalのrefcountがデクリメントされ、循環の一部になりそうな時は、zvalが”ルートバッファ”に書き込まれます。このルートバッファがいっぱいになると、マーク・アンド・スイープ・ガベージコレクションにより、可能性のある循環が収集される仕組みです。追加のサイクルコレクタをサポートするため、実際のzval構造体は以下のようになります。zval_gc_infoの構造体には、通常のzvalと共に追加のポインタが埋め込まれています。なお、uは共用体（union）を表しているので、実際のところ、これは1つのポインタで2つの型を指しているということに注意してください。bufferedポインタは、zvalがルートバッファ内のどこで参照されているかを保持するために使われており、サイクルコレクタが実行する前に破壊された場合は（その可能性は非常に高いです）削除しても構いません。ちなみにコレクタが値を破壊する時にはnextが使われますが、それについてはここでは割愛します。ここでサイズについて話をしたいと思います（以下、全てのサイズは64ビットシステム上でのサイズです）。まず、strとobjは両メンバ共に16バイトのため、zvalue_valueの共用体も16バイトになります。zval全体の構造体は（パディングにより）24バイトで、zval_gc_infoは32バイトです。それと、ヒープにzvalを割り当てることで、アロケーションオーバーヘッドの16バイトが加算されます。zvalは複数の場所で使うことができますが、それはともかくとして、zvalごとに48バイト使う計算になりますね。ここで、このzval実装の（数ある）非効率性について考えてみましょう。zvalが整数を保持する単純なケースを頭に思い描いてみてください。その場合、それ自体では8バイトになります。加えて、どんな場合でも型タグの格納が必要となってきます。これについては、本来なら1バイトですが、パディングのせいで8バイトが必要とされます。（最初の概算で）実際に”必要”とされるこの16バイトに加え、参照カウントと循環収集のための16バイトが必要となり、さらにアロケーションオーバーヘッドの16バイトも必要になります。言うまでもありませんが、割り当てと解放は実際にやらなければならず、どちらとも非常に高コストな演算です。ここで、ある疑問が生じます。単純な整数値は、参照カウントされる値や循環収集される値として、またヒープに割り当てられる値として、本当に保持する必要があるのでしょうか？　その答えはもちろんノーです。これは理にかなっていませんよね。以下にPHP5におけるzval実装の主な問題点をまとめてみました。ではPHP7で新しくなったzvalの実装についてお話しします。基本的な変更点として、zvalはもはや個別にヒープに割り当てられることはなく、自身にrefcountを保持するものでもなくなりました。代わりに、zvalがポイントする先の（文字列、配列、オブジェクトなどの）複雑な値自身にrefcountが格納されます。これにより次のような利点があります。ではzvalの定義方法を見てみましょう。最初のメンバは前と同様、valueの共用体です。次のメンバは型情報を格納する整数で、共用体を使って更に分割されています（ZEND_ENDIAN_LOHI_4は、異なるエンディアンのプラットフォーム間でレイアウトを引き継ぐためのマクロですので無視してください）。このサブストラクチャで重要なのは、type（以前のバージョンと同様です）とtype_flagｓです。それについては今から説明します。この時点でちょっとした問題があります。それは、valueメンバは8バイトの大きさですが、パディングが挿入されるため、1バイト追加するだけでzvalのサイズは16バイトにふくれてしまうのです。当然、型を格納するためだけに、8バイトも必要ありません。そのためzvalはもう1つの共用体u2を持っています。これはデフォルトでは使用しませんが、周辺のコードから、4バイトのデータを格納する目的を持たせることができます。さまざまな共用体メンバが、この予備のデータスロットをそれぞれの用途で使用します。PHP7では、value共用体はわずかに変更されます。まず、value共用体は16バイトではなく8バイトになっていることに注目してください。整数（lval）と倍精度浮動小数点数（dval）のみ直接格納することができます、他はいずれもポインタです。全てのポインタ型は（上記の例でspecial（特別）とされているものを除き）、参照カウントを使用し、zend_refcontedで定義された共通のヘッダを持っています。もちろんこの構造にはrefcountが含まれています。更にtype、flags、gc_infoもあります。typeが行うのは、zval型を複製し、zvaｌを格納せずに参照カウントされた別の構造体をGCに識別させることです。flagsは異なる型に異なる目的で使用されますが、それについては次のパートで個別に説明します。gc_infoは、従来のzvalのbufferedエントリと同じですが、ポインタをルートバッファに格納する代わりに、インデックスを含むようになりました。ルートバッファは固定サイズ（10000エレメント）で、64ビットのポインタの代わりに16ビット数を使用するには十分です。gc_info情報は、コレクションを行っているノードの識別に使用する”色”を符号化します。zvalが個別にヒープに割り当てられないことは既に言及しました。しかし、当然どこかの領域には配置される必要があります。ではどのように機能するのでしょうか？　zvalはヒープに割り当てられた構造の一部でありながら、直接埋め込まれているのです。例えば、ハッシュテーブルのバケツが、別のzvalを指すポインタを格納する代わりに直接zvalを埋め込むのです。関数のコンパイル済みの変数テーブルやオブジェクトのプロパティテーブルはzval配列になり、1つのチャンクとしてアロケーションされます。別のzvalへのポインタを格納することはありません。したがって新しいzvalは間接参照が1段階少なくなります。以前zval*だったものが今ではzvalになるのです。新しい領域でzvalが使用される際、以前はzval*をコピーして、そのrefcountをインクリメントする必要がありました。新しいバージョンでは、zvalの中身（u2は無視します）をコピーし、例えばその値が参照カウントを使用する場合は、それがポイントしているrefcountの値を1つ増やすかもしれないということになります。値が参照カウントされていることを、PHPはどのように把握するのでしょうか？　単に型のみでは判断できません。文字列や配列などの型が必ず参照カウントされるとは限らないからです。代わりに1ビットのzval type_infoメンバが、そのzvalが参照カウントされているかどうかを決定します。型のプロパティを符号化しているビットは他にもたくさんあります。型が持つことの出来る最初の3つのプロパティは”refcounted（参照カウントされる）
“、”collectable（コレクションできる）”、”copyable（コピーできる）”です。refcountedについてはもうご存知ですね。collectableはそのzvalがサイクルに参加できるかどうかを表します。例えば、文字列は（頻繁に）参照カウントされますが、そこの文字列でサイクルを作ることはできません。copyableは”複製”が実行されたときに、その値がコピーされる必要があるかどうかを決定します。複製とはハードコピーを意味します。例えば、ある配列をポイントしているzvalを複製する場合、単純にその配列のrefcountを増やすことにはならず、新しく別の配列が生成されます。しかし、オブジェクト型やリソース型など場合は、複製であってもrefcountをインクリメントすることになります。このような型はnon-copyable（コピーできない）と呼ばれます。これはオブジェクトやリソースを渡すセマンティクスと合致します（念のため言っておくと、これらはリファレンスで渡されるのではありません）。次のテーブルはそれぞれの型と、その型が使用するフラグを示したものです。”Simple types”は、別の構造体へのポインタを使用しない整数値やブーリアン値などを指します。”immutable”フラグのカラムもあります。これは、不変の配列を識別するために使用されますが、詳細は次のパートで説明します。ここで、zval管理が実際どのように行われているか、例を2つ見てみましょう。まずは上のPHP5の例から整数を使用する例です。非常につまらないですね。整数は共有されていませんし、2つの変数はそれぞれ異なるzvalを使用します。ポインタを表す-&gt;の代わりに=を書いて強調した部分は、zvalがアロケーションされているのではなく埋め込まれているということを忘れないでください。変数を設定しない場合、当該のzvalの型はIS_UNDEFをセットすることになります。次は、複雑な変数が使われる際の面白い例を見てみましょう。ここでも、各変数はそれぞれ異なる（埋め込まれた）zvalを使用していますが、どのzvalも同じ（参照カウントされた）zend_array構造体をポイントしています。変更されると、その配列は複製されなければいけません。この例はPHP5での動きと似ています。PHP7でサポートされている型を詳しく見てみましょう。上記の項目はPHP5でサポートされているものとほとんど変わりませんが、追加されたものがいくつかあります。今IS_LONG型は普通のC言語longの代わりに、zend_longが値として使われています。今までは、64ビットWindows(LLP64)でも、long型は32ビット幅しかなかったので、PHP5でも32ビット整数を使うしかありませんでした。しかし、PHP7では、使っているOSが64ビットであれば、Windowsでも、64ビット整数が使えるようになっています。次のパートで、zend_refcount型を詳しく説明します。ここでは、実装されているPHPリファレンスを見ていきたいと思います。PHP7におけるPHP&amp;リファレンスの扱いは、PHP5でのアプローチとは全く異なります。これが、PHP7でバグが発生する主な原因であると言えると思います。まずは、PHP5ではリファレンスがどのように機能しているのか見ていきましょう。通常のコピーオンライトの原理では、zvalを書き換える前に、zvalを共有している全ての場所の値が変更されないよう、原本とコピーを分ける必要があるとされています。書き換え時にコピーすることで、値渡しのセマンティクスに合わせています。しかし、この原理はPHPリファレンスには当てはまりません。値がPHPリファレンスである場合、その値を使う全ての場所に変更を適用させる必要があります。PHP5では、zvalの一部であったis_refフラグによって、値がPHPリファレンスであるか、書き換える前に分ける必要があるかを判断します。例えば下記のようになります。このデザインの重大な問題は、PHPリファレンスである変数とそうでない変数で値を共有できないことです。下記の例をご覧ください。PHPでは、最終的に普通の値よりリファレンスの値を使う方が動きを遅くしてしまいますが、このリファレンスの動きがその原因の1つです。これが問題となる場合の簡単な例は下記の通りです。count()は値を値渡しとして受け取りますが、$arrayはPHPリファレンスのため、配列のコピーを全て完了してからcount()へ渡されます。$arrayがリファレンスでなければ、count()と$arrayは同じ値を共有できます。では、PHP7に実装されたリファレンスを見ていきましょう。PHP7ではzvalが個別に割り当てられなくなっているため、PHP5と同じアプローチはできません。その代わり、zend_reference構造を値とするIS_REFERENCE型が追加されています。つまり、zend_referenceは単に参照カウントされたzvalなのです。リファレンス集合内の変数は、IS_REFERENCE型のzvalとして同じzend_referenceのインスタンスに関数ポインタが指しています。val zvalは他のzvalと同じように振る舞う上に、ポインタ先が複雑な値であっても共有することが可能です。例えば、リファレンスである変数とそうでない変数の間で配列を共有することができます。もう一度上記のコードを見てみましょう。今度はPHP7での動きを見ます。簡潔にするために、各変数のzvalを書かずにポインタ先の構造のみを書きます。参照渡しでの代入で、新しいzend_referenceが作成されました。ちなみに、リファレンスの値は（変数がPHPリファレンス集合の一部のため）refcountが2ですが、値自体は（1つのzend_reference構造のポインタ先であるため）refcountが1です。では、リファレンスである変数とそうでない変数が混在する場合を考えてみましょう。PHP5からの重要な変更点は、リファレンスである変数とそうでない変数の全てを同じ配列で共有することが可能であることです。ただし、書き換えを行うと配列は分かれます。つまり、PHP7で、安心して大きな参照配列をcount()に渡すことができ、重複することがありません。リファレンスの値が普通の値より動きを遅くしてしまうのは、zend_referenceの割り当て（および間接参照）をする必要があり、必ずしもそれが速いエンジンコードのパスで行われていないからです。要約すると、PHP7での主な変更点は、zvalが個別にヒープに割り当てられなくなったことと、参照カウントを格納しなくなったことです。代わりに、ポインタ先の文字列や配列、オブジェクトなどの複雑な値が参照カウントを格納しています。さらに、割り当てや間接参照が減り、メモリ消費量の減少につながっています。次のパートでは複雑な型についてご説明します。
