How to write a Bloom filter in C++ （2016-04-11） by Michael Schmatzブルームフィルタとは、「ある要素が集合のメンバである可能性があるか、それとも確実に集合のメンバではないか」を効果的に確認することのできるデータ構造です。この記事では、C++でブルームフィルタを実装する簡単な方法をご紹介します。ブルームフィルタとは何なのか、また、その背後にある多くの数学的要素については紹介していませんので、ご了承ください。これらのトピックに関しては、素晴らしいリソースがあるので、そちらを参考にしてください。まずは、ブルームフィルタを定義していきましょう。ここでは、3つのパブリック関数を定義していきます。また、フィルタの状態を保持するビットの配列を含んだ、メンバ変数についても定義します。1つ覚えておいていただきたいのは、std::vector&lt;bool&gt;はstd::vectorの空間効率性に特化したもので、1つの要素に対して1ビットしか必要としないことです（一方、通常の実装では1要素に1バイトが必要）。アップデート：HNのnate_martinは、拡張としてこの構造体をテンプレート化することを勧めています。キーの型やハッシュ関数をハードコード化する代わりに、例えば以下のようなコードと一緒にクラスをテンプレート化することができます。これにより、より複雑なデータ型にブルームフィルタを一般化することが可能になります。Nateありがとう！ブルームフィルタを構成する上で使われたパラメータは以下の2つです。フィルタサイズm、ハッシュ関数の数k、そして挿入された要素の数nを基に、公式を使って、偽陽性によるエラー率pを割り出すことができます1。現在の形式のままでは、この公式は役に立ちません。与えられた推定集合濃度とエラー許容範囲を元に、望ましいフィルタサイズはどれぐらいか、使用するハッシュ関数がいくつなのかを知ることができる計算式にしたいと思います。これらのパラメータを計算するには2つの方程式を使うことができます。もう1点だけ、必須の理論があります。ハッシュ関数kは一体どう実装するのかと思われたかもしれません。偽陽性の確率に影響を与えることなく、kのハッシュ値を生成するには、ダブルハッシュ法が使えます。これは以下の公式で表せます。iが序数であるなら、mはブルームフィルタのサイズで、mはハッシュされる値です。より詳しい証明は、このペーパーを読んでください。まず、コンストラクタを記述しましょう。単純にパラメータを記録し、ビット配列のサイズを変える役割があります。次に、指定されたアイテムの128bitのハッシュを計算する関数を記述します。128bitのハッシュ関数で、パフォーマンス、分布、雪崩のふるまい、衝突耐性の間の最適なトレードオフを実現するMurmurHash3を使います。この関数は128bitのハッシュ値を生成しますが、ここでは2つの64bitのハッシュが必要なので、ハッシュの戻り値を半分に分ければとを取得できます。これでハッシュ値が得られますので、ハッシュ関数
の出力を返すための関数を書く必要があります。あとは、指定されたアイテムのビットを設定またはチェックする関数を記述するだけです。私のラップトップでは、4.3MBのブルームフィルタと13のハッシュ関数で、180万のアイテム挿入が1要素につきおよそ189ナノ秒でできました。偽陽性の確率も、理論上の値と適合しています。より良い実装のアイデアがあれば、コメントを残すか、メッセージを送ってください。読んでくださってありがとうございます。
