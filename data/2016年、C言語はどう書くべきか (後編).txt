<p><a href="https://matt.sh/howto-c" rel="nofollow" title="" class="ext-link">How to C in 2016</a> （2016-01-07） by <a href="https://matt.sh/about" rel="nofollow" title="" class="ext-link">Matt Stancliff</a></p><p>(前編はこちら：<a href="http://postd.cc/how-to-c-in-2016-1/">2016年、C言語はどう書くべきか (前編)</a>)</p><p>まだ「32 bitのプラットフォームでは32 bitのlong型、64 bitのプラットフォームでは64 bitのlong型がいい」という不満があるようですね。</p><p>プラットフォームに依存する2つの異なるサイズを使うため、<em>故意に</em>コードを難しくすることを考えたくなければ、システム依存の型のために<code>long</code>を使おうとは思わないでしょう。</p><p>この状況では、プラットフォームのためにポインタ値を保持する整数型、<code>intptr_t</code>を使うべきです。</p><p>モダン32-bitプラットフォームでは、<code>intptr_t</code>は<code>int32_t</code>です。</p><p>モダン64-bitプラットフォームでは、<code>intptr_t</code>は<code>int64_t</code>です。</p><p><code>intptr_t</code>は<code>uintptr_t</code>の形でもあります。</p><p>ポインタのオフセットを保持するためには、名が体を表す通りの<code>ptrdiff_t</code>を使います。これは、ポインタの差分の値を格納するのに適した型です。</p><p>システム内で使える全ての整数を保持できる整数型が必要な場合はどうしますか。</p><p>この場合、より小さな符号なし整数型を<code>uint64_t</code>にキャストするなど、可能な限り最大の型を選びがちですが、さらに規則正しく、どんな値でもその他のあらゆる値を確実に保持させ得る方法があります。</p><p>全ての整数にとって最も安全なコンテナは<code>intmax_t</code>（または<code>uintmax_t</code>）です。あらゆる符号付き整数を精度を損ねることなく<code>intmax_t</code>にキャストしたり、割り当てたりすることができます。さらに、どのような符号なし整数も<code>uintmax_t</code>に精度を損ねることなくキャスト、割り当てすることも可能です。</p><p>最も頻繁に使われるシステム依存の型は、<code>size_t</code>で、<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/stddef.h.html" rel="nofollow" title="" class="ext-link">stddef.h</a>に定義されています。</p><p><code>size_t</code>は基本的に「最大の配列インデックスを保持できる整数」ですが、プログラム内の最大のメモリオフセットを保持が可能という意味もあります。</p><p>実際の用途としては、<code>size_t</code>は<code>sizeof</code>オペレータの戻り値の型です。</p><p>いずれにしても、<code>size_t</code>は全てのモダンプラットフォーム上の<code>uintptr_t</code>と同様になるよう、<em>実用的に</em>定義されます。そのため、32-bitプラットフォームでは、<code>size_t</code>は<code>uint32_t</code>であり、64-bitプラットフォームでは、<code>size_t</code>は<code>uint64_t</code>です。</p><p>他にも、<code>ssize_t</code>があり、これはライブラリ関数からの返り値として使われる符号付きの<code>size_t</code>で、エラーの際に<code>-1</code>を返します（注：<code>ssize_t</code>はPOSIXであり、Windowsインターフェースには適用されません）。</p><p>では、あなたの関数パラメータ内で、任意のシステム依存型のサイズのための<code>size_t</code>を使うべきでしょうか。技術的には、<code>size_t</code>は<code>sizeof</code>の戻り値の型なので、バイト数を表したサイズ値を受け取る関数は全て<code>size_t</code>に変換できます。</p><p>他の用法には次のものが含まれます。：<code>size_t</code>はmallocに渡される引数の型であり、<code>ssize_t</code>は<code>read()</code>と<code>write()</code>の戻り値の型です（<code>ssize_t</code>が存在せず、戻り値がただの<code>int</code>であるWindowsの場合を除きます）。</p><p>決して出力中に型をキャストしてはいけません。</p><p>常に、<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html" rel="nofollow" title="" class="ext-link">inttypes.h</a>で定義された適切な型指定子を使いましょう。</p><p>それには次のものが含まれますが、この限りではありません。</p><p><code>PRI*</code>フォーマット指定子に関する覚書：これらは<em>マクロ</em>であり、マクロはプラットフォーム固有の基盤上の適切なprintf型指定子まで範囲を広げられます。つまり、次のようにはできないということです。</p><p>しかし代わりに、マクロであるがゆえに、次の記述が可能です。</p><p><code>%</code>はフォーマット文字列リテラルの<em>中に</em>置きましょう。ただし、型指定子はフォーマット文字列リテラルの<em>外に</em>置きます。なぜなら、全ての隣接した文字列はプリプロセッサによって1つのまとまった最終的な文字列に連結されるためです。</p><p>ですから、次のようにしないことです。</p><p>代わりにこうしましょう。</p><p>注意：緊密なループがある場合、イニシャライザの配置をテストしてください。時に、分散された宣言によって予期せぬスローダウンが起こることがあります。通常の非ファストパスコード（世界のほとんど全て）は、可能な限り明確にするのが大事です。また初期化のそばで型を定義することで、可読性は大きく向上します。</p><p>ですから、次のようにしてはいけません。</p><p>必ず以下の通りにしましょう。</p><p>1つの例外：ループを出た後もカウンタ値を保つ必要がある場合はもちろん、ループ範囲内にカウンタを指定しないようにします。</p><p>よって、次のようにしてはいけません。</p><p>ただ、以下のように記述します。</p><p><code>#pragma once</code>はコンパイラに、ヘッダを一度だけincludeさせるので、3行のヘッダガードを書く必要が<em>なくなりました</em>。このプラグマはあらゆるプラットフォーム上のあらゆるコンパイラを広くサポートしていますので、手動のヘッダガード作成よりも推奨されます。</p><p>詳細は、<a href="https://en.wikipedia.org/wiki/Pragma_once" rel="nofollow" title="" class="ext-link">pragma once</a>でサポートしているコンパイラのリストを参照してください。</p><p>ですから、次のようにしないことです。</p><p>代わりにこうしましょう。</p><p>ですから、次のようにしてはいけません。</p><p>代わりにこうしましょう。</p><p><strong>重要なメモ：</strong>パディングを持つ構造体の場合は、<code>{0}</code>メソッドは余分なパディングのバイト数をゼロに初期化しません。例えば、<code>struct thing</code>には、ワードサイズでのインクリメントを考慮するために、<code>counter</code>の後に4バイトのパディングを持っています（64-bitプラットフォームの場合）。未使用のパディングも<em>含め</em>、構造体全体をゼロにする必要がある時は、<code>memset(&amp;localThing, 0, sizeof(localThing))</code>を使いましょう。アクセス可能なコンテンツが<code>8 + 4 = 12 bytes</code>のみだったとしても、<code>sizeof(localThing) == 16 bytes</code>だからです。</p><p>既に割り当てられた構造体を再度初期化する場合は、後の代入のために、グローバルなゼロ構造体を宣言してください。</p><p>幸運にも、C99（あるいはそれ以降）の環境がある場合は、グローバルな”ゼロ構造体”を保持する代わりに、複合リテラルが使えます（2001からの<a href="http://www.drdobbs.com/the-new-c-compound-literals/184401404" rel="nofollow" title="" class="ext-link">The New C: Compound Literals</a>も参照してください）。</p><p>複合リテラルを使うことで、コンパイラで一時的に匿名構造体を作ってから、ターゲット値にコピーすることもできます。</p><p>下記のようにしてはいけません（配列が小さいことがわかっている、あるいは何かをすぐにテストしたい場合）。</p><p>代わりに次のようにします。</p><p><strong>重要：</strong>可変長配列（VLA）は（たいてい）、通常の配列のようにまとめて割り当てられます。300万の要素を持つ通常の配列を静的に作るのでなければ、この構文で実行中に300万の要素の配列を作ろうとしないことです。これらはスケーラブルなpython/rubyの自動拡張リストではありません。実行時の配列の長さを明示し、その長さがスタックに対して大き過ぎる場合、あなたのプログラムは恐ろしいことを引き起こすでしょう（クラッシュやセキュリティ問題）。VLAは小さく、目的が1つだけの状況の場合は便利ですが、プロダクションソフトウェアで、そのスケールに頼るべきではありません。ある時は3要素の配列を使い、またある時は300万要素の配列が必要という場合は、当然、可変長配列機能を使ってはいけません。</p><p>VLAが動いているのに出くわした場合（あるいは、短い単発テストをしたい場合）にVLA構文を意識することは大事です。しかしそれはほとんど<a href="https://twitter.com/grynspan/status/685509158024691712" rel="nofollow" title="" class="ext-link">危険なアンチパターン</a>とされています。なぜなら、要素サイズの限度のチェックをしなかったり、空きスタックスペースのない間違った対象プラットフォームにいることを忘れたりするだけでプログラムはクラッシュし得るからです。</p><p>覚書：この状況では<code>arrayLength</code>は合理的なサイズです（よって、数KB以下の場合、奇妙なプラットフォームではスタックは4KBで最大値を超えることがあります）。巨大な配列（100万のエントリなど）にスタックを割り当てることはできませんが、配列の要素数が限られていることを分かっていれば、<a href="https://en.wikipedia.org/wiki/Variable-length_array" rel="nofollow" title="" class="ext-link">C99 VLA</a>機能の利用は、mallocを使って手動でヒープメモリをリクエストするよりもずっと容易です。</p><p>覚書 続き：上述の機能はユーザの入力をチェックすることはできません。そのためユーザは巨大なVLAを割り当てて、いとも簡単にプログラムを壊してしまいます。中には、VLAをアンチパターンと呼ぶところまで<a href="https://twitter.com/comex/status/685423016981966848" rel="nofollow" title="" class="ext-link">行ってしまった人もいますが</a>、範囲を厳しくすれば、特定の状況では小さな勝利が得られます。</p><p><a href="https://en.wikipedia.org/wiki/Restrict" rel="nofollow" title="" class="ext-link">restrictキーワード</a>（<code>__restrict</code>であることが多い）を見てください。</p><p>関数が<strong>任意の</strong>入力データと長さの処理を受け付けるなら、パラメータの型は制限しないようにしましょう。</p><p>そこで、次のようには記述しません。</p><p>代わりにこのようにします。</p><p>関数に対する入力の型は、パラメータでコードが何をするかではなく、コード内の<em>インターフェース</em>を表します。このコードへのインターフェースが意味するのは「バイト配列1つと長さ1つを受け入れよ」ということですから、呼び出しをuint8_tのみに制限しないほうがよいのです。ユーザは旧スタイルの<code>char *</code>型の値やその他予期せぬ方法でデータを渡そうとするかもしれません。</p><p>入力の型を<code>void *</code>として定義し、関数内で実際に使いたい型に再代入または再キャストすることで、その関数を使おうとするユーザはあなた自身のライブラリ<em>内</em>の抽象化について考えずに済みます。</p><p>この例において、アライメントの問題について指摘する読者がいましたが、ここでは1バイトの要素の入力にアクセスしているので、問題ありません。もし、そうではなく複数のバイト数に入力をキャストするなら、アライメントに気を配る必要があります。プラットフォームを横断するアライメントを扱う別の記述方法は、<a href="https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt" rel="nofollow" title="" class="ext-link">非アライメントのメモリアクセス</a>を参照してください（改めて注：この包括的な概要のページは、複雑なアーキテクチャのC言語を扱うものではありません。どの例においても、活用の際はここに書かれている以上の知識や経験が必要です）。</p><p>C99では<code>&lt;stdbool.h&gt;</code>を活用できます。これは<code>true</code>を<code>1</code>に、<code>false</code>を<code>0</code>に定義するものです。</p><p>成功/失敗の戻り値として、関数は<code>true</code>または<code>false</code>を返すべきです。<code>int32_t</code>の型にして、手動で<code>1</code>と<code>0</code>を指定するべきではありません（さらにひどいのは、<code>1</code>と<code>-1</code>（または<code>0</code>が成功で、<code>1</code>がエラー、<code>0</code>が成功で<code>-1</code>がエラー、など）。</p><p>関数が入力パラメータを、パラメータが無効になるほどに変えてしまうなら、変更ポインタを戻す代わりに、API全体で、入力が無効になる可能性があるところ全て、パラメータとしてポインタへのポインタを強制しなければなりません。「ある呼び出しの場合は、戻り値は入力を無効にする」というルールでコーディングすると、大人数が使う場合にエラーを出しやすくなります。</p><p>ですから、次のような記述は避けましょう。</p><p>代わりに下記のようにします。</p><p>さらに良い方法は以下の通りです。</p><p>コーディングスタイルは、非常に重要ながら同時に全くの無意味でもあります。</p><p>プロジェクトに、50ページのコーディングスタイルガイドラインがあるなら、誰も手を貸そうとしないでしょう。しかし、あなたのコードが読めない場合は、誰も<em>手を貸したい</em>と思わないでしょう。</p><p>ここで紹介する解決法は<strong>常に</strong>自動コードフォーマッタを使うことです。</p><p>2016年のC言語フォーマッタで唯一使えるのは、<a href="http://clang.llvm.org/docs/ClangFormat.html" rel="nofollow" title="" class="ext-link">clang-format</a>です。clang-formatは自動C言語フォーマッタの中でも最善のデフォルト機能を備えており、現在もなお活発に開発が進められています。</p><p>これが、良いパラメータでclang-formatを走らせる私の好きなスクリプトです。</p><p>これを次のように呼び出します（スクリプトに<code>cleanup-format</code>と名付けたと仮定して）。</p><p><code>-i</code>オプションは、新規ファイルに書いたり、バックアップファイルを作成したりするのではなく、フォーマッティング変更として既存ファイルを上書きします。</p><p>ファイルが多数ある場合は、並行して、全体のソースツリーを再帰的に処理することができます。</p><p>他にもcleanup-tidyというスクリプトがあります。<code>cleanup-tidy</code>のコンテンツは下記です。</p><p><a href="http://clang.llvm.org/extra/clang-tidy/" rel="nofollow" title="" class="ext-link">clang-tidy</a>はポリシー主導のコードリファクタリングツールです。上記のオプションは、2つの解決法を可能にします。</p><p><code>clang-tidy</code>は、うまく機能すれば非常に便利ですが、複雑なコードベースにおいては動かなくなる場合があります。また、<code>clang-tidy</code>は<em>フォーマットしません</em>。そのため、新しい中括弧をアライメントさせ、マクロの書式を揃えた後で<code>clang-format</code>を走らせなければなりません。</p><p><em>ここで筆が止まり始めました…。</em></p><p>コードファイルの論理的な内包部分</p><p>行数を1,000行（最悪でも1,500行）に限定しましょう。静的関数をテストするためなどの理由で、テストがソースファイルのインラインにあるなら、適宜調整します。</p><p>常に<code>calloc</code>を使うべきです。メモリをゼロで初期化しても、パフォーマンスのペナルティはありません。<code>calloc(object count, size per object)</code>の関数プロトタイプが好きではないなら、<code>#define mycalloc(N) calloc(1, N)</code>でラップすることもできます。</p><p>この件についての読者のコメントです。</p><p>どれも良い指摘です。だからこそ、コンパイラ、プラットフォーム、オペレーティングシステム、そしてハードウェアデバイスに渡って、常に速度のパフォーマンステスト、リグレッションテストを行わねばなりません。</p><p>ラッパーを用いず、<code>calloc()</code>を直接使う1つの利点は、<code>malloc()</code>とは異なり、<code>calloc()</code>は最終の割り当てサイズを取得するために引数を掛け合わせるので、整数のオーバーフローをチェックできることです。小さな割り当てのみを行うのであれば、<code>calloc()</code>のラップで機能するでしょう。無制限のデータの流れを割り当てる可能性がある場合は、正規の<code>calloc(element count, size of each element)</code> 呼び出し規約を保持するとよいかもしれません。</p><p>何にでも適用できる助言はありませんが、一般的な推奨事項を<em>完全に漏れなく</em>明確にしようとすると、結局、言語仕様書を読んでいるのと変わりません。</p><p><code>calloc()</code>がどのようにメモリをクリアにするかは、次の記事を参照してください。</p><p>それでもなお私は、2016年におけるほとんどの一般的なシナリオ（仮定：x64対象プラットフォーム、人間のゲノムでなく、身長程度のサイズのデータ）に対して、常に<code>calloc()</code>を使うことを薦めたいと思います。「想定」からの逸脱は、「領域知識」に対する絶望をもたらします。どちらも今日び使わない言葉です。</p><p>追記：<code>calloc()</code>により前もってゼロにされたメモリは、一度きりの対処法です。<code>calloc()</code>の割り当てを<code>realloc()</code>すると、reallocによって拡張されたメモリは新規にゼロに初期化されたメモリではありません。拡大した割り当てには、kernelが提供する一般的な未初期化のコンテンツで埋められています。reallocの後にメモリをゼロにする必要がある場合は、手動で拡大した割り当ての範囲を<code>memset()</code>しなければなりません。</p><p>静的に構造体（または配列）をゼロに初期化できる場合は、クリアにする際、あるいは、インラインの複合文字列を代入するか、またはグローバルなゼロ埋めされた構造体を代入するかして、リセットできる時は、<code>memset(ptr, 0, len)</code>を使ってはいけません。</p><p>しかし、パディングバイトを含めて構造体をゼロに初期化する必要があり、<code>memset()</code>が唯一の方法である場合は別です。</p><p><a href="http://en.cppreference.com/w/c/types/integer" rel="nofollow" title="" class="ext-link">固定長の整数型（C99以降）</a>も見てください。</p><p>Appleの<a href="https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/64bitPorting/MakingCode64-BitClean/MakingCode64-BitClean.html" rel="nofollow" title="" class="ext-link">「コードを64-bitクリーンにする」</a>も見てください。</p><p><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=4374" rel="nofollow" title="" class="ext-link">アーキテクチャごとのC言語の型のサイズ</a>も見てください。- あなたが書くコード全行のためにテーブル全体を頭で覚えておくのではなく、明確に定義された整数幅を使うべきです。char/short/int/longのビルトインの記憶領域型も使わないように。</p><p><a href="http://www.viva64.com/en/a/0050/" rel="nofollow" title="" class="ext-link">size_tとptrdiff_t</a>も見てください。</p><p><a href="https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard" rel="nofollow" title="" class="ext-link">セキュアコーディング</a>も見てください。全てを完璧に書きたいと本当に思うなら、ただ彼らのシンプルな1,000の例を覚えてしまいましょう。</p><p>InriaのJens Gustedtによる<a href="http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf" rel="nofollow" title="" class="ext-link">Modern C</a>も見てください。</p><p><a href="http://www.dotslashzero.net/2014/08/22/understanding-characterstring-literals-in-cc/" rel="nofollow" title="" class="ext-link">C/C++の文字リテラル、文字列リテラルを理解する</a>で、C11におけるUnicodeサポートの詳細を参照してください。</p><p>どこでも通用する正しいコードを書くことは元来不可能です。たとえ、RAMにおけるランダムなビット反転や、未知の確率で誤った情報を送ってくるブロックデバイスなどを考慮しないとしても、複数のオペレーティングシステム、ランタイム、ライブラリ、ハードウェアプラットフォームがあり、心配は尽きません。</p><p>私たちにできる最善の方法は、シンプルで理解しやすいコードを書き、無目的な記述や、解読できないが、なぜか機能しているといった状態を極力減らすことでしょう。</p><p>この記事はtwitterとHN経由で広まり、多くの人たちが不備や、私の偏った考えを指摘してくれました。</p><p>まず、Jeremy Fallerと<a href="https://twitter.com/Sosowski/status/685431663501926400" rel="nofollow" title="" class="ext-link">Sos Sosowski</a>とMartin Heistermann、その他の人たちは、私の<code>memset()</code>のサンプルが壊れていたことを指摘し、適切な修正をしてくれました。</p><p>Martin Heistermannからはさらに、<code>localThing = localThingNull</code>サンプルが壊れていたとの指摘あり。</p><p>「もし避けられるならC言語を使うな」という冒頭の引用は、知的なインターネットの賢人<a href="https://twitter.com/badboy_" rel="nofollow" title="" class="ext-link">@badboy_</a>から。</p><p><a href="https://twitter.com/rgacogne/status/685390620723154944" rel="nofollow" title="" class="ext-link">Remi Gacogne</a>からは私が<code>-Wextra</code>を忘れている、との指摘あり。</p><p><a href="https://twitter.com/pineal_servo/status/685393454487056384" rel="nofollow" title="" class="ext-link">Levi Pearson</a>から、gcc-5デフォルトをc89でなく、gnu11にし、デフォルトのclangモードを明確にするよう指摘あり。</p><p><a href="https://twitter.com/shrydar/status/685375992114757632" rel="nofollow" title="" class="ext-link">Christoper</a>から、<code>-02</code>対<code>-03</code>の項が明確ではないと指摘あり。</p><p><a href="https://twitter.com/chadmiller/status/685469896914919424" rel="nofollow" title="" class="ext-link">Chad Miller</a>からは、私のclang-formatスクリプトのパラメータの使い方が適当過ぎる、と指摘あり。</p><p><a href="https://twitter.com/lordcyphar/status/685444198481412096" rel="nofollow" title="" class="ext-link">大勢</a>が、<code>calloc()</code>の助言は<em>常に</em>良策とは言えないという指摘あり。例えば極端な環境や、標準から外れたハードウェア（最小限の埋め込みシステム、ゲームコンソール、30年前のハードウェアなど）の場合など。</p><p>Charles Randolphから、”Building”の誤植の指摘あり。</p><p>Sven Neuhausも、私には”initialization”や”initializers”のスペルの処理能力がないことを指摘してくれました（さらに、その指摘を反映させたつもりが、再度”initialization”を誤っていたことも）。</p><p><a href="https://twitter.com/colmmacc/status/685493166988906497" rel="nofollow" title="" class="ext-link">Colm MacCárthaigh</a> からは、<code>#pragma once</code>の記述がないと指摘あり。</p><p><a href="https://twitter.com/jyasskin/status/685493531515826176" rel="nofollow" title="" class="ext-link">Jeffrey Yasskin</a>からは、厳しいエイリアシングも止めるべき（主にgcc最適化）と指摘あり。</p><p>Jeffrey Yasskinはさらに、<code>-fno-strict-aliasing</code>に関する項で、より良い説明文を提供してくれています。</p><p><a href="https://twitter.com/fugueish/status/685503534230458369" rel="nofollow" title="" class="ext-link">Chris Palmer</a>とその他数人から、calloc-vs-mallocパラメータの利点、<code>calloc()</code>のラッパーを書くことによって起こる障害について指摘あり。第一に、<code>calloc()</code>は<code>malloc()</code>よりもセキュアなインターフェースである、ということでした。</p><p>Damien Sorressoは、<code>calloc()</code>呼び出しでメモリがゼロに初期化された後、<code>realloc（）</code>でメモリを再確保した場合、増えた分のメモリはゼロに初期化されないことを、人々に忠告したほうがいいと、指摘してくれました。</p><p>Pat Pogsonは、私が”declare”のスペルも間違えていると指摘してくれました。</p><p><a href="https://twitter.com/TopShibe/status/685505183762223105" rel="nofollow" title="" class="ext-link">@TopShibe</a>は、私が挙げた例がグローバル変数だったので、スタック割り当ての初期化の例は間違っていると、指摘してくれました。そこで、スタック領域またはデータセクションに「自動割り当て」されることを意味するように言葉を変更しました。</p><p><a href="https://twitter.com/grynspan/status/685509158024691712" rel="nofollow" title="" class="ext-link">Jonathan Grynspan</a>は、VLAは<strong>絶対</strong>使い方を誤ると危険なので、VLAの例に関する説明の表現を厳しくするよう提案してくれました。</p><p>David O’Mahony氏は、ご親切にも”specify”のスペルも間違っていると指摘してくれました。</p><p>David Alan Gilbert博士は、<code>ssize_t</code>はPOSIXなので、Windowsにはないと指摘してくれました。</p><p>Chris Riddは、C99は1999年策定のC言語であり、C11は2011年策定のC言語であることを明示したほうがいいと提案してくれました。そうでないと、11が99よりも新しいのは奇妙に見えるからです。</p><p>Chris Riddはまた、<code>clang-format</code>の例で、あいまいな命名規則が使用されていることに気付き、全ての例にわたってもっと一貫性を保つように提案してくれました。</p><p><a href="https://twitter.com/Ideo_logiq/status/685384708188930048" rel="nofollow" title="" class="ext-link">Anthony Le Goff</a>は、私たちに、<a href="http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf" rel="nofollow" title="" class="ext-link">Modern C</a>という本1冊分の最新のC言語の考え方や処方箋に目を向けさせてくれました。</p><p>Stuart Popejoyは”deliberately”のスペルが本当に間違っていると指摘してくれました。</p><p>jack rosenは、”exists”という単語の使い方が、私が意図した”exits”を意味していないと指摘してくれました。</p><p>Jo Boothは、私が”compatibility”を”compatability”のようにつづるのが好きだと指摘してくれました。そのほうが論理的に見えますが、英語を使う人たちは賛同してくれないようです。</p><p>Stephen Andersonは、私の異常な”stil”というスペルを”still”にデコードしてくれました。</p><p>Richard Weinbergerは、構造体を<code>{0}</code>で初期化してもパディングはゼロに初期化されないので、<code>{0}</code>の構造体を回線を通じて送信すると、値が定まっていない構造体にある意図していなかったバイトがリークする可能性があると指摘してくれました。</p><p><a href="https://twitter.com/JayBhukhanwala" rel="nofollow" title="" class="ext-link">@JayBhukhanwala</a>は、「戻り値の型」の項の関数のコメントが不正確だと指摘してくれました。私がコードを変更したときに、コメントを更新していなかったからです（皆さんもよくあるでしょう）。</p><p>Lorenzoは、「パラメータの型」の項の中で、異なるプラットフォーム間でアライメントの問題が起こる可能性について、はっきりと警告したほうがいいと指摘してくれました。</p><p><a href="https://twitter.com/Blaisorblade/status/686042231917178881" rel="nofollow" title="" class="ext-link">Paolo G. Giarrusso</a>は、前回追加したアライメントの警告は、私が挙げた例に関してさらに正しいと、再度はっきりさせてくれました。</p><p>Fabian Klötzlは、構造体の複合リテラルの有効な代入例を提供してくれました。それは私が今まで出会ったことのない完全に有効な構文です。</p><p>Omkar Ekboteは、”platform”、”actually”、”defining”、”experience”、”simultaneously”、”readability”などのタイプミスと矛盾点と顕著に意味不明な言い回しを徹底的に直してくれました。</p><p>Carlo Bellettiniは、異常な単語のスペルミスを修正してくれました。</p><p><a href="https://github.com/Keith-S-Thompson" rel="nofollow" title="" class="ext-link">Keith S Thompson</a>は、すばらしい記事<a href="https://github.com/Keith-S-Thompson/how-to-c-response" rel="nofollow" title="" class="ext-link">how-to-c-response</a>の中で、技術的な誤りを訂正してくれました。</p><p>Marc Bevandは、<code>fprintf</code>の型指定子は<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html" rel="nofollow" title="" class="ext-link">inttypes.h</a>で定義されていることを述べたほうがいいと指摘してくれました。</p><p><a href="https://twitter.com/brian_cain" rel="nofollow" title="" class="ext-link">Brian Cain</a>は、<em>fast</em>型と<em>least</em>型についても言及したほうがいいと指摘してくれました。</p><p>多くのredditユーザは、この記事のどこかに当初間違って<code>#import</code>があったので、怒ってしまいました。この記事は、1年間ドラフトのまま、改訂もレビューもされずに配信したので、キレた方、すみません。今は改善されています。</p><p>また、何人かに、静的初期化の例で、とにかくデフォルトで必ずゼロに初期化される（静的に割り当てられているので、初期化すらされない）グローバル変数を使っていると指摘されました。これは私の例の選択がお粗末だったせいですが、コンセプトは関数のスコープの典型的な用法をなお表しています。例は、汎用的な”コードスニペット”となるように作られており、必ずしも最上位のグローバル変数というわけではありません。</p><p>数人の方は、この記事を「私はC言語が嫌いです」と解釈したようですが、そうでありません。C言語は間違った使い方をすると危険です（広くデプロイされるときには、十分なテストと経験が必要）。ですから、逆説的に言えば、C言語の開発者は、2種類に限られるべきです。一方は、ただの初心者の愛好家（コードの失敗は問題を引き起こしません。ただのおもちゃです）で、もう一方は、喜んで一生懸命テストする人（コードの失敗は生命や経済の損失を引き起こします。ただのおもちゃではありません）で、製品のためにC言語のコードを書いている人です。「うわべだけのC言語開発」をする余地はありません。それが、世界中でErlangが使われている理由です。</p><p>また、多くの人が自分にとって重要な同様の問題または、この記事の範囲を超えた問題（私たちにC11のジェネリックの能力を思い出させてくれた<a href="https://twitter.com/irrequietus/status/685407732464226306" rel="nofollow" title="" class="ext-link">George Makrydakis</a>のように新しいC11だけの機能を含めて）にも言及してくれました。</p><p>さらに”Practical C”に関する記事では、おそらく、テスト、プロファイリング、パフォーマンスのトレース、有用だが任意の警告レベルなどを取り上げて配信します。</p>
