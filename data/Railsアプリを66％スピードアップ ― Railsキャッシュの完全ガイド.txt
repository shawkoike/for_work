<p><a href="http://www.nateberkopec.com/2015/07/15/the-complete-guide-to-rails-caching.html" rel="nofollow" title="" class="ext-link">Speed Up Your Rails App by 66% – The Complete Guide to Rails Caching</a> by <a href="https://twitter.com/nateberkopec" rel="nofollow" title="" class="ext-link">Nate Berkopec</a></p><p>(訳注：2016/3/2、頂いた翻訳フィードバックをもとに記事を修正いたしました。)</p><p>Railsアプリでのキャッシングは、「たまに夕食を一緒にするけれど、本当はもっと頻繁に一緒にいるべき友達」に少し似ています。パフォーマンスをまじめに考えるRailsアプリのほぼ全てで、もっとキャッシングを使えるはずですが、ほとんどのRailsアプリでは、完全にキャッシングを避けています。それでも普通は、Railsで高速なサーバ応答を達成するための唯一の道は、キャッシングの知的な利用なのです。約250msの応答時間を、簡単に50～100msに高速化できます。</p><p>定義についての注意　―　この記事は、アプリケーション層のキャッシングのみを対象としています。HTTPキャッシング（これは全く別の難物で、あなたのアプリケーションに実装する必要はありません）は、別の機会で扱いましょう。</p><p>私たち開発者は、もともと、エンドユーザとは違います。私たちは、ソフトウェアやウェブアプリケーションで見えるものの裏側で何が起こるのかをよく理解しています。典型的なウェブページがロードされるときは、大量のコードが実行され、データベースクエリが実行され、ときにはHTTP上でサービスがpingされるということを知っています。これには時間がかかります。コンピュータと対話するときは、コンピュータが答えを返すまでには、少し間があるという考えに慣れています。</p><p>でも、エンドユーザは全く違います。彼らにとって、ウェブアプリケーションは魔法の箱です。1エンドユーザは、その箱の中で何が起こるかを知らないのです。<sup><a href="#1">1</a></sup>特に最近、<strong>エンドユーザは、魔法の箱が、ほとんど瞬間的に応答してくれることを期待します。</strong>ほとんどのエンドユーザは、欲しいものを何でも、<em>今すぐ</em>ウェブアプリから取り出したいのです。</p><p><a name="1"><img src="http://i.imgur.com/X17puIB.gif"></a><br>
1:<em>開発者から見たエンドユーザ</em></p><p>これは、分かりきったことのように見えます。それでも、開発者はユーザの都合と製品の仕様に、厳しいパフォーマンス要件を決して設定しません。たとえサーバ応答時間を簡単に測定して目標にすることができても、また、ユーザが高速なウェブページを求めていることを知っていても、「このページは100ms以内に応答しなければならない」というような、特別なサイトや機能を扱いたくないのです。その結果、次のユーザの都合、次の素晴らしい機能を優先して、パフォーマンスはしばしば棚上げにされます。パフォーマンスの負債は、技術的な負債と同様に、あっというまに積み上がります。誰かが新しいリクエストを行うたびに<strong>アプリケーションが根本的に炎上するようになるまでは、パフォーマンスは、決して優先事項になりません。</strong></p><p>さらに、キャッシングは必ずしも簡単ではありません。<strong>キャッシュ</strong>の<strong><em>期限切れ</em></strong>は、<strong>特に混乱を招く問題になります。</strong>キャッシング動作のバグは、インテグレーション層で起こる傾向にあり、この層は、アプリケーションで最もテストが疎かになりがちな層です。このことから、キャッシングのバグは目立たず、発見と再現が難しくなるのです。</p><p>さらに悪いことに、Railsの世界では、<strong>キャッシングのベストプラクティスは頻繁に変わるように思われます</strong>。キーベースの何とか。ロシアンモールキャッシングとか、ドールとか。</p><p>では、なぜキャッシングを使うのでしょうか。答えは簡単です。スピードです。Rubyでは、簡単にスピードが得られません。その理由は、まず、この言語はあまり速くないからです。<sup><a href="#2">2</a></sup><em>各リクエストでのRubyの実行を少なくする</em>ことによってスピードを得る必要があります。その最も簡単な方法は、キャッシングを使うことです。処理を行ったら、結果をキャッシュし、キャッシュした結果を将来のために保存します。</p><p><a name="2"><img src="http://i.imgur.com/UDkHBEc.png"></a><br>
2:<em><a href="http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=yarv&amp;lang2=v8" rel="nofollow" title="" class="ext-link">ベンチマークゲーム</a>でのRubyとJavaScriptのパフォーマンス比較</em></p><p>でも、実際にどれぐらい速くなければならないのでしょうか。</p><p><a href="http://theixdlibrary.com/pdf/Miller1968.pdf" rel="nofollow" title="" class="ext-link">コンピュータが最初に開発された1960年代から、人間とコンピュータのインタラクションのためのガイドラインが知られています</a>。ユーザが、サイトがロードされるのを待たずに、サイトで「<em>自由にページ間を移動している</em>」ように感じるための応答時間の閾値は、1秒以下です。ユーザがサイトをクリックするかインタラクションした瞬間から、その対話が完了する（DOMが描画を終える）までは、1秒の<em>応答時間</em>ではなく、1秒の”<em>表示のための</em>“秒数です。</p><p>1秒の”表示のための”秒数は、それほど長い時間ではありません。まず、ネットワーク遅延に約50msを想定します（これは机上の想定です。モバイルでの遅延は別の議論になります）。次に、JSおよびCSSリソースをロードして、レンダーツリーを構築し、描画するために、さらに150msを計上します。最後に、ダウンロードしたJavaScriptを全て実行するために、<em>少なくとも</em>250msを想定し、また、JavaScriptに、DOMに結びつく機能が多く含まれる場合は、より多くの時間を想定します。このように、サーバがどのぐらいの時間で応答すべきかを考える前に、すでに約500msの時間がカウントされています。<strong>ウェブページを表示するのに常に１秒を達成するには、サーバ応答は300ms未満を維持しなければなりません。</strong><a href="http://www.nateberkopec.com/2015/05/27/100-ms-to-glass-with-rails-and-turbolinks.html" rel="nofollow" title="" class="ext-link">私が別の記事で扱ったように</a>、100msのウェブページ表示時間を得るためには、サーバ応答は、約25～30msを維持する必要があります。</p><p>各リクエストに300msという値は、特に、SQLクエリとActiveRecordの使用に熱心な開発者なら、Railsアプリでキャッシングを使わずに達成することは不可能ではありません。しかし、キャッシングを使えば、はるかに簡単です。私が目にしてきた大多数のRailsアプリは、常に応答に300ms以上かかるページをアプリ内に少なくとも半ダースかかえているので、キャッシングの恩恵を受けられるはずです。さらに、Railsに加えて、人気のある電子商取引フレームワークのSpreeのような重いフレームワークを使うと、それぞれのリクエストに追加される余分のRuby実行が原因となって、応答が著しく遅くなる可能性があります。DeviseやActiveAdminのような人気のある重いgemでさえ、それぞれのリクエストサイクルに数千行ものRubyのラインを追加します。</p><p>もちろん、キャッシングが助けにならない部分も、アプリの中に必ずあります。例えば、POSTエンドポイントなどです。POSTやPUTへの応答でアプリが行っていることが非常に複雑な場合は、おそらくキャッシングは助けにならないでしょう。しかし、その場合は、処理をバックグラウンド処理に移動させることを考えてみてください（後日、ブログ記事にします）。</p><p>まず、<a href="http://guides.rubyonrails.org/caching_with_rails.html" rel="nofollow" title="" class="ext-link">キャッシングに関するRailsの公式ガイド</a>は、Railsの様々なキャッシングAPIの技術的詳細を参照するには最適です。まだ読んだことがないならば、ぜひじっくり全体に目を通すことをおすすめします。</p><p>後で、Rails開発者として利用可能な、様々なキャッシングのバックエンドについて議論したいと思います。それぞれに長所と短所があります。スピードは遅いけれどホストとサーバ間での共有が提供されるものもあれば、速いけれど全く、他のプロセスとさえ、キャッシュを共有できないというものもあります。皆のニーズは同じではありません。つまり、デフォルトのキャッシュストア、<code>ActiveSupport::Cache::FileStore</code>もOKなのですが、このガイドで使われている方法（特に、キーベースのキャッシュ期限切れ）に倣うなら、やはり別のキャッシュストアに変更する必要があります。</p><p>キャッシングを初めて行う人たちへのアドバイスですが、<strong>アクションキャッシングとページキャッシングは無視しましょう。</strong>これら2つのテクニックを使う状況というのは非常に特殊なので、Rails 4.0からは除かれています。それよりも、これから説明するフラグメントキャッシングを使いこなせるようにするのがおすすめです。</p><p>さて、キャッシュストアのセットアップも済み、準備ができました。けれども、何をキャッシュすればいいのでしょうか？</p><p>ここでプロファイリングの出番です。アプリケーションのどのエリアがパフォーマンスのホットスポットなのか、「闇雲に」推察しようとするよりも、プロファイリングツールを起動し、ページのどの部分が遅いのか教えてもらいましょう。</p><p>この仕事をするツールで気に入っているのは、優秀な<a href="https://github.com/MiniProfiler/rack-mini-profiler" rel="nofollow" title="" class="ext-link">rack-mini-profiler</a>です。<code>rack-mini-profiler</code>は、一定のサーバ応答の間、全ての時間がまさにどこに費やされているのかを1行1行解析し、内訳を示してくれます。</p><p>しかし、もし面倒であれば、<code>rack-mini-profiler</code>やその他のプロファイリングツールさえ使わなくてもよいのです。Railsはログのボックスからページ生成にかかる合計時間を提供してくれるからです。<sup><a href="#3">3</a></sup>それはこのように表示されます。</p><p>3:<a name="3"><img src="http://i.imgur.com/wTHHYbr.png"></a></p><p>合計時間（この場合は110ms）は重要です。Viewsで費やされた時間は、テンプレートファイル（index.html.erbなど）で費やされた時間の総計です。しかし、ActiveRecord::Relationsのデータのロードがどれだけ遅延するかによって、これは少々ミスリードになり得ます。もし、コントローラ内でActiveRecord::Relationを用いてインスタンス変数を定義して(<code>@users = User.all</code>のように)いながら、ビュー内で結果を使い始める（例えば<code>@users.each do</code>など）までその変数に何も操作を行わなかった場合、そのクエリ（と、ActiveRecordオブジェクトへの具象化）でかかる時間はViewsで費やされる時間に含まれます。ActiveRecord::Relationsの遅延ロードとは、実際に結果にアクセスされる（たいていビューにおいて）まで、データベースクエリは実行されないということです。</p><p>ここでのActiveRecordの秒数もミスリードです。Railsのソースを読む限りで分かるのは、この数字はActiveRecordにおいてRubyが実行される（クエリを作り、クエリを実行し、クエリ結果をActiveRecordオブジェクトに変える動き）際に費やされた時間ではなく、データベースを問い合わせるためだけに要した時間（データベース内でかかった時間）です。時々、とりわけ多くのローディングを求める非常に複雑なクエリを使う場合、クエリ結果をActiveRecordオブジェクトに変換するのに<em>多くの</em>時間がかかってしまい、さらにここのActiveRecordの数字には反映されないこともあり得ます。</p><p>それでは、残りの時間はどこに行ったのでしょうか？　たいていの場合、その行き先はほとんどがRackミドルウェアとコントローラコードです。しかし、リクエストの間、時間が<em>正確には</em>どこに使われたか、ミリ秒ごとの内訳を得るには、<code>rack-mini-profiler</code>と、<code>flamegraph</code>エクステンション<sup><a href="#4">4</a></sup>が必要になってきます。それらのツールを使うことで、リクエストの間、全てのミリ秒がどこに費やされたか、1行ごとに分かります。現在、私は<code>rack-mini-profiler</code>の利用ガイドを作っているところです。完成したらお知らせしますので、興味のある人は、<a href="http://www.nateberkopec.com/2015/07/15/the-complete-guide-to-rails-caching.html" rel="nofollow" title="" class="ext-link">私のニュースレターに登録してください（ページ右下から）</a>。</p><p><a name="4"><img src="http://i.imgur.com/h3ZvWGm.png"></a><br>
4:<em>rack-mini-profilerにおけるフレームグラフ</em></p><p>Railsアプリケーションのパフォーマンスをプロファイルする時は<strong>常に、本番モードで行っています。</strong>もちろん、本番で、ということではなく、<code>RAILS_ENV=production</code>を使っているという意味です。本番モードで実行すると、自身のローカル環境がエンドユーザの体験に近くなるようにしてくれるだけでなく、開発モードにおいてRailsリクエストのスピードをことごとく大幅に下げてしまう2つの要素、コードのリロードとアセットコンパイルを無効にしてくれます。本番環境設定を完璧に模倣するDockerが使えるならさらに良いでしょう。例えばHerokuを利用しているなら、Herokuが最近リリースしたDockerイメージが便利です。ただ、たいていの仮想化は本番環境に近づけるのに不必要なステップであることが多いのですが。多くの場合、Railsサーバを本番モードで実行することだけを気をつければよいのです。</p><p>簡単に復習しましょう。ローカルマシンでRailsアプリケーションを本番モードで走らせる際にしなければならないことは下記です。</p><p>加えて、<strong>セキュリティ、プライバシー関連の懸念がない限り、私はいつも本番データのコピーでテストします</strong>。開発中のデータベースクエリ（User.allのような）は、100やそこら程度のサンプル行を返してくることが非常に多いのですが、本番では、サイトをクラッシュさせ得る100,000行もの結果が吐き出されるからです。本番データを使うか、シードデータをできる限り実際に近い形にして使いましょう。このことは<code>includes</code>やローディング要求の多いRails機能を広範囲にわたって使う場合は<em>特に</em>重要です。</p><p>最後に、<strong>自身のサイトの最大許容平均応答時間（MAART）を設定する</strong>ことをおすすめします。パフォーマンスの素晴らしいところは、多くの場合、測定が可能だということです。そして測れるものは、管理が可能です。2種類のMAARTが必要かもしれません。開発用ハードウェアを使い開発モードで達成できるもの、それから本番ハードウェアを使って本番モードにおいて出る数字です。</p><p>仮想化によってCPUとメモリアクセスを制御し、完璧に1対1の本番／開発の環境のセットを用意できるのであればよいですが、そうでないのならパフォーマンス結果をそれら2つの環境にわたって再現することはできません（近いものを得ることはできますが）。しかし、それで問題ありません。細かい点をつつき回さないことです。ただ、ページパフォーマンスがおおむね正確であることを確認してください。</p><p>例えば、<a href="http://www.nateberkopec.com/2015/05/27/100-ms-to-glass-with-rails-and-turbolinks.html" rel="nofollow" title="" class="ext-link">以前投稿したように</a>、100ms”表示のための”ウェブアプリケーションを作りたいとします。そのためにはサーバ応答は25～50msに抑えなければなりません。そこで開発モードでのMAARTは25msに設定し、本番では50ms程度の設定に緩めることにします。私の開発マシンはHeroku dyne（私の基本的なデプロイ環境）よりも速いため、本番には少し余分に時間を足しておきます。</p><p>最大許容平均応答時間について、自動的にテストしてくれるツールの存在は今のところ知りません。現状では、ベンチマークツールを使って手動で行う必要があります。</p><p>では、開発環境において、サイトの実際の平均応答時間をどのように判断するのでしょうか。ここまで説明したのは、ログから応答時間を読み取る方法だけです。すると最善の方法は、ブラウザで再読み込みを何度か行って、結果の平均から推測することでしょうか？　違います。</p><p>ここで役に立つのが、<code>wrk</code>や<code>Apache Bench</code>といったベンチマークツールです。<code>Apache Bench</code>、すなわち<code>ab</code>は私のお気に入りですが、使い方を簡単に説明しましょう。Homebrewにインストールするには、<code>brew install ab</code>とします。<sup><a href="#6">6</a></sup></p><p><a name="6"></a><br>
6:<em>そのためには、最初に”brew tap homebrew/apache”を実行する必要があるかもしれません。</em></p><p>前述したように本番モードでサーバを開始して、Apache Benchを以下の設定で起動します。</p><p>もちろん、このURLは適切なものに置き換える必要があります。-tのオプションはベンチマークする時間（秒）を指定し、-cのオプションは同時に試すリクエストの数を指定します。-cは本番環境の負荷に応じて設定してください。もし（1サーバで）1秒につき平均1リクエスト以上になる場合は、-cを「（1分当たりの本番環境リクエスト数÷本番サーバまたはdyneの数）×2」を目安とした数に増やすとよいでしょう。私はたいてい、スレッドや並行処理のおかしなエラーが出ないかチェックするために、少なくとも-c 2でテストしています。</p><p>以下は、分かりやすいように簡略化したApache Benchの出力例です。</p><p>この「time per request」の数値をMAARTと比べることになります。95パーセンタイル（リクエストの95％がXより速い）の目標も設定している場合は、リスト末尾にある「95％」の時間と比較できます。便利ですよね。</p><p>Apache Benchで何ができるかについては、マニュアルを参照してください。SSLサポートやKeepAlive、POST/PUTサポートなどのオプションも重要です。</p><p>もちろん、このツールの優れている点は、本番サーバに対しても使えるということです。しかし、負荷の高い環境についてベンチマークしたい場合は、顧客に影響しないように、ステージング環境で実行するのが望ましいでしょう。</p><p>ここからのワークフローはシンプルです。<strong>設定したMAARTを満たさない限りは何もキャッシュしません。</strong>もしページがMAARTより遅いなら、<code>rack-mini-profiler</code>を使って、ページのどの部分で時間がかかっているかを調べます。<sup><a href="#5">5</a></sup>私が特に注意するのは、大きなSQLがリクエストのたびに無駄に実行されていたり、大量のコードが繰り返し実行されていたりする部分がないかということです。</p><p><a name="5"><img src="https://imgur.com/gtMaUPI.png"></a><br>
rack-mini-profilerの出力例</p><p>キャッシュから書いたり読んだりすることは、とても簡単です。繰り返しますが、基本的な事項については、<a href="http://guides.rubyonrails.org/caching_with_rails.html" rel="nofollow" title="" class="ext-link">このトピックに関するRailsのガイドを参照してください</a>。<strong>キャッシングにおいて複雑なのは、キャッシュを失効させるタイミングを把握することです。</strong></p><p>以前は、Rails開発者はObserverやSweeperを使って、キャッシュの有効期限切れをよく手動で設定していました。現在では、その方法はすっかり使われなくなり、<em>キーベースの期限切れ</em>が使われるようになっています。</p><p>キャッシュとは、Hashと同様に、キーと値のシンプルな集まりでしたね。実際、Rubyでは常にハッシュをキャッシュとして使っています。キーベースの期限切れとは、<em>キャッシュされている値</em>の情報を<em>キャッシュキー</em>に持たせて、キャッシュにおけるエントリを失効させる方法です。この場合、オブジェクトが（私たちの気にかけているような形で）変わった時に、そのオブジェクトのキャッシュキーも変わります。それをキャッシュストアに残し、（もう使われなくなった）前のキャッシュキーを失効させるのです。キャッシュにおけるエントリを手動で失効させることはありません。</p><p>ActiveRecordオブジェクトの場合は、ある属性を変更してオブジェクトをデータベースに保存するたびに、そのオブジェクトの<code>updated_at</code>属性が変わることは分かっています。ですので、ActiveRecordオブジェクトをキャッシュするときには、キャッシュキーにおける<code>updated_at</code>が使えます。つまり、ActiveRecordオブジェクトが変わるたびにそのupdated_atが変わることを使って、キャッシュを破棄するのです。幸い、Railsはこれに対応しており、処理も非常に簡単です。</p><p>例えば、Todoアイテムがあるとすると、以下のようにキャッシュできます。</p><p>ActiveRecordオブジェクトを<code>cache</code>に入れると、Railsはそのことを認識して以下のようなキャッシュキーを生成します。</p><p>code&gt;viewsの部分は説明不要ですね。<code>todos</code>の部分はActiveRecordオブジェクトのClassがベースになります。次の部分はオブジェクトの<code>id</code>（この例では123）と<code>updated_at</code>の値（2012年のある時）を組み合わせたものです。最後の部分はテンプレートツリーダイジェストと呼ばれるもので、このキャッシュキーが呼び出されたテンプレートのMD5ハッシュです。テンプレートが変わると（例えばテンプレートのある行を変えて、その変更を本番環境に反映させるような場合）、キャッシュは破棄されて、新しいキャッシュ値が再生成されます。これなら、テンプレートのどこかを変えた時に全てのキャッシュを手動で失効させる必要がないので、非常に便利です。</p><p>ここで注意したいのは、キャッシュキー中の何かを変えるとキャッシュが失効するということです。したがって、既定のTodoアイテムについて以下の項目のどれかが変わった場合、キャッシュは失効して新しいコンテンツが生成されます。</p><p>この方法では、どのキャッシュキーも<em>実際に</em>失効するわけではなく、使われない状態になるだけであることに注意してください。スペースがなくなった時に、手動でキャッシュからエントリを失効させる代わりに、使われなくなった値をキャッシュ自体が追い出すようにしているのです。または、時間ベースの期限切れとして、ある期間が過ぎたらキャッシュから古いエントリを失効させる方法もあります。</p><p>Arrayを<code>cache</code>に入れた場合は、キャッシュキーはArrayの全要素を連結したものがベースになります。このことは、同じActiveRecordオブジェクトを使う別々のキャッシュにおいて役に立ちます。例えば、current_userに依存する以下のようなtodoアイテムのビューがあるとします。</p><p>この場合、current_userが更新された時<em>または</em>todoが変わった時に、このキャッシュキーは失効して置き換えられます。</p><p>“ロシア人形キャッシュ”はDHHが名付けたつけたキャッシングの手法です。こじゃれた名前に身構えなくても大丈夫ですよ。難しいことは全くありません。</p><p>ロシアのマトリョーシカ人形は分かりますよね？　人形の中にまた小さな人形が入っている、というやつです。ロシア人形キャッシュの構造もまさに同じ状況で、フラグメントキャッシュが入れ子になっている状態を言います。以下のTodoの要素のリストで見てみましょう。</p><p>
</p>
<p>上記のコードには問題があります。例えば、「犬の散歩をする」という現在のTodoの記述を、「猫に餌をやる」に変更したとしましょう。そして、これでページをリロードすると、Todoリストは「犬を散歩する」のままになります。これは、内側のキャッシュを変更しても外側のキャッシュ（Todoリスト全体をキャッシュしたもの）が変更されていないからです。これはいけません。内側のキャッシュは再利用したいですが、同時に外のキャッシュは失効させたいですよね。</p><p>この問題を解決するには単純に、ロシア人形キャッシュで、キーベースのキャッシュの期限切れを指定すればいいのです。内側のキャッシュが失効したら、外側のキャッシュも失効させたいけど、外側のキャッシュが失効した時は、内側のキャッシュは失効させ<em>たくありません</em>。前述した例がどうなるか、以下のtodo_listで見てみましょう。</p><p>
</p>
<p>ここでは、どこかの@todoが修正されるか（そうすると@todos.maximum(:updated_at)が変更される）、Todoが削除されるか@todoに追加されるかすると（そうすると@todos.map(&amp;:id)が変更される）、外側のキャッシュは失効します。しかし、変更がされていないTodoのアイテムは、内側のキャッシュ内では同じキャッシュキーを持ったままです。つまり、キャッシュされた値は再利用されます。分かりました？　これだけのことです。</p><p>さらに、ActiveRecordの関連付けで<code>touch</code>オプションが使用されるのを見たことがあるでしょうか。ActiveRecordオブジェクトの<code>touch</code>メソッドを呼び出すと、データベースで記録された<code>updated_at</code>の値がアップデートされます。以下がその様子です。</p><p>上記を使えばロシア人形キャッシュをスムーズに失効することができます。</p><p>上記のキャッシュの構造（上記のように設定された<code>touch</code>の関係性）で、<code>@brake.car.save</code>を呼び出した場合、外側の2つのキャッシュは失効します（なぜなら<code>updated_at</code>の値が変更されるからです）。しかし、内側のキャッシュ（<code>@brake</code>の）はそのままの状態で再利用もされません。</p><p>Railsの開発者には、キャッシュのバックエンドの選択肢はいくつかあります。</p><p>それでは、それぞれの長所と短所を比べながら1つ1つ詳しく見ていきましょう。最後にはパフォーマンスのベンチマークを用意しています。それぞれのキャッシュストアと折り合うパフォーマンスの妥協点のアイディアをみなさんに提供できればと思っています。</p><p>FileStoreは、私が知る限りの全てのRailsアプリでデフォルトキャッシュのインプリメンテーションです。もし、production.rb （もしくは別のどんな環境でも）に<code>config.cache_store</code>を設定していなければ、FileStoreを使っていることになります。</p><p>FileStoreは単純に、デフォルトで<code>tmp/cache</code>に一連のファイルやフォルダの中に全てのキャッシュを保存していきます。</p><p><strong>FileStoreはプロセス間で使える。</strong>例えば、UnicornのRailsのアプリを起動する1つのHerokuのdyneがあって、Unicornを扱うworker が3つならば、3つ全てが同じキャッシュを共有できます。もし、worker 1が計算をして先ほどの例のtodoリストのキャッシュに保存すると、worker 2もそのキャッシュの値を使用することができます。しかし、このやり方はホスト間では通用しません。（もちろん、ほとんどのホストは同じファイルシステムにアクセスすることはありませんが。）繰り返しになりますが、Herokuでは各dyneごとの全てのプロセスでキャッシュが共有できますが、dynoでは共有できません。</p><p><strong>RAMよりディスクスペースがより安い。</strong>ホストのMemcacheのサーバは安くはありません。例えば、30MBのMemcacheサーバでは1カ月で数ドルの費用です。ではこれが5GBになったらどうでしょうか？　月290ドルになってしまいます。でもディスクスペースはRAMよりは、ものすっごく安くなります。ですから、もし多くのディスクスペースにアクセスしたり、膨大なキャッシュがあるのであれば、FileStoreがとても便利です。</p><p><strong>FileStoreは比較的遅い。</strong>RAMにアクセスするよりもディスクにアクセスするほうが断然速度が遅くなってしまいます。それでも、ネットワークを介してキャッシュにアクセスするよりは速いです（ネットワークを介すると1分くらいかかってしまうでしょう）。</p><p><strong>キャッシュがホスト間で共有できない。</strong>残念ながら、Railsサーバとキャッシュは共有できません。Railsサーバはファイルシステムとも共有できません（例えばHeroku dyneのように）。これにより、FileStore は巨大なデプロイ環境には適していません。</p><p><strong>LRUキャッシュではない。</strong>これはFileStoreの一番大きな欠点です。FileStoreはエントリを失効させますが、それはキャッシュに書き換えられた時であって、最後には使われたりアクセスされたりした時点ではありません。これは、キーベースのキャッシュの期限切れを扱う時にはFileStoreでは意味をなしません。前述の例を思い出してみてください。キーベースの期限切れは、手動でキャッシュキーを失効させるは際にはありませんでした。FileStoreでこれをやろうと思うと、キャッシュは最大のサイズ（1GB！）まで膨れ上がります。それから、キャッシュが作られた時間をベースにキャッシュのエントリを失効していきます。例えば、todoリストをまず作って、1秒間に10回のアクセスがあるとします。それでもFileStoreはアイテムを先に失効していきます。Least-Recently-Used cache algorithms（LRU）はキーベースのキャッシュの期限切れでうまく動きます。それはLRUがしばらく使われていないエントリを先に失効させていくからです。</p><p><strong>Herokuのdynoをクラッシュする。</strong>FileStoreのもう1つの特徴は、一時的なHerokuのファイルシステムとは完全に相性が悪いことです。Herokuでファイルシステムにアクセスするととてつもなく遅く、実際にdyneの“スワップメモリ”に追加します。Railsのアプリが、アクセスに時間のかかるHerokuでの巨大なFileStoreのキャッシュのせいで遅くなるのを私は見てきました。さらにHerokuは24時間ごとに全てのdyneを再起動させます。これが起こると、ファイルシステムはリセットされ、キャッシュは削除されてしまいます！</p><p>リクエストの負荷が低ければ（1～2個のサーバであれば）、FileStoreを使えますが、依然として大きなキャッシュが必要です。なお、Herokuでは使わないでください。</p><p>MemoryStoreはRailsで提供されているメインの実装の1つです。ファイルシステムにキャッシュの値を保存する代わりに、MemoryStoreは巨大なハッシュ形式でRAMに直接保存します。</p><p>ActiveSupport::MemoryStoreはスレッドセーフです。今回リストアップした他のキャッシュストアも全てそうです。</p><p>もしサーバが1つか2つでworkerがそれぞれ数個なら、保存されるキャッシュデータは非常に小さいので（20MB以下）、そのような場合はMemoryStoreを使うのがいいでしょう。</p><p>Memcacheは、Railsのアプリケーションではおそらく一番よく使用され、外部のキャッシュストアで一番推奨されています。Memcacheは2003年にLiveJournal向けに開発されました。そして、Wordpress.orgやWikipediaやYoutubeなどでも使用されています。</p><p>Memcacheは、巨大なプロダクションのデプロイメントを持つという長所がある一方で、他のキャッシュストアよりもデプロイメントの速度がなぜか遅くなってしまうという点もあります（古くて使い込まれていても壊れていなければ、修正はしないでください）。</p><p>1つか2つ以上のホストを使う場合、分散したキャッシュストアを使ったほうがいいです。しかし、Redisのほうがわずかですが勝っていると私は思います。その理由は以下のとおりです。</p><p>RedisはMemcacheと同じようなメモリ上のkey-valueデータストアです。2009年にSalvatore Sanfilippo氏が開発を始め、現在でも同氏がプロジェクトを先導し、ただ1人で保守管理を行っています。</p><p><a href="https://github.com/redis-store/redis-store" rel="nofollow" title="" class="ext-link">redis-store</a>に加え、<a href="https://github.com/sorentwo/readthis" rel="nofollow" title="" class="ext-link">readthis</a>という新しいRedisキャッシュgemが登場しました。こちらは活発に開発が進んでいて、期待できそうです。</p><p>2つ以上のサーバまたはプロセッサを運用しているのであれば、キャッシュストアにRedisを使うことをお勧めします。</p><p>Discourseの共同創設者Sam Saffron氏によって開発されたLruReduxは、ActiveSupport::MemoryStoreを高度に最適化したものです。しかし残念なことにActiveSupportの互換インターフェースはまだ提供されていません。そのため、今のところは初期状態のRailsキャッシュストアとしてではなく、アプリの低位レベルで使うことになります。</p><p>アルゴリズムが高性能な（そしてハッシュが大きくなりすぎても問題のない大きさの）キャッシュを関数に要求する場合はLruReduxを使ってください。</p><p>優れたベンチマークは皆さん大好きですよね。<a href="https://gist.github.com/nateberkopec/14d6a2fb7fe5da06a1f6" rel="nofollow" title="" class="ext-link">全てのベンチマークのコードが、こちらのGitHubで入手できます</a>。</p><p>全てのRailsキャッシュストアの中で、最もよく使われるメソッドが<code>fetch</code>です。この値がキャッシュに存在する場合は、値を読み取ります。そうでない場合は、与えられたブロックを実行して値を書き込みます。このメソッドをベンチマークすることで、読み取りと書き込みの両方のパフォーマンスをテストできます。<code>i/s</code>は“iterations（イテレーション）/second（秒）”を省略したものです。</p><p>すごいですね。この結果から以下のことが分かります。</p><p>このテストのために、RailsアプリのWebページ上のコンテンツをいくつかキャッシュしてみることにします。これによって、全体の要求サイクルが必要な場合も、フラグメントキャッシュを読み取りまたは書き込みするのにかかる時間が分かるはずです。</p><p>本来、アプリがするのは、1から16の間のランダムな数字に<code>@cache_key</code>を設定し、次のようにレンダリングするだけです。</p><p><code class="language-text" data-lang="text">&lt;% cache(@cache_key) do %&gt;<br>
  &lt;p&gt;&lt;%= SecureRandom.base64(100_000) %&gt;&lt;/p&gt;<br>
&lt;% end %&gt;<br>
</code></p><p>以下の結果がApache Benchによって得られました。プロダクションモードに設定されたローカルのRailsサーバに平均10,000リクエストがありました。</p><p>これは本当に面白い結果です！　最速のキャッシュストア（MemoryStore）とキャッシュが無効なバージョンの間の差は約6ミリ秒です。つまり<code>SecureRandom.base64(100_000)</code>によって行われる仕事は6ミリ秒しかかかっていないと推測できます。この場合、離れたキャッシュにアクセスするのは、仕事そのものをするよりずっと遅くなるのです！</p><p>学んだことは何でしょう。<strong>リモートに分散されたキャッシュを使う際は、キャッシュを読み取るのにかかる実際の時間を計算しましょう。</strong>私が行ったのと同じようにベンチマークを使っても計測できますし、Railsログから読み取ることもできます。書き込むより読み取りに時間がかかってしまうようなら、絶対にキャッシュしないでください。</p><p>この投稿が皆さんの技術の向上のために必要な情報をお伝えし、Railsアプリでもっとキャッシングを活用するための助けになれば幸いです。これは非常に高性能なRailsサイトの本当のキーとなります。</p>
