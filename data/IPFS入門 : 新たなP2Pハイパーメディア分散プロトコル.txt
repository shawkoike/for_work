<p><a href="https://medium.com/@ConsenSys/an-introduction-to-ipfs-9bba4860abd0#.rtfpjmxml" rel="nofollow" title="" class="ext-link">An Introduction to IPFS</a> （2016-02-17）<br>
by <a href="https://twitter.com/ChrisLundkvist" rel="nofollow" title="" class="ext-link">Dr. Christian Lundkvist</a>, Director of Engineering,<br>
and <a href="https://twitter.com/johnlilic" rel="nofollow" title="" class="ext-link">John Lilic</a>, ConsenSys Enterprise<br>
posted on <a href="https://consensys.net/" rel="nofollow" title="" class="ext-link">ConsenSys</a> Medium</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1350/1*czZJ7mvEAqL4wNAg-jt9Ow.jpeg" src="https://cdn-images-1.medium.com/max/1350/1*czZJ7mvEAqL4wNAg-jt9Ow.jpeg"><br>
<em>提供：Bogdan Burcea</em></p><p>執筆：John Lilic</p><p>本稿の後半では、同僚のChristian Lundkvist博士が<a href="http://whatdoesthequantsay.com/2015/09/13/ipfs-introduction-by-example/" rel="nofollow" title="" class="ext-link">踏み込んだ技術的概要</a>を紹介していますので、その導入となる大まかな考え方をこのセクションでお話ししたいと思います。</p><p>IPFSは、バージョン管理された科学的データを巡回する高速システムの構築を目的として、Juan Benetの取り組みによって始まりました。<a href="https://en.wikipedia.org/wiki/Software_versioning" rel="nofollow" title="" class="ext-link">バージョン管理</a>が行われていると、ソフトウェアの変更履歴を追跡できるのです（<a href="https://ja.wikipedia.org/wiki/Git" rel="nofollow" title="" class="ext-link">Gitのような仕組み</a>）。その後、IPFSは<a href="https://ipfs.io/ipfs/QmNhFJjGcMPqpuYfxL62VVB9528NXqDNMFXiqN5bgFYiZ1/its-time-for-the-permanent-web.html" rel="nofollow" title="" class="ext-link">分散された永続的なWeb</a>として考えられるようになりました。「<em>IPFSとは、あらゆる端末を同じファイルシステムに接続することを意図した分散ファイルシステムです。</em>ある点でこれはWebの本来の目的と似ていますが、実はIPFSは、Gitオブジェクトを交換する単一のBitTorrentスウォームの方にもっと似ています。IPFSはインターネットの新たな主要サブシステムになるかもしれません。適切に構築されれば、HTTPやそれ以上のものを補完したり、置き換えたりできる可能性もあります。途方もない考えのように思えますが、まさに途方もないシステムです」［<a href="https://ipfs.io/ipfs/QmNhFJjGcMPqpuYfxL62VVB9528NXqDNMFXiqN5bgFYiZ1/its-time-for-the-permanent-web.html" rel="nofollow" title="" class="ext-link">1</a>］</p><p>IPFSの中核はバージョン管理されたファイルシステムであり、ファイルを受け取って管理し、どこかに保管も行って、バージョン履歴を追跡することができます。IPFSでは、各ファイルのネットワークでの動きも分かりますから、分散ファイルシステムでもあるのです。</p><p>IPFSでは、データやコンテンツがネットワークをどう動くかについて、BitTorrentと性質的に似たルールがあります。IPFSのファイルシステムのレイヤには、以下のような非常に興味深い特性があります。</p><p>IPFSは、オブジェクト（画像、記事、映像）を参照する時にどのサーバに保管されているかを調べるのではなく、全ての参照においてファイルのハッシュを使います。考え方としては、ブラウザで特定のページにアクセスしたい場合、IPFSはネットワーク全体に対して「このハッシュに対応するこのファイルを持っているか？」と問い合わせを行い、該当するIPFSのノードがファイルを返すことで、ページにアクセス可能になるという仕組みです。</p><p>IPFSはHTTPレイヤでコンテンツ・アドレッシングを使っています。これは、「コンテンツをlocationで指定する識別子を生成するのではなく、コンテンツ自体の表現でコンテンツを指定します」、と宣言するやり方です。つまり、コンテンツがアドレスを決定するのです。IPFSにファイルが追加されると、それを暗号化したハッシュが生成されるという仕組みなので、ファイルの表現は非常に小さく安全なものとなります。従って、同じハッシュを持つ別のファイルを誰かが偶然見つけてそれをアドレスとして使うようなことはできません。IPFSでは、ファイルのアドレスは通常、ルートオブジェクトを識別するハッシュで始まり、走査するパスが次に続きます。サーバではなく特定のオブジェクトと通信して、そのオブジェクト内のパスを調べるのです。</p><p>HTTPには、識別子に所在が含まれているという便利な特性があるので、ファイルを提供しているコンピュータを見つけてそれと通信することは簡単です。これは便利な性質であり大抵は問題ないのですが、オフラインの場合や、ネットワークの負荷をできる限り少なくしたい大規模分散環境では、うまい方法とは言えません。</p><p>IPFSでは、このステップは以下の2つに分かれています。</p><p>その結果、IPFSは、高速なルーティングが可能なPeer-to-Peer（P2P）型のオーバーレイとなっています。</p><p>詳細については、<a href="https://www.youtube.com/watch?v=8CMxDNuuAiQ" rel="nofollow" title="" class="ext-link">アルファ版のデモ映像</a>をご覧ください。</p><p>執筆：Christian Lundkvist博士</p><p>技術的に見ると、<a href="http://ipfs.io/" rel="nofollow" title="" class="ext-link">IPFS</a>（InterPlanetary File System:惑星間ファイルシステム）は、<a href="https://ja.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB" rel="nofollow" title="" class="ext-link">分散ハッシュテーブル</a>や<a href="https://git-scm.com/" rel="nofollow" title="" class="ext-link">Git</a>バージョン管理システム、<a href="https://ja.wikipedia.org/wiki/BitTorrent" rel="nofollow" title="" class="ext-link">BitTorrent</a>といった実績のあるインターネットテクノロジの統合体です。IPFSではP2Pスウォームが生成され、<em>IPFSオブジェクト</em>の交換ができるようになっています。IPFSオブジェクトの総体は、<em>Merkle DAG</em>として知られる暗号化認証されたデータ構造を形成し、このデータ構造を基にして他の多くのデータ構造が作られます。以下ではIPFSオブジェクトとMerkle DAGについて紹介し、IPFSを使って作られる構造の例を見ていきます。</p><p><a href="http://ipfs.io/" rel="nofollow" title="" class="ext-link">IPFS</a>は本質的に、<em>IPFSオブジェクト</em>を検索し共有するためのP2Pシステムです。IPFSオブジェクトとは、以下2つのフィールドをもつデータ構造です。</p><p>Link構造体には、以下3つのフィールドがあります。</p><p><em>Size</em>フィールドは、主にP2Pネットワーキングを最適化するために使用されますが、概念上は、論理構造に必要なものではないため、本稿では特に扱いません。</p><p>IPFSオブジェクトは通常、Base58でエンコードされたハッシュによって参照されます。例えば、<em>QmarHSr9aSNaPSR6G9KFPbuLV9aEqJfTk1y9B8pdwqK4Rq</em>というハッシュを持つIPFSオブジェクトを、IPFSコマンドラインツールで見てみましょう（これは自宅で試してくださいね）。</p><p>全てのハッシュが「Qm」で始まっていることにお気づきでしょうか。その理由は、このハッシュが実は<strong>multihash</strong>の形式であるからです。つまり、ハッシュの先頭2バイトで、ハッシュ自体がハッシュ関数とハッシュの長さを示しているのです。上記の例では、先頭2バイトを16進数で表すと<em>1220</em>となりますが、<em>12</em>はこれがSHA-256ハッシュ関数であること、<em>20</em>はハッシュの長さが32バイトであることを意味しています。</p><p>データと、名前付きのリンクがあることで、IPFSオブジェクトの集合は<strong>Merkle DAG</strong>の構造を取ります。<a href="https://ja.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E9%9D%9E%E5%B7%A1%E5%9B%9E%E3%82%B0%E3%83%A9%E3%83%95" rel="nofollow" title="" class="ext-link">DAG</a>は有向非巡回グラフを意味し、<a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%AB%E3%83%95%E3%83%BB%E3%83%9E%E3%83%BC%E3%82%AF%E3%83%AB" rel="nofollow" title="" class="ext-link">Merkle</a>はこれが暗号化認証されたデータ構造であり、コンテンツのアドレス指定に暗号化ハッシュを用いていることを示しています。このグラフで閉路を持つことができない理由について考えるのは、皆さんの練習問題としておきましょう。</p><p>このグラフ構造を目に見えるようにするため、IPFSオブジェクトを視覚化してみたいと思います。グラフでは、ノードにDataがあり、Linksは他のIPFSオブジェクトへ向かう有向グラフのエッジ、LinkのNameはグラフのエッジに付けられたラベルとなります。以下の図は、上記の例を視覚化したものです。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/675/1*9rVlSSzV0efkf18NiYo2eg.jpeg" src="https://cdn-images-1.medium.com/max/675/1*9rVlSSzV0efkf18NiYo2eg.jpeg"><br>
それでは、IPFSオブジェクトで表すことのできる様々なデータ構造の例を見ていきましょう。</p><p>IPFSは、ファイルとディレクトリから構成されるファイルシステムを簡単に表すことができます。</p><p>小さなファイル（256kB以下）をIPFSオブジェクトで表すと、<em>data</em>がファイルのコンテンツ（および小さなヘッダとフッタ）で、リンクがないため<em>links</em>は空配列となります。ファイル名がIPFSオブジェクトの一部ではないことに注意してください。つまり、コンテンツが同じで名前の異なる2つのファイルは、IPFSオブジェクトの表現が同じになるため、生成されるハッシュも同一なのです。</p><p><em>ipfs add</em>というコマンドを使うと、IPFSに小さなファイルを追加することができます。</p><p><em>ipfs cat</em>を使えば、上記IPFSオブジェクトのファイルのコンテンツを見ることができます。</p><p><em>ipfs object get</em>で基本構造を見てみましょう。</p><p>このファイルを視覚化すると、以下のようになります。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/675/1*dWuAv67ihETN3FAdzsb87A.jpeg" src="https://cdn-images-1.medium.com/max/675/1*dWuAv67ihETN3FAdzsb87A.jpeg"></p><p>大きなファイル（256kB以上）は、256kB以下のファイルの塊に対するリンクのリストと、このオブジェクトが大きなファイルの表現であることを示す最小限の<em>Data</em>で表されます。ファイルの塊に対するリンクは、名前として空文字列を持っています。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/900/1*bgKkxhSphiCdAF8QKm-oxw.jpeg" src="https://cdn-images-1.medium.com/max/900/1*bgKkxhSphiCdAF8QKm-oxw.jpeg"></p><p>ディレクトリは、ファイルや他のディレクトリを表すIPFSオブジェクトへのリンクのリストで表されます。リンク名は、ファイル名やディレクトリ名です。例えば、次のようなディレクトリ<em>test_dir</em>のディレクトリ構造を考えてみてください。</p><p><em>hello.txt</em>と<em>my_file.txt</em>というファイルの両方に文字列<em>Hello World!\n</em>が含まれ、<em>testing.txt</em>というファイルには文字列<em>Testing 123\n</em>が含まれています。</p><p>このディレクトリ構造をIPFSオブジェクトとして表すと、以下のようになります。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1350/1*-wVVj4B-YhxvF82iSUrbOQ.jpeg" src="https://cdn-images-1.medium.com/max/1350/1*-wVVj4B-YhxvF82iSUrbOQ.jpeg"></p><p><em>Hello World!\n</em>を含むファイルの自動重複排除に注意してください。このファイル内のデータはIPFS内の1つの論理的な場所に格納されているだけ（ハッシュによるアドレス指定）です。</p><p>IPFSコマンドラインツールを使えば、シームレスにディレクトリのリンク名を追って、ファイルシステムを横断できます。</p><p>IPFSは、Gitで使われているデータ構造を表して、バージョン管理されたファイルシステムを実現可能にします。Gitコミットオブジェクトについては、<a href="http://www.git-scm.com/book/en/v2/Git-Internals-Git-Objects#Commit-Objects" rel="nofollow" title="" class="ext-link">Git Book</a>に説明があります。IPFSコミットオブジェクトの構造は、本稿の執筆時点では完全には規定されておらず、<a href="https://github.com/ipfs/notes/issues/23" rel="nofollow" title="" class="ext-link">議論が続いています</a>。</p><p>コミットオブジェクトの主な特性は、前のコミットを指す<em>parent0、parent1</em>などといった名前の1つ以上のリンクと、<em>object</em>（Gitでは<em>tree</em>と呼ばれます）というリンク名の、コミットによって参照されるファイルシステム構造を指す1つのリンクを持つということです。</p><p>一例として、従来のファイルシステムのディレクトリ構造を2つのコミットと共にご紹介しましょう。1つ目のコミットは元の構造です。2つ目のコミットでは、もともとの<em>Hello World!</em>ではなく<em>Another World!</em>と表示されるように、ファイル<em>my_file.txt</em>が更新されています。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1350/1*84YPXEWxIyuH7WGousjsjg.jpeg" src="https://cdn-images-1.medium.com/max/1350/1*84YPXEWxIyuH7WGousjsjg.jpeg"></p><p>自動重複排除機能があるので、2つ目のコミットの新しいオブジェクトは、メインディレクトリ、新しいディレクトリ<em>my_dir</em>、そして更新されたファイル<em>my_file.txt</em>だけだということにも気を付けてください。</p><p>これはIPFSで最も面白いユースケースの1つです。ブロックチェーンには自然なDAG構造があり、過去のブロックはハッシュによって後のブロックと常にリンクされています。<a href="https://ethereum.org/" rel="nofollow" title="" class="ext-link">Ethereum</a>で使われているような高度なブロックチェーンも関連づけられた状態データベースを持っており、そのデータベースは<a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" rel="nofollow" title="" class="ext-link">Merkle-Patricia tree</a>構造で、IPFSオブジェクトを使ってエミュレートすることもできます。</p><p>前提としているのはブロックチェーンの単純すぎるモデルで、各ブロックが含んでいるデータは以下のとおりです。</p><p>それから、このブロックチェーンは次のようにIPFSでモデル化することができます。</p><p><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1350/1*Vk9w5CXlRdp4T10UTpEYXg.jpeg" src="https://cdn-images-1.medium.com/max/1350/1*Vk9w5CXlRdp4T10UTpEYXg.jpeg"></p><p>状態データベースをIPFSに配置する際に得る重複排除機能が見られます。2つのブロック間には変更された状態のエントリのみが明示的に格納されなくてはなりません。</p><p>ここで興味深い点は、ブロックチェーン上にデータを格納することと、ブロックチェーン上にデータのハッシュを格納することとの違いです。Ethereumプラットフォームでは、関連づけられた状態データベースにデータを格納するためにかなりのコストがかかります。状態データベースの肥大化（”ブロックチェーンの肥大化”）を最小限に抑えるためです。そのため、大きめのデータは、データそのものではなく、データのIPFSハッシュを状態データベースに格納するのが一般的なデザインパターンです。</p><p>関連づけられた状態データベースを持つブロックチェーンが既にIPFSで表されている場合、ブロックチェーン上にハッシュを格納することとブロックチェーン上にデータを格納することとの違いは、やや不鮮明になります。とにかく全てがIPFSに格納されているので、ブロックのハッシュに必要なのは、状態データベースのハッシュだけです。この場合、IPFSリンクがブロックチェーンに格納されていれば、シームレスにそのリンクをたどって、まるでデータがブロックチェーン自体に格納されているかのように、データにアクセスできます。</p><p>しかし、それでもオンチェーンとオフチェーンのデータストレージを見分けることができます。新しいブロックを作る際にマイナーが処理しなければならないものを見て、区別します。現在のEthereumネットワークでは、状態データベースを更新するトランザクションをマイナーが処理する必要があります。それを行うため、どこが変更されても更新できるように、マイナーには完全な状態データベースへのアクセスが必要です。</p><p>従って、IPFSで表されるブロックチェーンの状態データベース内で、やはりデータに”オンチェーン”か”オフチェーン”かのタグを付けなければならないでしょう。”オンチェーン”データは、マイニングを行うためにマイナーがローカルに保持する必要があり、このデータは直接トランザクションの影響を受けます。”オフチェーン”データは、ユーザが更新しなければならず、従ってマイナーがこれに触れる必要はありません。</p>
