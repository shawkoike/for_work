<p><a href="http://www.parsonsmatt.org/2017/01/07/how_do_type_classes_differ_from_interfaces.html" rel="nofollow" title="" class="ext-link">How do type class differ from interfaces?</a> （2017-01-07） by <a href="http://www.parsonsmatt.org/about/" rel="nofollow" title="" class="ext-link">Matt Persons</a></p><p><small><br>
(注：2017/02/27、いただいたフィードバックを元に翻訳を修正いたしました。)<br>
</small></p><p>Haskellの型クラスは、Haskellを学び始めたばかりの多くの人にとっては難しい概念です。たいていの言語はこれを表すことが全くできませんし、それに近い概念も持っていません。多くのオブジェクト指向型の言語にとっては、利用可能なものの中では<code>Interface</code>が最も近い言語要素でしょう。Rubyの<code>modules</code>は似たような役割を持っています。しかし、この概念は両方とも、名前の多重定義と一種のポリモーフィズムをアドレスするので、型クラスが提供するパワーの一部を欠いています。</p><p>この記事は、型クラスに興味を持っている人向けです。Haskellや関数型プログラミングの予備知識は必要ありません。JavaやC言語のような静的な型付き言語に慣れていれば、役に立つでしょう。</p><p>型クラスとは何かを知っているなら、この項目は飛ばしてください。</p><p>要約すると、Haskellの型クラスとは、以下のように定義されます。</p><p>上記のコードスニペットは以下のように解釈できます。</p><p>まず、toyデータ型の<code>ToyOrd</code>を作ります。</p><p>このデータ型には、2つの構成要素があります。フィールドを持たない<code>Smol</code>と、1つの<code>Int</code>フィールドを持つ<code>Large</code>です。これを<code>Ord</code>のインスタンスにするには、<code>Eq</code>のインスタンスにしなくてはいけません。</p><p><code>ToyOrd</code>データ型のための<code>Eq</code>インスタンスを定義したので、<code>Ord</code>を定義できます。</p><p>型クラスを得たら、インプットとしてその型クラスのインスタンスだと期待される関数を書くことができます。順序付け演算子を定義してみましょう。</p><p>この関数は<code>a</code>を提供する全ての型で機能するように記述します。そのような型は、<code>Ord</code>型クラスのインスタンスです。</p><p>Javaのインターフェースを使えば、オブジェクトがサポートするメソッドのセットを記述することができますし、Java 8では、これらのメソッド用のデフォルトでの実装も記述することができます。ですから、<code>Ord</code>と本質的には全く同じインターフェースを書くことができるのです。</p><p>これは、Javaの<code>Eq</code>インターフェースです。デフォルトの実装を利用しています。どちらか一つをオーバーライドしなければ、メソッドを呼び出そうとする際に無限にループを続けることになります。</p><p>これらのインターフェースに関して、ジェネリックなメソッドを書くこともできます。</p><p>表面上は、これらはそっくりに見えます。しかし、いくつか重要な違いがあるのです。</p><p>Haskellの<code>compare</code>関数の型シグネチャは、その引数の型に非常に特異的なものです。</p><p>この型シグネチャが意味するのは、次のようなことです。</p><p>忘れないでほしいのは、<code>compare</code>に対するパラメータがいずれも同じ型を持つように型シグネチャが<em>要求する</em>ということです！　<code>compare Smol 10</code>と記述してしまうと実行できません。Javaの場合は2つのオブジェクトが<em>何であろうと</em>、<code>Ord</code>インターフェースが実装されていれば引き渡されます。</p><p>Javaによる同等のコードはこんな風になります。</p><p>このメソッドのシグネチャはジェネリックの型変数<code>A</code>を導き、<code>A</code>によって<code>Ord</code>インターフェースが拡張か実装されなければならないと述べています。このメソッドでは、次に2つのパラメータを取り上げますが、どちらも同じジェネリック<code>A</code>型です。</p><p>Javaのクラスは1か所で定義されます。クラスが実装するインターフェースはいずれも同じクラス上に定義されなければなりません。Javaは直和型を処理することが得手ではありませんので、上位の<code>ToyOrd</code>クラスから<code>Large</code>を処理するだけになります。</p><p><code>compare</code>と<code>equalTo</code>を定義しました。注意すべきは、これらのメソッドが適切に実装されるように<code>instanceof</code>を実行し、型の変換を行なわなければならないということです。では、任意の型のオブジェクト2つを取り上げ比較することにどんな意味があるでしょうか？</p><p>あるupstream packageから<code>Large</code>を取り込み、独自のインターフェースを定義したとします。</p><p><code>SomeOtherPackage</code>インターフェースに<code>Large</code>を実装させることは全くできません！　そんなことはせずに、コントロール可能な新しいクラスで元々のクラスをラップしなければなりません。そうすることでインターフェースが実装されるのであり、もしそうしない場合には<code>Large</code>へデリゲートします。</p><p>型クラスはデータ型の定義とクラスのインスタンスに<em>分けられます</em>。ゆえに別のパッケージから<code>ToyOrd</code>を取り込むとしたら、以下のようなことが容易にできます。</p><p>これが、<em>幅広くて</em>驚嘆の誰でも使える型クラスです。<em>return型ポリモーフィズム</em>と言います。ちょっといやらしい存在です。</p><p>実行してもうまくいかないHaskellの型クラスを定義してみましょう。</p><p><code>Maybe</code>型用のインスタンスは簡単に作ることができます。</p><p>では、<code>CanFail</code>インスタンスを書いてみましょう。</p><p><code>CanFail</code>の項で幾つかの関数を書くことができます。安全なゼロ除算関数が書けます。</p><p>この関数シグネチャはとても面白いことを行なっています。普通の文章に翻訳してみましょう。</p><p>えっ、callerが型を選択？　つまり下記のようなコードが書けます。</p><p>上の関数で<code>safeDivision</code>のcallerのように、<code>Maybe</code>型を選択することもできます。他のインスタンスは何があるでしょうか。</p><p><code>MaybeError</code><em>も同じく</em>選択できます！　必要なら<code>IO</code>のインスタンスも作れます。</p><p>あたかも<code>print</code>か同様のもののように、<code>IO</code>で<code>safeDivision</code>関数を使えるようになります。</p><p>return型ポリモーフィズムは非常にスマートで、間違いなく型クラスの中で最高のものの1つです。同時に、他の言語でのインターフェースやモジュールとはかけ離れたところにあるものの1つです。</p>
