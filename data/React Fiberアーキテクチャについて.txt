<p><a href="https://github.com/acdlite/react-fiber-architecture" rel="nofollow" title="" class="ext-link">React Fiber Architecture</a> （2016-08-19時点版） by <a href="https://github.com/acdlite" rel="nofollow" title="" class="ext-link">Andrew Clark</a></p><p>React Fiberは、現在進行形で進められているReactのコアアルゴリズムの再実装であり、Reactチームの2年以上にわたる研究の成果です。</p><p>React Fiberは、アニメーション、レイアウト、ジェスチャーといった領域に対する適性を向上させることを目指しています。React Fiberの目玉となる<strong>インクリメンタルレンダリング</strong>は、レンダリング作業を分割して、複数のフレームに分散させることができる機能です。</p><p>他には主に、新たな更新があった際に作業を休止・強制終了・再利用できる機能、更新の種類別に優先順位をつけられる機能、新しい並行プリミティブなどが挙げられます。</p><p>Fiberは、コードを見ただけでは分かりにくい斬新な概念をいくつも導入します。このドキュメントはそもそも、ReactプロジェクトにおけるFiberの実装に伴って私が取っていたメモを集めたものでした。メモが増えてくるにしたがって、他の方にも役立つ資料になるかもしれないと考えるようになったのです。</p><p>できるだけ分かりやすい言い回しを心掛け、鍵となる用語を明示的に定義して、専門用語は避けたいと思います。また可能な場合は、外部情報源へのリンクをどんどん張っていきます。</p><p>なお、私はReactチームのメンバーではなく、いかなる権限から話すわけでもありませんので、ご注意ください。<strong>これは公式ドキュメントではありません</strong>。Reactチームのメンバーには、このドキュメントに間違いがないかレビューを依頼しています。</p><p>また、この作業は現在進行中です。<strong>Fiberは、完成までにかなりのリファクタリングが必要となりそうな、継続中のプロジェクトです</strong>。よって、その設計をこうしてドキュメントにまとめていくという私の試みも、同じく続いています。改善すべき点や提案があれば、ぜひお聞かせください。</p><p>私が目指しているのは、このドキュメントを読んだ方が、Fiberをよく理解して<a href="https://github.com/facebook/react/commits/master/src/renderers/shared/fiber" rel="nofollow" title="" class="ext-link">その実装過程をフォロー</a>できるようになり、ゆくゆくはReactへのコントリビュートまでできるようになるということです。</p><p>読み進めていく前に、以下の資料に目を通していただくことを強くお勧めします。</p><p>「このドキュメントを読む前に」のセクションをまだ読んでいない方は、そちらをご確認ください。</p><p>新しい内容を見ていく前に、いくつかの概念を再確認しておきましょう。</p><p><em><strong>リコンシリエーション（調停）（reconciliation）</strong></em><br>
どの部分に変更が必要か判断すべく、ツリー同士の差分を出すためにReactが使うアルゴリズム。</p><p><em><strong>更新（update）</strong></em><br>
Reactアプリをレンダリングするのに使われるデータ中の変更。通常は、<code>setState</code>で行われる。最終的には再レンダリングに至る。</p><p>ReactのAPIで中心となる考え方は、更新があたかもアプリ全体の再レンダリングを引き起こすかのように見なすことです。これによって開発者は、アプリを何らかの状態から別の状態へ（AからBへ、BからCへ、CからAへなど）効率的に遷移させる方法を気にするのではなく、宣言的に思考できるようになるのです。</p><p>実は、アプリ全体を変更の度に再レンダリングするという方法は、ごく小規模なアプリでしかうまくいきません。現実的なアプリでは、パフォーマンスの点でコストが途方もなく高くなるのです。Reactでは、優れたパフォーマンスを維持しながらアプリ全体を再レンダリングしたように見せる最適化がなされています。こうした最適化の大部分は、<strong>リコンシリエーション</strong>と呼ばれるプロセスの一部となっています。</p><p>リコンシリエーションは、「仮想DOM」として広く理解されている仕組みの背後にあるアルゴリズムです。ざっと説明してみましょう。Reactアプリケーションをレンダリングする際、そのアプリを記述するノードのツリーがメモリ内に生成され保存されます。このツリーはその後、レンダリング環境にフラッシュされ(流し込まれ)ます。例えば、ブラウザアプリケーションの場合では、1組のDOM操作に変換されます。アプリが（通常は<code>setState</code>を介して）更新されると、新しいツリーが生成されます。この新しいツリーと以前のツリーとの差分を出すことで、描画されたアプリを更新するためにどの操作が必要であるかを計算するというものです。</p><p>Fiberはこのリコンシリエーションを行う部分（リコンサイラ）を一から書き直すものですが、<a href="https://facebook.github.io/react/docs/reconciliation.html" rel="nofollow" title="" class="ext-link">Reactドキュメントに記載されている</a>上位レベルのアルゴリズムは、大部分は変わらないでしょう。以下が重要なポイントです。</p><p>DOMは、Reactの描画先となり得るレンダリング環境の1つにすぎません。他の主なターゲットは、React Nativeを介したネイティブのiOSビューとAndroidビューです（このため、「仮想DOM」という呼び方には若干語弊があるのです）。</p><p>Reactがそれほどのターゲットをサポートできる理由は、Reactが、リコンシリエーションとレンダリングが別個の工程となるように設計されているからです。リコンサイラは、ツリーのどの部分が変わったか計算する作業を行い、レンダラはその情報を使って、描画されたアプリを実際に更新します。</p><p>この役割分担のおかげで、React DOMとReact Nativeは、Reactのコアが提供する同じリコンサイラを共有しながら、独自のレンダラを用いることができるのです。</p><p>Fiberはリコンサイラを再実装するものです。この新しいアーキテクチャをサポート（して利用）するにはレンダラは変わる必要がありますが、Fiberは概してレンダリングに関与していません。</p><p><em><strong>スケジューリング（scheduling）</strong></em><br>
作業が実行されるべきタイミングを判断するプロセス。</p><p><em><strong>作業（work）</strong></em><br>
実行されなければならない計算。作業は通常、更新（例えば<code>setState</code>）の結果として生じる。</p><p>この件については、Reactのドキュメント「<a href="https://facebook.github.io/react/contributing/design-principles.html#scheduling" rel="nofollow" title="" class="ext-link">Design Principles</a>」（設計原理）で申し分なく説明されていますので、以下にそのまま引用します。</p><p>重要なポイントは以下のとおりです。</p><p>Reactは現在のところ、スケジューリングを目立った形では活用していません。更新によってサブツリー全体が即座に再レンダリングされるようになっているのです。スケジューリングを活用するためにReactのコアアルゴリズムを洗い直すというのが、Fiberを推し進めている考え方です。</p><p>これでFiberの実装について見ていく準備ができました。次のセクションは、ここまでの説明よりも専門的な内容となります。読み進める前に、前述の資料が理解できているかご確認ください。</p><p>React Fiberのアーキテクチャの核心についてお話ししていきます。Fiberは、アプリケーション開発者が一般的に考えるよりもずっと下位のレベルの抽象化です。Fiberを理解しようとしてうまくいかなかったとしても、諦めないでください。努力を続ければ、やがて意味が分かってくるでしょう（ついに理解できるようになった際には、このセクションの改善についてご提案いただければ幸いです）。</p><p>それでは始めましょう。</p><p>Fiberの最大の目的はReactがスケジューリングを活用できるようにすることだと、既に確認しました。具体的には、以下のことを可能にする必要があります。</p><p>上記のどれを実現させるにしても、まずは作業を構成単位に分解する手段が必要です。ある意味、それこそがfiberといえます。fiberは<strong>作業の構成単位</strong>を表すのです。</p><p>さらに詳しく見ていくため、<a href="https://github.com/reactjs/react-basic#transformation" rel="nofollow" title="" class="ext-link">データの関数としてのReactコンポーネント</a>という概念を振り返ってみましょう。これは一般的に、以下のように表されます。</p><p>つまり、Reactアプリのレンダリングは、本体に他の関数などへの呼び出しが含まれる関数を呼び出すことに似ているのです。この類似性は、fiberについて考える時に役立ちます。</p><p>コンピュータがプログラムの実行を追跡する典型的な方法は、<a href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF" rel="nofollow" title="" class="ext-link">コールスタック</a>を用いることです。関数が実行される時、新しいスタックフレームがスタックに追加されます。そのスタックフレームは、その関数によって実行される作業を表します。</p><p>UIを扱う際の問題は、同時に実行される作業が多すぎる場合、アニメーションのフレーム落ちが発生して、滑らかに見えなくなる可能性があるということです。その上、作業の中には、より新しい更新によって置き換えられたため不要になっているものがあるかもしれません。コンポーネントには一般の関数よりも具体的な用途があるため、この場面ではUIコンポーネントと関数を比較することができません。</p><p>比較的新しいブラウザ（とReact Native）は、まさにこの問題への対処に役立つAPIを実装しています。<code>requestIdleCallback</code>は、アイドル期間中に呼び出されるべき優先順位の低い関数をスケジューリングし、<code>requestAnimationFrame</code>は、次のアニメーションフレームで呼び出されるべき優先順位の高い関数をスケジューリングするのです。問題は、そうしたAPIを使うためには、レンダリング作業をインクリメンタルな構成単位に分解する手段が必要だということです。コールスタックだけに依存している場合は、スタックが空になるまで作業を続けることになります。</p><p>UIのレンダリング向けに最適化するためコールスタックの振る舞いをカスタマイズできるとしたら、素晴らしいことですよね。また、コールスタックに自由に割り込んでスタックフレームを手動で操作できるとしたら、素晴らしいことですよね。</p><p>それがReact Fiberの目的です。Fiberは、Reactコンポーネントに特化した、スタックの再実装です。単一のfiberは<strong>仮想スタックフレーム</strong>と見なすことができます。</p><p>スタックを再実装する利点は、<a href="https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/" rel="nofollow" title="" class="ext-link">スタックフレームをメモリに保持</a>し、好きなように（かつ、<em>いつでも</em>）それを実行できるということです。これは、スケジューリングに関する目的を果たすのに不可欠なことです。</p><p>スケジューリングに加えて、スタックフレームを手動で扱うことで、並行処理やエラー境界といった機能への可能性が生まれます。それらのテーマについては、今後のセクションで取り上げる予定です。</p><p>次のセクションでは、fiberの構造をさらに詳しく見ていきましょう。</p><p><em>注：実装の細部について具体的に説明していきますので、変更の生じている内容があるかもしれません。誤りや古い情報に気づかれた場合は、ぜひプルリクエストをお送りください。</em></p><p>fiberは具体的にいえば、コンポーネントとその入出力についての情報を含んだ、JavaScriptオブジェクトです。</p><p>fiberはスタックフレームに相当しますが、コンポーネントのインスタンスにも相当します。</p><p>以下に、fiberに属する重要なフィールドをいくつか挙げていきます（網羅的なリストではありません）。</p><p>fiberのtypeとkeyは、Reactエレメントの場合と同じ目的のために使われます（実は、fiberがエレメントから生成される際、この2つのフィールドは直接コピーされます）。</p><p>fiberのtypeは、対応するコンポーネントを示します。複合コンポーネントの場合、typeは関数かクラスコンポーネントそのものとなります。ホストコンポーネント（<code>div</code>や<code>span</code>など）の場合、typeは文字列となります。</p><p>typeは概念上、実行がスタックフレームによって追跡される、（<code>v = f(d)</code>で示されるような）関数です。</p><p>typeに加えて、keyはリコンシリエーションの際に、そのfiberが再利用できるかを判断するために使われます。</p><p>これらのフィールドは他のfiberを指し、fiberの再帰ツリー構造を示します。</p><p>child fiberは、コンポーネントの<code>render</code>メソッドによって返される値に相当します。例をご覧ください。</p><p>上記において、<code>Parent</code>のchild fiberは、<code>Child</code>に相当します。</p><p>siblingフィールドは、<code>render</code>が複数のchildを返す（Fiberの新機能です）場合に使われます。</p><p>上記のchild fiberは、先頭が1番目のchildである単方向リストとなります。この例では、<code>Parent</code>のchildは<code>Child1</code>であり、<code>Child1</code>のsiblingは<code>Child2</code>です。</p><p>再び関数とのアナロジーで考えてみると、child fiberは、<a href="https://en.wikipedia.org/wiki/Tail_call" rel="nofollow" title="" class="ext-link">末尾呼び出しされる関数</a>と見なすことができます。</p><p>return fiberは、プログラムが現在のfiberを処理したあとの復帰先となるfiberです。これは概念的に、スタックフレームのリターンアドレスと同じものです。parent fiberと見なすこともできます。</p><p>fiberが複数のchild fiberを持つ場合、各child fiberのreturn fiberはparentとなります。よって、前のセクションの例でいえば、<code>Child1</code>と<code>Child2</code>のreturn fiberは、<code>Parent</code>です。</p><p>概念上、propsは関数の引数です。fiberの<code>pendingProps</code>は実行の最初に設定され、<code>memoizedProps</code>は最後に設定されます。</p><p>新たに設定される<code>pendingProps</code>が<code>memoizedProps</code>と等しい場合、fiberの前回の出力を再利用して、不要な作業を回避できるということになります。</p><p>fiberによって表現される作業の優先順位を示す数値です。<a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js" rel="nofollow" title="" class="ext-link">ReactPriorityLevel</a>モジュールは、様々な優先レベルとその意味をリストにしています。</p><p>優先順位が0である<code>NoWork</code>は例外として、数値が大きいほど優先順位が低くなっています。例えば、以下の関数を使ってみると、あるfiberの優先順位が指定したレベル以上であるかを確認できます。</p><p><em>上記の関数は説明専用のものですので、実際にはReact Fiberのコードベースに含まれていません。</em></p><p>スケジューラはpriorityフィールドを使って、実行すべき次の作業単位を検索します。このアルゴリズムについては、今後のセクションで取り上げる予定です。</p><p><em><strong>フラッシュ（flush）</strong></em><br>
fiberをフラッシュするとは、fiberの出力を画面上にレンダリングすること。</p><p><em><strong>進行中の作業（work-in-progress）</strong></em><br>
未完了のfiber。概念的には、まだ返されていないスタックフレーム。</p><p>あるコンポーネントインスタンスはどの時点においても、対応するfiberを多くて2つ持っています。フラッシュされた現在のfiberと、作業進行中のfiberです。</p><p>現在のfiberのalternateは作業進行中のfiberであり、作業進行中のfiberのalternateは現在のfiberです。</p><p>fiberのalternateは、<code>cloneFiber</code>と呼ばれる関数を使って遅延評価で生成されます。<code>cloneFiber</code>は、新しいオブジェクトを常に生成するのではなく、fiberのalternateが存在すればそれを再利用し、割り当てを最小限に抑えます。</p><p><code>alternate</code>フィールドは実装の細部と見なすといいでしょう。ただし、コードベース内でよく登場しますので、ここで取り上げる価値のあるフィールドです。</p><p><em><strong>ホストコンポーネント（host component）</strong></em><br>
Reactアプリケーションのリーフノード。レンダリング環境に固有（例：ブラウザアプリでは、<code>div</code>、<code>span</code>など）。JSXでは、小文字のタグ名で示される。</p><p>概念上、fiberのoutputは、関数の戻り値です。</p><p>どのfiberも最終的にoutputを持ちますが、outputは<strong>ホストコンポーネント</strong>によってリーフノードでのみ生成されます。outputはその後、ツリーの上方へ移されるのです。</p><p>outputは、レンダリング環境へ変更をフラッシュできるようにするため、最終的にレンダラに渡されます。outputが生成・更新される方法を定義するのは、レンダラの役目となります。</p><p>差し当たっての説明は以上ですが、このドキュメントは完成には程遠い状態です。今後のセクションでは、更新のライフサイクル全体を通して使われるアルゴリズムについてお話ししたいと思います。取り上げる予定のテーマは以下のとおりです。</p>
