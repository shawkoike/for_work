<p><a href="http://chris.beams.io/posts/git-commit/" rel="nofollow" title="" class="ext-link">How to Write a Git Commit Message</a> （2014-08-31） by <a href="http://chris.beams.io/" rel="nofollow" title="" class="ext-link">Chris Beams</a></p><p><small>(訳注：2015/10/31、いただいた翻訳フィードバックを元に記事を修正いたしました。)</small><br>
<small>(訳注：2015/11/1、いただいた翻訳フィードバックを元に記事を再修正いたしました。)</small></p><p>
<style>#content .block-text blockquote p {font-size: 17px; font-weight: normal; line-height: 28px;}</style>
</p><p><img src="http://imgs.xkcd.com/comics/git_commit.png"><br>
<em>訳：　プロジェクトが長引くほど、私のGitのコミットメッセージは情報が薄くなっていく。</em></p><p><a href="#intro">イントロダクション</a> | <a href="#7rules">7つのルール</a> | <a href="#tips">ヒント</a></p><p>Gitのリボジトリのログをランダムに閲覧すると、ひどいコミットメッセージを目にすることがあります。例として、私が昔書いたSpringにコミットした<a href="https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams" rel="nofollow" title="" class="ext-link">これらのgem</a>を見てみましょう。</p><p><em>訳：<br>
e5f4b49 r814内で一旦削除したConfigurationPostProcessorTestsを再度追加。最近のビルドの失敗の原因だと分かったため、testCglibClassesAreLoadedJustInTimeForEnhancement()メソッドを@Ignore。ClassLoaderのハッキングがわずかなダウンストリームエフェクトの原因となり、関係のないテストを破壊。テストメソッドはそれでも使えるが、CGLIB が早まってclassloadをしないように手動で実行するべきで、自動ビルドの一部とし実行すべきではない。<br>
2db0f12　ビルド失敗原因の2つのissueを修正＋ClassMetadataReadingVisitorをrevision 794に変更＋ダウンストリームテストが失敗する理由を突き止めるまでConfigurationPostProcessorTestsを消去（関係なさそうなClassPathXmlApplicationContextTestsなど）<br>
147709f　package-info.javaファイルを変更<br>
22b25e0　 UtilとutableAnnotationUtilsクラスを存在するAsmUtilsと統合<br>
7f96f57　修正中<br>
</em></p><p>おえっ。これを、同じリボジトリから書いた<a href="https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb" rel="nofollow" title="" class="ext-link">より最近の</a>のコミットメッセージと比べてみましょう。</p><p><em>注釈：<br>
$ git log –oneline -5 –author pwebb –before “Sat Aug 30 2014″<br>
5ba3db6　 CompositePropertySourceTestsの不具合を修正<br>
84564a0　先に解析したロジックで@PropertySourceを再作業<br>
e142fd1　 ImportSelectorのメタデータのテストを追加<br>
887815f　 docbookの付属をアップデートしてepubを生成<br>
ac8326d　 mockitoの用法を修正<br>
</em></p><p>あなただったらどっちを読みたいですか？</p><p>前者は文章も長いし見た目も幅広くなっています。後者は簡潔で一貫性があります。前者はデフォルトで書かれたものです。後者は偶発的に書かれたものではありません。</p><p>前者のようなリポジトリのログを多く見かけますが、例外もあります。<a href="https://github.com/torvalds/linux/commits/master" rel="nofollow" title="" class="ext-link">Linux kernel</a>と<a href="https://github.com/git/git/commits/master" rel="nofollow" title="" class="ext-link">Gitそれ自体</a>がそのいい例です。<a href="https://github.com/spring-projects/spring-boot/commits/master" rel="nofollow" title="" class="ext-link">Spring Boot</a>など<a href="https://github.com/tpope/vim-pathogen/commits/master" rel="nofollow" title="" class="ext-link">Tim Pope</a>によって管理されているリポジトリを見てみてください。</p><p>これらのリポジトリの作成者は、上手に記述されたGitのコミットメッセージが変更<em>内容</em>を仲間の開発者に伝える一番良い方法だと知っています（もちろん将来、自分で見た時のためにも）。diffで何が変更されたかが分かりますが、なぜ変更されたのか正しく<em>理由</em>を教えてくれるのはコミットメッセージです。Peter Huttere氏は<a href="http://who-t.blogspot.co.at/2009/12/on-commit-messages.html" rel="nofollow" title="" class="ext-link">これをうまく説明しています</a>。</p><p>優れたGitのコミットメッセージを書くににはどうしたら良いか、まだ理解してないならば、今までに<code>git log</code>や関連ツールをあまり使ってこなかったということかもしれません。それは悪循環を引き起こします。コミット履歴は統制が取れておらず矛盾が生じているので、使ったり手入れをしたりする時間を費やさなくなります。そして、コミット履歴は使われなかったり手入れをされない状態だと、統制が取れず矛盾が生じたままです。</p><p>しかし、ログをしっかり手入れすれば、美しくて使い勝手の良いものとなります。そして、<code>git blame</code>、<code>revert</code>、<code>rebase</code>、<code>log</code>、<code>shortlog</code>や他のサブコマンドが活かせます。他の人が書いたコミットメッセージを見れば、プルリクエストが役に立つはずです。すると、突然自分でも書けるようになるはずです。数カ月、数年前になぜそのことが発生したのかを理解することが可能になるだけでなく、効果的にできるようになります。</p><p>プロジェクトの長期的な成功の鍵は（とりわけ）メンテナンス性にあります。そして、メンテナンス担当者にとってプロジェクトのログ以上に強力なツールはありません。時間をかけても使い方を学ぶ価値はあります。最初は大変かもしれませんが、すぐに慣れます。そしてそれが自信となり、プロジェクトにかかわる全ての生産性を高めるでしょう。</p><p>この投稿では、健全なコミット履歴を維持する最もベーシックなやり方をご紹介します。つまり、どうやってコミットメッセージを書くのか、ということです。コミットに関してはもう1つ、commit squashing という大事なものがありますが、今回は省略します。もしかしたら次回の投稿でご説明することになるかもしれませんが。</p><p>プログラミング言語の多くは、どうすれば自然なスタイルになるかということに関して、うまく確立されたルールがあります。例えば、ネーミングやフォーマットなどです。これらのルールにバリエーションがあるのは当然ですが、1つのルールのみを使って、そのやり方に従うほうが、それぞれの開発者が別々の方法を使ってカオスになるよりマシであると多くの開発者は賛同してくれるでしょう。</p><p>チームでコミットログに取り組む時も違いはありません。使えるリビジョン履歴をつくるには、チームは初めにコミットメッセージのルールを決めておくべきです。少なくも下記の3点に関しては合意を取っておきましょう。</p><p><strong>スタイル</strong>：マークアップ構文、空白、文法、大文字、句読点。これらのことに関して議論し、なんとなくで作業するのをやめ、可能な限り単純なスタイルにしましょう。これを実践すれば、一貫性のあるログになり、<em>ログを読むことが</em>習慣になってしまうくらい楽になるでしょう。</p><p><strong>内容：</strong>コミットメッセージの本文（もしあれば）が伝えたい情報はどんな内容ですか？ また、含まれて<em>いない</em>情報は何ですか？</p><p><strong>メタデータ：</strong>Issue Tracking IDやプルリクエストの番号などはどうやって参照しますか？</p><p>幸運にも、自然なGitのコミットメッセージを書くにはどうしたらいいのかという、確立されたルールが存在します。実際に、いくつかのルールはGitコマンドの機能に則って定められています。あなたが自分で再発明する必要はないのです。以下の<a href="http://chris.beams.io/posts/git-commit/#seven-rules" rel="nofollow" title="" class="ext-link">7つのルール</a>にただ従えばいいのです。そうすればプロと同じようにコミットできるようになります。</p><p>
</p>
<p><strong><em>訳注 : このルールは英語での書き方に準拠するものであり、日本語でコミットメッセージを書く場合は異なる場合があります。</em></strong></p><p>例を挙げてみます。</p><p><em>(訳：<br>
だいたい50字以内で変更を要約</em></p><p>必要であればより詳細な説明を書く。約72字以内で改行する。コンテキストによっては、初めの1文をコミットのタイトル、それ以下を本文とすることも。タイトルと本文の間は必ず1行空ける（本文を全く書かない場合を除く）。タイトルと本文を繋げて書くと、 <code>log</code> や <code>shortlog</code> 、<code>rebase</code> などのさまざまなツールが混乱するため。</p><p>このコミットが解決している問題を説明する。どのように、ではなく、なぜこの変更をしたのかに重きを置く（どのように変更したかはコードを見れば分かる）。この変更で生じる副作用や直感的には分からない他の結果は生じないか？何かあればここで説明する。</p><p>さらに文を追加する場合は、1行空ける。</p><p>Issue Tackerを使用する場合は、以下のようにリファレンスをつけておく。</p><p>Resolves: #123<br>
See also: #456, #789<br>
</p><p>以下は<code>git commit</code>の<a href="https://www.kernel.org/pub/software/scm/git/docs/git-commit.html#_discussion" rel="nofollow" title="" class="ext-link">manpage</a>からの引用です。</p><p>しかし、コミットは必ずしもタイトルと本文が必要ではありません。特に変更がとてもシンプルで、それ以上の説明が必要ない場合などは、1文のみで問題ない場合もしばしばあります。例えば以下のような形です。</p><p><em>(訳：ユーザガイドの序文で誤字を修正)</em></p><p>これ以上のことは言う必要はありません。もし、これを読んだ人が、誤字とは何だったのか知りたければ、<code>git show</code>や<code>git diff</code>や<code>git log -p</code>を使うなどして変更そのものを確認すればいいだけのことです。</p><p>コマンドラインでこのように何かをコミットするなら、<code>-m</code>スイッチから<code>git commit</code>を使ったほうが簡単です。</p><p><em>注釈：　$ git commit -m “ユーザガイドの序文で誤字を修正”</em></p><p>しかし、コミットが説明や内容を必要としていれば、本文を書いたほうがいいでしょう。以下が例です。</p><p><em>注釈：<br>
マスタコントロールプログラムを消去</em></p><p>MCPは悪役で、世界征服を企んでいることが分かった。<br>
このコミットは、トロンのディスクをMCPに投げて（これで、姿を消せます）、ディスクをチェスゲームに戻す。</p><p>この場合は、<code>-m</code>スイッチでコミットするのは難しいです。適切なエディタが必要です。コマンドラインでGitを使うのにエディタをまだ設定してなければ、<a href="http://git-scm.com/book/ch7-1.html#Basic-Client-Configuration" rel="nofollow" title="" class="ext-link">Pro Gitの項目</a>を読んでください。</p><p>どんな場合もタイトルと本文を分けることは、ログを閲覧する際に効果的です。ここにログエントリの全文があります。</p><p><em>注釈：<br>
マスタコントロールプログラムを消去</em></p><p>MCPは悪で、世界征服を企んでいることが分かった。<br>
このコミットは、トロンのディスクをMCPに投げて（これで、姿を消せます）、ディスクをチェスゲームに戻す。<br>
</p><p>ここで、タイトルだけを表示する<code>git log –oneline</code>を使用すると、</p><p><em>注釈：<br>
42e769 マスタコントロールプログラムを消去<br>
</em></p><p>となります。もしくは、ユーザごとにコミットをグループ分けする<code>git shortlog</code>を使うと、上記と同様にタイトルだけが簡潔に表示されます。</p><p><em>注釈：<br>
Kevin Flynn (1):<br>
      マスタコントロールプログラムを消去</em></p><p>Alan Bradley (1):<br>
      セキュリティプログラム “Tron”の導入</p><p>Ed Dillinger (3):<br>
      チェスプログラムを”MCP”にリネーム<br>
      チェスプログラムの変更<br>
      チェスプログラムのアップグレード</p><p>Walter Gibbs (1):<br>
     チェスプログラムのプロトタイプの導入<br>
</p><p>Gitでは、他にもタイトルと本文を区別する箇所が多くありますが、タイトルと本文の間に空行が無ければ機能しません。</p><p>50字というのは絶対的な制限ではなく、要約する際の単なるルールです。タイトルをこの長さに維持することで読みやすさが保証される上に、何が起きているかを最も簡潔に説明するにはどうしたらいいか、記述者が考えるように促すことになります。</p><p>GitHubのユーザインターフェースはこうしたルールを完全に認識しています。50字の制限を超えてしまった場合、次のような警告が表示されます。</p><p><img src="http://i.imgur.com/zyBU2l6.png" alt="gh1"><br>
<em>注釈：<br>
プロのヒント：良いコミットの要約は、50字かそれ以内です。追加情報は説明欄に記述してください。<br>
</em></p><p>そしてタイトルが69字を超えると、省略記号を付けて切り捨てられます。</p><p><img src="http://i.imgur.com/27n9O8y.png" alt="gh2"></p><p>というわけですので、50字を目標としますが、上限値は69字です。</p><p>これは言葉通りの単純なことです。タイトルは全て大文字で書き始めます。</p><p>例えば、</p><p>ではなく、</p><p>と記述します。</p><p>タイトルにピリオドを付ける必要はありません。また、タイトルを<a href="http://chris.beams.io/posts/git-commit/#limit-50" rel="nofollow" title="" class="ext-link">50字かそれ以下</a>にしようと思ったら、スペースは貴重です。</p><p>例えば、</p><p>ではなく、</p><p>と記述します。</p><p><em>命令法</em>とは要するに”命令や指示をするような話し言葉または書き言葉”を意味します。いくつか例を挙げてみましょう。</p><p>今皆さんが読んでいる7つのルールはそれぞれ、命令法で書かれています（”Wrap the body at 72 characters（本文を72字以内におさめよ）”など）。</p><p>命令法は少し乱暴な言い方に聞こえるかもしれません。ですから私たちは普段あまり使いませんね。しかし、Gitコミットのタイトルにはまさにこれがうってつけなのです。<strong>あなたがコミットを作成する際に、Gitそれ自体が命令法で記述されている</strong>というのが理由の1つです。</p><p>例えば、<code>git merge</code>読み込みの際に作成される初期メッセージは以下のようになります。</p><p><em>注釈：ブランチ”myfeature”をマージせよ</em></p><p>そして、<code>git revert</code>を使う際には以下のようになります。</p><p><em>注釈：<br>
” Add the thing with the stuff “をrevertせよ</em></p><p>このrevertのコミットはcc87791524aedd593cff5a74532befe7ab69ce9dである。<br>
</p><p>または、GitHubのプルリクエストの”Merge”ボタンをクリックする時は以下のようになります。</p><p><em>注釈：<br>
ユーザ／ブランチからの#123プルリクエストをマージせよ<br>
</em></p><p>ですので、命令法でコミットメッセージを記述する時には、Gitそれ自体がビルトインしているルールに従っていることになるのです。例えば、<br>
<font color="green"></font></p><p></p><p>このような書き方は、最初は少しぎこちなく感じるかもしれません。私たちは、事実を伝える際に使う<em>直接法</em>で話すことに慣れています。そのため、以下のような文章のコミットメッセージをよく見かけるということになってしまうのです。<br>
<font color="red"></font></p><p></p><p>さらにコミットメッセージは、内容の説明として以下のように記述されることもあります。<br>
<font color="red"></font></p><p></p><p>混乱を避けるために、いつでも正しく記述できるようなシンプルなルールを紹介します。</p><p>適切に記述されたGitコミットのタイトルは常に、以下の文章を完成させるようなものになるべきです。</p><p>例を挙げます。</p><p>命令法以外の記述方法で書いた場合は、文章が正しく機能しないことに注意してください。</p><p><em>覚えておいていただきたいのですが、命令法を使うのは、タイトルに対してだけです。本文を記述する際にはこの制限に縛られることはありません。</em></p><p>Gitでは文字は自動的に切り詰められません。コミットメッセージの本文を記述する際には、右の余白と文字数制限に気を付けて手作業で行う必要があります。</p><p>推奨する文字数は72字です。Gitにはテキストをインデントするために余白がたくさんありますが、全て含めて80字以内におさめます。</p><p>優れたテキストエディタはこの作業を補助してくれます。例えば、Gitコミットを記述する際に、テキストを72字で制限するようにVimをコンフィギュレーションするのは簡単です。しかしこれまで、IDEでコミットメッセージのテキストを制限字数内におさめる際にスマートなサーポートを期待しても、提供されている方法はお粗末なものでした（この点に関しては、最近のバージョンであるintelliJ IDEAが、<a href="http://youtrack.jetbrains.com/issue/IDEA-53615" rel="nofollow" title="" class="ext-link">ついに</a><a href="http://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-446912" rel="nofollow" title="" class="ext-link">改善</a><a href="http://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-448299" rel="nofollow" title="" class="ext-link">しました</a>が）。</p><p>この<a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6" rel="nofollow" title="" class="ext-link">Bitcoin Coreのコミット</a>は、「何」と「なぜ」を説明している大変良い例です。</p><p><em>注釈：<br>
serialize.hの例外処理を簡素化する</em></p><p>関連メソッドのように、”state”と” exceptmask “をserialize.hの streamインプリメンテーションから削除する。</p><p>exceptmaskは常に”failbit “を含み、setstateは常にbits = failbitで呼び出されるので、実行するとただちに例外処理となる。これらの変数を取り除き、setstateをダイレクトな例外スローに置き換える（これによりデッドコードも取り除かれる）。</p><p>結果として、エラー後にgood()は実行されず（callは2つだけで、1つはテスト内にある）、単にby !eof()によって置き換えることができる。</p><p>fail()、 clear(n)、exceptions()は呼び出されない。それらを削除する。<br>
</p><p><a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6" rel="nofollow" title="" class="ext-link">全てのdiff</a>を見てみましょう。そして、コメントの記述者が変更時に時間をかけて内容を提供してくれたことで、同僚や将来このコードを手掛ける人が、どんなに時間を節約できるか考えてみてください。もし彼が手間をかけてくれなければ、変更内容は永遠に分からなくなっていたことでしょう。</p><p>大抵の場合、どのように変更が行われたかという詳細が書き残されます。この点についてですが、コードとは通常それ自体がコードの説明となっています（もしコードが非常に複雑で説明文が必要な場合には、ソースコメントという手があります）。まずは、変更した理由を明らかにすることに焦点を絞りましょう。変更前にはどのように機能していたのか（そして何が問題だったのか）、今はどのように機能しているのか、そしてなぜその方法で解決することに決めたのか、ということです。</p><p>あなたに感謝する将来のメンテナンス担当者は、あなた自身かもしれませんよ。</p><p>Gitのサブコマンドがあるのと同じくらい多くの理由から、コマンドラインを採用することは賢明なことです。Gitは非常に強力です。IDEも強力ですが、どのように強力であるかは異なります。私は毎日IDEを使用しており（IntelliJ IDEA）、他のものも幅広く使ってきました（Eclipse）。しかし（一度知ってしまうと）、コマンドラインの簡便さと強力さに匹敵するようなGit用のIDEインテグレーションは無いことが分かります。</p><p>Git関連のIDEの関数の中には大変役に立つものもあります。例えばファイルを削除する際の<code>git rm</code>の呼び出しなどです。また、リネームする際に<code>git</code>で正しく処理できます。ただ、コミット、マージ、リベース、精密な履歴の分析などをしようと思った時に、IDEでは全てがバラバラになってしまいます。</p><p>Gitのパワーをフル活用するならば、最適といえるのがコマンドラインなのです。</p><p>使っているのがBashであれZ shellであれ、サブコマンドやスイッチを覚えておく労力を軽減してくれる<a href="http://git-scm.com/book/ja/v2/Git-%E3%81%AE%E5%9F%BA%E6%9C%AC-Git-%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9" rel="nofollow" title="" class="ext-link">タブ補完スクリプト</a>があることを覚えておいてください。</p><p><a href="http://git-scm.com/book/ja/v2" rel="nofollow" title="" class="ext-link">Pro Git</a>の本はオンライン上で無料で入手できる素晴らしい本です。ぜひ利用してください。</p>
