Getting Started with TDD in React （2016-05-25） by Dave Ceddia最小限の設定のTDD手法を使い、「何をテストすべきか？」から、よくある落とし穴の避け方まで、Reactコンポーネントをテストする方法を学びましょう。まず、Reactを触ったことがあり、更にはいくつかのテストも書いた経験があるとしましょう。それでも、コンポーネントをどうテストするのが最善なのか、よく分からないかもしれません。どこから始めるのでしょう。具体的には何をテストすればよいのでしょうか。いくつかのReactコンポーネントは簡潔過ぎて、そもそもテストが必要なのかすらはっきりしません。AngularからReactに乗り換えた人なら、テストには愛憎のような思いがあるかもしれません。確かにAngularにはテストを支援するツールがたくさんありますが、同時にテストを書くのが難しくなる可能性があります。冗長ながら省略できない定型コードが多々ある上、$digestの呼び出しを忘れるとテストが当然パスすべきところで失敗する原因になるので、デバッグの時間がおびただしく増えてしまいます。Reactのテストはそれよりも理解しやすく、Reactで行うTDDは、俊敏で高速な反復をキャプチャし、テストを楽しくします。このチュートリアルではReactのみを中心に見ていきます。Reduxについては述べません。エコシステムというのは始めは押しつぶされそうになるほど巨大なトピックなので、まずは小さく始めましょう。何よりもまず、テスト環境が必要です。Testing React Components with Enzyme and Mocha（EnzymeとMochaでReactコンポーネントをテストする）は、スタート地点として最適であり、プロセスを丁寧に説明してくれます。この記事を読んだなら、あるいは今読む時間があるなら、そこから始めましょう。あるいは、とりあえず近道をとりたい場合は、次のステップを踏んでください。Quikをインストールします。このパッケージがあれば、手動でビルドを設定することなく、即座に実行できます。ここではグローバルにインストールするため-gを使い、新規のquikコマンドがインストールされるようにします。テストに、アサーションを作るためのライブラリが必要です。Chaiがよく知られています。さらに、スパイを設定するライブラリ、Sinonもインストールしましょう。また、Airbnbが作った、Reactコンポーネントテストのためのライブラリ、Enzyme、それからJavaScriptでブラウザDOMをシミュレートするライブラリ、jsdomもインストールします。Enzymeは同位の依存パッケージとしてReactを必要とします。またreact-domとreact-addon-test-utilsも使いますので、インストールしましょう。テストランナーも要ります。これには、Mocha、Tape、Jasmineなどいくつか選択肢があります。ReactコミュニティではMochaが人気を集めているので、それを使います。mochaコマンドを使用できるよう、グローバルにインストールしましょう。テストファイルではES6とJSXを使いますので、Mochaが実行できるよう、テストをBabelで変換しなければなりません。そのために、Babelとプリセットをいくつか（ES2015、ES6用のes2015と、JSX用のreact）インストールします。最後に、Babelにこれら2つのプリセットを使うよう指示する必要があります。これは.babelrcという名前のファイルに設定します。.babelrcファイルを作成し、次のコードをペーストしてください。波括弧を忘れずに。もう1つ、フェイクのDOMを初期化するsetup.jsファイルも必要です。setup.jsファイルを作成し、次のコードをペーストしましょう。次に進む前に、環境の設定と機能をチェックするとよいでしょう。Mochaの動作のテストcomponents.spec.jsという名前のファイルを作成し、次のコードをペーストします。そして、以下のとおりMochaを実行します。これでテストにパスするはずです。エラーが出た場合は、上のステップに戻り、漏れがないか確認してください。Quikの機能のテストQuikが正しく動くかどうかもテストしましょう。ファイルindex.jsを作成し、次のコードをペーストします。それから、次のようにQuikを実行します。ブラウザウィンドウに「Hi」というテキストが表示されるはずです。表示されない場合は、ブラウザを再度読み込むか、quikを再起動してください。興味がある人のために、Quikが動く過程を述べます。Quikをインストールすると、独自のホットリロードWebpackビルドがバンドルされています。Quikは、呼び出された全てのプロジェクトにおいてこれを適用します。quikコマンドを実行すると、index.jsファイルを探し、それをアプリケーションのルートとして扱います。index.jsファイルは最低でもReactDOM.render()を呼び出します。このファイル内に少しでも多くでも好きなだけ置いて、他のファイルを必要なだけimportしましょう。それでは私たちの”商売道具”、Reactのコードをテストする時に使うライブラリとアプリケーションを見直してみましょう。Mochaはテストランナー、またはテストの”フレームワーク”です。ここに挙げるツールの中では、階層の最上位に位置します。Mochaには、テストファイルを探して読み込み、それを変換し、テストを構成するdescribeブロックやitブロックなどのテストコードそのものを実行するという役割があります。Chaiはアサーションライブラリです。全てが正しく動作しているかを確認するためのテストで使うexpectコールやassertコールなどを提供します。Sinonはスパイを作り出して検査するためのライブラリです。テスト中のコンポーネントだけにテストを集中させるために、スパイによって部分的な機能のモックやスタブを使うことが可能になります。EnzymeはReactコンポーネント上でレンダリングをしたり、アサーションを作ったりするためのライブラリです。ここに挙げたツールの中で、Reactに特化したツールはこれだけです。これらのツールがどのように連携して機能するかを以下に示します。これらのツールの役割は、テストを書き始めると、より明確になっていきます。この記事の冒頭で、いくつかの動機づけについて述べました。なぜReactコンポーネントをテストし、更に重要な問題として、これらの一体何についてテストをする必要があるのでしょうか？Reactコンポーネントはとてもシンプルな場合があります。そんなに単純ならテストなど必要ないのではないでしょうか。それぞれのコンポーネントには、簡単なテストだとしても、テストをする価値が多かれ少なかれあります。一目で明らかかもしれませんが、それでも期待通りにコンポーネントが動いているという確信が得られますし、後で自信を持ってリファクタリングを行えます。リファクタリングを行えるということは大切です。ユーザ名とメールアドレスをレンダリングするシンプルなコンポーネントのテストを行えば（一例として）、将来的に、コンポーネントをバラバラにしても、それぞれが正しく機能するという確信を持ってリファクタリングを行えます。私たちが多用するテクニックは、シャローレンダリングです。これは、コンポーネントをレンダリングする時に、第一階層の深さのコンポーネントだけをレンダリングする方法のことです。つまり、あるコンポーネントのみを”実行”し、その子は一つも”実行”しないということです。例を挙げてみましょう。nameとageを保持するpersonというオブジェクトがあるとします。こちらがpersonを表示するためのコンポーネントです。シャローレンダリングを用いて実行すると、最終的に以下の要素が表示されます。NameとAgeが全く変わっていない点に着目してください。これらの内部は評価されていません。これに対し、フル（ディープ）レンダリングを実行すれば、ReactはNameとAgeを評価し、以下のような要素が表示されるはずです。シャローレンダリングを使うと、どのように子コンポーネントが実装されているかを気にする必要がなくなるため、シャローレンダリングはとても有効な方法です。”モック”に少し似ていますが、モックとは異なりシャローレンダリングはコストをかけず利用できます。また、DOMも不要となります。この例では、どのようにPersonが動作するか、ということにテストを集中させることができます。Personの実装をNameやAgeの動作と密接に結合させる必要はありません。ディープレンダリングしたコンポーネントでテストを行い、ファーストネームだけだったNameの実装を”ラストネーム、ファーストネーム”に変えていたら、どうなっていたでしょうか。Personの実装が何も変わっていないにも関わらず、Personのテストはアップデートが必要となったでしょう。これが、コンポーネントのテストにシャローレンダリングばかりを使う理由です。最近行った入力処理を扱うテストの中で、コンポーネント全体のレンダリングが必要となる場合がいくつかありました。jsdomのインストールや、setup.jsファイルが必要なのはそのためです。必ずレンダリングされること最低限、コンポーネントがエラーを出さずに、確実にレンダリングされるようにします。JSXの構文エラーがなく、全ての変数が定義されていることなどを確認します。レンダリングされたアウトプットがnullではないことを確認する程度の簡単なことでしょう。アウトプットをテストする：上記の”レンダリングする”というステップは、”正しいものをレンダリングする”ということです。任意のプロパティのセットにおいて、どんなアウトプットが予想されるでしょうか。Personはnameとageをレンダリングするでしょうか。または、nameと”TODO: age coming in v2.1″をレンダリングするのでしょうか。状態をテストする：全ての条件に対応できなければいけません。もしclassNamesが条件付きなら（例えば、enabled/disabled、success/warning/errorなど）、classNamesを決定するロジックがうまく働いているかを確認するテストが必要です。条件付きでレンダリングされた子にも同じことが言えます。例えば、ユーザがログインした時にだけLogoutボタンが現れるなら、必ずそれをテストしなければいけません。イベントをテストする：コンポーネントが相互作用するなら（例えばinputまたはbuttonとonClick、onChange、onAnythingなど）、そのイベントが期待通りに働き、thisをバインディングすることも含めて、正しい引数と共に一意の関数を呼び出すかということを、重要なものに関してテストします。エッジケースをテストする：配列上で行う操作には、どんなものでも境界線上のケースが存在します。空の配列、1つの要素を持つ配列、25項目で切り捨てなければならないページ付けされたリストなどです。考えられる全てのエッジケースを試し、全てが正しく動作することを確認します。私たちは、とてもシンプルな”リスト”のアプリケーションを構築しようとしています。項目を追加したり、項目のリストを閲覧したりできるアプリケーションです。こういった単純な機能の集まりであっても、実装にはいくつかの方法があります。ボトムアップ方式かトップダウン方式です。また、自分のアプリケーションを構築する際には、「UI優先」にするのか「データ優先」にするのか決めようと思うでしょう。つまり、最初は仮のデータを使って、見たいと思うUIを作るのか、それともデータ構造から着手して、データに合わせてUIを構築するのかということです。ここではUI優先の手法を採用します。ここにUIのモックアップがあります。コンポーネントに名前をつけてから、テストを始めましょう。始める前に、Githubから完成リポジトリをクローンしておくと、上手くいかない時に作業をチェックすることができます。ほとんど空のコンテナをレンダリングする、基本的なコードから始めましょう。index.jsファイルを開いて、ファイル全体を以下の内容に置き換えます。このindex.jsファイルは、ルートコンポーネントをレンダリングする役割を担います。コンポーネント自体は、components.jsに記述します。ファイルを作成し、次のように入力します。簡単にするために、この例題では、あらゆるものを1つのファイルに保存しておくことにします。皆さんが自分のコードを書く場合には、こうしたコンポーネントを別々のファイルに分けるでしょう。なぜファイルを分けるのか疑問に思うかもしれません。どうしてindex.jsに全部まとめておかないのかと思うでしょう。その理由は、テストにコンポーネントをimportする必要があるからです。もしindex.jsファイルからインポートすることになれば、ReactDOM.render()が実行されます。そうすると（シャローレンダリングを使うので）テストではほとんどDOMが不要であるにもかかわらず、DOMの有無に作業が左右されてしまいます。始める前に、quikとmochaを起動しましょう。そうすれば、テストのフィードバックが即座に得られ、それと同時にUIの挙動が分かります。プロジェクトディレクトリに戻って、Quikを起動します。次に別のターミナルウィンドウを開いて、Mochaを起動します。ブラウザが開いて、「Beer！」と表示されるはずです。それでは、最初のテストを記述しましょう。先ほど作成したcomponents.spec.jsファイルを開きます。次のコードで内容を置き換えます。InputAreaもBeerListも未定義なので、このテストはすぐにエラーとなります。修正を行う前に、このテストの処理の様子を見てみましょう。最初に、必要な部品を全てインポートします。JSX（React.createElementの呼び出しのためにコンパイルされます）を使っているので、Reactは必要です。また、コンポーネントと同様に、expectとshallowもインポートします。次にmountをインポートしていますが、これを使うのはもっと後になってからです。JSXの表現である&lt;BeerListContainer/&gt;に渡してshallowを呼び出します。BeerListContainerにInputAreaとBeerListを含めたいので、これらの子コンポーネントをwrapper.containsAllMatchingElementsでチェックします。ここで気を付けてほしいのですが、コンテナをシャローレンダリングする場合でも、子コンポーネントの存在がチェックできるように、名前を定義しておく必要があります。今回は名前がまだ定義されていないために、テストはエラーになってしまいました。それでは修正しましょう。components.jsに戻って、次の2つのコンポーネントを最後に追加します。最低限の内容だけを追加して、後で修正することにします。しかし、今度は子コンポーネントが存在するので、components.spec.jsに戻って次の行を先頭のインポートの部分に追加します。ところが、テストはまだ通りません。エラーにはならないので前進したと言えますが、BeerListContainerを修正する必要があります。components.jsに戻り、読み込むBeerListContainerコンポーネントを次のように変更します。これでテストは通ります。シャローレンダリングの深さは1階層だけではないことに注意してください。実際には、全てのビルトインコンポーネント（divやspanなど）をレンダリングするものの、カスタムコンポーネントをレンダリングするには至りません。確かめる場合には、divを他のdivでラップしても、テストに通るか試してみてください。コードの構築の見地からすると、コンテナがリストの管理、つまり状態の管理やリストへの項目追加といった役割を担うのが望ましいと言えます。子コンポーネントへ作業を進める前に、そうした機能性について確認しましょう。最初、リストには、項目を持たない空の配列が格納されています。components.spec.jsに、次のようにテストを記述します。これはエラーになります。初期化していないため、コンポーネントのstateはnullです。BeerListContainerにコンストラクタを追加して、状態を初期化する必要があります。components.jsに戻りましょう。与えられたプロパティを用いてsuperを呼び出すのはいい考えなので、そのようにします。これを保存してからテストを実行すれば、今度は通るはずです。ところが、今度は別のエラーになってしまいました。これは、===演算子を使ってオブジェクトの等価性をテストする.equalを使ったためです。2つの空の配列は同じオブジェクトではないので、完全に等しいとは言えなかったのです。その代わりにeqlを使えば、テストは通ります。components.spec.js内のエクスペクテーションを以下のように変更します。これでテストは通りました。これで、コンテナに空のリストができたので、そのリストにアイテムを足すための道筋を作りましょう。コンテナはリストの状態の保持を担うことを覚えておいてください。ここに、後でInputAreaに渡すことになるaddItem関数を持たせます。components.spec.js内に、存在しないaddItem関数のテストを追加してください。addItemは存在しないので失敗し、次のメッセージが表示されます。そこで、その関数を、components.jsに追加します。まだテストにパスしません。同じエラーが表示されました。shallow(&lt;BeerListContainer/&gt;)から返されたオブジェクトが、実際はBeerListContainerのインスタンスになっていない、と言っているわけです。しかし、wrapper.instance()で、クラスインスタンスには接続できます。その行、つまり以下のような行を以下のように変更します。次は別のエラーが出ました。そこで、stateを内部のaddItemから更新することにします。addItemを次のように変えましょう。テストに通りました。以上のような配列の更新方法は見慣れないかもしれません。こうすることで、既存の状態を誤って変化させたりせずに済むのです。stateの変化を避けるのを習慣にしたいものです。Reduxを使っている、使う予定がある際はなおさらそれが重要でしょう。常に確実にレンダリングビューを現在の状態と同期させることができるからです。Immutable.jsのようなライブラリを使用すると、上述のような不変のコードの記述が容易です。このチュートリアルでは、なるべく複雑にしないためImmutable.jsを使いませんが、基礎を押さえた後に試してみる価値はあります。コンテナの内部が全て正常に動作するようになったところで、addItem関数をプロパティとして、後にaddItemの呼び出しを担うInputAreaに渡しましょう。新規プロパティをコンポーネントに追加する際にはいつも、そのためのPropTypesの定義を作るようにするのは非常に良いアイデアです。PropTypesが重要な理由についてはこの記事に詳しいですが、要は、PropTypes で期待するプロパティと型を定義すると、必要なプロパティを渡し忘れたり、誤った型を渡したりした場合に、Reactが警告を出してくれるということです。PropTypesでデバッグがとても簡単になります。最初にコンポーネントを書く時だけでなく、将来それを再利用する時も同様です。ですから、テストを書く前にcomponents.js内にPropTypesを追加します。そして、テストをcomponents.spec.jsに追加してください。InputAreaへの参照を取得し、そのonSubmitプロパティにaddItem関数が渡されることを確認します。これは失敗し、次のエラーが表示されるはずです。テストにパスさせるには、BeerListContainerのrenderメソッドを修正し、onSubmitプロパティをInputAreaに渡すようにします。この時点までで、4つのテストに通りました。InputAreaに渡された関数がまだ機能し続けていることを確認しましょう。少々冗長かもしれませんが、このテストを追加してください。すると失敗し、次のエラーが表示されます。ES6のクラスをReactでそのまま使うのは、難しい場合があります。つまり、ここの場合のaddItemのようなインスタンスメソッドは、自動的にインスタンスにバインドされるわけではないのです。ちなみに、ドットで関数を呼び出すのは、直接呼び出すことと同じではありません。Reactでこの問題を解決するには、2つの一般的な方法があります。1の方法のほうが良いので、ここでは1を使います。BeerListComponent（components.js内）のコンストラクタを次のように修正します。末尾の新しい行がaddItemを一度で全てをバインドするので、これでテストに通ります。BeerListContainerの処理が完了したので、InputAreaの階層に移ります。既にコンポーネントは存在していますが、動作するものはほとんどありません。InputAreaがinputとbuttonを含めるようテストを書きましょう。components.spec.jsの中に、新規で最上階層のdescribeブロックを作ります。このテストはボタンのテキストも確認しますが、下記のように失敗します。そこで、components.jsに戻って、InputAreaが正しくレンダリングされるよう修正しましょう。こうして再び、全てのテストに通るようになりました。次に、inputボックスが変更を受け取るよう、連携させていきましょう。次のテストを書きます。ここではinput.simulateを使い、引数として指定されたオブジェクトでonChangeイベントを発火します。この動作により、内部状態の一部が入力のvalueプロパティにフィードバックされます。まずは失敗し、次のエラーが表示されるはずです。見覚えがあるでしょうか。stateが初期化されていない時に、テスト 2で出たエラーと同じです。状態を初期化し、setTextメソッドも追加して、直後に必要になるバインディングで完成です。このようなコンストラクタを前に見てきました。setTextメソッドは、通常のパターンを使用し、入力された新規の値で状態を更新します。テストは再び失敗しますが、今回は別のエラーが出ます。これは、inputがつながっていないためです。setTextメソッドをonChangeプロパティとして渡し、stateにあるテキストをvalueプロパティとして渡す必要があります。しかしこの変更の後も、まだ動きません。同じエラーが表示されます。ただし、実行に失敗する場所は以前とは違います。状態をチェックする最初のexpectは問題なく実行できています。ところが次の行のexpectは実行に失敗しています。入力のvalueプロパティが更新されていないからです。随分話を戻しますが、入力のハンドリングには（シャローではなく）フルレンダリングが必要だと、本稿の冒頭で触れたことを思い出してください。いよいよそれを実行する時が来ました。テストを更新して、shallowではなくmountを呼び出すようにします。これでまた、テストは全部正常に完了するはずです。この時点ではまだ「Add」（追加）ボタンは何も実行しません。これの修正に取り掛かりましょう。ボタンがクリックされたら、InputAreaへ渡されるonSubmit プロパティを呼び出す操作を実装したいのです。addItem関数が正常に動作することを検証するテストは既に書いたので、これは、アイテムをリストに追加する前に実装する機能の、最後のピースと言えます。テストを書く前に、components.spec.jsの冒頭に新しいインポートを追加しなければなりません。そこで今度は、テスト内で次の通りspy()関数を使います。spyを作成して、onSubmit プロパティの呼び出しを追跡します。次はユーザーが値を入力する場面なので、状態を表すtextを設定し、ボタンをクリックします。最後に、spyが呼び出されること、しかも正しい値を使って呼び出されることを検証します。当然ながら、テストは次のメッセージを表示して終了します。ここで中間ハンドラ関数handleClickが必要になります。この関数はクリックに反応し、現在入力されているテキストでonSubmitを呼び出します。これはコンストラクタとバインドする必要があります。その後、ボタン上のonClick プロパティに渡されます。今度は、このテストもパスします。そろそろ終わりも見えてきましたが、まだリストのレンダリングが残っています。これの修正に取り掛かりましょう。まずは、リストが「空」のケースを扱う場合をテストしましょう。これはBeerListに対して実行する最初のテストなので、まず最上位階層の記述ブロックを新規作成し、テストを追加します。空のリストを使ったテストはパスしましたが、驚くほどのことではありません。BeerList コンポーネントは今のところ骨組みだけで、空の“`“`タグが1個入っているだけだからです。3番目のテスト、アイテムをレンダリングするところで、予測通りテストは失敗します。BeerListを更新し、items プロパティを通じて受け取った配列をレンダリングするようにします。現時点で「未定義のアイテム」テストは失敗していますが、それ以外の2つのテストはパスしています。この状況は当然です。なぜならthis.props.itemsは未定義だからです。ここでは、以下の2つの問題があります。これらの問題を解決するには、BeerListレンダリング関数を修正し、itemsの値がtrueであることをチェックしてからレンダリングするようにします。また、末尾にpropTypesも追加します。これで再び、全てのテストにパスするようになります。コードは今度こそ正常に動作するでしょう。このテストをまだ開発環境サーバのQuik上で実行していた場合は、実環境のブラウザに切り替えます。その際、タブをリフレッシュして、リストにアイテムを幾つか追加する操作を試みなければならない場合があります。「Add」をクリックしたのにアイテムが表示されない場合は、まずコンソールをチェックしてください。ただし次のような警告が表示されます。ここで itemsを渡すのを忘れているからです。これで、私たちが注目するべき場所が特定できました。問題を解決する前に、失敗することが分かっているテストをあえて書いてみましょう。ここはcomponents.spec.jsで、アイテムを幾つか指定してBeerListContainer のディープレンダリングを実行すれば、アイテムが表示されることを確認したいところです。しかしテストは予測通り、次のメッセージを表示してエラーで終了します。この場合は、BeerListContainerを更新してビールを渡します。この最終テストにパスしたことで、アプリケーションの全機能が正常に実装されていることが証明されたはずです。Quikの自動更新のトリガーが作動しなかった場合はブラウザの表示を更新して、以上のコードが動作することを確認してください。ここまでやって、ようやく非常にシンプルな、しかし機能的なリストが完成しました。この方式の開発をさらに続ける際には、次に示す改善のアイデアが参考になるでしょう。いざ実行すると恐らく、本稿で触れていない事態に直面することでしょう。その場合、いつも頼りになるGoogle以外にも、公式ドキュメントが役立つことがあります。参考文献のリンクを以下に示します。ここまでやれば、ReactでのTDDはどう進めればいいか、感覚がだいぶつかめたと思います。次にやるべきこととしては、各自の実際の環境で試す以外にありません。「習うより慣れよ」とよく言いますが、TDDも例外ではないのです。ここで説明した手法を使い、このようにシンプルなリストコンポーネントになるように改善し、TDDで、さらに野心的なコンポーネントをビルドすることにも挑戦してください。TDDを日常の作業ルーチンに組み込めば、慣れるにつれて実行の効率も上がるでしょう。そうすればコードの質も向上します。TDDを導入したReactの世界へ皆さんがスムーズに移行するために、本稿がいくらかでも皆さんのお役に立つことを願っています。本稿に対する感想や質問があれば、どうぞ下記のコメント欄に書き込んでください。
