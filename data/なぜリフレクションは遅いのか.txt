<p><a href="http://mattwarren.org/2016/12/14/Why-is-Reflection-slow/" rel="nofollow" title="" class="ext-link">Why is reflection slow?</a> (2016-12-14) by <a href="https://twitter.com/matthewwarren" rel="nofollow" title="" class="ext-link">Matt Warren</a></p><p><a href="http://stackoverflow.com/search?q=reflection+slow" rel="nofollow" title="" class="ext-link">.NETのリフレクションが遅い</a>のは周知の事実ですが、なぜなのでしょうか。この投稿では、リフレクションの<em>実装</em>を見ながらなぜ遅いのかを解明します。</p><p>リフレクションが速くない理由の1つとして、そもそも<em>高いパフォーマンス</em>が設計上の目標にされてはいないことを挙げることができます。<a href="https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/Documentation/botr/type-system.md#design-goals-and-non-goals" rel="nofollow" title="" class="ext-link">型システム概要 – 設計の目標および非目標</a>では次のように記載されています。</p><p>また、<a href="https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/Documentation/botr/type-loader.md#key-data-structures" rel="nofollow" title="" class="ext-link">型ローダ設計-主なデータ構造</a>では次のように記載されています。</p><p><strong>リフレクションの高速処理を実現することが設計目標ではないことは分かりましたが、では、何に時間がかかっているのでしょうか。</strong></p><p>実は複数のことが実行されているのですが、理解しやすいようにリフレクションの呼び出しで実行されるマネージドコードとアンマネージドコードのコールスタックを見てみましょう。</p><p>上記のリンクにアクセスして個別のC#/cppメソッドを確認しなくても、<em>多く</em>のコードが実行されていることは想像がつくと思います。例えば、最終メソッドであり、処理の大部分が実行される <a href="https://github.com/dotnet/coreclr/blob/e67851210d1c03d730a3bc97a87e8a6713bbf772/src/vm/reflectioninvocation.cpp#L1322-L1732" rel="nofollow" title="" class="ext-link"><code>System.RuntimeMethodHandle.InvokeMethod</code>の行数は400以上</a>にも及びます。</p><p><strong>概要は分かったと思いますが、では<em>具体的に</em>何をしているのでしょうか。</strong></p><p>リフレクションを介してフィールドやプロパティ、メソッドを呼び出す前に専用の<code>FieldInfo/PropertyInfo/MethodInfo</code>ハンドルを取得する必要があります。下記のコードを使用します。</p><p>前セクションで記載したように、関連するメタデータを取得したり、パースしたりなどしなければならないため、これにはコストがかかります。興味深いことに、ランタイムは、全てのフィールドやプロパティ、メソッドの内部キャッシュを保持することで助けてくれます。このキャッシュは<a href="https://github.com/dotnet/coreclr/blob/b638af3a4dd52fa7b1ea1958164136c72096c25c/src/mscorlib/src/System/RtType.cs#L178-L248" rel="nofollow" title="" class="ext-link"><code>RuntimeTypeCache</code>クラス</a>によって実装され、使用例は<a href="https://github.com/dotnet/coreclr/blob/b638af3a4dd52fa7b1ea1958164136c72096c25c/src/mscorlib/src/System/Reflection/MethodInfo.cs#L95" rel="nofollow" title="" class="ext-link"><code>RuntimeMethodInfo</code>クラス</a>で見ることができます。</p><p><a href="https://gist.github.com/mattwarren/be21d80a016043ea5c462415b81d9b69" rel="nofollow" title="" class="ext-link">このgist</a>を実行してキャッシュの動きを見てみると、リフレクションを適切に使用してランタイム内部を検証しているのが分かります。</p><p>リフレクションで<code>FieldInfo</code>を取得する前に、gistのコードは下記を出力します。</p><p>フィールドを1つでも取得すると下記が出力されます。</p><p><code>ReflectionOverhead.Program</code>は下記のとおりです。</p><p>つまり、すでに作成され、存在するリストをランタイムでフィルタするだけなので、継続的に<code>GetField</code>あるいは<code>GetFields</code>を呼び出す方がコストがかからないことを意味します。これは、<code>GetMethod</code>や<code>GetProperty</code>にも当てはまり、<code>GetMethod</code>や<code>GetProperty</code>を最初に呼び出した時に<code>MethodInfo</code>キャッシュあるいは<code>PropertyInfo</code>キャッシュが作成されます。</p><p><code>MethodInfo</code>取得後、<code>Invoke</code>を呼び出す前にまだやるべきことがたくさんあります。下記のようなコードを書いたと想像してください。</p><p>実行すると、下記の例外が発生します。</p><p>上記は<code>String</code>クラスの<code>Length</code>プロパティの<code>PropertyInfo</code>を取得した結果なのですが、<code>Uri</code>オブジェクトで呼び出したため、明らかに異なる型になっています。</p><p>これに加え、呼び出すメソッドに渡す引数のバリデーションも必要です。引数を渡すために、リフレクションAPIは、引数ごとに1つの<code>object</code>の配列であるパラメータを取ります。従って、リフレクションを使用して<code>Add(int x、int y)</code>メソッドを呼び出す場合は、<code>methodInfo.Invoke(..、new [] {5、6})</code>を使用します。渡された値と型は実行時にチェックする必要があります。この場合、値が2つで、両方とも<code>int</code>であることを保証する必要があります。欠点は、多くの場合、追加コストのかかる<em>ボックス化</em>を伴うことですが、<a href="https://github.com/dotnet/corefx/issues/14021" rel="nofollow" title="" class="ext-link">将来的に軽減される</a>ことを期待します。</p><p>実行されている主なタスクの1つが複数のセキュリティチェックです。例えば、リフレクションを使用して好みのメソッドを呼び出すことはできません。信頼性の高い.NET Frameworkコードでのみ呼び出しのできる制約あるいは<a href="https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/vm/dangerousapis.h#L7-L13" rel="nofollow" title="" class="ext-link">「危険なメソッド」</a>が存在します。ブラックリストに加えて、<a href="https://github.com/dotnet/coreclr/blob/e67851210d1c03d730a3bc97a87e8a6713bbf772/src/vm/reflectioninvocation.cpp#L880-L947" rel="nofollow" title="" class="ext-link">呼び出し中にチェックする</a>必要がある最新の<a href="https://msdn.microsoft.com/en-us/library/33tceax8(v=vs.110).aspx" rel="nofollow" title="" class="ext-link">コードアクセスセキュリティの許可</a>の有無に応じた動的なセキュリティチェックが実行されます。</p><p>リフレクションが<em>舞台裏で</em>何をしているのか分かったところで、かかるコストを見てみましょう。これらのベンチマークは、直接リフレクションを介してプロパティへの読み書きを比較していることにご注意ください。.NETにおいて、プロパティは実は<a href="http://stackoverflow.com/questions/23102639/are-c-sharp-properties-actually-methods/23102679#23102679" rel="nofollow" title="" class="ext-link">コンパイラが生成する</a><code>Get / Set</code>メソッドのペアですが、単なるバッキングフィールドがあるプロパティの場合、パフォーマンス上の理由から.NET JITはメソッドの呼び出しをインライン化します。つまり、プロパティにアクセスするためのリフレクションの使用は最悪の方法と言えるのですが、<a href="https://github.com/StackExchange/dapper-dot-net" rel="nofollow" title="" class="ext-link">ORM</a>や<a href="http://www.newtonsoft.com/json" rel="nofollow" title="" class="ext-link">JSONのシリアル化/逆シリアル化ライブラリ</a>、および<a href="http://automapper.org/" rel="nofollow" title="" class="ext-link">オブジェクトマッピングツール</a>などでも見られるとおり、最も一般的に使用されている方法なのです。</p><p>下記は<a href="http://benchmarkdotnet.org/" rel="nofollow" title="" class="ext-link">BenchmarkDotNet</a>で表示している生の結果です。さらに同じ結果を2つの表形式でも表示しています(ベンチマークの全コードは<a href="https://gist.github.com/mattwarren/a8ae31a197f4716a9d65947f4a20a069" rel="nofollow" title="" class="ext-link">こちら</a>です) 。</p><p><img src="http://mattwarren.org/images/2016/12/Reflection%20Benchmark%20Results.png" alt="Reflection Benchmark Results"></p><p><em>注釈：method – メソッド<br>
Mean – 平均<br>
StdErr – Standard Error – 標準エラー<br>
Scaled – 縮尺<br>
Bytes Allocated/Op – 割り当てられたバイト数</em></p><p><em>注釈：method – メソッド<br>
Mean – 平均<br>
StdErr – Standard Error – 標準エラー<br>
Scaled – 縮尺<br>
Bytes Allocated/Op – 割り当てられたバイト数</em></p><p>上記から通常のリフレクションコード(<code>GetViaReflection</code>と<code>SetViaReflection</code>)の方がプロパティに直接アクセスする(<code>GetViaProperty</code>と<code>SetViaProperty</code>)よりもかなり遅いことは明確です。他の結果については、さらに詳しく見てみましょう。</p><p>まず、下記のような<code>TestClass</code>から始めます。</p><p>さらに、全オプションの活用を可能にする共通のコードは下記のとおりです。</p><p>まず、開始地点や「最悪のケース」の役目を果たす通常のベンチマークコードを使用します。</p><p>次は、毎回取得するのではなく、<code>PropertyInfo</code>を参照先として保持することで、速度を少し上げます。しかし、プロパティに直接アクセスするよりもまだ遅いです、これは、リフレクションの「呼び出し」にはかなりコストがかかることを実証しています。</p><p>ここでは、使い方の簡単なMarc Gravellの<a href="http://blog.marcgravell.com/2012/01/playing-with-your-member.html" rel="nofollow" title="" class="ext-link">Fast Memberライブラリ</a>を利用します。</p><p>ここでの注意点は、他のオプションとは若干異なることをしていることです。1つだけではなく、型の<strong>全</strong>プロパティへのアクセスを可能にする<code>TypeAccessor</code>を作成します。しかし、欠点は結果的に実行に余計時間がかかることです。これは、プロパティの値を取得する前にリクエストしたプロパティ(この場合は「データ」)の<code>delegate</code>をまず内部で取得する必要があるからです。でも、このオーバヘッドはかなり小さく、FastMemberを使用する方がリフレクションよりもかなり早い上、簡単なので、まずは見てみることをお勧めします。</p><p>このオプションを初め、これ以降のオプションは全てリフレクションコードを<code>delegate</code>に変換することで、毎回のリフレクションのオーバヘッドなしで直接呼び出し、高速化しています。</p><p><code>delegate</code>の作成にもコストはかかることを述べておきます(詳しい情報は<a href="%E8%A8%B3%E6%B3%A8%EF%BC%9A%E8%A8%98%E4%BA%8B%E6%9C%80%E5%BE%8C%E3%81%AE%E3%80%8C%E9%96%A2%E9%80%A3%E8%A8%98%E4%BA%8B%E3%80%8D%E3%81%AB%E9%A3%9B%E3%81%B6%E3%82%88%E3%81%86%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%8C%E8%B2%BC%E3%82%89%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99">関連記事</a>をお読みください)。簡単に言うと、コストのかかることを1回(セキュリティチェックなど)で終わらせ、強い型付けの<code>delegate</code>を格納することで、小さいオーバヘッドで繰り返し使用することができるのです。結果、速度を上げることができるのです。リフレクションの使用が1度だけならこのような手法は使用しませんし、1度だけならパフォーマンスの弊害にもなりませんので、遅いことが気になることはないでしょう。</p><p><code>delegate</code>を介したプロパティの読み込みの方が直接のプロパティを読み込むより遅い理由は、.NET JITがプロパティへのアクセスのように<code>delegate</code>メソッドの呼び出しをインライン化しないからです。つまり、<code>delegate</code>を使用する際は、メソッドの呼び出しには直接アクセスする場合にはかからないコストが発生するということです。</p><p>このオプションでは<code>CreateDelegate</code>関数を使用して、PropertyInfoを通常の<code>delegate</code>変換します。</p><p>欠点はコンパイル時に確定した型を知っている必要があることです。例えば、上記のコードの<code>Func&lt;TestClass, string&gt;</code>の部分です(<code>Func&lt;object, string&gt;</code>は使用できません。使用した場合は例外処理が実行されます)。リフレクションを使用している状況においてコンパイル時に確定した型が分かっている場合はほとんどありません。だからこそ、リフレクションを使用することになるのです。これは解決策としては不十分です。</p><p>これを回避できる非常に興味深く/思いがけない方法については、Jon Skeetの素晴らしいブログ記事<a href="https://codeblog.jonskeet.uk/2008/08/09/making-reflection-fly-and-exploring-delegates/" rel="nofollow" title="" class="ext-link">『リフレクションを機能させ、デリゲートを探る』</a>の<code>MagicMethodHelper</code>コード、あるいはこの後に続くオプション4またはオプション5をお読みください。</p><p>ここでも<code>delegate</code>を生成しますが、何が違うかというと、<code>object</code>を渡すことで「オプション 3」の制約を回避できることです。ここで使用するのは、動的コードの生成を可能にする.NETの<code>Expression</code><a href="https://msdn.microsoft.com/en-us/library/mt654263.aspx" rel="nofollow" title="" class="ext-link">treeAPI</a>です。</p><p><code>Expression</code>ベースのアプローチの全コードはブログ投稿<a href="http://geekswithblogs.net/Madman/archive/2008/06/27/faster-reflection-using-expression-trees.aspx" rel="nofollow" title="" class="ext-link">『式木を使用してリフレクションを速くする』</a>を参照くしてださい。</p><p>やっと最下位レベルのアプローチ、生ILを記述する方法にたどり着きました。しかし、<em>「大いなる力には大いなる責任が伴う」</em>ものなのです。</p><p><code>Expression</code>treeの使用(オプション4)は、直接ILコードを記述する時のような柔軟性はありませんが、無効なコードを記述するのを防いでくれます。間違えたプログラミングをしても、もっと良いエラーメッセージで注意してくれる素晴らしい<a href="https://github.com/kevin-montrose/Sigil" rel="nofollow" title="" class="ext-link">Sigilライブラリ</a>の使用をお勧めします。</p><p>要点は、リフレクションを使用してパフォーマンス問題に直面した場合のみ、いくつかの異なる方法で速度を上げることができるということです。<code>delegate</code>の取得でこれらは可能になり、毎回のリフレクションのオーバヘッドなしでプロパティやフィールド、メソッドに直接アクセスすることができます。</p><p>この投稿の意見を<a href="https://www.reddit.com/r/programming/comments/5ie775/why_is_reflection_slow/" rel="nofollow" title="" class="ext-link">/r/programming</a>と<a href="https://www.reddit.com/r/csharp/comments/5igo67/why_is_reflection_slow/" rel="nofollow" title="" class="ext-link">/r/csharp</a>にお寄せください。</p><p>参考としてランタイムが<strong>デリゲート作成</strong>の際に通過するコールスタックやコードフローを一覧にしました。</p>
