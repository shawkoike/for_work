<p><a href="http://blog.spreedly.com/2014/06/24/merge-pull-request-considered-harmful/#.U6zPj41_vv8" rel="nofollow" title="" class="ext-link">Merge pull request Considered Harmful</a> (2014-06-24) by <a href="http://blog.spreedly.com/author/ntalbott/" rel="nofollow" title="" class="ext-link">Nathaniel Talbott</a>, <a href="https://spreedly.com/" rel="nofollow" title="" class="ext-link">Spreedly</a></p><p><img src="http://blog.spreedly.com/wp-content/uploads/2014/06/merge-pull-request-button.png" class="alignright"></p><p>私は<a href="https://github.com/" rel="nofollow" title="" class="ext-link">GitHub</a>が大好きです。GitHubはオープンソースへの<em>コントリビューション</em>（寄与貢献）を何十倍も容易に、そして楽しいものにしたと思います。ですが、GitHubがPull RequestというwebのUI形式で前面に押し出しているオープンソースの<em>メンテナー</em>のワークフローが、プロジェクト品質とコントリビューションを受けつけるスピードの弊害になるということに気がつきました。そこで、GitHubの<a href="https://help.github.com/articles/using-pull-requests" rel="nofollow" title="" class="ext-link">Pull Request</a>にある「Merge pull request」ボタンをクリックする前に、少しお話をさせてください。</p><p><img src="http://blog.spreedly.com/wp-content/uploads/2014/06/lotsa-pull-requests.png" class="alignright"></p><p>ジェーンはそこそこの成功を収めているオープンソースプロジェクトのメンテナーです。彼女は毎週プロジェクトのGitHubリポジトリに上がる新しい<a href="https://guides.github.com/features/issues/" rel="nofollow" title="" class="ext-link">Issue</a>を確認し、リクエストに対し速やかにフィードバックを返します。リクエストをすべて実行する時間がない場合は、<img src="http://blog.spreedly.com/wp-content/uploads/2014/06/thumbsup.png">や<img src="http://blog.spreedly.com/wp-content/uploads/2014/06/thumbsdown.png">のマークを送り、開発者たちがコードを完成させPull Requestできるようにします。<br>
いいメンテナーなら誰でもするように、彼女は<a href="https://github.com/blog/1184-contributing-guidelines" rel="nofollow" title="" class="ext-link">コントリビューティング</a>ドキュメントを書き上げました。当然彼女のリポジトリにはプロジェクトが進むにつれて<a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html" rel="nofollow" title="" class="ext-link">README</a>や<a href="http://en.wikipedia.org/wiki/Changelog" rel="nofollow" title="" class="ext-link">CHANGELOG</a>が更新されます。コントリビュータが開発しながら実行でき、機能を追加するごとに拡張できる数段階の自動化テストもあります。コードベースをきれいにしておくため、ジェーンは包括的な<a href="https://github.com/styleguide" rel="nofollow" title="" class="ext-link">公式スタイルガイド</a>をも採用しました。</p><p>このように、できる限り入念に気を配っているジェーンですが、問題を抱えています。マージされていないPull Requestが彼女のリポジトリに何十個もあるのです。どれもさほど複雑ではないのですが、彼女はマージ作業が常に遅れているように感じています。ざっと見てみると、フィードバックに基づいて大幅な修正が必要なものもいくつかはありますが、大部分はテストの追加やスタイルガイドに沿った数ヵ所のスペース調整、CHANGELOGエントリーの欠落、大量のコミットをひとまとめにするなど、ちょっとしたことで行き詰まっているのです。</p><p>さらにストレスが溜まるのは、ジェーンがすぐにフィードバックをしても、大抵の場合、コントリビュータは興味を失っていたり、当初自分が送ったPull Requestを最後に受けつけるのを忘れているのです。ジェーンが（半ば意地になって）見落としによるスタイル変更など、ささいな依頼を5回もすると、もはやあら探しのように感じられ、コントリビュータの興味を失わせる結果となってしまいます。</p><p>その結果どうなるでしょうか？　マージされていないあらゆる<a href="http://www.amazon.com/The-Goal-Process-Ongoing-Improvement/dp/0884271951" rel="nofollow" title="" class="ext-link">コード一覧</a>が精神的な負担となっていきます。ストレスを溜めたジェーンはやる気を失い、コントリビュータも次第に姿を現さなくなりそうです。</p><p><img src="http://blog.spreedly.com/wp-content/uploads/2014/06/linus-torvalds-git.jpg" class="alignright"></p><p>どうも、ナサニエルです。以前は私もジェーンと同じ立場でした。最近、<a href="https://github.com/Shopify/active_merchant" rel="nofollow" title="" class="ext-link">ActiveMrchant</a>プロジェクトに参加したのですが、当初このプロジェクトのPull Request一覧には、取るに足らない内容の項目が何ページも続いていました。ほとんどはすぐに解決できるものでしたが、下記の2つの方法を前に行き詰まってしまったのです。</p><p>どちらも、あまり気が進みません。しばらくは前者の方法をとっていました。コントリビュータに詳細をフィードバックし、適用されるまで待つのです。しかしほとんどの項目に動きはなく、長いリストが私を見つめ返してくるばかり。そのうち私は大勢の人にGitの上級レベルの使い方を教えて回る羽目になりまし た。「WIPステータスのコミット5つをsquashしてもらえますか？」と言うと「スカッシュって野菜の名前でしたっけ？」という答えが返ってくるんですからね（訳注：米ではズッキーニや近似種をまとめてsummer squashと呼びます）。</p><p>ですが、後者の手順をとると修正履歴のステータスがおかしくなります。まず、ちゃんと動かない中間コードが<span style="font-family: Courier; font-weight: bold; color: #7f0a0c;">git bisect</span>の二分探索で特定されてしまう可能性があります。コードの修正に時間がかかる場合、修正前のコミット（または複数のコミット）に対して新しいPull Requestが出されることもあるでしょう。修正自体を忘れてしまうことだってあるかもしれません。この方法は1、2度試してみましたが、あまりの苦痛に完璧主義の私にはとうてい耐えられませんでした。</p><p>では、どうすればいいのか。最終的に分かったのは、Gitはこうした状況を簡単に処理できるよう、きちんと設計されているということです。私が抵抗を感じた真の理由は、GiｔHubが採用しているワークフローにありました。そこで私は「Merge pull request」ボタンを使うのをやめ、代わりに下記の手順を踏むことにしたのです。</p><p>もちろんこれで終わりではありません。このあと変更をプッシュすべく準備する必要がありますが、次のステップへ進む前に、このやり方の重要な点を説明させてください。Gitには、メーラーの受信ボックスに届いたパッチを吸い上げるために設計された<span style="font-family: Courier; font-weight: bold; color: #7f0a0c;">am</span>（”apply mail”の略）というビルトインツールが用意されています。GitHubの便利な<a href="https://github.com/github/hub" rel="nofollow" title="" class="ext-link">hub</a>ツールは、この<span style="font-family: Courier; font-weight: bold; color: #7f0a0c;">git am</span>を利用してwebにホストされたパッチ、特に<a href="https://github.com/Shopify/active_merchant/pull/1259.patch" rel="nofollow" title="" class="ext-link">どんなPull Requestであっても取得できる生パッチ</a>を処理しています。つまり上記のやり方は、例えばカーネルのメンテナーがパッチのレビューやマージを行う際にとる手順にずっと近いと言えるのです。</p><p><img src="http://blog.spreedly.com/wp-content/uploads/2014/06/choose-your-own-adventure.jpg" class="alignright"></p><p>さて、ローカルのmasterブランチに完璧なコード（言いすぎ？）があって、<span style="font-family: Courier; font-weight: bold; color: #7f0a0c;">git log</span>にはコントリビュートされたコミットがすべて表示され、私の変更はまだコミットされていません。このあと私がするべきことは、状況によって異なります。</p><p>ActiveMerchantプロジェクトでは、コミット履歴は次のようなものになります。</p><p><img src="http://blog.spreedly.com/wp-content/uploads/2014/06/shopify-history.jpg" class="aligncenter"></p><p>Railsのコミット履歴と比べてみてください。<br>
<img src="http://blog.spreedly.com/wp-content/uploads/2014/06/rails-history.jpg" class="aligncenter"></p><p>私の好みは決まっています。さらにうれしいことに、私は今ではコントリビュータのことでああでもない、こうでもないと時間を費やすことがずっと少なくなり、コードのマージにずっと多くの時間を使えるようになりました。最後にとっておきの情報をお教えしましょう。ActiveMerchantの履歴を見て気がついたでしょうか？　私がどれだけコミットの編集やリベースを行ったとしても、コントリビュータはコミットに対する功績をすべて認められます。それが私のやり方なのです。</p><p><img src="http://blog.spreedly.com/wp-content/uploads/2014/06/merge-pull-request-button.png" class="alignright"></p><p>それでも、「Merge pull request」ボタンを使った方がいいのはどんな時でしょうか？</p><p>では「Merge pull request」ボタンを使用しないことのメリットは何でしょうか。</p><p>これには、ジェーンも100%賛成してくれるはずですよ！</p>
