<p><a href="https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-3.html" rel="nofollow" title="" class="ext-link">Kernel booting process Part 3</a> by <a href="https://github.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a><br>
in <a href="https://www.gitbook.com/book/0xax/linux-insides/details" rel="nofollow" title="" class="ext-link">Linux Inside</a> GitBook</p><p>カーネル起動処理シリーズのパート3です。前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md#kernel-booting-process-part-2" rel="nofollow" title="" class="ext-link">パート</a>では、<code>set_video</code>ルーチンを<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c#L181" rel="nofollow" title="" class="ext-link">main.c</a>.から呼び出す直前までを扱いました。今回は、次の内容を見ていきます。</p><p>注　プロテクトモードについてよく知らない場合は、前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md#protected-mode" rel="nofollow" title="" class="ext-link">パート</a>の内容を見てください。また、参考になる<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md#links" rel="nofollow" title="" class="ext-link">リンク</a>も同ページに掲載しています。</p><p>上にも書いたように、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/video.c#L315" rel="nofollow" title="" class="ext-link">arch/x86/boot/video.c</a>ソースコードファイルに定義された<code>set_video</code>関数から始めましょう。内容を見ると、まずビデオモードを<code>boot_params.hdr</code>構造体から取得することから始まるのがわかります。</p><p>これは<code>copy_boot_params</code>関数内で値を定義したものになります（前回の投稿で詳しく説明しています）。<code>vid_mode</code>は、ブートローダによって入力される必須フィールドです。関連する情報はカーネル起動プロトコルにあります。</p><p>linuxカーネル起動プロトコルには、このように記述されています。</p><p><em>訳：<br>
ここには1つの整数型（C言語記法では、10進数、8進数、16進数のいずれか）または、”normal”（0xFFFFの意）、”ext” （0xFFFEの意）、”ask” （0xFFFDの意）のどれかの文字列が入ります。この値は、コマンドライン分析の前にカーネルが使うため、vid_modeフィールドに入力します。<br>
</em></p><p>そこで、GRUBまたはその他のブートローダ設定ファイルに<code>vga</code>オプションを追加して、それをカーネルコマンドラインに渡します。このオプションは上記の説明通り、様々な値を持つことができます。例えば、整数<code>0xFFFD</code>や<code>ask</code>などです。<code>ask</code>を<code>vga</code>に渡すと、下図のようなメニューが表示されます。</p><p><img src="https://camo.githubusercontent.com/fc6d3f91001fe97d4036d3d37bbdac89a3e5d3b9/687474703a2f2f6f6935392e74696e797069632e636f6d2f656a637a38312e6a7067" alt="video mode setup menu" data-canonical-src="http://oi59.tinypic.com/ejcz81.jpg" style="max-width:100%;"><br>
ここでビデオモードを選択しなければなりません。これからその実装に移りますが、その前に他に確認すべき点が幾つかあります。</p><p>以前、カーネルセットアップコードにおける<code>u16</code>などの様々なデータタイプの定義について述べました。カーネルが提供するデータタイプを見てみましょう。</p><p>
</p>
<p>カーネルのソースコードを読んでいると、これらを目にする機会は非常に多いので、覚えておくとよいでしょう。</p><p><code>set_video</code>関数で、<code>vid_mode</code>を<code>boot_params.hdr</code>から取得した後は、<code>RESET_HEAP</code>関数の呼び出しを見ていきます。<code>RESET_HEAP</code>は、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/boot.h#L199" rel="nofollow" title="" class="ext-link">boot.h</a>に次のように定義されているマクロです。</p><p>パート2を読んだ人は、ヒープを<code>init_heap</code>関数で初期化したのを覚えているでしょう。幾つか、ヒープのためのユーティリティ関数が<code>boot.h</code>に定義されています。</p><p>上記のコードで示したように、これは<code>HEAP</code>変数を<code>_end</code>と等しい値に設定することによってヒープをリセットします。ここでは、<code>_end</code>は<code>extern char _end[];</code>です。</p><p>次は<code>GET_HEAP</code>マクロです。</p><p>このマクロは、ヒープを割り当てるためのものです。内部関数<code>__get_heap</code>を次の3つのパラメータで呼び出します。</p><p><code>__get_heap</code>の実装は以下のとおりです。</p><p>また、使用例を以下に示します。</p><p>それでは、<code>__get_heap</code>の動きを説明します。ここにある<code>HEAP</code>（ <code>RESET_HEAP()</code>の後の<code>_end</code>と同等です）は、<code>a</code>パラメータによって配置されたメモリのアドレスです。この後、メモリアドレスを<code>HEAP</code>から<code>tmp</code>変数に保存し、<code>HEAP</code>を割り当てられたブロックの末尾に移動させ、割り当てメモリの開始アドレスである<code>tmp</code>を返します。</p><p>そしてこれが、最後の関数です。</p><p><code>HEAP</code>の値を<code>heap_end</code>から減算し（前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md" rel="nofollow" title="" class="ext-link">パート</a>で計算しました）、<code>n</code>個だけ保存するのに十分なメモリがあれば、1を返します。</p><p>以上です。このシンプルなヒープ用APIで、ビデオモードをセットアップします。</p><p>さて、ビデオモードを初期化できるようになりました。前回の投稿では<code>set_video</code>関数内の<code>RESET_HEAP()</code>の呼び出しのところまで説明しました。次は、<code>store_mode_params</code>の呼び出しです。この関数は、<a href="https://github.com/0xAX/linux/blob/master/include/uapi/linux/screen_info.h" rel="nofollow" title="" class="ext-link">include/uapi/linux/screen_info.h</a>に定義されている<code>boot_params.screen_info</code>構造体にビデオモードパラメータを格納します。</p><p><code>store_mode_params</code>関数を見ると、<code>store_cursor_position</code>関数の呼び出しから始まっています。関数の名称から分かるように、カーソルの情報を取得して格納します。</p><p>最初に<code>store_cursor_position</code>は、<code>biosregs</code>型の2つの変数を<code>AH = 0x3</code>で初期化し、<code>0x10</code>BIOS割り込みを呼び出します。割り込みが成功すると、<code>DL</code>と<code>DH</code>レジスタに行と列を返します。行と列は、<code>boot_params.screen_info</code>構造体の<code>orig_x</code>と<code>orig_y</code>フィールドに格納されます。</p><p><code>store_cursor_position</code>を実行すると、<code>store_video_mode</code>関数が呼び出されます。 単純に進行中のビデオモードを取得し、<code>boot_params.screen_info.orig_video_mode</code>に格納します。</p><p>この後、この関数は進行中のビデオモードをチェックし、<code>video_segment</code>を設定します。BIOSがブートセクタに制御を移した後、次のアドレスをビデオメモリに使います。</p><p>現在のビデオモードがMDA、HGC、VGAのモノクロモードの場合は、<code>video_segment</code>変数を<code>0xB000</code>に設定し、カラーモードの場合は、<code>0xB800</code>に設定します。ビデオセグメントのアドレスをセットアップした後は、次のようにしてフォントサイズを<code>boot_params.screen_info.orig_video_points</code>に格納する必要があります。</p><p>最初に、<code>set_fs</code>関数で、<code>FS</code>レジスタに0を代入します。<code>set_fs</code>のような関数は前回のパートで既に見てきました。これらは全て<a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/boot.h" rel="nofollow" title="" class="ext-link">boot.h</a>に定義されています。それから、アドレス<code>0x485</code>（このメモリ位置はフォントサイズの取得に使います）に存在する値を読み、フォントサイズを<code>boot_params.screen_info.orig_video_points</code>に保存します。</p><p>次に、アドレス<code>0x44a</code>で、まとまった量の列を、アドレス<code>0x484</code>で行を取得し、<code>boot_params.screen_info.orig_video_cols</code>と<code>boot_params.screen_info.orig_video_lines</code>に格納します。これで、<code>store_mode_params</code>の実装は完了です。</p><p>続いて、スクリーンコンテンツをヒープに保存する<code>save_screen</code>関数です。この関数は、行や列数など、先の関数で取得した全てのデータを収集し、<code>saved_screen</code>構造体に格納します。定義は次の通りです。</p><p>また次の通り、ヒープがそのデータのための空きスペースを持っているかどうかをチェックします。</p><p>ヒープ内に十分な空きがあれば、スペースを割り当て、その中に<code>saved_screen</code> を格納します。</p><p>次に、<a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/video-mode.c#L33" rel="nofollow" title="" class="ext-link">arch/x86/boot/video-mode.c</a>から<code>probe_cards(0)</code> が呼び出されます。この関数は全ての<code>video_cards</code>を巡回し、カードが提供するモードの数を集めます。ここで面白いのは、ループがあることです。</p><p>しかし、<code>video_cards</code>はどこにも宣言されていません。答えはシンプルです。x86カーネルセットアップコードにおける全てのビデオモードは次のように定義されています。</p><p>ここで、<code>__videocard</code>はマクロです。</p><p>つまり、以下の<code>card_info</code>構造体</p><p>が、<code>.videocards</code>セグメントに含まれます。それでは<a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/setup.ld" rel="nofollow" title="" class="ext-link">arch/x86/boot/setup.ld</a>リンカファイルの内部を見てみましょう。</p><p>つまり、<code>video_cards</code>は単なるメモリのアドレスで、全ての<code>card_info</code>構造体はこのセグメントに置かれているわけです。また、全ての<code>card_info</code>構造体が<code>video_cards</code>と<code>video_cards_end</code>の間にあるということも意味するので、これを使ってループすることで全ての構造体を得られます。<code>probe_cards</code>の実行の後には、<code>nmodes</code>（ビデオモードの数）が代入済みの<code>static __videocard video_vga</code>のような構造体全てを得ることができます</p><p><code>probe_cards</code>の実行が済むと、<code>set_video</code>関数内のメインループに移ります。そこには、無限ループがあり、<code>set_mode</code>関数でビデオモードをセットアップしようとします。あるいは、<code>vid_mode=ask</code>をカーネルコマンドラインに渡すか、ビデオモードが定義されていない場合は、メニューを表示します。</p><p><code>set_mode</code>関数は<a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/video-mode.c#L147" rel="nofollow" title="" class="ext-link">video-mode.c</a>に定義されており、ただ1つのパラメータ、<code>mode</code>を取得します。これはビデオモードの数です（この値は、メニューから取得するか、<code>setup_video</code>の起動時にカーネルセットアップヘッダから取得します）。</p><p><code>set_mode</code>関数は<code>mode</code>を確認し、<code>raw_set_mode</code>関数を呼び出します。、この関数には、<code>card_info</code>構造体からアクセスできます。各ビデオモードはこの構造体をビデオモードによって入力された値（例えば、<code>vga</code>には、<code>video_vga.set_mode</code>。上の例、<code>vga</code>のための<code>card_info</code>構造体を参照）で定義します。<code>video_vga.set_mode</code>は、<code>vga_set_mode</code>で、vgaモードをチェックし、それぞれの関数を呼び出します。</p><p>ビデオモードをセットアップする各関数は、ただ<code>0x10</code>BIOS割り込みを、<code>AH</code>レジスタの値で呼び出すだけです。</p><p>ビデオモードを設定した後、それを<code>boot_params.hdr.vid_mode</code>に渡します。</p><p>次に<code>vesa_store_edid</code>を呼び出します。この関数は単純に、カーネルが使用する<a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data" rel="nofollow" title="" class="ext-link">EDID</a>情報を格納します。この後、<code>store_mode_params</code>が再び呼び出されます。最後に、<code>do_restore</code>が設定されていれば、スクリーンは前の状態に復元されます。</p><p>この後、ビデオモードを設定し、プロテクトモードに切り替えられるようになります。</p><p>では、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/main.c#L184" rel="nofollow" title="" class="ext-link">main.c</a>の末尾にある<code>go_to_protected_mode</code>の呼び出しについて説明します。コメントに<code>Do the last things and invoke protected mode</code>とあるように、これらの最後の作業を確認し、プロテクトモードに切り替えましょう。</p><p><code>go_to_protected_mode</code>は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/pm.c#L104" rel="nofollow" title="" class="ext-link">arch/x86/boot/pm.c</a>に定義されています。この関数には、プロテクトモードに飛び込む前の最終準備を行う幾つかの関数が含まれています。では、コードを見て、何を行うのか、どう機能するのかを理解しましょう。</p><p>初めに、<code>go_to_protected_mode</code>内の<code>realmode_switch_hook</code>関数の呼び出しです。この関数はリアルモードスイッチフックがあればそれを動かし、<a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt" rel="nofollow" title="" class="ext-link">NMI</a>を無効化します。フックはブートローダが標準以外の環境で稼動するときに使われます。フックについてもっと知りたい人は、<a href="https://www.kernel.org/doc/Documentation/x86/boot.txt" rel="nofollow" title="" class="ext-link">boot protocol</a> の<strong>ADVANCED BOOT LOADER HOOKS</strong>の項を読んでください。</p><p><code>realmode_switch</code>フックは16ビットリアルモードへのポインタを提示し、マスク不可割り込みを無効化するサブルーチンを呼び出します。<code>realmode_switch</code>フック（私のために存在するわけではありません）が確認されると、マスク不可割り込み（NMI）の無効化が起こります。</p><p>まず、割り込みフラグ（<code>IF</code>）をクリアにする<code>cli</code>命令を伴う、インラインアセンブリ命令があります。その後、外部割り込みが無効化されます。次の行がNMIを無効にします。</p><p>割り込みは、ハードウェアやソフトウェアから出されるCPUへのシグナルです。シグナルを取得すると、CPUは実行中の命令シークエンスを中断し、その状態を保存してコントロールを割り込みハンドラに移します。割り込みハンドラが処理を終えると、コントロールを割り込み前の命令に移します。NMIは、常に許可なしで独自に進行する割り込みです。無視することはできず、復旧不可能なハードウェアエラーのためのシグナルに使われるのが普通です。割り込みについてここで詳細を述べるのは控えますが、次の投稿で取り上げます。</p><p>コードに戻りましょう。2行目で<code>0x80</code>（無効化されたビット）バイトから<code>0x70</code>（CMOSアドレスレジスタ）バイトまでの範囲に書き込みを実行していることが分かります。その後、<code>io_delay</code>関数の呼び出しが起こります。<code>io_delay</code>は小さな遅延を作り出すもので、次のように記述されます。</p><p>何らかのバイトをポート<code>0x80</code>に出力すると、ちょうど1マイクロ秒遅延します。そこで<code>0x80</code>ポートに、どのような値（この場合は、<code>AL</code>レジスタの値）でも書くことができます。この遅延の後、<code>realmode_switch_hook</code>関数の実行が完了すると、次の関数に進むことができます。</p><p>次の関数は<a href="https://en.wikipedia.org/wiki/A20_line" rel="nofollow" title="" class="ext-link">A20ライン</a>を有効にする<code>enable_a20</code>です。この関数は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/a20.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/a20.c</a>に定義されており、様々なメソッドでA20ゲートを有効化しようとします。1つ目は<code>a20_test_short</code>関数で、<code>a20_test</code>関数によってA20がすでに有効化されているか否かをチェックします。</p><p>最初に<code>FS</code>レジスタに<code>0x0000</code>を入力し、<code>GS</code>レジスタに<code>0xffff</code>を入力します。次に、アドレス<code>A20_TEST_ADDR</code>（<code>0x200</code>です）の値を読み、この値を<code>saved</code>変数と<code>ctr</code>に入力します。</p><p>それから、更新した<code>ctr</code>の値を<code>wrfs32</code>関数を使って<code>fs:gs</code>に書き込みます。1マイクロ秒の遅延が出た後、アドレス<code>A20_TEST_ADDR+0x10</code>によって<code>GS</code>レジスタから値を読みます。もしゼロでない場合は、既にA20ラインが有効になっています。A20が無効だった場合は、<code>a20.c</code>にある別のメソッドで有効化を試みます。例えば、<code>AH=0x2041</code>などで、<code>0x15</code>BIOS割り込みを呼び出します。</p><p><code>enabled_a20</code>関数が失敗に終わった場合は、エラーメッセージを表示させ、関数<code>die</code>を呼び出します。今回の作業を開始した最初のソースコードファイル – <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/header.S</a>を思い出す人もいるでしょう。</p><p>A20ゲートの有効化に成功すると、<code>reset_coprocessor</code>関数が呼び出されます。</p><p>この関数は、<code>0xf0</code>に<code>0</code>を記述して、数値演算コプロセッサのデータを消去し、<code>0xf1</code>に<code>0</code>を記述してリセットさせます。</p><p>続いて、<code>mask_all_interrupts</code>関数が呼び出されます。</p><p>これは、主要PICの<code>IRQ2</code>を除く 補助PIC（Programmable Interrupt Controller、プログラム可の割り込みコントローラ）と主要PICにおける全ての割り込みをマスクします。</p><p>これらの準備が全て終わると、実際にプロテクトモードに移行できます。</p><p>ではいよいよ、割り込みディスクリプタテーブル（IDT）のセットアップに入ります。<code>setup_idt</code>を以下に示します。</p><p>これでIDT（割り込みハンドラなどを示すもの）がセットアップされました。この時点ではIDTをまだインストールしていませんが（後でやります）、IDTを<code>lidtl</code>命令で読み込みました。<code>null_idt</code>にはIDTのアドレスとサイズを格納しますが、今のところは0が入っています。<code>null_idt</code> は<code>gdt_ptr</code>型の構造体です。定義を以下に示します。</p><p>上記のコードは、IDTの長さ（<code>len</code>）は16ビット、IDTへのポインタは32ビットでそれぞれ表すことを示しています（IDTと割り込みの詳細は、次回の投稿で詳しく説明します）。また、<code>__attribute__((packed))</code>は、<code>gdt_ptr</code>のサイズが必要最小限であることを示しています。従って、<code>gdt_ptr</code>のサイズは6バイト、即ち48ビットです。（以下で、 <code>GDTR</code>レジスタに <code>gdt_ptr</code>へのポインタを読み込む処理を説明します。前回の投稿で<code>gdt_ptr</code>のサイズは48ビットだと説明したことをここで思い出した方もいるでしょう。）</p><p>続いて、グローバル記述子テーブル（GDT）もセットアップします。GDTをセットアップするのは<code>setup_gdt</code>関数です（詳細は<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md#protected-mode" rel="nofollow" title="" class="ext-link">カーネル起動処理　パート2</a>を参照してください）。この関数には <code>boot_gdt</code> 配列の定義が含まれますが、配列には3つのセグメントの定義が含まれます。</p><p>3つのセグメントとは、コード、データ、タスクステートセグメント（TSS）です。セグメントのうち、TSSは今回使いません。しかしTSSがここに追加されているのは、コメント行に書かれている通り、Intel VTを満足させるためです（Intel VTに興味がある方は、<a href="https://github.com/torvalds/linux/commit/88089519f302f1296b4739be45699f06f728ec31" rel="nofollow" title="" class="ext-link">この記事</a>に詳細が書かれているので参照してください）。では<code>boot_gdt</code>を見ていきましょう。まず、ここに<code>__attribute__((aligned(16)))</code>属性が含まれていることに注意してください。つまり、この構造体は16バイト単位で整列されるということです。簡単な例を以下に示します。</p><p>技術的な観点からいえば、 <code>int</code>フィールドを一つ含む構造体は4バイトでなければなりませんが、ここで示した<code>aligned</code>構造体は16バイトです。</p><p><code>GDT_ENTRY_BOOT_CS</code>のインデックスの値はここでは- 2で、<code>GDT_ENTRY_BOOT_DS</code>には<code>GDT_ENTRY_BOOT_CS + 1</code>などの値が格納されます。初期値は2です。先頭はnullディスクリプタ（index – 0）で、これは必須です。また、2番目は未使用（index – 1）です。</p><p><code>GDT_ENTRY</code>は、フラグ、ベース、上限の値を取ってGDTエントリを構築するマクロです。例えば、コードセグメントのエントリを見てみましょう。<code>GDT_ENTRY</code>には以下の値が格納されています。</p><p>これは何を意味するのでしょう。セグメントのベースアドレスは0、上限（セグメントのサイズ）は<code>0xffff</code>（1 MB）です。ここでフラグを見てみましょう。フラグの値は<code>0xc09b</code>です。これをバイナリで表すと、</p><p>となります。各ビットの意味は以下の通りです。左から右に向かって、順番に示します。</p><p>各ビットの意味の詳細は、前回の <a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md" rel="nofollow" title="" class="ext-link">投稿</a>または<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" rel="nofollow" title="" class="ext-link">Intel® 64 and IA-32 Architectures Software Developer’s Manuals 3A</a>を参照してください。</p><p>以下のコードを実行すると、GDTの長さを取得できます。</p><p><code>boot_gdt</code>のサイズを取得して、そこから1（GDTの末尾の有効なアドレス）を引きます。</p><p>次に以下のコードで、GDTへのポインタを取得します。</p><p>ここで<code>boot_gdt</code>のアドレスを取得して、データセグメントのアドレスを左に4ビットシフトしたものに、このアドレスを加えます（現在はリアルモードであることを思い出してください）。</p><p>最後に<code>lgdtl</code>命令を実行して、GDTをGDTRレジスタに読み込みます。</p><p>これで<code>go_to_protected_mode</code>関数は終わりです。ここまでにIDTとGDTを読み込み、割り込みを無効にしたので、次はCPUをプロテクトモードに切り替えます。最後のステップは、以下の2つのパラメータを指定して<code>protected_mode_jump</code>関数を呼び出すことです。</p><p>この関数は<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/pmjump.S#L26" rel="nofollow" title="" class="ext-link">arch/x86/boot/pmjump.S</a>で定義されています。2つのパラメータの意味は次のとおりです。</p><p>ではここから、<code>protected_mode_jump</code>の内部を詳しく見ていきます。上記の通り、これは<code>arch/x86/boot/pmjump.S</code>ファイル内にあります。先頭のパラメータは<code>eax</code> レジスタに、次のパラメータは<code>edx</code>.レジスタに格納されます。</p><p>まず、<code>esi</code>レジスタ内に<code>boot_params</code>のアドレスを、コードセグメントのレジスタ<code>cs</code>のアドレス（0x1000）を<code>bx</code>に書き込みます。次に <code>bx</code>の内容を4ビットシフトさせて、そこにラベル<code>2</code>のアドレスを加算し（この処理の後、<code>bx</code> にあるラベル<code>2</code>の物理アドレスを取得します）、ラベル<code>1</code>にジャンプします。続けて、データセグメントとタスクステートセグメントを、以下の通り <code>cs</code>レジスタと<code>di</code>レジスタにそれぞれ置きます。</p><p>上記から分かる通り、<code>GDT_ENTRY_BOOT_CS</code>のインデックス値は2なので、GDTの各エントリは8バイト、従って<code>CS</code>は<code>2 * 8 = 16</code>、<code>__BOOT_DS</code>は24、のようになります。</p><p>次に、<code>CR0</code>コントロールレジスタ内のProtection Enable（<code>PE</code>）ビットを次の通りセットして、</p><p>プロテクトモードへ大きくジャンプします。</p><p>ここで</p><p>これでプロテクトモードに移行しました。</p><p>プロテクトモードの最初のステップを詳しく見ていきます。まず、データセグメントを以下のようにセットアップします。</p><p>ここで、 <code>cx</code>レジスタに<code>$__BOOT_DS</code>を格納したことを思い出しましょう。これで、<code>cs</code> 以外の全てのセグメントレジスタに値が格納されました（<code>cs</code>には既に<code>__BOOT_CS</code>が格納されています）。次に、<code>eax</code>以外の汎用レジスタ全てに0を格納します。</p><p>最後に、32ビットのエントリポイントにジャンプします。</p><p><code>eax</code>には32ビットエントリのアドレスが格納されていることに注意してください（この値を最初のパラメータとして <code>protected_mode_jump</code>に渡したためです）。</p><p>以上です。プロテクトモードに入って、そのエントリポイントまでを説明しました。この続きは次の投稿で説明します。</p><p>Linuxカーネル内部の解説、パート3は以上です。次回の投稿では、プロテクトモードの最初のステップを詳しく解説してから、 <a href="http://en.wikipedia.org/wiki/Long_mode" rel="nofollow" title="" class="ext-link">ロングモード</a>への移行についても触れる予定です。</p><p>この記事について質問や提案があれば、どうぞ遠慮なく<a href="https://twitter.com/0xAX" rel="nofollow" title="" class="ext-link">こちらのTwitterアカウント</a>にコメントまたはメッセージを送ってください。</p><p><strong>ただし英語は私の母語ではないので、コミュニケーションに多少不便があるかもしれませんが、どうぞご理解ください。記事に誤りを見つけた場合は、訂正内容を添えて <a href="https://github.com/0xAX/linux-internals" rel="nofollow" title="" class="ext-link">linux-internals</a>にプルリクエストを送ってください。</strong></p>
