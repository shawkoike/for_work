<p><a href="https://blog.mozilla.org/research/2014/06/23/static-checking-of-units-in-servo/" rel="nofollow" title="" class="ext-link">Static checking of units in Servo</a> by <a href="http://limpet.net/mbrubeck/" rel="nofollow" title="" class="ext-link">Matt Brubeck</a></p><p>ウェブ・ブラウザは幾何学的な座標上で多くの計算を行っていますが、様々な座標系と単位系が混在しています。たとえばブラウザは、画面の原点から相対的にきまるハードウェアのピクセルとして表現された位置を、ドキュメントの原点からみたCSSの<em>px</em>単位へと変換する必要があります．</p><p>もし異なる単位系や座標系の間でコードを正しく変換できなければ、厄介な<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=935219" rel="nofollow" title="" class="ext-link">バグ</a>を引き起こすでしょう (<a href="http://www.victoria.ac.nz/staff/stephen_marshall/SE/Failures/SE_MCO.html" rel="nofollow" title="" class="ext-link">世界で最も知られていない単位変換のバグ</a>に書かれたほどひどいバグではないかもしれませんが)。</p><p>このたび私は、<a href="https://github.com/mozilla/servo/" rel="nofollow" title="" class="ext-link">Servo</a>プロジェクトの一環で、<a href="http://www.rust-lang.org/" rel="nofollow" title="" class="ext-link">Rust</a>で書かれた2Dのジオメトリーライブラリーの一つである<a href="https://github.com/mozilla-servo/rust-geom/" rel="nofollow" title="" class="ext-link">rust-geom</a>に、こうしたバグを避けるための新機能をいくつか追加しました。その新機能中には、長さの単位の一つにタグ付けされた数値を一つ持つことのできる型 <code>Length</code> や、異なる単位系の間の変換に用いられる型 <code>ScaleFactor</code> などがあります。一例を以下に示します。</p><p>単位のチェックは静的に行われます。ある表現部分で使われるべき単位系とは別の単位系を持つLengthの値を使おうとすると、あなたのコードはコンパイルに失敗するので、単位系の変換を明示的に追加する必要があります。</p><p>さらに、この単位が使われるのはコンパイル時<em>だけ</em>です。実行時には、<code>Length&lt;Inch, f32&gt;</code>の値は何らの追加データなしに単一の浮動小数点の数値<code>f32</code>としてメモリー上に格納されます。その単位の型は<a href="http://www.haskell.org/haskellwiki/Phantom_type" rel="nofollow" title="" class="ext-link">“Phantom types”</a>となり、参照されることもないし実行時に何もしません。</p><p><code>Length</code>の値はまた、このライブラリーがサポートするあらゆる幾何学演算の前後で単位系を正しく保つために、<code>Rect</code>、<code>Size</code>、<code>Point2D</code> などの他のrust-geomの型と共に用いることができます。またこれらを複合した型を使うとき便利なように、型のエイリアスやコンストラクタもあります。一例を示します。</p><p>こうした機能をServoで利用すれば、デバイスの画素や画面上の座標、それにCSSのpxなど、異なる座標系や測定単位系の間で数値が正しく変換されるかどうか確認できます。Servoで用いられる単位については<a href="https://github.com/mozilla/servo/blob/4fef0d1c1c8f5fea1ff5e3ed7f9a98cec01cd8a8/src/components/util/geometry.rs#L14-L53" rel="nofollow" title="" class="ext-link">geometry.rs</a>に記述があります。これらの型は、コンポジターやウィンドウイングのモジュールで使われています。現在、より多くのServoコードがこの機能を利用するように記述変更を進めています。</p><p>このおかげでいくつかのバグも見つけることができました。たとえば、下の記述例では、当初はデバイスの画素からページの画素への変換が抜け落ちていました。そのため開いているウィンドウの解像度がCSS pxあたりハードウェアの1画素分と異なる場合に、マウスを動かしても思い通りの結果が得られなかったのです。:</p><p>そこで私たちがこのモジュールで用いられる型に単位を付加したところ、このコードが<a href="https://github.com/mbrubeck/servo/commit/c87cdcebb409f6b9bf5853514cd1a519ea49c2bc#diff-7b2596670fc5f8be65a6be4df2f0229eL638" rel="nofollow" title="" class="ext-link">修正</a>されるまでビルドできないようになりました。</p><p>私のRustコードは、Kartikaya Guptaによる<a href="https://staktrace.com/spout/entry.php?id=800" rel="nofollow" title="" class="ext-link">Gecko上で静的チェックされた単位</a>のC++コードによる実装をそのまま組み込んだものが基本になっています。いくつか細かな相違点 (例えばGeckoには一次元の 「長さ」 を示す型が無いなど) がありますが、C++からRustに移植したにもかかわらず基本的なデザインは容易にわかるようになっています。</p><p>この問題に取り組んでいるプロジェクトはほかにも数多くあります。とりわけ、F#言語はその言語の特徴として<a href="http://msdn.microsoft.com/en-us/library/dd233243.aspx" rel="nofollow" title="" class="ext-link">単位系</a>を組み込んでいます。たとえば、異なる単位系の任意の組合せの上で行われる演算の静的な解析 (これはまだrust-geomには実装前) などです。彼らの<a href="http://research.microsoft.com/en-us/um/people/akenn/units/" rel="nofollow" title="" class="ext-link">研究報告</a>には関連のある仕事が引用されています。RustやC++のような言語は単位系に関して特別言語レベルの範疇には入っていませんが、一般的な型やphantom型を利用すれば、ライブラリー・コードにオーバーヘッドなく同様の静的チェックを組み込むことができます。私たちがGeckoとServoで行った仕事は、このアプローチが実用上いかに有益であるかを示しました。</p>
