1995 Programming on the Sega Saturn by Mick Westこの記事は、1995年にNeversoft社で初となるゲーム｢Skeleton Warriors｣を開発した際に書いたドキュメントです。これは、私が68Kアセンブリ言語を使わずに作った初めてのゲームです。こちらの写真から、当時の仕事環境を窺い知ることができます。右側にあるのがセガサターン用ソフト開発キット（”スモールボックス”とICEで構成されています）です。以下のドキュメントで、セガサターン用ゲームソフト「Skeleton Warriors」用に書かれたコードを簡単に説明します。また、その中には現在でも使われている方法が多くありますので、そのいくつかをご紹介します。このドキュメントの主な目的は、それぞれのモジュールの働きと、その対話方法を説明しながら、DanとKen、Jamesに現代のコードについて効率的に理解してもらうことです。またMick（筆者）が書いた残念なコードを振り返り、自分自身の気を引き締めたいと思っています。更に、プログラムへのデータ（.GOBと.GOBファイル）の取り込みについても詳細を少し説明し、将来的にどう扱うかについて説明していきます。今回、ターゲットにするマシンはセガサターンです。これには、2つの「SH-2」というRISCマイクロプロセッサと1つの68000が搭載されています。現在は、マスタのSH-2のみを使っていて、スレーブのSH-2は時間に余裕があれば使うことになるでしょう。68000はサウンドチップを動作させるために使われていますが、セガが提供しているサウンドライブラリを使うので、これに対するコードは書かなくてもいいでしょう。ほぼ全てのプログラムが、ただのC言語で書かれています。また、SH-2アセンブリのアウトプットを生成するために、GNUのSH-2コンパイラが使われています。SH-2モジュールもいくつか使われていますが、そのほとんどで純粋なデータに限定されています。私は、今までにSH-2の重要な部分について何かを書いたことはありません。私たちが使っている開発システムはPsyQです。これは、セガの標準的な開発システムではありませんが、利用した人たちはみんな、最高のシステムだと言います。代替システムはセガの子会社Cross Productsが開発したSNASMです。セガが提供するコードのほとんどは、SNASM開発システムで実行されることが前提になっていますが、簡単にPsyQとの互換性を保つことができます。PsyQシステムには、PCにインストールしたSCSIインターフェースボードと、セガサターンに接続するカートリッジ、そしてその2つをつなぐケーブルが含まれています。ソースはPC上でコンパイルされ、実行機であるセガサターンにダウンロードされます。コードをPCからデバッグすることも可能です。この接続は、マシン間のコミュニケーションを扱うTSRプログラム（PSYBIOS）によって制御されています。これによって、セガサターンは、CDからファイルを読み込むのと同じようにPCからファイルを読み込むことができます。この機能を利用し、各レベルでファイルを読み込むようにしています。Mickの部屋には他にも大きくてうるさい筐体が2台あります。PCも2台保有しています。小さい方の筐体はE7000PC。インサーキット・エミュレータを備えたSH-2です。これはPsyQデバッガが停止しなかった場合に、プログラムがどこでクラッシュしたかを調べるのに役立ちます。メモリの書き込みを監視するのにも便利なのですが、まだその機能はあまり使ったことはありません。2つめのうるさい筐体は「スモールボックス」として知られるものです（オリジナルの「ラージボックス」は小さい冷蔵庫ぐらいのサイズでした）。基本的にこれはE7000とCDエミュレータのためのインターフェースをサターンに追加したものです。国別コードを変更するためのスイッチと、PALとNTSCの切り替えスイッチが正面についています。CDエミュレータはもう片方のコンピュータに入っているもので、コンピュータのハードディスクを仮想的にCDドライブとみなすための大きな基盤です。CDイメージを作成し、実際にCDでプレイした時にどうなるかリアルタイムモードでエミュレートできます。これでほぼうまくいきそうですが、まだいくつか問題があり、セガと協力して解決しようとしています。最終的なプログラムの構造全般は1つのMakefile、すなわちMAKEFILE.MAKによって制御されています。ここにはプロジェクト全般の依存関係とターゲットが含まれていて、.GOBと.GOVファイルのコンパイルも含まれています。個々のCのソース（.C）モジュールは、プログラムCCSH によって、SH-2（.OBJ）オブジェクトモジュールにコンパイルされます。最初に（C:\GNUSH2\BIN内の）GNU CプリプロセッサCPPSHを呼び出し、その後このアウトプットの中のCC1SHを呼び出し、SH-2アセンブリコードを生成します。最後に（C:\PSYQ内の）ASSHを呼び出し、これを最終的なオブジェクトフォーマットへとアセンブルします。法外に大きなオブジェクトファイルを生成すると聞いていたので、C++は使わないことにしました。まだC++を試してみたことはありません。//でコメントアウトするなどの機能は便利そうなので、どうぞご自身で試してみてください。私たちが使用したSH-2アセンブリ言語ファイル（.S拡張子）は、ASMSH（ASSHと同じものではなく、より複雑なマクロアセンブラ）を使って直接.OBJファイルにシンプルにアセンブルされます。この時点では、単にデータの組み込みに用いられ、マシン特有のコードはありません。コードを格納しておくためのサターンのRAMは、1メガバイトのチャンク2つに分かれています。1つはアドレス$06000000、もう1つは$00200000にあります。$00200000の方のチャンクは主としてメインキャラクタの画像を格納するのに使用され、プログラムコードは実際には$06010000に格納されます（最初の$10000バイトはシステムスペースやスタックなどに使われます）。コードは位置に依存し、特定のアドレス($06010000)で実行されるようコンパイルされます。他のアドレスでは実行できません。.OBJファイルはPSYLINKプログラムとリンクして、MAIN.CPEというファイルを生成します。これは小さなヘッダを備えた実行可能なプログラムで、RUNプログラムと一緒にサターンにダウンロードすることができます。PSYLINKはTEST.LNKというファイルを使って、どの.OBJファイルを採用し、どこに格納するのかを特定します。ゲームはいくつものレベルに分割されています。異なるレベルで同じデータを利用することも多いですが、ほとんどはレベルによって異なっています。各レベルで利用するデータは最終的に2つの巨大なファイル、.GOVと.GOB（鉱山であればMINE.GOVとMINE.GOB）に集約されます。.GOVファイルは短いヘッダと、ビデオメモリに格納する必要がある全データを含んでいます。.GOBファイルはRAMに格納されるべき全データを含んでいます。各レベルは以下に挙げるデータファイルから構成されます。これらのファイルはASMSHアセンブラにより、適切な.GOVと.GOBファイルにアセンブルされます。LEVEL.SとLEVEL1.Sというファイルを参照して、どのようになっているか見てみてください。レベル固有のデータは.GOVファイルに格納されているものもあります。とは言え全ての機能は正常に動作しますし、最初の実装やテストをするには十分に優秀なフレームワークを提供するものです。この偉業を成し遂げたDanをほめてあげてください。MANとPATHの状態を記述した変数を含んでいます。[アップデート]以下にMAN.Cのサンプルコードを掲載します。全てがハードコードされていて、グローバルの”Man”データ構造を参照しています。ハードコードされた数値も多いです。OB.Cファイルが、ゲームの個々のオブジェクトの行動パターンを全て含んだ9000行の巨大ファイルにまで大きくなってしまいました。以下のような、ハードコードされた数値も大量にあります。ひどいものですね。ゲームがとても小さく、68Kから脱却したばかりの時代には、このコードスタイルでもまだ大丈夫だったのです。
