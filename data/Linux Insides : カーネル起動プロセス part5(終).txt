<p><a href="https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-5.html" rel="nofollow" title="" class="ext-link">Kernel booting process Part 5</a> by <a href="https://github.com/0xAX" rel="nofollow" title="" class="ext-link">0xAX</a><br>
in <a href="https://www.gitbook.com/book/0xax/linux-insides/details" rel="nofollow" title="" class="ext-link">Linux Inside</a> GitBook</p><p>カーネルの起動処理（<code>Kernel booting process</code>）シリーズの第5弾です。<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-4.md#transition-to-the-long-mode" rel="nofollow" title="" class="ext-link">前回</a>は、64ビットモードへの移行を見てきましたが、今回はその続きを説明していきたいと思います。カーネル展開の前準備と再配置、実際のカーネル展開処理のコードにジャンプする前の、最後のステップを見ていきます。それでは、カーネルコードの世界に再び飛び込んでいきましょう。</p><p>前回は64ビットのエントリポイント<code>startup_64</code>にジャンプする直前まででした。これは<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/head_64.S</a>のソースコードファイルの中にあります。すでに<code>startup_32</code>での<code>startup_64</code>へのジャンプは見てきましたね。</p><p>前回のパートで、<code>startup_64</code>に入りました。新しいグローバル･ディスクリプタ･テーブルをロードし、他のモード（私たちのケースでは64ビットモード）へのCPUトランジションをしたので、<code>startup_64</code>の始めの部分でデータセグメントの設定を行います。</p><p><code>cs</code>以外の全てのセグメントレジスタは<code>x18</code>である<code>ds</code>を指しています（なぜ<code>x18</code>かが分からない場合は、前回のパートを読んでください）。</p><p>次のステップでは、カーネルがコンパイルされた時とロードされた時の違いを計算していきます。</p><p><code>rbp</code>は展開されたカーネルの先頭アドレスを含みます。このコードが実行された後は、<code>rbp</code>レジスタに展開のためのカーネルコードを再配置するアドレスが含まれています。すでに<code>startup_32</code>で、このようなコードを見てきていますが（前回の<a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-4.md#calculate-relocation-address" rel="nofollow" title="" class="ext-link">再配置のアドレスを計算する</a>の章で触れています）、この計算を再度行う必要があります。というのも、ブートローダは64ビットブートプロトコルを利用できますが、<code>startup_32</code>は今回のケースで単に実行されないかもしれないからです。</p><p>次のステップでは、フラグレジスタのスタックの設定とリセットについて見ていきます。</p><p>上記のように、<code>rbx</code>レジスタにはカーネルコード展開の先頭アドレスが読み込まれており、<code>boot_stack_end</code>でこのアドレスをオフセットして<code>rsp</code>へ置きます。これによってスタックの値は正しくなります。<code>compressed/head_64.S</code>ファイルの最後に <code>boot_stack_end</code>の定義がされています。</p><p><code>.pgtable</code>直前の<code>.bss</code>セクションに位置します。<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/vmlinux.lds.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/vmlinux.lds.S</a>を見れば見つけられます。</p><p>スタックをセットしたので、展開されたカーネルのアドレスを計算すれば、上記で取得したアドレスに圧縮されたカーネルをコピーできます。コードを見てみましょう。</p><p>最初に、スタックに対して<code>rsi</code>をプッシュします。<code>rsi</code>の値を保存する必要がある理由は、このレジスタが<code>boot_params</code>リアルモード構造体を指すポインタを保持しているからです（カーネルのセットアップの最初にこの構造体のフィールドを埋めたので、おそらくこの構造体の事は覚えているでしょう）。このコードの最後に、<code>rsi</code>に<code>boot_params</code>を指すポインタを再度書き込みます。</p><p>次の2つの<code>leaq</code>命令は、<code>rip</code>と<code>rbx</code>に置かれているアドレスを<code>_bss - 8</code>でオフセットして有効なアドレスになるよう計算し、<code>rip</code>と<code>rbx</code>に置きます。なぜこれらのアドレスを計算するのでしょうか？　実際のところ、圧縮したカーネルイメージは、このコピーするコード（<code>startup_32</code>から現在のコードまで）と展開コードの間に配置されています。リンカスクリプトの<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/vmlinux.lds.S" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/vmlinux.lds.S</a>を見れば、これを確認できます。</p><p>気を付けなければいけないのは、<code>.head.text</code>セクションは<code>startup_32</code>を含むということです。前回のパートを思い出してください。</p><p><code>text</code>セクションは展開したコードを含みます。</p><p>アセンブリです。</p><p>そして<code>.rodata..compressed</code>は圧縮されたカーネルイメージを含んでいます。</p><p>そのため<code>rsi</code>には<code>rip</code>のアドレス(<code>_bss - 8</code>からの相対アドレス)を含み、<code>rdi</code>は再配置位置(同じく<code>_bss - 8</code>からの相対アドレス)を含みます。レジスタにこれらのアドレスを保存したので、<code>_bss</code>アドレスを<code>rcx</code>レジスタへ置きます。<code>vmlinux.lds.S</code>を見て分かるように、セットアップ/カーネルコードを含む全てのセクションの最後で配置されます。<code>movsq</code>命令で<code>rsi</code>から<code>rdi</code>までのデータを8バイトごとにコピーし始められるようになりました。</p><p>データをコピーする前に<code>std</code>命令があることに留意してください。<code>DF</code>フラグがセットされますが、これは<code>rip</code>と<code>rdi</code>がデクリメントされることを意味します。言い換えれば、逆向きにバイトをコピーすることになります。</p><p>最後に<code>cld</code>命令で<code>DF</code>フラグをクリアし、<code>rsi</code>へ<code>boot_params</code>構造体を復元します。</p><p>この後、<code>.text</code>セクションのアドレスを取得して、そこにジャンプします。</p><p><code>.text</code>セクションは<code>relocated</code>ラベルから開始します。最初に<code>bss</code>セクションを次のようにクリアします。</p><p>ここでは<code>eax</code>をクリアし、<code>_bss</code>のRIP相対アドレスを<code>rdi</code>に、<code>_ebss</code>を<code>rcx</code>に置き、<code>rep stosq</code>命令によってゼロフィルします。</p><p>最後のほうで<code>decompress_kernel</code>ルーチンが呼び出されています。</p><p>ここでもまた、ポインタと<code>rsi</code>を<code>boot_params</code>構造体に保存し、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/misc.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/misc.c</a>から7つの引数と共に<code>decompress_kernel</code>を呼び出します。全ての引数はレジスタに渡されます。これで全ての準備が終わったので、カーネルの展開に移りましょう。</p><p>上述のように、<code>decompress_kernel</code>関数は、<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/misc.c" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/misc.c</a>ソースコードファイルの中にあります。この関数は、前のパートで触れたvideo/consoleの初期化から始まります。この呼び出しでは、ブートローダが32ビットのプロトコルを使っているのか、それとも64ビットのプロトコルなのかを知る必要があります。この後、フリーメモリの先頭地点にポインタを保存し、最後には次のようにします。</p><p><code>decompress_kernel</code>関数の2つめのパラメータが<code>heap</code>ですが、これは次のようにして取得します。</p><p>上記で見たとおり、<code>boot_heap</code>は次のように定義されます。</p><p>カーネルが<code>bzip2</code>で圧縮されている場合は<code>BOOT_HEAP_SIZE</code>は<code>0x400000</code>となり、そうでない場合は、<code>0x8000</code>となります。</p><p>次のステップでは<a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/aslr.c#L298" rel="nofollow" title="" class="ext-link">arch/x86/boot/compressed/aslr.c.</a>から<code>choose_kernel_location</code>を呼び出します。名称から分かるように、この関数はカーネルイメージが展開されるメモリの位置を選択します。見てみましょう。</p><p>スタート時、<code>CONFIG_HIBERNATION</code>が設定されていれば、<code>choose_kernel_location</code>はコマンドラインオプションに<code>kaslr</code>がないか捜そうとします。もしこのコンフィギュレーションオプションの<code>CONFIG_HIBERNATION</code>が設定されていなければ<code>nokaslr</code>オプションを捜します。</p><p>コマンドラインに<code>kaslr</code>も<code>nokaslr</code>も見当たらなかった場合、<code>out</code>ラベルまでジャンプします。</p><p>そして返ってきた<code>output</code>パラメータを、変更を加えずに<code>choose_kernel_location</code>へ渡します。<code>kaslr</code>について考えてみましょう。<a href="https://github.com/torvalds/linux/blob/master/Documentation/kernel-parameters.txt" rel="nofollow" title="" class="ext-link">documentation</a>を参照してみてください。</p><p>つまりこれは、<code>kaslr</code>オプションをカーネルのコマンドラインに渡し、展開されたカーネル用のランダムなアドレスを取得できるということを意味します（aslrについては<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E3%81%AE%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E5%8C%96" rel="nofollow" title="" class="ext-link">ここ</a>をお読みください）。</p><p>カーネルのコマンドラインが<code>kaslr</code>オプションを含んでいる場合について考えてみましょう。</p><p>同じ<code>aslr.c</code>ソースコードファイルから、<code>mem_avoid_init</code>関数が呼び出されます。この関数はunsafeなメモリ領域（initrdや、カーネルコマンドラインなど）を取得します。これらのメモリ領域を把握して、展開後にカーネルとオーバーラップしないようにする必要があります。例を挙げます。</p><p>ここでは<a href="https://ja.wikipedia.org/wiki/Initrd" rel="nofollow" title="" class="ext-link">initrd</a>の先頭アドレスとサイズを計算しています。<code>ext_ramdisk_image</code>はブートヘッダの<code>ramdisk_image</code>フィールドの高位32ビットであり、<code>ext_ramdisk_size</code>は、<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt" rel="nofollow" title="" class="ext-link">boot protocol</a>からの<code>ramdisk_size</code>フィールドの高位32ビットです。</p><p><code>ext_ramdisk_image</code>と<code>ext_ramdisk_size</code>については<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/zero-page.txt" rel="nofollow" title="" class="ext-link">Documentation/x86/zero-page.txt</a>をご覧ください。</p><p>さて<code>ext_ramdisk_image</code>と<code>ext_ramdisk_size</code>を使い、それらを32ビットのままにして（高位32ビットの中に低位32ビットが含まれています）、<code>initrd</code>の先頭アドレスとサイズを取得します。この後、これらの値を<code>mem_avoid</code>配列に保存します。これは次のように定義されます。</p><p><code>mem_vector</code>の構造体は次のようになります。</p><p><code>mem_avoid</code>配列から全てのunsafeなメモリ領域を収集した後、次のステップは、unsafeな領域とオーバーラップしないランダムなアドレスを捜すことです。ここでは<code>find_random_addr</code>関数を使います。</p><p>最初に<code>find_random_addr</code>関数で出力アドレスが整列されます。</p><p>前のパートでやった<code>CONFIG_PHYSICAL_ALIGN</code>コンフィギュレーションオプションを覚えていますね？　このオプションはどのカーネルが整列されるべきか値を提供しますが、この値はデフォルトで<code>0x200000</code>です。整列された出力アドレスを取得できたら、メモリを探索して、展開したカーネルイメージに適した領域を収集します。</p><p><a href="https://github.com/0xAX/linux-insides/blob/master/Booting/linux-bootstrap-2.md#memory-detection" rel="nofollow" title="" class="ext-link">カーネル起動処理パート2</a>の2番目のパートで<code>e820_entries</code>を収集したのを思い出してください。</p><p>最初に、<code>process_e820_entry</code>関数はe820メモリ領域がnon-RAMではないというチェックを行います。つまり、そのメモリ領域の先頭アドレスが、許可された<code>aslr</code>オフセットの最大値よりも小さく、メモリ領域がカーネル整列の値よりも小さくないことをチェックします。</p><p>この後、e820メモリ領域の先頭アドレスとサイズを<code>mem_vector</code>構造体に保存します（この構造体の定義は上記でやりました）。</p><p>これらの値を保存したら、<code>find_random_addr</code>関数でしたように<code>region.start</code>を整列して、オリジナルのメモリ領域よりも大きなアドレスを取得しなかったことを確認します。</p><p>次にオリジナルのアドレスと整列されたものとの差を取得し、メモリ領域の末尾のアドレスが<code>CONFIG_RANDOMIZE_BASE_MAX_OFFSET</code>よりも大きければメモリ領域サイズを減らし、カーネルイメージの末尾が<code>aslr</code>オフセットの最大値よりも小さくなるようにします。</p><p>最後には全てのunsafeなメモリ領域を探索して、各領域がカーネルのコマンドラインやinitrdなどのunsafeなエリアとオーバーラップしていないことをチェックします。</p><p>メモリ領域がunsafeな領域とオーバーラップしていなければ、領域の先頭アドレスで<code>slots_append</code>関数を呼び出します。<code>slots_append</code>関数は<code>slots</code>配列からメモリ領域の先頭アドレスを収集します。</p><p>これは次のように定義されます。</p><p><code>process_e820_entry</code>が実行された後、展開されたカーネルにとって安全なアドレスの配列が分かりました。次は、<code>slots_fetch_random</code>関数を呼び出し、この配列から任意のアイテムを取得します。</p><p>ここでは<code>get_random_long</code>関数がCPUのフラグを調べて<code>X86_FEATURE_RDRAND</code>または<code>X86_FEATURE_TSC</code>なのかをチェックし、乱数を得るためのメソッド（RDRAND命令、タイムスタンプカウンタ、プログラマブルインターバルカウンタ（PIT）などがあります）を選択します。ランダム化されたアドレスを取得したら、<code>choose_kernel_location</code>の実行は終了です。</p><p>では <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/misc.c#L404" rel="nofollow" title="" class="ext-link">misc.c</a>に戻りましょう。カーネルイメージのアドレスを取得した後、ランダム化されたアドレスが正しく整列されているか、そしてアドレスが間違っていないか、ということをチェックします。</p><p>これらのチェックが全て終了すれば、次のような見慣れたメッセージが見られるでしょう。</p><p>そして<code>decompress</code>関数を呼び、カーネルを展開します。<code>decompress</code>関数は、カーネルのコンパイル時にどの展開アルゴリズムが選ばれたかに依存します。</p><p>カーネルが展開されたら、最後の関数<code>handle_relocations</code>が<code>choose_kernel_location</code>から取得したアドレスへとカーネルを再配置します。カーネルが再配置されたら、<code>decompress_kernel</code>から<code>head_64.S</code>に戻ります。カーネルのアドレスは<code>rax</code>レジスタにあるので、そこへジャンプします。</p><p>これで全てです。これでカーネルの展開ができました。</p><p>これでLinuxカーネル起動処理の5つのパートが全て終了です。カーネルの起動についてはこれが最後の投稿になります（更新はするかもしれません）が、カーネル内部についての投稿は今後もしていきます。</p><p>次の章はカーネルの初期化についてです。Linuxのカーネル初期化コードの最初のステップを見ていきます。</p><p>ご質問やご意見があればコメントを書いていただくか、<a href="https://twitter.com/0xAX" rel="nofollow" title="" class="ext-link">twitter</a>で呼びかけてみてください。</p><p>英語は私の第一言語ではないことをご承知おきください。誤りを見つけた方は<a href="https://github.com/0xAX/linux-insides" rel="nofollow" title="" class="ext-link">linux-internals</a>に、プルリクエストを送ってください。</p>
