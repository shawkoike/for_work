<p><a href="http://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/" rel="nofollow" title="" class="ext-link">Why you should understand (a little) about TCP</a> （2015-11-21） by <a href="http://jvns.ca/about/" rel="nofollow" title="" class="ext-link">Julia Evans</a></p><p>この記事はTCPの<em>全て</em>を理解する、あるいは<a href="http://www.amazon.com/TCP-Illustrated-Vol-Addison-Wesley-Professional/dp/0201633469?tag=viglink122062-20" rel="nofollow" title="" class="ext-link">『TCP/IP Illustrated』</a>（訳注：日本語版:<a href="http://www.amazon.co.jp/%E8%A9%B3%E8%A7%A3TCP-IP%E3%80%88Vol-1%E3%80%89%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB-W-%E3%83%AA%E3%83%81%E3%83%A3%E3%83%BC%E3%83%89-%E3%82%B9%E3%83%86%E3%82%A3%E3%83%BC%E3%83%B4%E3%83%B3%E3%82%B9/dp/4894713209" rel="nofollow" title="" class="ext-link">『詳解TCP/IP〈Vol.1〉プロトコル』</a>）を読破しようとか、そういうことではありません。ほんの少しのTCPの知識がどれほど欠かせないものなのかについてお話します。まずはその理由をお話しましょう。</p><p>私が<a href="https://www.recurse.com/" rel="nofollow" title="" class="ext-link">Recurse Center</a>で働いているとき、PythonでTCPスタックを書きました（<a href="http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/" rel="nofollow" title="" class="ext-link">またPythonでTCPスタックを書いたらどうなるかについても書きました</a>）。それはとても楽しく、ためになる経験でした。またそれでいいと思っていたんです。</p><p>そこから1年ぐらい経って、仕事で、誰かが「NSQへメッセージを送ったんだが、毎回40ミリ秒かかる」とSlackに投稿しているのを見つけました。私はこの問題についてすでに1週間ほど考え込んでいましたが、さっぱり答えがでませんでした。</p><p>ここでちょっとした補足を。NSQはメッセージを送るときのキューです。メッセージを送る方法は、HTTPリクエストをローカルホストに送るというものです。本来ならローカルホストへHTTPリクエストを送るのに<strong>40ミリ秒</strong>もかかりません。何かが完全に間違っていました。NSQデーモンはCPUの読み込みに高い負荷を与えてはいませんし、多くのメモリを使ってもいません。またガベージコレクションによって休止しているようにも見えません。どういうことでしょう。</p><p>そこで1週間前に、<a href="https://gocardless.com/blog/in-search-of-performance-how-we-shaved-200ms-off-every-post-request/" rel="nofollow" title="" class="ext-link">「パフォーマンスを求めて-各POSTリクエストごとに、どうやって200ミリ秒を削ったか」</a>という記事を読んだのを思い出しました。この記事では、なぜPOSTリクエストを送るごとに200ミリ秒余分にかかっているのかについて触れています。確かに妙ですね。以下が、その記事のポイントとなる段落です。</p><p>要約すると次のようになります。</p><p>その後のTCPのやりとりは、以下のように続きます。</p><p>アプリケーション： やあ、パケット1だよ。<br>
HAProxy：＜無反応で、2つ目のパケットを待っている＞<br>
HAProxy：＜そのうちACKするけど、まあいいか＞<br>
アプリケーション：＜無反応＞<br>
アプリケーション：＜ACKを待っているんだけど、ネットワークが混雑しているのかな＞<br>
HAProxy：もう待ち疲れた。はい、ACKだよ。<br>
アプリケーション：やった！　じゃあ2つ目のパケットを送るよ。<br>
HAProxy：よかった。これで終了だ。</p><p>アプリケーションとHAProxyが両方、意図的に他方が情報を送ってくるのを待っている期間がありますよね。それが余分の200ミリ秒です。アプリケーションはNagleのアルゴリズムにのっとっているためにそうなっていて、HAProxyは遅延ACKsのせいでそうなっているのです。</p><p>私の知る限り、全てのLinuxシステムでは初期値で遅延ACKが設定されています。だからこれはエッジケースとか例外ではありません。2つ以上のTCPパケットでデータを送れば起こり得ることです。</p><p>前述の記事を読んだ後、そのことについては忘れてしまっていました。でも、余分な40ミリ秒について思い悩んでいた時、ふと思い出したのです。</p><p>私はこう思いました。これは私の問題とは別物なはずだ。いや、同じなのか？　そして私はチームにメールを送りました。「頭が変になったのかもしれないが、これはTCP問題かもしれない」と。</p><p>そこで私はアプリケーションに対しTCP_NODELAYをオンにして変更をコミットしたのです。すると、ジャーン。</p><p>なんと全ての40ミリ秒遅延の問題は<strong>瞬時に消えました。</strong>全てが解決したのです。まるで魔法使いになったような気分でした。</p><p>補足：@alicemazzyが投稿した<a href="https://twitter.com/alicemazzy/status/667799010317574145" rel="nofollow" title="" class="ext-link">すばらしい内容のツイート</a>に、<a href="https://news.ycombinator.com/item?id=9048947" rel="nofollow" title="" class="ext-link">Hacker Newsに掲載された</a>John Nagle(Nagleアルゴリズム)のコメントがありました。</p><p>続けて彼は、「ACKは小さくて安価だが、実際に遅延ACKによって起こる問題は恐らくACKが解決している問題よりもひどいと言える」とコメントしています。</p><p>私はこれまで、TCPはさほど難しいものではないと思っていましたし、理解する必要もないと思っていました。確かにそうかもしれません。しかし現実的には、TCPアルゴリズム内の何かが原因で起こるバグが発生したりします。ですから、結局はTCPを理解することは重要なのです（私のブログの中で度々話題にしていますが、これはシステムコールやOSといった多くのことに当てはまります:):)）。</p><p>遅延ACKとTCP_NODELAYの相性は特に悪く、あらゆるプログラミング言語でHTTPリクエストを送信するコードを書く人に影響を与えかねません。このようなことを思いつくために、システムプログラミングの天才である必要はありません。TCPがどう機能するのかを少しでも理解していたおかげで、この問題に対処する手助けになりました。そしてこのブログに書かれていたことが、私の問題と原因が同じであるということに気付けたのです。私はstraceも使っていましたけどね。ずっと使い続けますよ。</p>
