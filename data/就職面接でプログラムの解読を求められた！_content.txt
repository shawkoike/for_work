I was just asked to crack a program in a job interview ! （2014-09-17）by Eren Yagdiran長文ですが、よかったら読んでください。就職面接でプログラムの解読を求められました。そして、就職が決まりました。皆さん、こんにちは。新しいブログを開設したので、私は今とても張り切っています。週に何度か記事を投稿するつもりです。タイトルを見れば大体の話の内容は分かると思いますが、これから書くのは、トルコのアンカラで受けた就職面接の話です。私が応募した職は「ソフトウェアセキュリティエンジニア」でした。面接中、面接官たちは非常に専門性が低い質問をしてきましたが、分かることもあれば分からないこともありました。その後、その企業からメールが届き、保護および暗号化されたバイナリファイルが添付されていました（「解読してみろ」ということでしょう）。帰宅後にファイルをダウンロードすると、ファイルを開くために聞かれたのはパスワードだけでした。面接官が私に課した課題は、そのパスワードを探すことでした。初めはとても難しそうに見えますが、私が行った手順の基本的な概念を紹介しようと思います。まず端末に入力したのは以下の通りです。的外れなキーワードを3回入力すると、プログラムが終了しました。でも、分析手段はまだありますよ。もう少しファイルについて調べてみましょう。よし、これで少しバイナリファイルに関する情報が増えましたね。これはどうでしょう。なるほど、普通の内容ですね。少し説明します。linux-gate.soはファイルシステム内に存在しませんが、lddコマンドでは共有ライブラリとして表示されていますよね？　そうなんです。仮想DSO（仮想動的共有オブジェクト）について聞いたことはありますか？linux-gate.soについて読んでみてください。恐らくご存じだと思いますが、 libc.so.6は、GNUシステムの標準Cライブラリです。ld-linux.soは、Linuxの動的ローダです。とにかく、ここまでは全て順調です。あとはデバッグ環境でプログラムを実行して、何が起こるか見てみる必要があります。プログラムがクラッシュしましたね。デバッガを走らせていると分かったのです。ということは、プログラムの中にアンチデバッグ技法が埋め込まれているはずです。プログラムをリロードしてスタート地点に戻りましょう。プログラムのエントリポイントがありました。そこにブレークポイントを入れ、エントリポイントを通じてプログラムのデバッグを開始しましょう。“r”でプログラムを実行します。するとエントリポイントの1行目で中断するはずです。このように見えるはずです。この構文モードはAT&amp;Tですが、Intelモードにも変更できます。私の考えではIntel構文の方が少し良いです。アドレス中の0x8047654ですが、まずALレジスタに0x55を入れ、0x99を介して排他的論理和（xor）をとると、0xCCとなります。0xCCは非常に重要です。なぜなら、それは処理を中断する、もしくはコメントでピーターが言ったように、x86アーキテクチャの中では実行を中断してデバッガを起動することを意味するからです。デバッガがプログラムを中断したい時、その中断したい所でバイトを0xCCにスワップします。0x8047666にrepnz scas命令がありますね。これは、esレジスタによって区切られたediまでのメモリリージョンの中でal内の値（0xCC）があるかどうかを探します。ですから、これらの行は基本的にはメモリをスキャンし、0xCCがあるとプログラムをクラッシュさせたりするのです。ここであまり時間を使いたくありません。straceを使ってみましょう。最後の方の行を見ると、プログラムがまたクラッシュしています。原因はptraceシステムコールです。Linuxでptraceは「Process Trace」の略で、デバッガのように内部の状態を変更しながら別のプロセスを制御することができます。デバッガはptraceを非常によく使います。それが仕事ですからね。コードをイメージすると、こんな感じのはずです。ところで、ptrace[PTRACE_TRACEMe]は1度しか行えません。ですから、過去にデバッガがプログラムでptraceを実行していたら、プログラム制御をしているものがあることに気付かせるために、その後の呼び出しにはFALSEが返ってくるでしょう。デバッガの下で実行されているということをプログラムに気付かせないために、このptrace保護を回避する必要があります。そこで、システムコールの結果を書き変えてしまうことにしましょう。システムコールはユーザ空間からカーネル空間への入り口です。ptraceもプロセスを操作するのに、何らかのシステムコールを使用しているに違いありません。プログラムがいつptraceを使用するのかを見破り、その結果を0に設定してしまいましょう。次のようにします。ホームディレクトリに、新たに.gdbinitファイルを作成します。これにより、gdbを実行する度に次のような設定が自動的に読み込まれます。eaxはシステムコールの結果を保持します。そしてそれは常に0に、いわば真になるわけです。このようにしてptrace保護を回避します。それでは改めてgdbを実行しましょう。これで少なくともデバッガは思い通りに使えるようになりました。ここでPJeGPC4TIVaKFmmy53DJに新たにブレークポイントを設定します。これは面白いですね。いくつかの定数がどこかに移動していっています。そして私がプログラムに与えた入力とこれらの定数との排他的論理和がとられています。さらに調べてみます。ここも同じですね。今度は別の定数群を格納しています。さて、以下が関数の残りの部分です。パターンが分かりましたか？　分からなくても大丈夫です。ここでは再び、排他的論理和をとった後の私の入力と定数とを、プログラムが比較しています。ここで、改めて入力に注目してみましょう。最初の入力といくつかの定数との排他的論理和がとられ、その結果が他の定数と比較されています。これら2つの関数はおそらく以下のようなものでしょう。パスワードを見つけるために、これらの2つの定数の排他的論理和をとる簡単なPythonのスクリプトを書いてみましょう。やりました！次は、パート2についても書こうと思っています。会社がラウンド2として、新たな問題を送ってきたのです。そちらも面白いですよ。（ちなみに、採用は決まりました）自分も挑戦してみたいという方がいらっしゃれば、バイナリファイルをお送りしますので、私にメールをください。(タイポの指摘でもいいですけどね）
