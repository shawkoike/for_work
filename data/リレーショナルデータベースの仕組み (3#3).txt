<p><a href="http://coding-geek.com/how-databases-work/" rel="nofollow" title="" class="ext-link">How does a relational database work</a> （2015-08-19） by <a href="http://coding-geek.com/" rel="nofollow" title="" class="ext-link">Christophe Kalenzaga</a></p><p><img class="aligncenter wp-image-1096" alt="data manager in databases" width="400" height="153" src="http://coding-geek.com/wp-content/uploads/2015/08/data_manager.png.pagespeed.ce.pF4S50HmwT.png"></p><p>このステップで、クエリマネージャはクエリを実行するので、テーブルとインデックスからデータを取得する必要があります。そこでデータマネージャに対してデータを取得するよう要求するのですが、ここで次の2つの問題が発生します。</p><p>このセクションでは、リレーショナルデータベースがこの2つの問題にどう対処しているかを説明します。なお、データマネージャがデータを取得する方法については、ここでは触れません。さほど重要なことでもないからです（それに、本稿は既にかなり長くなっていますし）。</p><p>上述の通り、データベースのボトルネックはハードディスクとの間の入出力（I/O）です。そこでパフォーマンスを向上させるために、最近のデータベースではキャッシュマネージャが導入されています。</p><p><img class="aligncenter wp-image-1094" alt="cache manager in databases" width="300" height="153" src="http://coding-geek.com/wp-content/uploads/2015/08/cache_manager.png.pagespeed.ce.KrvvedJjHc.png"></p><p>クエリを実行しているプログラムは、ファイルシステムから直接データを取得するのではなく、キャッシュマネージャに対してデータを要求します。キャッシュマネージャには、インメモリのキャッシュが備えられていて、これを<strong>バッファプール</strong>と言います。<strong>メモリからデータを取得すると、データベースの処理速度は格段に向上します。</strong>しかし複数の処理間で重要度の順位付けをするのは非常に難しいことです。重要度はそのときに処理しなければならない処理によって左右されるからです。例えば以下のようなことを判断しなければなりません。</p><p>一方データベースに利用するのは、以下のタイプのディスクです。</p><p>ざっと言えば、<strong>メモリの処理速度はHDDの100～10万倍は速い</strong>です。</p><p>このことが、さらに新たな問題につながっています（データベースに問題は付き物ですが）。キャッシュマネージャは、クエリを実行しているプログラムが使用する<em>前に</em>、メモリにデータを読み込んでおく必要があります。そうしないと、クエリマネージャは処理の遅いHDDからデータが届くのを待たなければならなくなります。</p><p>この問題はプリフェッチと呼ばれるものです。クエリを実行するプログラムは、必要なデータを認識しています。クエリ全体の流れを把握しており、さらに統計のおかげでディスク上のデータについての知識があるからです。以下のような流れになります。</p><p>キャッシュマネージャは一連のデータを全てバッファプールに格納します。データがまだ必要かどうかを確認するために、キャッシュマネージャは一度読み込んだデータに対して、キャッシュされたデータについての別の情報（<strong>ラッチ</strong>）を付加します。</p><p>しかし時として、クエリを実行するプログラムが必要なデータを認識していない場合があります。さらに一部のデータベースシステムは、この機能を備えていません。こんな場合は、投機的プリフェッチ（例えば、クエリを実行するプログラムが値「1, 3, 5」を要求してきた時、近い将来「7,9,11」も要求されるだろう、と推測します）またはシーケンシャルプリフェッチ（この場合、キャッシュマネージャはディスク上で、要求されたデータに隣接した位置にあるデータを読み込みます）を実行します。</p><p>プリフェッチの効果を監視するために、最近のデータベースは<strong>バッファ/キャッシュヒット率</strong>という尺度を使います。ヒット率とは、ディスクアクセスをしない状態で、要求されたデータのうちどれだけがバッファまたはキャッシュに含まれているかを表す数字です。</p><p>注： キャッシュヒット率が悪いのは、必ずしもキャッシュが不調だからとは限りません。詳細は、<a href="http://docs.oracle.com/database/121/TGDBA/tune_buffer_cache.htm" rel="nofollow" title="" class="ext-link">Oracleドキュメント</a>を参照してください。</p><p>ただし、バッファのメモリ容量はごく<strong>限られています</strong>。従って、新しいデータを読み込むには、バッファ内のデータの一部を消去しなければなりません。ディスクとネットワークI/Oの観点から見ると、キャッシュの読み込みと消去は負荷の高い処理です。たびたび実行するクエリがある場合、それを実行するたびにデータを読み込み、また消去するのは効率が良くありません。この問題に対処するため、最近のデータベースはバッファ置換戦略を採用しています。</p><p>最近のデータベースシステム（少なくともSQL Server、MySQL、 Oracle、DB2は該当します）は、LRUアルゴリズムを採用しています。</p><p><strong>LRU</strong> とは、「<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed」の略、つまり最後に使用してから最も長い時間がたったものから削除するということです。このアルゴリズムは、最近使用したデータは再度使われる確率が高いからキャッシュ内に留めておこう、という発想に基づいています。</p><p>この概念を視覚化したのが以下の図です。</p><p><img class="aligncenter wp-image-1107" alt="LRU algorithm in a database" width="350" height="270" src="http://coding-geek.com/wp-content/uploads/2015/08/LRU.png.pagespeed.ce.mt5583hG_X.png"></p><p>この図を分かりやすく説明するため、バッファ内のデータがラッチでロックされることはないと仮定しましょう（そのため取り除くことも可能です）。この簡単な例では、バッファに3つの要素を格納できます。</p><p>このアルゴリズムはとても優れていますが、いくつかの限界があります。例えば、大規模なテーブル上でフルスキャンを行うとどうなるでしょうか。言い方を変えると、バッファのサイズを超えた大きさのテーブルやインデックスを扱うと、どうなるのかということです。このアルゴリズムを使用すると、フルスキャンのデータは一度しか使わない可能性が高いにも関わらず、キャッシュに残る全ての値を取り除いてしまうでしょう。</p><p>この事象を防ぐために、特有のルールを加えたデータベースもあります。<a href="http://docs.oracle.com/database/121/CNCPT/memory.htm#i10221" rel="nofollow" title="" class="ext-link">Oracleのドキュメント</a>で例を見てみましょう。</p><p>また、LRU-Kと呼ばれるLRUの上位バージョンを使う場合もあります。例として、SQL  ServerがK=2となるLRU-Kを使うことが挙げられます</p><p>このアルゴリズムの背景には、使用履歴をもっと配慮するべきだという考えがあります。単純なLRU（これもK=1のLRU-Kです）を使うと、アルゴリズムは最後に使ったデータのみをのみを考慮します。しかし、LRU-Kを使うと以下のようになります。</p><p>重みの計算は負荷が高いため、SQL ServerではK=2のみを使っています。この値は許容できる程度のオーバーヘッドで高いパフォーマンスを見せます。</p><p>LRU-Kについて、もう少し詳しく学びたい場合は、初出の論文『The LRU-K page replacement algorithm for database disk buffering（データベースディスクをバッファリングするためのLRU-Kページ置換えアルゴリズム）』（1993年）をお読みください。</p><p>当然ですが、キャッシュを管理するアルゴリズムは他にもあります。例をご紹介しましょう。</p><p>また、初期設定ではない別のアルゴリズムを使えるデータベースもあります。</p><p>ここまで、読み取りバッファについての「データを使う前にロードするもの」というお話だけしてきました。しかし、データベース内には書き込みバッファもあります。データを1つ1つ書き出しては個別にディスクへアクセスし、それを大量に行う……ということをする代わりに、書き込みバッファにはデータを格納し、ひとまとまりでディスク上に書き出します。</p><p>バッファは、列（理論的に、または人間がデータを見る時のデータ）ではなくページ（データの最小ユニット）を格納することを覚えておいてください。修正されて、ディスクに書き込まれていない場合、バッファプール内のページは<strong>ダーティ</strong>です。このダーティページをディスク上に書き込む最適なタイミングを決めるため、複数のアルゴリズムが存在しています。これは、この記事の次のパートでご紹介するトランザクションの概念と強く結びついています。</p><p>このパートは最後になりますが、とても大切なことを説明します。それはトランザクションマネージャです。このプロセスが、どのようにトランザクションでクエリを実行するのかを見ていきます。しかし、その前にACIDトランザクションの概念を理解しなければいけません。</p><p>ACIDトランザクションとは、次の4つのことを確実にするための作業単位です。</p><p><img class="aligncenter wp-image-1099" alt="one dollar" width="250" height="109" src="http://coding-geek.com/wp-content/uploads/2015/08/250x109xdollar_low.jpg.pagespeed.ic.fdNRspFlUc.webp"></p><p>同じトランザクションが行われている間、複数のSQLクエリを実行し、データの読み取り、生成、更新、削除ができます。2つのトランザクションが同じデータを使っていると、混乱が生じます。古典的な例として、口座Aから口座Bへと送金する場合が挙げられます。以下の2つのトランザクションを想像してください。</p><p>ACID特性に話を戻しましょう。</p><p>[このパートについては、もし興味がなければ飛ばして次のパートを読んでください。ここで話す内容は、この後の記事の内容にはあまり関わってきません。]</p><p>最近のデータベースの多くでは、デフォルト動作として完全なトランザクションの分離を使用していません。これは、パフォーマンスに大きく影響するからです。SQL標準では、トランザクション分離レベルを次の4段階に定義しています。</p><p>例えば、トランザクションAが「SELECT count(1) from TABLE_X」を実行した後で、トランザクションBが新しいデータをTABLE_Xに追加し、コミットした場合、トランザクションAが再びcount(1)を実行して返される値は、最初に実行した時に返された値とは異なります。</p><p>これは<strong>ファントムリード</strong>と呼ばれます。</p><p>これは<strong>non-repeatable read(反復不能読み取り)</strong>と呼ばれます。</p><p>これは<strong>ダーティリード</strong>と呼ばれます。</p><p>多くのデータベースでは独自のカスタム分離レベルがあります（例えば、PostgreSQLやOracle、SQL Serverで使用されているスナップショット分離）。さらに、多くのデータベースではSQL標準の全ての分離レベル（特にread uncommittedの分離レベル）を導入していません。</p><p>デフォルトの分離レベルは、接続の初めに、ユーザや開発者によってオーバーライドすることが可能です（とても簡単なコードを書き足すだけです）。</p><p>独立性や一貫性、原子性を確保するための一番の問題は、<strong>同じデータへの書き込み処理</strong>です（データの追加、更新、そして削除など）。</p><p>この問題を並行性制御と呼びます。</p><p>この問題を解決する最も簡単な方法は、各トランザクションを1件ずつ実行することです（例えば、順番に）。しかしこれではまったくスケーラビリティはありません。また、1件のトランザクションの処理に対して、マルチプロセッサやコアサーバ上で1つのコアだけを動作させるのは非常に効率が悪いと言えます。</p><p>理想的な解決方法は、トランザクションが作成または取り消された場合に、下記を実行することです。</p><p>形式的には、これは重複するスケジューリングの問題です。具体的に言うと、非常に難しく、CPUコストの高い最適化問題なのです。エンタープライズのデータベースでは、新しいトランザクションが生じるたびに、ベストなタイミングを計って実行する余裕はありません。そのため、矛盾するトランザクションへの対応に時間を費やすようなやり方は理想的なアプローチとは言えません。</p><p>この問題に対し、多くのデータベースは<strong>ロック</strong>や、あるいは<strong>データのバージョン管理</strong>を行います。重要だと思うので、まず、ロックについて話してから、データのバージョン管理について触れます。</p><p>まず、ロックの概念は次のとおりです。</p><p>これを排他ロックと呼びます。</p><p>データ読み取り専用のトランザクションのためだけに排他ロックを使用すると、<strong>同じデータを必要としている別のデータ読み取り専用のトランザクションを待機させるため</strong>、コストがかかってしまいます。このような場合に対応するために、<strong>共有ロック</strong>と呼ばれるタイプの異なるロックがあります。</p><p>共有ロックでは次のことが可能です。</p><p>さらに、別のトランザクションでデータの読み取りが必要になっても、排他ロックが解除され、共有ロックに変わるのを待たないと、データの読み取りはできません。</p><p><img class="aligncenter wp-image-1105" alt="lock manager in a database" width="450" height="267" src="http://coding-geek.com/wp-content/uploads/2015/08/lock_manager.png.pagespeed.ce.bnsB0oihjW.png"></p><p>ロックマネージャは、ロックの実行および解除を行います。内部的には、ロックをハッシュテーブルで（ロックするデータの鍵の場所を）保持し、対象のデータを把握します。</p><p>しかし、ロックを使用すると、2つのトランザクションが永遠にデータを待ち続けてしまう場合があります。</p><p><img class="aligncenter wp-image-1098" alt="deadlock with database transactions" width="350" height="169" src="http://coding-geek.com/wp-content/uploads/2015/08/deadlock.png.pagespeed.ce.ADtogISN4q.png"></p><p>上の図では、</p><p>これを<strong>デッドロック</strong>と呼びます。</p><p>デッドロックの状態を解除するために、どのトランザクションを取り消し（ロールバック）するかは、ロックマネージャが決めます。この判断は簡単ではありません。</p><p>これらを決める前に、まずデッドロックが存在するかを確認する必要があります。</p><p>ハッシュテーブルを（上の図のように）グラフとして見ることができます。グラフでループが見られる場合はデッドロックが存在すると言うことです。しかし、（全てのロックを確認できるグラフは大きく）ループを確認するのはコストがかかるため、<strong>タイムアウト</strong>を使用する方が簡単です。タイムアウト前にロックを獲得できない場合、トランザクションはデッドロック状態に陥ります。</p><p>さらにロックマネージャでロックする前に、デッドロック状態の原因にならないかの確認をします。しかし、これも完璧に行うためには、計算コストがかかります。そのため、大抵基本的ルールとして、事前に確認は設定されています。</p><p>分離を確実なものにする<strong>最も簡単な</strong>方法は、トランザクション実行の開始にロックを取得し、終了にロックを解放することです。つまり、トランザクション実行前に全てのロックを取得するまで待機し、処理後に解放しなければなりません。これは機能こそしますが、全てのロックを待機するために<strong>多くの時間を無駄遣いします</strong></p><p>さらに早く実行できる方法は、<strong>2フェーズロックプロトコル</strong>（DB2やSQL Serverで使用）で、トランザクションを次の2つのフェーズに分散することです。</p><p><img class="aligncenter wp-image-1088" alt="a problem avoided with two phase locking" width="500" height="242" src="http://coding-geek.com/wp-content/uploads/2015/08/two-phase-locking.png.pagespeed.ce.9tRrKpgVYi.png"><br>
<em>訳注<br>
2フェーズロックがないと生じる一般的な矛盾<br>
トランザクションA実行前、X=1およびY=2とする。トランザクションA実行後に、AがトランザクションBによって変更されたデータY=1を処理。分離性からAはY=2を処理しなければならない。</em></p><p>2つのフェーズに分ける単純な発想の背景には次のような考えがあります。</p><p>このプロトコルは良く機能しますが、例外があります。それは、データを変更しロックを解除したトランザクションが取り消された（ロールバックされた）場合になります。この時、別のトランザクションによって変更された値が読み取られても、この値はロールバックされてしまいます。このような問題を回避するため、<strong>全ての排他ロックをトランザクション終了後に解放する必要があります。</strong></p><p>実際のデータベースでは、もっと高性能なタイプのロック（インテンションロックなど）や粒度の細かいロック（行単位ロック、ページ単位ロック、セグメント単位ロック、テーブル単位ロック、表領域単位ロックなど）を使用していますが、発想は同じです。</p><p>私がここまでトランザクションのデータアクセスの際に発生する問題の解決方法として、純粋にロックを基本とする視点で話を進めてきました。<strong>別の方法としては、データのバージョン管理で対応することができます。</strong></p><p>この発想の背景には次のような考えがあります。</p><p>データのバージョン管理は、次の理由からパフォーマンスを向上できます。</p><p>2つのトランザクションによって、同じデータが変更された場合以外では、ロックを使用するよりも良い方法だと思います。さらに、オーバーヘッドのディスクの空き容量が多くなります。</p><p>データのバージョン管理とロックの構想は異なります。<strong>楽観ロックと悲観ロックの違い</strong>なのです。それぞれ、一長一短ですが、使用目的によっても異なってきます（読み取りが多いのか、書き込みが多いのかなど）。データのバージョン管理について読みたい方は、<a href="http://momjian.us/main/writings/pgsql/mvcc.pdf" rel="nofollow" title="" class="ext-link">この素晴らしいプレゼンテーション</a>をお勧めします。このプレゼンでは、PostgreSQLで複数のバージョンの並行性制御をどのように導入しているか説明しています。</p><p>DB2(DB2 9.7まで)やSQL Server(スナップショット分離以外)のようなデータベースではロックを使用しています。しかし、PostgreSQLやMySQL、Oracleはロックとデータのバージョン管理が混在するアプローチを取っています。データのバージョン管理のみを使用するデータベースは知りません（ご存じの方はぜひ教えてください）。</p><p>[08/20/2015更新] 記事を読んだ方からいただいたコメントです。</p><p>複数の分離レベルについて書きましたが、分離性を高めるとロックの数を増やすことになり、結果的にトランザクションを待機させ、無駄に時間を消耗することになります。このことから、多くのデータベースは最も高いトランザクション分離レベル（Serializable）をデフォルトにしていません。</p><p>これも、主要なデータベースのドキュメントで内容を確認してください（例えば、<a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-model.html" rel="nofollow" title="" class="ext-link">MySQL</a>や<a href="http://www.postgresql.org/docs/9.4/static/mvcc.html" rel="nofollow" title="" class="ext-link">PostgreSQL</a>、<a href="http://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#i5337" rel="nofollow" title="" class="ext-link">Oracle</a>など）。</p><p>ここまでに見てきたように、データベースはパフォーマンス向上のためにデータをメモリバッファに保存します。しかし、トランザクションがコミットされている途中にサーバがクラッシュすると、クラッシュ時にメモリに残っているデータが失われ、トランザクションの永続性が壊されます。</p><p>ディスクにはトランザクションの全部を書き込むことができますが、サーバがクラッシュすると、ディスクにデータを書き込んでいる途中で終わってしまい、トランザクションの原子性が壊されます。</p><p><strong>トランザクションによって書き込まれた修正は、全く実行されないか、完了するかのどちらかでなければならなりません。</strong></p><p>この問題に対処するには、２つの方法があります。</p><p>多くのトランザクションを伴う大きなデータベースでシャドーコピー／ページを使用すると、巨大なディスクオーバーヘッドが生まれます。これが、最近のデータベースが<strong>トランザクションログ</strong>を使用する理由です。トランザクションログは、<strong>安定したストレージ</strong>に保存しなければなりません。ここではストレージ技術について深くは触れませんが、ディスク故障から保護するには、（少なくとも）RAIDディスクが必須です。</p><p>ほとんどのデータベース（少なくともOracle、<a href="https://technet.microsoft.com/en-us/library/ms186259(v=sql.105).aspx" rel="nofollow" title="" class="ext-link">SQL Server</a>、<a href="http://www.ibm.com/developerworks/data/library/techarticle/0301kline/0301kline.html" rel="nofollow" title="" class="ext-link">DB2</a>、<a href="http://www.postgresql.org/docs/9.4/static/wal.html" rel="nofollow" title="" class="ext-link">PostgreSQL</a>、MySQLおよび<a href="https://www.sqlite.org/wal.html" rel="nofollow" title="" class="ext-link">SQLite</a>）は、<strong>ログを先に書き出すプロトコル</strong> (WAL)を使用してトランザクションログを処理します。WALプロトコルには、3つの規則があります。</p><p><img class="aligncenter wp-image-1106" alt="log manager in a database" width="400" height="139" src="http://coding-geek.com/wp-content/uploads/2015/08/log_manager.png.pagespeed.ce.Knj3Pv92iG.png" psa_not_processed=""></p><p>この作業はログマネージャによって行われます。簡単に言うと、ログマネージャはキャッシュマネージャとデータアクセスマネージャ（データをディスクに書き込む）の間にあり、全ての更新／削除／作成／コミット／ロールバックを、それらがディスクに書き込まれる前に毎回トランザクションログに書き込みます。簡単ですね?</p><p>いいえ、違います!　これまで見てきたように、データベースに関係することは全て、「データベース効果」に呪われているのです。まじめに言うと、問題は、パフォーマンスを良好に保ちながらログを書く方法を見つけることです。トランザクションログへの書き込みが遅すぎると、何もかもが遅くなってしまいます。</p><p>1992年に、IBMの研究者たちはARIESと呼ばれるWALの拡張版を「発明」しました。近代のほとんどのデータベースでは多かれ少なかれARIESが使用されています。論理は同じでなくても、ARIESの背景にある概念はどこにでも使われています。「発明」を括弧に入れた理由は、この<a href="http://db.csail.mit.edu/6.830/lectures/lec15-notes.pdf" rel="nofollow" title="" class="ext-link">MITの講義</a>によれば、IBMの研究者たちは、「トランザクションを復旧するための優れた実践方法を書くこと以上のことはしなかった」からです。ARIESが発表されたのは私が5歳の頃なので、辛口の研究者たちから出た古い噂は気になりません。実は、この情報をここに出すのは、最後の技術解説を始める前に皆さんに一息入れてもらうためです。私は、<a href="http://www.cs.berkeley.edu/~brewer/cs262/Aries.pdf" rel="nofollow" title="" class="ext-link">ARIEの研究論文</a>の大部分を読みましたが、とても興味深いものでした。ここではARIESの概要に触れるだけなので、詳細を知りたい方は、この論文をお読みになることを強くお薦めします。</p><p>ARIESは、 <strong>A</strong>lgorithms for <strong>R</strong>ecovery and <strong>I</strong>solation <strong>E</strong>xploiting <strong>S</strong>emanticsの略語です。</p><p>この技法の目的は2つです。</p><p>データベースがトランザクションをロールバックする理由はいくつかあります。</p><p>時には（例えば、ネットワーク故障の場合）、デースベースがトランザクションを復旧することができます。</p><p>どうすれば可能なのでしょうか?　この問いに答えるには、ログレコードに保存されている情報について理解する必要があります。</p><p><strong>トランザクション中の各処理（追加／削除／修正）についてログが作成されます。</strong>このログレコードは、次の要素で構成されています。</p><p>さらに、ディスクの各ページ（ログデータではなくデータを保存している）には、そのデータを修正した最後の処理のログレコードのID（LSN）があります。</p><p><a href="#nLSN" name="pLSN">1</a>：LSNが与えられる方法はログが保存される方法に関連しているので、もっと複雑です。しかし、概念は同じです。</p><p><a href="#nUNDO" name="pUNDO">2</a>：物理的UNDOの処理は実に厄介なので、ARIESでは論理UNDOだけを使用します。</p><p>注：私のわずかな知識によると、UNDOを使用しないのはPostgreSQLだけです。これは、その代わりにガーベジコレクションのデーモンを使用して、古いバージョンのデータを削除します。このことは、PostgreSQLでのデータバージョン管理の実装に関連しています。</p><p>イメージしやすいように、クエリ”UPDATE FROM PERSON SET AGE = 18;”で生成されたログレコードの例を、以下にシンプルな形で図示します。このクエリが、例えばトランザクション18で実行されるとしましょう。</p><p><img class="aligncenter wp-image-1091" alt="simplified logs of ARIES protocole" width="550" height="192" src="http://coding-geek.com/wp-content/uploads/2015/08/ARIES_logs.png.pagespeed.ce.M5AjtchS6v.png" psa_not_processed=""></p><p>それぞれのログには固有のLSNがあります。リンクされているログは同じトランザクションに属しており、その順番は時系列順です（リンクされたリストの最後のログが、最後の処理のログ）。</p><p>ログの書き込みが大きなボトルネックになることを避けるため、ログバッファが使われます。</p><p><img class="aligncenter wp-image-1090" alt="log writing process in databases" width="450" height="264" src="http://coding-geek.com/wp-content/uploads/2015/08/ARIES_log_writing.png.pagespeed.ce.CJWCrf5xuT.png" psa_not_processed=""></p><p>クエリエグゼキュータが修正を求める時の手順。</p><p><strong>トランザクションがコミットされたとは、トランザクション内の全ての処理に対して上記5段階の手順が完了したという意味です。</strong>トランザクションログへの書き込みは、「トランザクションログのどこかにログを追加する」だけなので高速ですが、一方でディスクにデータを書き込むのは、「データを速く読めるように書き込む」ので、より複雑です。</p><p>パフォーマンスの観点から、<strong>手順5をコミット後に行うという選択肢があります。</strong>これにより、クラッシュが起こった場合でもREDOログでトランザクションのリカバリが可能です。これを<strong>No force</strong>と言います。</p><p>逆にForceを選択しているデータベース（手順5はコミット前に行われる）では、リカバリ中の作業負荷を軽減できます。</p><p>それとは別に、<strong>データを段階的にディスクに書き込むか（Steal）</strong>、あるいはコミット命令が出るまでバッファマネージャが待機し、全データを1度に書き込むか（No steal）という選択の問題があります。書き込みの速さ（代わりにUNDOログを使うリカバリには時間がかかる）を選ぶか、それとも高速なリカバリを選ぶか、いずれを優先するかがその決め手です。</p><p>以下に、リカバリにおける上記の方法の効果をまとめました。</p><p>ログについてよく分かりましたよね。どんどん使っていきましょう。</p><p>さて、話は変わって新しいインターンがデータベースをクラッシュさせたとします（ルール1：いつだってインターンの失敗）。そうなると、データベースをリスタートしてリカバリしなければなりません。</p><p>ARIESでは、以下の3つの手順でクラッシュから回復します。</p><p>REDOの段階の間、REDOログは時系列順に処理されます（LSNを使用）。</p><p>リカバリプロセスは各ログに関して、ディスク上で修正すべきデータを含むページのLSNを読み込みます。</p><p>LSN（ディスクのページ）≧LSN（ログレコード）であれば、データはクラッシュ前に既にディスクに書き込まれたことを意味するので（ただし、値はログの後、クラッシュの前に処理によって上書きされている）、何も行われません。</p><p>LSN（ディスクのページ）＜LSN（ログレコード）の場合、ディスクのページが更新されます。</p><p>REDOは、リカバリのプロセスを簡略化するという理由から、ロールバックされる見込みのトランザクションでも実行されます（が、最近のデータベースはその限りではないと思います）。</p><p>リカバリの間は、ディスクのデータがトランザクションログに書き込まれているものと同期されるように、リカバリプロセスによるアクションの通告をトランザクションログは受ける必要があります。その解決策の1つとして考えられるのは、実行されないトランザクションのログレコードを削除することですが、それは非常に困難です。その代わりとしてARIESでは、削除されるトランザクションのログレコードを論理的に削除するトランザクションログに補正ログを書き込みます。</p><p>トランザクションが「手動」でキャンセルされるか、ロックマネージャにより（デッドロックを止めるために）キャンセルされるか、あるいは単にネットワークの不具合でキャンセルされた場合、分析のプロセスは必要ありません。何をREDOしてUNDOするかの情報はメモリ内の2つのテーブルで利用できます。</p><p>これらのテーブルは、新規の各イベントに関連してキャッシュマネージャとトランザクションマネージャにより更新されます。どちらもメモリ内に保持されているため、データベースがクラッシュすれば破壊されます。</p><p>分析の段階でやることは、クラッシュ後にトランザクションログの情報を参照しながら両方のテーブルを再作成することです。1：分析プロセスをスピードアップするため、ARIESでは<strong>チェックポイント</strong>という考えを用意しています。その意味するところは、トランザクションテーブルやダーティページテーブルの内容、それから当該の書き込み時点における最終LSNをディスクに書き込むというもので、これによって分析プロセスの際、このLSN以降のログだけを分析すれば済むようになるというわけです。</p><p>この記事を書く前からテーマの大きさは心得ていましたし、詳しく書こうとすれば時間がかかるだろうことも承知していたつもりです。しかし実際にかかった時間は想定の2倍以上でした。自分の心づもりは多少楽観的に過ぎたようです。ただ、その間に多くを学ぶことはできました。</p><p>もしデータベースについて良質な総括資料をお望みの場合は、ぜひとも研究論文「<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" rel="nofollow" title="" class="ext-link">Architecture of a Database System</a>（データベースシステムの構造）」を読んでみてください。これはデータベースについての優れた入門書（110ページ）で、コンピュータ科学分野以外の人でも読める内容となっています。この記事の計画を練るにあたって私も大いに参考にしました。基本的には私の記事のようにデータ構造やアルゴリズムに主眼を置くのではなく、構造の概念についてより重点的に解説しています。</p><p>この記事を注意深く読んでいただいた方々はデータベースの強力さについて十分に理解されたはずですが、長い記事だったので、ここで改めてまとめておきます。</p><p>上記以外にも、データベースには豊富な機能があります。例えば、私は以下のような厄介な問題には触れませんでした。</p><p>バグの多いNoSQLデータベースと堅実なリレーショナルデータベースのどちらかを選ばなければならない時はよく考えましょう。誤解しないでいただきたいのは、一部のNoSQLデータベースはとても素晴らしいということです。ただ、まだ歴史が浅く、いくつかの用途に関する特定の問題にしか答えられていないのも事実です。</p><p>最後に、もし誰かがデータベースの仕組みについて皆さんに質問したとしましょう。ここまで読んでくださった皆さんなら、その質問に背を向けずに答えることができますよね。</p><p><img class="aligncenter size-full wp-image-1110" alt="magic gif" width="200" height="183" src="http://coding-geek.com/wp-content/uploads/2015/08/magic_low2.gif.pagespeed.ce.9TDj0eH96v.gif" psa_not_processed=""></p><p>答える代わりに、この記事のことを教えていただいてもいいですよ。</p>
